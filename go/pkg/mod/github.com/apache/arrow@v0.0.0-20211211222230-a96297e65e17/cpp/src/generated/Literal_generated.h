// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LITERAL_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
#define FLATBUFFERS_GENERATED_LITERAL_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

#include "Schema_generated.h"

namespace org {
namespace apache {
namespace arrow {
namespace computeir {
namespace flatbuf {

struct ListLiteral;
struct ListLiteralBuilder;

struct StructLiteral;
struct StructLiteralBuilder;

struct KeyValue;
struct KeyValueBuilder;

struct MapLiteral;
struct MapLiteralBuilder;

struct Int8Literal;
struct Int8LiteralBuilder;

struct Int16Literal;
struct Int16LiteralBuilder;

struct Int32Literal;
struct Int32LiteralBuilder;

struct Int64Literal;
struct Int64LiteralBuilder;

struct UInt8Literal;
struct UInt8LiteralBuilder;

struct UInt16Literal;
struct UInt16LiteralBuilder;

struct UInt32Literal;
struct UInt32LiteralBuilder;

struct UInt64Literal;
struct UInt64LiteralBuilder;

struct Float16Literal;
struct Float16LiteralBuilder;

struct Float32Literal;
struct Float32LiteralBuilder;

struct Float64Literal;
struct Float64LiteralBuilder;

struct DecimalLiteral;
struct DecimalLiteralBuilder;

struct BooleanLiteral;
struct BooleanLiteralBuilder;

struct DateLiteral;
struct DateLiteralBuilder;

struct TimeLiteral;
struct TimeLiteralBuilder;

struct TimestampLiteral;
struct TimestampLiteralBuilder;

struct IntervalLiteralMonths;
struct IntervalLiteralMonthsBuilder;

struct IntervalLiteralDaysMilliseconds;
struct IntervalLiteralDaysMillisecondsBuilder;

struct IntervalLiteral;
struct IntervalLiteralBuilder;

struct DurationLiteral;
struct DurationLiteralBuilder;

struct BinaryLiteral;
struct BinaryLiteralBuilder;

struct FixedSizeBinaryLiteral;
struct FixedSizeBinaryLiteralBuilder;

struct StringLiteral;
struct StringLiteralBuilder;

struct Literal;
struct LiteralBuilder;

enum class IntervalLiteralImpl : uint8_t {
  NONE = 0,
  IntervalLiteralMonths = 1,
  IntervalLiteralDaysMilliseconds = 2,
  MIN = NONE,
  MAX = IntervalLiteralDaysMilliseconds
};

inline const IntervalLiteralImpl (&EnumValuesIntervalLiteralImpl())[3] {
  static const IntervalLiteralImpl values[] = {
    IntervalLiteralImpl::NONE,
    IntervalLiteralImpl::IntervalLiteralMonths,
    IntervalLiteralImpl::IntervalLiteralDaysMilliseconds
  };
  return values;
}

inline const char * const *EnumNamesIntervalLiteralImpl() {
  static const char * const names[4] = {
    "NONE",
    "IntervalLiteralMonths",
    "IntervalLiteralDaysMilliseconds",
    nullptr
  };
  return names;
}

inline const char *EnumNameIntervalLiteralImpl(IntervalLiteralImpl e) {
  if (flatbuffers::IsOutRange(e, IntervalLiteralImpl::NONE, IntervalLiteralImpl::IntervalLiteralDaysMilliseconds)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIntervalLiteralImpl()[index];
}

template<typename T> struct IntervalLiteralImplTraits {
  static const IntervalLiteralImpl enum_value = IntervalLiteralImpl::NONE;
};

template<> struct IntervalLiteralImplTraits<org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths> {
  static const IntervalLiteralImpl enum_value = IntervalLiteralImpl::IntervalLiteralMonths;
};

template<> struct IntervalLiteralImplTraits<org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds> {
  static const IntervalLiteralImpl enum_value = IntervalLiteralImpl::IntervalLiteralDaysMilliseconds;
};

bool VerifyIntervalLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, IntervalLiteralImpl type);
bool VerifyIntervalLiteralImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class LiteralImpl : uint8_t {
  NONE = 0,
  BooleanLiteral = 1,
  Int8Literal = 2,
  Int16Literal = 3,
  Int32Literal = 4,
  Int64Literal = 5,
  UInt8Literal = 6,
  UInt16Literal = 7,
  UInt32Literal = 8,
  UInt64Literal = 9,
  DateLiteral = 10,
  TimeLiteral = 11,
  TimestampLiteral = 12,
  IntervalLiteral = 13,
  DurationLiteral = 14,
  DecimalLiteral = 15,
  Float16Literal = 16,
  Float32Literal = 17,
  Float64Literal = 18,
  ListLiteral = 19,
  StructLiteral = 20,
  MapLiteral = 21,
  StringLiteral = 22,
  BinaryLiteral = 23,
  FixedSizeBinaryLiteral = 24,
  MIN = NONE,
  MAX = FixedSizeBinaryLiteral
};

inline const LiteralImpl (&EnumValuesLiteralImpl())[25] {
  static const LiteralImpl values[] = {
    LiteralImpl::NONE,
    LiteralImpl::BooleanLiteral,
    LiteralImpl::Int8Literal,
    LiteralImpl::Int16Literal,
    LiteralImpl::Int32Literal,
    LiteralImpl::Int64Literal,
    LiteralImpl::UInt8Literal,
    LiteralImpl::UInt16Literal,
    LiteralImpl::UInt32Literal,
    LiteralImpl::UInt64Literal,
    LiteralImpl::DateLiteral,
    LiteralImpl::TimeLiteral,
    LiteralImpl::TimestampLiteral,
    LiteralImpl::IntervalLiteral,
    LiteralImpl::DurationLiteral,
    LiteralImpl::DecimalLiteral,
    LiteralImpl::Float16Literal,
    LiteralImpl::Float32Literal,
    LiteralImpl::Float64Literal,
    LiteralImpl::ListLiteral,
    LiteralImpl::StructLiteral,
    LiteralImpl::MapLiteral,
    LiteralImpl::StringLiteral,
    LiteralImpl::BinaryLiteral,
    LiteralImpl::FixedSizeBinaryLiteral
  };
  return values;
}

inline const char * const *EnumNamesLiteralImpl() {
  static const char * const names[26] = {
    "NONE",
    "BooleanLiteral",
    "Int8Literal",
    "Int16Literal",
    "Int32Literal",
    "Int64Literal",
    "UInt8Literal",
    "UInt16Literal",
    "UInt32Literal",
    "UInt64Literal",
    "DateLiteral",
    "TimeLiteral",
    "TimestampLiteral",
    "IntervalLiteral",
    "DurationLiteral",
    "DecimalLiteral",
    "Float16Literal",
    "Float32Literal",
    "Float64Literal",
    "ListLiteral",
    "StructLiteral",
    "MapLiteral",
    "StringLiteral",
    "BinaryLiteral",
    "FixedSizeBinaryLiteral",
    nullptr
  };
  return names;
}

inline const char *EnumNameLiteralImpl(LiteralImpl e) {
  if (flatbuffers::IsOutRange(e, LiteralImpl::NONE, LiteralImpl::FixedSizeBinaryLiteral)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLiteralImpl()[index];
}

template<typename T> struct LiteralImplTraits {
  static const LiteralImpl enum_value = LiteralImpl::NONE;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::BooleanLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::BooleanLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int8Literal> {
  static const LiteralImpl enum_value = LiteralImpl::Int8Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int16Literal> {
  static const LiteralImpl enum_value = LiteralImpl::Int16Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int32Literal> {
  static const LiteralImpl enum_value = LiteralImpl::Int32Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Int64Literal> {
  static const LiteralImpl enum_value = LiteralImpl::Int64Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt8Literal> {
  static const LiteralImpl enum_value = LiteralImpl::UInt8Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt16Literal> {
  static const LiteralImpl enum_value = LiteralImpl::UInt16Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt32Literal> {
  static const LiteralImpl enum_value = LiteralImpl::UInt32Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::UInt64Literal> {
  static const LiteralImpl enum_value = LiteralImpl::UInt64Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::DateLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::DateLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::TimeLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::TimeLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::TimestampLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::TimestampLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::IntervalLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::IntervalLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::DurationLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::DurationLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::DecimalLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::DecimalLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Float16Literal> {
  static const LiteralImpl enum_value = LiteralImpl::Float16Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Float32Literal> {
  static const LiteralImpl enum_value = LiteralImpl::Float32Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::Float64Literal> {
  static const LiteralImpl enum_value = LiteralImpl::Float64Literal;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::ListLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::ListLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::StructLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::StructLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::MapLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::MapLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::StringLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::StringLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::BinaryLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::BinaryLiteral;
};

template<> struct LiteralImplTraits<org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral> {
  static const LiteralImpl enum_value = LiteralImpl::FixedSizeBinaryLiteral;
};

bool VerifyLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, LiteralImpl type);
bool VerifyLiteralImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct ListLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ListLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct ListLiteralBuilder {
  typedef ListLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> values) {
    fbb_.AddOffset(ListLiteral::VT_VALUES, values);
  }
  explicit ListLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ListLiteralBuilder &operator=(const ListLiteralBuilder &);
  flatbuffers::Offset<ListLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ListLiteral>(end);
    fbb_.Required(o, ListLiteral::VT_VALUES);
    return o;
  }
};

inline flatbuffers::Offset<ListLiteral> CreateListLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> values = 0) {
  ListLiteralBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<ListLiteral> CreateListLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>(*values) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateListLiteral(
      _fbb,
      values__);
}

struct StructLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StructLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  /// Values for each struct field; the order must match the order of fields
  /// in the `type` field of `Literal`.
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct StructLiteralBuilder {
  typedef StructLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> values) {
    fbb_.AddOffset(StructLiteral::VT_VALUES, values);
  }
  explicit StructLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StructLiteralBuilder &operator=(const StructLiteralBuilder &);
  flatbuffers::Offset<StructLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StructLiteral>(end);
    fbb_.Required(o, StructLiteral::VT_VALUES);
    return o;
  }
};

inline flatbuffers::Offset<StructLiteral> CreateStructLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>> values = 0) {
  StructLiteralBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<StructLiteral> CreateStructLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal>>(*values) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateStructLiteral(
      _fbb,
      values__);
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const org::apache::arrow::computeir::flatbuf::Literal *key() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Literal *>(VT_KEY);
  }
  const org::apache::arrow::computeir::flatbuf::Literal *value() const {
    return GetPointer<const org::apache::arrow::computeir::flatbuf::Literal *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyTable(key()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  KeyValueBuilder &operator=(const KeyValueBuilder &);
  flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyValue>(end);
    fbb_.Required(o, KeyValue::VT_KEY);
    fbb_.Required(o, KeyValue::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<KeyValue> CreateKeyValue(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> key = 0,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct MapLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MapLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           verifier.EndTable();
  }
};

struct MapLiteralBuilder {
  typedef MapLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>> values) {
    fbb_.AddOffset(MapLiteral::VT_VALUES, values);
  }
  explicit MapLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MapLiteralBuilder &operator=(const MapLiteralBuilder &);
  flatbuffers::Offset<MapLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MapLiteral>(end);
    fbb_.Required(o, MapLiteral::VT_VALUES);
    return o;
  }
};

inline flatbuffers::Offset<MapLiteral> CreateMapLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>> values = 0) {
  MapLiteralBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<MapLiteral> CreateMapLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::KeyValue>>(*values) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateMapLiteral(
      _fbb,
      values__);
}

struct Int8Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int8LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int8_t value() const {
    return GetField<int8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct Int8LiteralBuilder {
  typedef Int8Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int8_t value) {
    fbb_.AddElement<int8_t>(Int8Literal::VT_VALUE, value, 0);
  }
  explicit Int8LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int8LiteralBuilder &operator=(const Int8LiteralBuilder &);
  flatbuffers::Offset<Int8Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int8Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int8Literal> CreateInt8Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t value = 0) {
  Int8LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int16LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int16_t value() const {
    return GetField<int16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct Int16LiteralBuilder {
  typedef Int16Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int16_t value) {
    fbb_.AddElement<int16_t>(Int16Literal::VT_VALUE, value, 0);
  }
  explicit Int16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int16LiteralBuilder &operator=(const Int16LiteralBuilder &);
  flatbuffers::Offset<Int16Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int16Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int16Literal> CreateInt16Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t value = 0) {
  Int16LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int32LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct Int32LiteralBuilder {
  typedef Int32Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int32Literal::VT_VALUE, value, 0);
  }
  explicit Int32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int32LiteralBuilder &operator=(const Int32LiteralBuilder &);
  flatbuffers::Offset<Int32Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int32Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int32Literal> CreateInt32Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  Int32LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Int64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Int64LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct Int64LiteralBuilder {
  typedef Int64Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(Int64Literal::VT_VALUE, value, 0);
  }
  explicit Int64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Int64LiteralBuilder &operator=(const Int64LiteralBuilder &);
  flatbuffers::Offset<Int64Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Int64Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Int64Literal> CreateInt64Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  Int64LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt8Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt8LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint8_t value() const {
    return GetField<uint8_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UInt8LiteralBuilder {
  typedef UInt8Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint8_t value) {
    fbb_.AddElement<uint8_t>(UInt8Literal::VT_VALUE, value, 0);
  }
  explicit UInt8LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt8LiteralBuilder &operator=(const UInt8LiteralBuilder &);
  flatbuffers::Offset<UInt8Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt8Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt8Literal> CreateUInt8Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t value = 0) {
  UInt8LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt16LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UInt16LiteralBuilder {
  typedef UInt16Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(UInt16Literal::VT_VALUE, value, 0);
  }
  explicit UInt16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt16LiteralBuilder &operator=(const UInt16LiteralBuilder &);
  flatbuffers::Offset<UInt16Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt16Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt16Literal> CreateUInt16Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  UInt16LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt32LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint32_t value() const {
    return GetField<uint32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UInt32LiteralBuilder {
  typedef UInt32Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint32_t value) {
    fbb_.AddElement<uint32_t>(UInt32Literal::VT_VALUE, value, 0);
  }
  explicit UInt32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt32LiteralBuilder &operator=(const UInt32LiteralBuilder &);
  flatbuffers::Offset<UInt32Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt32Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt32Literal> CreateUInt32Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t value = 0) {
  UInt32LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct UInt64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UInt64LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint64_t value() const {
    return GetField<uint64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UInt64LiteralBuilder {
  typedef UInt64Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint64_t value) {
    fbb_.AddElement<uint64_t>(UInt64Literal::VT_VALUE, value, 0);
  }
  explicit UInt64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UInt64LiteralBuilder &operator=(const UInt64LiteralBuilder &);
  flatbuffers::Offset<UInt64Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UInt64Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<UInt64Literal> CreateUInt64Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t value = 0) {
  UInt64LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Float16Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float16LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  uint16_t value() const {
    return GetField<uint16_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct Float16LiteralBuilder {
  typedef Float16Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(uint16_t value) {
    fbb_.AddElement<uint16_t>(Float16Literal::VT_VALUE, value, 0);
  }
  explicit Float16LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float16LiteralBuilder &operator=(const Float16LiteralBuilder &);
  flatbuffers::Offset<Float16Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float16Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float16Literal> CreateFloat16Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t value = 0) {
  Float16LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Float32Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float32LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct Float32LiteralBuilder {
  typedef Float32Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(Float32Literal::VT_VALUE, value, 0.0f);
  }
  explicit Float32LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float32LiteralBuilder &operator=(const Float32LiteralBuilder &);
  flatbuffers::Offset<Float32Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float32Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float32Literal> CreateFloat32Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  Float32LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Float64Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Float64LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct Float64LiteralBuilder {
  typedef Float64Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(Float64Literal::VT_VALUE, value, 0.0);
  }
  explicit Float64LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Float64LiteralBuilder &operator=(const Float64LiteralBuilder &);
  flatbuffers::Offset<Float64Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Float64Literal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Float64Literal> CreateFloat64Literal(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  Float64LiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DecimalLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DecimalLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  /// Bytes of a Decimal value; bytes must be in little-endian order.
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct DecimalLiteralBuilder {
  typedef DecimalLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(DecimalLiteral::VT_VALUE, value);
  }
  explicit DecimalLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DecimalLiteralBuilder &operator=(const DecimalLiteralBuilder &);
  flatbuffers::Offset<DecimalLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DecimalLiteral>(end);
    fbb_.Required(o, DecimalLiteral::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<DecimalLiteral> CreateDecimalLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  DecimalLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<DecimalLiteral> CreateDecimalLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateDecimalLiteral(
      _fbb,
      value__);
}

struct BooleanLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BooleanLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BooleanLiteralBuilder {
  typedef BooleanLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BooleanLiteral::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BooleanLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BooleanLiteralBuilder &operator=(const BooleanLiteralBuilder &);
  flatbuffers::Offset<BooleanLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BooleanLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<BooleanLiteral> CreateBooleanLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BooleanLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DateLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DateLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DateLiteralBuilder {
  typedef DateLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(DateLiteral::VT_VALUE, value, 0);
  }
  explicit DateLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DateLiteralBuilder &operator=(const DateLiteralBuilder &);
  flatbuffers::Offset<DateLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DateLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<DateLiteral> CreateDateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  DateLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TimeLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimeLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TimeLiteralBuilder {
  typedef TimeLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(TimeLiteral::VT_VALUE, value, 0);
  }
  explicit TimeLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimeLiteralBuilder &operator=(const TimeLiteralBuilder &);
  flatbuffers::Offset<TimeLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimeLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimeLiteral> CreateTimeLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  TimeLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct TimestampLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TimestampLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct TimestampLiteralBuilder {
  typedef TimestampLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(TimestampLiteral::VT_VALUE, value, 0);
  }
  explicit TimestampLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TimestampLiteralBuilder &operator=(const TimestampLiteralBuilder &);
  flatbuffers::Offset<TimestampLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TimestampLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<TimestampLiteral> CreateTimestampLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  TimestampLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct IntervalLiteralMonths FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntervalLiteralMonthsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MONTHS = 4
  };
  int32_t months() const {
    return GetField<int32_t>(VT_MONTHS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MONTHS) &&
           verifier.EndTable();
  }
};

struct IntervalLiteralMonthsBuilder {
  typedef IntervalLiteralMonths Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_months(int32_t months) {
    fbb_.AddElement<int32_t>(IntervalLiteralMonths::VT_MONTHS, months, 0);
  }
  explicit IntervalLiteralMonthsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntervalLiteralMonthsBuilder &operator=(const IntervalLiteralMonthsBuilder &);
  flatbuffers::Offset<IntervalLiteralMonths> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntervalLiteralMonths>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntervalLiteralMonths> CreateIntervalLiteralMonths(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t months = 0) {
  IntervalLiteralMonthsBuilder builder_(_fbb);
  builder_.add_months(months);
  return builder_.Finish();
}

struct IntervalLiteralDaysMilliseconds FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntervalLiteralDaysMillisecondsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DAYS = 4,
    VT_MILLISECONDS = 6
  };
  int32_t days() const {
    return GetField<int32_t>(VT_DAYS, 0);
  }
  int32_t milliseconds() const {
    return GetField<int32_t>(VT_MILLISECONDS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DAYS) &&
           VerifyField<int32_t>(verifier, VT_MILLISECONDS) &&
           verifier.EndTable();
  }
};

struct IntervalLiteralDaysMillisecondsBuilder {
  typedef IntervalLiteralDaysMilliseconds Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_days(int32_t days) {
    fbb_.AddElement<int32_t>(IntervalLiteralDaysMilliseconds::VT_DAYS, days, 0);
  }
  void add_milliseconds(int32_t milliseconds) {
    fbb_.AddElement<int32_t>(IntervalLiteralDaysMilliseconds::VT_MILLISECONDS, milliseconds, 0);
  }
  explicit IntervalLiteralDaysMillisecondsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntervalLiteralDaysMillisecondsBuilder &operator=(const IntervalLiteralDaysMillisecondsBuilder &);
  flatbuffers::Offset<IntervalLiteralDaysMilliseconds> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntervalLiteralDaysMilliseconds>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntervalLiteralDaysMilliseconds> CreateIntervalLiteralDaysMilliseconds(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t days = 0,
    int32_t milliseconds = 0) {
  IntervalLiteralDaysMillisecondsBuilder builder_(_fbb);
  builder_.add_milliseconds(milliseconds);
  builder_.add_days(days);
  return builder_.Finish();
}

struct IntervalLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntervalLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl value_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *value_as_IntervalLiteralMonths() const {
    return value_type() == org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl::IntervalLiteralMonths ? static_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *>(value()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *value_as_IntervalLiteralDaysMilliseconds() const {
    return value_type() == org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl::IntervalLiteralDaysMilliseconds ? static_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           VerifyIntervalLiteralImpl(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *IntervalLiteral::value_as<org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths>() const {
  return value_as_IntervalLiteralMonths();
}

template<> inline const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *IntervalLiteral::value_as<org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds>() const {
  return value_as_IntervalLiteralDaysMilliseconds();
}

struct IntervalLiteralBuilder {
  typedef IntervalLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl value_type) {
    fbb_.AddElement<uint8_t>(IntervalLiteral::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(IntervalLiteral::VT_VALUE, value);
  }
  explicit IntervalLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntervalLiteralBuilder &operator=(const IntervalLiteralBuilder &);
  flatbuffers::Offset<IntervalLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntervalLiteral>(end);
    fbb_.Required(o, IntervalLiteral::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<IntervalLiteral> CreateIntervalLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl value_type = org::apache::arrow::computeir::flatbuf::IntervalLiteralImpl::NONE,
    flatbuffers::Offset<void> value = 0) {
  IntervalLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct DurationLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DurationLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DurationLiteralBuilder {
  typedef DurationLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(DurationLiteral::VT_VALUE, value, 0);
  }
  explicit DurationLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DurationLiteralBuilder &operator=(const DurationLiteralBuilder &);
  flatbuffers::Offset<DurationLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DurationLiteral>(end);
    return o;
  }
};

inline flatbuffers::Offset<DurationLiteral> CreateDurationLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  DurationLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct BinaryLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct BinaryLiteralBuilder {
  typedef BinaryLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(BinaryLiteral::VT_VALUE, value);
  }
  explicit BinaryLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryLiteralBuilder &operator=(const BinaryLiteralBuilder &);
  flatbuffers::Offset<BinaryLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryLiteral>(end);
    fbb_.Required(o, BinaryLiteral::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<BinaryLiteral> CreateBinaryLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  BinaryLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<BinaryLiteral> CreateBinaryLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateBinaryLiteral(
      _fbb,
      value__);
}

struct FixedSizeBinaryLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FixedSizeBinaryLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct FixedSizeBinaryLiteralBuilder {
  typedef FixedSizeBinaryLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(FixedSizeBinaryLiteral::VT_VALUE, value);
  }
  explicit FixedSizeBinaryLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FixedSizeBinaryLiteralBuilder &operator=(const FixedSizeBinaryLiteralBuilder &);
  flatbuffers::Offset<FixedSizeBinaryLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FixedSizeBinaryLiteral>(end);
    fbb_.Required(o, FixedSizeBinaryLiteral::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<FixedSizeBinaryLiteral> CreateFixedSizeBinaryLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  FixedSizeBinaryLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<FixedSizeBinaryLiteral> CreateFixedSizeBinaryLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateFixedSizeBinaryLiteral(
      _fbb,
      value__);
}

struct StringLiteral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringLiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringLiteralBuilder {
  typedef StringLiteral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringLiteral::VT_VALUE, value);
  }
  explicit StringLiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringLiteralBuilder &operator=(const StringLiteralBuilder &);
  flatbuffers::Offset<StringLiteral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringLiteral>(end);
    fbb_.Required(o, StringLiteral::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<StringLiteral> CreateStringLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringLiteralBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringLiteral> CreateStringLiteralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return org::apache::arrow::computeir::flatbuf::CreateStringLiteral(
      _fbb,
      value__);
}

struct Literal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LiteralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMPL_TYPE = 4,
    VT_IMPL = 6,
    VT_TYPE = 8
  };
  org::apache::arrow::computeir::flatbuf::LiteralImpl impl_type() const {
    return static_cast<org::apache::arrow::computeir::flatbuf::LiteralImpl>(GetField<uint8_t>(VT_IMPL_TYPE, 0));
  }
  /// Literal value data; for null literals do not include this field.
  const void *impl() const {
    return GetPointer<const void *>(VT_IMPL);
  }
  template<typename T> const T *impl_as() const;
  const org::apache::arrow::computeir::flatbuf::BooleanLiteral *impl_as_BooleanLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::BooleanLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::BooleanLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Int8Literal *impl_as_Int8Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::Int8Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Int8Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Int16Literal *impl_as_Int16Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::Int16Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Int16Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Int32Literal *impl_as_Int32Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::Int32Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Int32Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Int64Literal *impl_as_Int64Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::Int64Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Int64Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt8Literal *impl_as_UInt8Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::UInt8Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt8Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt16Literal *impl_as_UInt16Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::UInt16Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt16Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt32Literal *impl_as_UInt32Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::UInt32Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt32Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::UInt64Literal *impl_as_UInt64Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::UInt64Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::UInt64Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::DateLiteral *impl_as_DateLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::DateLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::DateLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::TimeLiteral *impl_as_TimeLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::TimeLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::TimeLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::TimestampLiteral *impl_as_TimestampLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::TimestampLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::TimestampLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::IntervalLiteral *impl_as_IntervalLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::IntervalLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::DurationLiteral *impl_as_DurationLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::DurationLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::DurationLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::DecimalLiteral *impl_as_DecimalLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::DecimalLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::DecimalLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Float16Literal *impl_as_Float16Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::Float16Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Float16Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Float32Literal *impl_as_Float32Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::Float32Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Float32Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::Float64Literal *impl_as_Float64Literal() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::Float64Literal ? static_cast<const org::apache::arrow::computeir::flatbuf::Float64Literal *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::ListLiteral *impl_as_ListLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::ListLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::ListLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::StructLiteral *impl_as_StructLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::StructLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::StructLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::MapLiteral *impl_as_MapLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::MapLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::MapLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::StringLiteral *impl_as_StringLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::StringLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::StringLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::BinaryLiteral *impl_as_BinaryLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::BinaryLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::BinaryLiteral *>(impl()) : nullptr;
  }
  const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *impl_as_FixedSizeBinaryLiteral() const {
    return impl_type() == org::apache::arrow::computeir::flatbuf::LiteralImpl::FixedSizeBinaryLiteral ? static_cast<const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *>(impl()) : nullptr;
  }
  /// Type of the literal value. This must match `impl`.
  const org::apache::arrow::flatbuf::Field *type() const {
    return GetPointer<const org::apache::arrow::flatbuf::Field *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IMPL_TYPE) &&
           VerifyOffset(verifier, VT_IMPL) &&
           VerifyLiteralImpl(verifier, impl(), impl_type()) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
};

template<> inline const org::apache::arrow::computeir::flatbuf::BooleanLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::BooleanLiteral>() const {
  return impl_as_BooleanLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Int8Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int8Literal>() const {
  return impl_as_Int8Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Int16Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int16Literal>() const {
  return impl_as_Int16Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Int32Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int32Literal>() const {
  return impl_as_Int32Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Int64Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::Int64Literal>() const {
  return impl_as_Int64Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt8Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt8Literal>() const {
  return impl_as_UInt8Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt16Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt16Literal>() const {
  return impl_as_UInt16Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt32Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt32Literal>() const {
  return impl_as_UInt32Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::UInt64Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::UInt64Literal>() const {
  return impl_as_UInt64Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::DateLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::DateLiteral>() const {
  return impl_as_DateLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::TimeLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::TimeLiteral>() const {
  return impl_as_TimeLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::TimestampLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::TimestampLiteral>() const {
  return impl_as_TimestampLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::IntervalLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::IntervalLiteral>() const {
  return impl_as_IntervalLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::DurationLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::DurationLiteral>() const {
  return impl_as_DurationLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::DecimalLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::DecimalLiteral>() const {
  return impl_as_DecimalLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Float16Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::Float16Literal>() const {
  return impl_as_Float16Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Float32Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::Float32Literal>() const {
  return impl_as_Float32Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::Float64Literal *Literal::impl_as<org::apache::arrow::computeir::flatbuf::Float64Literal>() const {
  return impl_as_Float64Literal();
}

template<> inline const org::apache::arrow::computeir::flatbuf::ListLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::ListLiteral>() const {
  return impl_as_ListLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::StructLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::StructLiteral>() const {
  return impl_as_StructLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::MapLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::MapLiteral>() const {
  return impl_as_MapLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::StringLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::StringLiteral>() const {
  return impl_as_StringLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::BinaryLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::BinaryLiteral>() const {
  return impl_as_BinaryLiteral();
}

template<> inline const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *Literal::impl_as<org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral>() const {
  return impl_as_FixedSizeBinaryLiteral();
}

struct LiteralBuilder {
  typedef Literal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_impl_type(org::apache::arrow::computeir::flatbuf::LiteralImpl impl_type) {
    fbb_.AddElement<uint8_t>(Literal::VT_IMPL_TYPE, static_cast<uint8_t>(impl_type), 0);
  }
  void add_impl(flatbuffers::Offset<void> impl) {
    fbb_.AddOffset(Literal::VT_IMPL, impl);
  }
  void add_type(flatbuffers::Offset<org::apache::arrow::flatbuf::Field> type) {
    fbb_.AddOffset(Literal::VT_TYPE, type);
  }
  explicit LiteralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LiteralBuilder &operator=(const LiteralBuilder &);
  flatbuffers::Offset<Literal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Literal>(end);
    fbb_.Required(o, Literal::VT_TYPE);
    return o;
  }
};

inline flatbuffers::Offset<Literal> CreateLiteral(
    flatbuffers::FlatBufferBuilder &_fbb,
    org::apache::arrow::computeir::flatbuf::LiteralImpl impl_type = org::apache::arrow::computeir::flatbuf::LiteralImpl::NONE,
    flatbuffers::Offset<void> impl = 0,
    flatbuffers::Offset<org::apache::arrow::flatbuf::Field> type = 0) {
  LiteralBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_impl(impl);
  builder_.add_impl_type(impl_type);
  return builder_.Finish();
}

inline bool VerifyIntervalLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, IntervalLiteralImpl type) {
  switch (type) {
    case IntervalLiteralImpl::NONE: {
      return true;
    }
    case IntervalLiteralImpl::IntervalLiteralMonths: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralMonths *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IntervalLiteralImpl::IntervalLiteralDaysMilliseconds: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteralDaysMilliseconds *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyIntervalLiteralImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyIntervalLiteralImpl(
        verifier,  values->Get(i), types->GetEnum<IntervalLiteralImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyLiteralImpl(flatbuffers::Verifier &verifier, const void *obj, LiteralImpl type) {
  switch (type) {
    case LiteralImpl::NONE: {
      return true;
    }
    case LiteralImpl::BooleanLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::BooleanLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::Int8Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int8Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::Int16Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int16Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::Int32Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int32Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::Int64Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Int64Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::UInt8Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt8Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::UInt16Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt16Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::UInt32Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt32Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::UInt64Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::UInt64Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::DateLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::DateLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::TimeLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::TimeLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::TimestampLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::TimestampLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::IntervalLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::IntervalLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::DurationLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::DurationLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::DecimalLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::DecimalLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::Float16Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float16Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::Float32Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float32Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::Float64Literal: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::Float64Literal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::ListLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::ListLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::StructLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::StructLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::MapLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::MapLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::StringLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::StringLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::BinaryLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::BinaryLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case LiteralImpl::FixedSizeBinaryLiteral: {
      auto ptr = reinterpret_cast<const org::apache::arrow::computeir::flatbuf::FixedSizeBinaryLiteral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyLiteralImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLiteralImpl(
        verifier,  values->Get(i), types->GetEnum<LiteralImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline const org::apache::arrow::computeir::flatbuf::Literal *GetLiteral(const void *buf) {
  return flatbuffers::GetRoot<org::apache::arrow::computeir::flatbuf::Literal>(buf);
}

inline const org::apache::arrow::computeir::flatbuf::Literal *GetSizePrefixedLiteral(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<org::apache::arrow::computeir::flatbuf::Literal>(buf);
}

inline bool VerifyLiteralBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<org::apache::arrow::computeir::flatbuf::Literal>(nullptr);
}

inline bool VerifySizePrefixedLiteralBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<org::apache::arrow::computeir::flatbuf::Literal>(nullptr);
}

inline void FinishLiteralBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedLiteralBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<org::apache::arrow::computeir::flatbuf::Literal> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace computeir
}  // namespace arrow
}  // namespace apache
}  // namespace org

#endif  // FLATBUFFERS_GENERATED_LITERAL_ORG_APACHE_ARROW_COMPUTEIR_FLATBUF_H_
