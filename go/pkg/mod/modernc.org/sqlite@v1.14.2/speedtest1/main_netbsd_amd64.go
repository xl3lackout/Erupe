// Code generated by 'ccgo -export-defines "" -o speedtest1/main_netbsd_amd64.go -trace-translation-units testdata/sqlite-src-3360000/test/speedtest1.c -Itestdata/sqlite-amalgamation-3360000 -l modernc.org/sqlite/lib -DNDEBUG -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_CORE -DSQLITE_ENABLE_COLUMN_METADATA -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_GEOPOLY -DSQLITE_ENABLE_JSON1 -DSQLITE_ENABLE_MEMORY_MANAGEMENT -DSQLITE_ENABLE_OFFSET_SQL_FUNC -DSQLITE_ENABLE_PREUPDATE_HOOK -DSQLITE_ENABLE_RBU -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_SESSION -DSQLITE_ENABLE_SNAPSHOT -DSQLITE_ENABLE_STAT4 -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_MUTEX_NOOP -DSQLITE_SOUNDEX -DSQLITE_THREADSAFE=1 -DSQLITE_OS_UNIX=1 -D__libc_cond_broadcast=pthread_cond_broadcast -D__libc_cond_destroy=pthread_cond_destroy -D__libc_cond_init=pthread_cond_init -D__libc_cond_signal=pthread_cond_signal -D__libc_cond_wait=pthread_cond_wait -D__libc_mutex_destroy=pthread_mutex_destroy -D__libc_mutex_init=pthread_mutex_init -D__libc_mutex_lock=pthread_mutex_lock -D__libc_mutex_trylock=pthread_mutex_trylock -D__libc_mutex_unlock=pthread_mutex_unlock -D__libc_mutexattr_destroy=pthread_mutexattr_destroy -D__libc_mutexattr_init=pthread_mutexattr_init -D__libc_mutexattr_settype=pthread_mutexattr_settype -D__libc_thr_yield=sched_yield', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/sqlite/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BIG_ENDIAN                            = 4321
	BUFSIZ                                = 1024
	BYTE_ORDER                            = 1234
	EOF                                   = -1
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	FDATASYNC                             = 0x0010
	FDISKSYNC                             = 0x0040
	FD_SETSIZE                            = 256
	FFILESYNC                             = 0x0020
	FILENAME_MAX                          = 1024
	FOPEN_MAX                             = 20
	FPARSELN_UNESCALL                     = 0x0f
	FPARSELN_UNESCCOMM                    = 0x04
	FPARSELN_UNESCCONT                    = 0x02
	FPARSELN_UNESCESC                     = 0x01
	FPARSELN_UNESCREST                    = 0x08
	FTS5_TOKENIZE_AUX                     = 0x0008
	FTS5_TOKENIZE_DOCUMENT                = 0x0004
	FTS5_TOKENIZE_PREFIX                  = 0x0002
	FTS5_TOKENIZE_QUERY                   = 0x0001
	FTS5_TOKEN_COLOCATED                  = 0x0001
	FULLY_WITHIN                          = 2
	F_LOCK                                = 1
	F_OK                                  = 0
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	GETPASS_7BIT                          = 0x080
	GETPASS_BUF_LIMIT                     = 0x004
	GETPASS_ECHO                          = 0x020
	GETPASS_ECHO_NL                       = 0x400
	GETPASS_ECHO_STAR                     = 0x040
	GETPASS_FAIL_EOF                      = 0x002
	GETPASS_FORCE_LOWER                   = 0x100
	GETPASS_FORCE_UPPER                   = 0x200
	GETPASS_NEED_TTY                      = 0x001
	GETPASS_NO_BEEP                       = 0x010
	GETPASS_NO_SIGNAL                     = 0x008
	HAVE_USLEEP                           = 1
	HN_AUTOSCALE                          = 0x20
	HN_B                                  = 0x04
	HN_DECIMAL                            = 0x01
	HN_DIVISOR_1000                       = 0x08
	HN_GETSCALE                           = 0x10
	HN_NOSPACE                            = 0x02
	INT16_MAX                             = 32767
	INT16_MIN                             = -32768
	INT32_MAX                             = 2147483647
	INT32_MIN                             = -2147483648
	INT64_MAX                             = 9223372036854775807
	INT64_MIN                             = -9223372036854775808
	INT8_MAX                              = 127
	INT8_MIN                              = -128
	INTMAX_MAX                            = 9223372036854775807
	INTMAX_MIN                            = -9223372036854775808
	INTPTR_MAX                            = 9223372036854775807
	INTPTR_MIN                            = -9223372036854775808
	INT_FAST16_MAX                        = 2147483647
	INT_FAST16_MIN                        = -2147483648
	INT_FAST32_MAX                        = 2147483647
	INT_FAST32_MIN                        = -2147483648
	INT_FAST64_MAX                        = 9223372036854775807
	INT_FAST64_MIN                        = -9223372036854775808
	INT_FAST8_MAX                         = 2147483647
	INT_FAST8_MIN                         = -2147483648
	INT_LEAST16_MAX                       = 32767
	INT_LEAST16_MIN                       = -32768
	INT_LEAST32_MAX                       = 2147483647
	INT_LEAST32_MIN                       = -2147483648
	INT_LEAST64_MAX                       = 9223372036854775807
	INT_LEAST64_MIN                       = -9223372036854775808
	INT_LEAST8_MAX                        = 127
	INT_LEAST8_MIN                        = -128
	LITTLE_ENDIAN                         = 1234
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	L_ctermid                             = 1024
	L_cuserid                             = 9
	L_tmpnam                              = 1024
	NAMEWIDTH                             = 60
	NBBY                                  = 8
	NDEBUG                                = 1
	NFDBITS                               = 32
	NODEVMAJOR                            = -1
	NOT_WITHIN                            = 0
	PARTLY_WITHIN                         = 1
	PDP_ENDIAN                            = 3412
	PTRDIFF_MAX                           = 9223372036854775807
	PTRDIFF_MIN                           = -9223372036854775808
	P_tmpdir                              = "/tmp/"
	RANDOM_MAX                            = 0x7fffffff
	RAND_MAX                              = 0x7fffffff
	R_OK                                  = 0x04
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	SIG_ATOMIC_MAX                        = 2147483647
	SIG_ATOMIC_MIN                        = -2147483648
	SIZE_MAX                              = 18446744073709551615
	SQLITE3_H                             = 0
	SQLITE3_TEXT                          = 3
	SQLITE_ABORT                          = 4
	SQLITE_ABORT_ROLLBACK                 = 516
	SQLITE_ACCESS_EXISTS                  = 0
	SQLITE_ACCESS_READ                    = 2
	SQLITE_ACCESS_READWRITE               = 1
	SQLITE_ALTER_TABLE                    = 26
	SQLITE_ANALYZE                        = 28
	SQLITE_ANY                            = 5
	SQLITE_API                            = 0
	SQLITE_APICALL                        = 0
	SQLITE_ATTACH                         = 24
	SQLITE_AUTH                           = 23
	SQLITE_AUTH_USER                      = 279
	SQLITE_BLOB                           = 4
	SQLITE_BUSY                           = 5
	SQLITE_BUSY_RECOVERY                  = 261
	SQLITE_BUSY_SNAPSHOT                  = 517
	SQLITE_BUSY_TIMEOUT                   = 773
	SQLITE_CALLBACK                       = 0
	SQLITE_CANTOPEN                       = 14
	SQLITE_CANTOPEN_CONVPATH              = 1038
	SQLITE_CANTOPEN_DIRTYWAL              = 1294
	SQLITE_CANTOPEN_FULLPATH              = 782
	SQLITE_CANTOPEN_ISDIR                 = 526
	SQLITE_CANTOPEN_NOTEMPDIR             = 270
	SQLITE_CANTOPEN_SYMLINK               = 1550
	SQLITE_CDECL                          = 0
	SQLITE_CHANGESETAPPLY_INVERT          = 0x0002
	SQLITE_CHANGESETAPPLY_NOSAVEPOINT     = 0x0001
	SQLITE_CHANGESETSTART_INVERT          = 0x0002
	SQLITE_CHANGESET_ABORT                = 2
	SQLITE_CHANGESET_CONFLICT             = 3
	SQLITE_CHANGESET_CONSTRAINT           = 4
	SQLITE_CHANGESET_DATA                 = 1
	SQLITE_CHANGESET_FOREIGN_KEY          = 5
	SQLITE_CHANGESET_NOTFOUND             = 2
	SQLITE_CHANGESET_OMIT                 = 0
	SQLITE_CHANGESET_REPLACE              = 1
	SQLITE_CHECKPOINT_FULL                = 1
	SQLITE_CHECKPOINT_PASSIVE             = 0
	SQLITE_CHECKPOINT_RESTART             = 2
	SQLITE_CHECKPOINT_TRUNCATE            = 3
	SQLITE_CONFIG_COVERING_INDEX_SCAN     = 20
	SQLITE_CONFIG_GETMALLOC               = 5
	SQLITE_CONFIG_GETMUTEX                = 11
	SQLITE_CONFIG_GETPCACHE               = 15
	SQLITE_CONFIG_GETPCACHE2              = 19
	SQLITE_CONFIG_HEAP                    = 8
	SQLITE_CONFIG_LOG                     = 16
	SQLITE_CONFIG_LOOKASIDE               = 13
	SQLITE_CONFIG_MALLOC                  = 4
	SQLITE_CONFIG_MEMDB_MAXSIZE           = 29
	SQLITE_CONFIG_MEMSTATUS               = 9
	SQLITE_CONFIG_MMAP_SIZE               = 22
	SQLITE_CONFIG_MULTITHREAD             = 2
	SQLITE_CONFIG_MUTEX                   = 10
	SQLITE_CONFIG_PAGECACHE               = 7
	SQLITE_CONFIG_PCACHE                  = 14
	SQLITE_CONFIG_PCACHE2                 = 18
	SQLITE_CONFIG_PCACHE_HDRSZ            = 24
	SQLITE_CONFIG_PMASZ                   = 25
	SQLITE_CONFIG_SCRATCH                 = 6
	SQLITE_CONFIG_SERIALIZED              = 3
	SQLITE_CONFIG_SINGLETHREAD            = 1
	SQLITE_CONFIG_SMALL_MALLOC            = 27
	SQLITE_CONFIG_SORTERREF_SIZE          = 28
	SQLITE_CONFIG_SQLLOG                  = 21
	SQLITE_CONFIG_STMTJRNL_SPILL          = 26
	SQLITE_CONFIG_URI                     = 17
	SQLITE_CONFIG_WIN32_HEAPSIZE          = 23
	SQLITE_CONSTRAINT                     = 19
	SQLITE_CONSTRAINT_CHECK               = 275
	SQLITE_CONSTRAINT_COMMITHOOK          = 531
	SQLITE_CONSTRAINT_FOREIGNKEY          = 787
	SQLITE_CONSTRAINT_FUNCTION            = 1043
	SQLITE_CONSTRAINT_NOTNULL             = 1299
	SQLITE_CONSTRAINT_PINNED              = 2835
	SQLITE_CONSTRAINT_PRIMARYKEY          = 1555
	SQLITE_CONSTRAINT_ROWID               = 2579
	SQLITE_CONSTRAINT_TRIGGER             = 1811
	SQLITE_CONSTRAINT_UNIQUE              = 2067
	SQLITE_CONSTRAINT_VTAB                = 2323
	SQLITE_COPY                           = 0
	SQLITE_CORE                           = 1
	SQLITE_CORRUPT                        = 11
	SQLITE_CORRUPT_INDEX                  = 779
	SQLITE_CORRUPT_SEQUENCE               = 523
	SQLITE_CORRUPT_VTAB                   = 267
	SQLITE_CREATE_INDEX                   = 1
	SQLITE_CREATE_TABLE                   = 2
	SQLITE_CREATE_TEMP_INDEX              = 3
	SQLITE_CREATE_TEMP_TABLE              = 4
	SQLITE_CREATE_TEMP_TRIGGER            = 5
	SQLITE_CREATE_TEMP_VIEW               = 6
	SQLITE_CREATE_TRIGGER                 = 7
	SQLITE_CREATE_VIEW                    = 8
	SQLITE_CREATE_VTABLE                  = 29
	SQLITE_DBCONFIG_DEFENSIVE             = 1010
	SQLITE_DBCONFIG_DQS_DDL               = 1014
	SQLITE_DBCONFIG_DQS_DML               = 1013
	SQLITE_DBCONFIG_ENABLE_FKEY           = 1002
	SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004
	SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005
	SQLITE_DBCONFIG_ENABLE_QPSG           = 1007
	SQLITE_DBCONFIG_ENABLE_TRIGGER        = 1003
	SQLITE_DBCONFIG_ENABLE_VIEW           = 1015
	SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    = 1012
	SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    = 1016
	SQLITE_DBCONFIG_LOOKASIDE             = 1001
	SQLITE_DBCONFIG_MAINDBNAME            = 1000
	SQLITE_DBCONFIG_MAX                   = 1017
	SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      = 1006
	SQLITE_DBCONFIG_RESET_DATABASE        = 1009
	SQLITE_DBCONFIG_TRIGGER_EQP           = 1008
	SQLITE_DBCONFIG_TRUSTED_SCHEMA        = 1017
	SQLITE_DBCONFIG_WRITABLE_SCHEMA       = 1011
	SQLITE_DBSTATUS_CACHE_HIT             = 7
	SQLITE_DBSTATUS_CACHE_MISS            = 8
	SQLITE_DBSTATUS_CACHE_SPILL           = 12
	SQLITE_DBSTATUS_CACHE_USED            = 1
	SQLITE_DBSTATUS_CACHE_USED_SHARED     = 11
	SQLITE_DBSTATUS_CACHE_WRITE           = 9
	SQLITE_DBSTATUS_DEFERRED_FKS          = 10
	SQLITE_DBSTATUS_LOOKASIDE_HIT         = 4
	SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL   = 6
	SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE   = 5
	SQLITE_DBSTATUS_LOOKASIDE_USED        = 0
	SQLITE_DBSTATUS_MAX                   = 12
	SQLITE_DBSTATUS_SCHEMA_USED           = 2
	SQLITE_DBSTATUS_STMT_USED             = 3
	SQLITE_DELETE                         = 9
	SQLITE_DENY                           = 1
	SQLITE_DEPRECATED                     = 0
	SQLITE_DESERIALIZE_FREEONCLOSE        = 1
	SQLITE_DESERIALIZE_READONLY           = 4
	SQLITE_DESERIALIZE_RESIZEABLE         = 2
	SQLITE_DETACH                         = 25
	SQLITE_DETERMINISTIC                  = 0x000000800
	SQLITE_DIRECTONLY                     = 0x000080000
	SQLITE_DONE                           = 101
	SQLITE_DROP_INDEX                     = 10
	SQLITE_DROP_TABLE                     = 11
	SQLITE_DROP_TEMP_INDEX                = 12
	SQLITE_DROP_TEMP_TABLE                = 13
	SQLITE_DROP_TEMP_TRIGGER              = 14
	SQLITE_DROP_TEMP_VIEW                 = 15
	SQLITE_DROP_TRIGGER                   = 16
	SQLITE_DROP_VIEW                      = 17
	SQLITE_DROP_VTABLE                    = 30
	SQLITE_EMPTY                          = 16
	SQLITE_ENABLE_COLUMN_METADATA         = 1
	SQLITE_ENABLE_FTS5                    = 1
	SQLITE_ENABLE_GEOPOLY                 = 1
	SQLITE_ENABLE_JSON1                   = 1
	SQLITE_ENABLE_MEMORY_MANAGEMENT       = 1
	SQLITE_ENABLE_OFFSET_SQL_FUNC         = 1
	SQLITE_ENABLE_PREUPDATE_HOOK          = 1
	SQLITE_ENABLE_RBU                     = 1
	SQLITE_ENABLE_RTREE                   = 1
	SQLITE_ENABLE_SESSION                 = 1
	SQLITE_ENABLE_SNAPSHOT                = 1
	SQLITE_ENABLE_STAT4                   = 1
	SQLITE_ENABLE_UNLOCK_NOTIFY           = 1
	SQLITE_ERROR                          = 1
	SQLITE_ERROR_MISSING_COLLSEQ          = 257
	SQLITE_ERROR_RETRY                    = 513
	SQLITE_ERROR_SNAPSHOT                 = 769
	SQLITE_EXPERIMENTAL                   = 0
	SQLITE_FAIL                           = 3
	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE       = 31
	SQLITE_FCNTL_BUSYHANDLER              = 15
	SQLITE_FCNTL_CHUNK_SIZE               = 6
	SQLITE_FCNTL_CKPT_DONE                = 37
	SQLITE_FCNTL_CKPT_START               = 39
	SQLITE_FCNTL_CKSM_FILE                = 41
	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE      = 32
	SQLITE_FCNTL_COMMIT_PHASETWO          = 22
	SQLITE_FCNTL_DATA_VERSION             = 35
	SQLITE_FCNTL_EXTERNAL_READER          = 40
	SQLITE_FCNTL_FILE_POINTER             = 7
	SQLITE_FCNTL_GET_LOCKPROXYFILE        = 2
	SQLITE_FCNTL_HAS_MOVED                = 20
	SQLITE_FCNTL_JOURNAL_POINTER          = 28
	SQLITE_FCNTL_LAST_ERRNO               = 4
	SQLITE_FCNTL_LOCKSTATE                = 1
	SQLITE_FCNTL_LOCK_TIMEOUT             = 34
	SQLITE_FCNTL_MMAP_SIZE                = 18
	SQLITE_FCNTL_OVERWRITE                = 11
	SQLITE_FCNTL_PDB                      = 30
	SQLITE_FCNTL_PERSIST_WAL              = 10
	SQLITE_FCNTL_POWERSAFE_OVERWRITE      = 13
	SQLITE_FCNTL_PRAGMA                   = 14
	SQLITE_FCNTL_RBU                      = 26
	SQLITE_FCNTL_RESERVE_BYTES            = 38
	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE    = 33
	SQLITE_FCNTL_SET_LOCKPROXYFILE        = 3
	SQLITE_FCNTL_SIZE_HINT                = 5
	SQLITE_FCNTL_SIZE_LIMIT               = 36
	SQLITE_FCNTL_SYNC                     = 21
	SQLITE_FCNTL_SYNC_OMITTED             = 8
	SQLITE_FCNTL_TEMPFILENAME             = 16
	SQLITE_FCNTL_TRACE                    = 19
	SQLITE_FCNTL_VFSNAME                  = 12
	SQLITE_FCNTL_VFS_POINTER              = 27
	SQLITE_FCNTL_WAL_BLOCK                = 24
	SQLITE_FCNTL_WIN32_AV_RETRY           = 9
	SQLITE_FCNTL_WIN32_GET_HANDLE         = 29
	SQLITE_FCNTL_WIN32_SET_HANDLE         = 23
	SQLITE_FCNTL_ZIPVFS                   = 25
	SQLITE_FLOAT                          = 2
	SQLITE_FORMAT                         = 24
	SQLITE_FULL                           = 13
	SQLITE_FUNCTION                       = 31
	SQLITE_GET_LOCKPROXYFILE              = 2
	SQLITE_IGNORE                         = 2
	SQLITE_INDEX_CONSTRAINT_EQ            = 2
	SQLITE_INDEX_CONSTRAINT_FUNCTION      = 150
	SQLITE_INDEX_CONSTRAINT_GE            = 32
	SQLITE_INDEX_CONSTRAINT_GLOB          = 66
	SQLITE_INDEX_CONSTRAINT_GT            = 4
	SQLITE_INDEX_CONSTRAINT_IS            = 72
	SQLITE_INDEX_CONSTRAINT_ISNOT         = 69
	SQLITE_INDEX_CONSTRAINT_ISNOTNULL     = 70
	SQLITE_INDEX_CONSTRAINT_ISNULL        = 71
	SQLITE_INDEX_CONSTRAINT_LE            = 8
	SQLITE_INDEX_CONSTRAINT_LIKE          = 65
	SQLITE_INDEX_CONSTRAINT_LT            = 16
	SQLITE_INDEX_CONSTRAINT_MATCH         = 64
	SQLITE_INDEX_CONSTRAINT_NE            = 68
	SQLITE_INDEX_CONSTRAINT_REGEXP        = 67
	SQLITE_INDEX_SCAN_UNIQUE              = 1
	SQLITE_INNOCUOUS                      = 0x000200000
	SQLITE_INSERT                         = 18
	SQLITE_INTEGER                        = 1
	SQLITE_INTERNAL                       = 2
	SQLITE_INTERRUPT                      = 9
	SQLITE_IOCAP_ATOMIC                   = 0x00000001
	SQLITE_IOCAP_ATOMIC16K                = 0x00000040
	SQLITE_IOCAP_ATOMIC1K                 = 0x00000004
	SQLITE_IOCAP_ATOMIC2K                 = 0x00000008
	SQLITE_IOCAP_ATOMIC32K                = 0x00000080
	SQLITE_IOCAP_ATOMIC4K                 = 0x00000010
	SQLITE_IOCAP_ATOMIC512                = 0x00000002
	SQLITE_IOCAP_ATOMIC64K                = 0x00000100
	SQLITE_IOCAP_ATOMIC8K                 = 0x00000020
	SQLITE_IOCAP_BATCH_ATOMIC             = 0x00004000
	SQLITE_IOCAP_IMMUTABLE                = 0x00002000
	SQLITE_IOCAP_POWERSAFE_OVERWRITE      = 0x00001000
	SQLITE_IOCAP_SAFE_APPEND              = 0x00000200
	SQLITE_IOCAP_SEQUENTIAL               = 0x00000400
	SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN    = 0x00000800
	SQLITE_IOERR                          = 10
	SQLITE_IOERR_ACCESS                   = 3338
	SQLITE_IOERR_AUTH                     = 7178
	SQLITE_IOERR_BEGIN_ATOMIC             = 7434
	SQLITE_IOERR_BLOCKED                  = 2826
	SQLITE_IOERR_CHECKRESERVEDLOCK        = 3594
	SQLITE_IOERR_CLOSE                    = 4106
	SQLITE_IOERR_COMMIT_ATOMIC            = 7690
	SQLITE_IOERR_CONVPATH                 = 6666
	SQLITE_IOERR_CORRUPTFS                = 8458
	SQLITE_IOERR_DATA                     = 8202
	SQLITE_IOERR_DELETE                   = 2570
	SQLITE_IOERR_DELETE_NOENT             = 5898
	SQLITE_IOERR_DIR_CLOSE                = 4362
	SQLITE_IOERR_DIR_FSYNC                = 1290
	SQLITE_IOERR_FSTAT                    = 1802
	SQLITE_IOERR_FSYNC                    = 1034
	SQLITE_IOERR_GETTEMPPATH              = 6410
	SQLITE_IOERR_LOCK                     = 3850
	SQLITE_IOERR_MMAP                     = 6154
	SQLITE_IOERR_NOMEM                    = 3082
	SQLITE_IOERR_RDLOCK                   = 2314
	SQLITE_IOERR_READ                     = 266
	SQLITE_IOERR_ROLLBACK_ATOMIC          = 7946
	SQLITE_IOERR_SEEK                     = 5642
	SQLITE_IOERR_SHMLOCK                  = 5130
	SQLITE_IOERR_SHMMAP                   = 5386
	SQLITE_IOERR_SHMOPEN                  = 4618
	SQLITE_IOERR_SHMSIZE                  = 4874
	SQLITE_IOERR_SHORT_READ               = 522
	SQLITE_IOERR_TRUNCATE                 = 1546
	SQLITE_IOERR_UNLOCK                   = 2058
	SQLITE_IOERR_VNODE                    = 6922
	SQLITE_IOERR_WRITE                    = 778
	SQLITE_LAST_ERRNO                     = 4
	SQLITE_LIKE_DOESNT_MATCH_BLOBS        = 1
	SQLITE_LIMIT_ATTACHED                 = 7
	SQLITE_LIMIT_COLUMN                   = 2
	SQLITE_LIMIT_COMPOUND_SELECT          = 4
	SQLITE_LIMIT_EXPR_DEPTH               = 3
	SQLITE_LIMIT_FUNCTION_ARG             = 6
	SQLITE_LIMIT_LENGTH                   = 0
	SQLITE_LIMIT_LIKE_PATTERN_LENGTH      = 8
	SQLITE_LIMIT_SQL_LENGTH               = 1
	SQLITE_LIMIT_TRIGGER_DEPTH            = 10
	SQLITE_LIMIT_VARIABLE_NUMBER          = 9
	SQLITE_LIMIT_VDBE_OP                  = 5
	SQLITE_LIMIT_WORKER_THREADS           = 11
	SQLITE_LOCKED                         = 6
	SQLITE_LOCKED_SHAREDCACHE             = 262
	SQLITE_LOCKED_VTAB                    = 518
	SQLITE_LOCK_EXCLUSIVE                 = 4
	SQLITE_LOCK_NONE                      = 0
	SQLITE_LOCK_PENDING                   = 3
	SQLITE_LOCK_RESERVED                  = 2
	SQLITE_LOCK_SHARED                    = 1
	SQLITE_MISMATCH                       = 20
	SQLITE_MISUSE                         = 21
	SQLITE_MUTEX_APPDEF                   = 1
	SQLITE_MUTEX_FAST                     = 0
	SQLITE_MUTEX_NOOP                     = 1
	SQLITE_MUTEX_RECURSIVE                = 1
	SQLITE_MUTEX_STATIC_APP1              = 8
	SQLITE_MUTEX_STATIC_APP2              = 9
	SQLITE_MUTEX_STATIC_APP3              = 10
	SQLITE_MUTEX_STATIC_LRU               = 6
	SQLITE_MUTEX_STATIC_LRU2              = 7
	SQLITE_MUTEX_STATIC_MAIN              = 2
	SQLITE_MUTEX_STATIC_MASTER            = 2
	SQLITE_MUTEX_STATIC_MEM               = 3
	SQLITE_MUTEX_STATIC_MEM2              = 4
	SQLITE_MUTEX_STATIC_OPEN              = 4
	SQLITE_MUTEX_STATIC_PMEM              = 7
	SQLITE_MUTEX_STATIC_PRNG              = 5
	SQLITE_MUTEX_STATIC_VFS1              = 11
	SQLITE_MUTEX_STATIC_VFS2              = 12
	SQLITE_MUTEX_STATIC_VFS3              = 13
	SQLITE_NOLFS                          = 22
	SQLITE_NOMEM                          = 7
	SQLITE_NOTADB                         = 26
	SQLITE_NOTFOUND                       = 12
	SQLITE_NOTICE                         = 27
	SQLITE_NOTICE_RECOVER_ROLLBACK        = 539
	SQLITE_NOTICE_RECOVER_WAL             = 283
	SQLITE_NULL                           = 5
	SQLITE_OK                             = 0
	SQLITE_OK_LOAD_PERMANENTLY            = 256
	SQLITE_OK_SYMLINK                     = 512
	SQLITE_OPEN_AUTOPROXY                 = 0x00000020
	SQLITE_OPEN_CREATE                    = 0x00000004
	SQLITE_OPEN_DELETEONCLOSE             = 0x00000008
	SQLITE_OPEN_EXCLUSIVE                 = 0x00000010
	SQLITE_OPEN_FULLMUTEX                 = 0x00010000
	SQLITE_OPEN_MAIN_DB                   = 0x00000100
	SQLITE_OPEN_MAIN_JOURNAL              = 0x00000800
	SQLITE_OPEN_MASTER_JOURNAL            = 0x00004000
	SQLITE_OPEN_MEMORY                    = 0x00000080
	SQLITE_OPEN_NOFOLLOW                  = 0x01000000
	SQLITE_OPEN_NOMUTEX                   = 0x00008000
	SQLITE_OPEN_PRIVATECACHE              = 0x00040000
	SQLITE_OPEN_READONLY                  = 0x00000001
	SQLITE_OPEN_READWRITE                 = 0x00000002
	SQLITE_OPEN_SHAREDCACHE               = 0x00020000
	SQLITE_OPEN_SUBJOURNAL                = 0x00002000
	SQLITE_OPEN_SUPER_JOURNAL             = 0x00004000
	SQLITE_OPEN_TEMP_DB                   = 0x00000200
	SQLITE_OPEN_TEMP_JOURNAL              = 0x00001000
	SQLITE_OPEN_TRANSIENT_DB              = 0x00000400
	SQLITE_OPEN_URI                       = 0x00000040
	SQLITE_OPEN_WAL                       = 0x00080000
	SQLITE_OS_UNIX                        = 1
	SQLITE_PERM                           = 3
	SQLITE_PRAGMA                         = 19
	SQLITE_PREPARE_NORMALIZE              = 0x02
	SQLITE_PREPARE_NO_VTAB                = 0x04
	SQLITE_PREPARE_PERSISTENT             = 0x01
	SQLITE_PROTOCOL                       = 15
	SQLITE_RANGE                          = 25
	SQLITE_READ                           = 20
	SQLITE_READONLY                       = 8
	SQLITE_READONLY_CANTINIT              = 1288
	SQLITE_READONLY_CANTLOCK              = 520
	SQLITE_READONLY_DBMOVED               = 1032
	SQLITE_READONLY_DIRECTORY             = 1544
	SQLITE_READONLY_RECOVERY              = 264
	SQLITE_READONLY_ROLLBACK              = 776
	SQLITE_RECURSIVE                      = 33
	SQLITE_REINDEX                        = 27
	SQLITE_REPLACE                        = 5
	SQLITE_ROLLBACK                       = 1
	SQLITE_ROW                            = 100
	SQLITE_SAVEPOINT                      = 32
	SQLITE_SCANSTAT_EST                   = 2
	SQLITE_SCANSTAT_EXPLAIN               = 4
	SQLITE_SCANSTAT_NAME                  = 3
	SQLITE_SCANSTAT_NLOOP                 = 0
	SQLITE_SCANSTAT_NVISIT                = 1
	SQLITE_SCANSTAT_SELECTID              = 5
	SQLITE_SCHEMA                         = 17
	SQLITE_SELECT                         = 21
	SQLITE_SERIALIZE_NOCOPY               = 0x001
	SQLITE_SESSION_CONFIG_STRMSIZE        = 1
	SQLITE_SESSION_OBJCONFIG_SIZE         = 1
	SQLITE_SET_LOCKPROXYFILE              = 3
	SQLITE_SHM_EXCLUSIVE                  = 8
	SQLITE_SHM_LOCK                       = 2
	SQLITE_SHM_NLOCK                      = 8
	SQLITE_SHM_SHARED                     = 4
	SQLITE_SHM_UNLOCK                     = 1
	SQLITE_SOUNDEX                        = 1
	SQLITE_SOURCE_ID                      = "2021-06-18 18:36:39 5c9a6c06871cb9fe42814af9c039eb6da5427a6ec28f187af7ebfb62eafa66e5"
	SQLITE_STATUS_MALLOC_COUNT            = 9
	SQLITE_STATUS_MALLOC_SIZE             = 5
	SQLITE_STATUS_MEMORY_USED             = 0
	SQLITE_STATUS_PAGECACHE_OVERFLOW      = 2
	SQLITE_STATUS_PAGECACHE_SIZE          = 7
	SQLITE_STATUS_PAGECACHE_USED          = 1
	SQLITE_STATUS_PARSER_STACK            = 6
	SQLITE_STATUS_SCRATCH_OVERFLOW        = 4
	SQLITE_STATUS_SCRATCH_SIZE            = 8
	SQLITE_STATUS_SCRATCH_USED            = 3
	SQLITE_STDCALL                        = 0
	SQLITE_STMTSTATUS_AUTOINDEX           = 3
	SQLITE_STMTSTATUS_FULLSCAN_STEP       = 1
	SQLITE_STMTSTATUS_MEMUSED             = 99
	SQLITE_STMTSTATUS_REPREPARE           = 5
	SQLITE_STMTSTATUS_RUN                 = 6
	SQLITE_STMTSTATUS_SORT                = 2
	SQLITE_STMTSTATUS_VM_STEP             = 4
	SQLITE_SUBTYPE                        = 0x000100000
	SQLITE_SYNC_DATAONLY                  = 0x00010
	SQLITE_SYNC_FULL                      = 0x00003
	SQLITE_SYNC_NORMAL                    = 0x00002
	SQLITE_SYSAPI                         = 0
	SQLITE_TESTCTRL_ALWAYS                = 13
	SQLITE_TESTCTRL_ASSERT                = 12
	SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS   = 10
	SQLITE_TESTCTRL_BITVEC_TEST           = 8
	SQLITE_TESTCTRL_BYTEORDER             = 22
	SQLITE_TESTCTRL_EXPLAIN_STMT          = 19
	SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS   = 29
	SQLITE_TESTCTRL_FAULT_INSTALL         = 9
	SQLITE_TESTCTRL_FIRST                 = 5
	SQLITE_TESTCTRL_IMPOSTER              = 25
	SQLITE_TESTCTRL_INTERNAL_FUNCTIONS    = 17
	SQLITE_TESTCTRL_ISINIT                = 23
	SQLITE_TESTCTRL_ISKEYWORD             = 16
	SQLITE_TESTCTRL_LAST                  = 32
	SQLITE_TESTCTRL_LOCALTIME_FAULT       = 18
	SQLITE_TESTCTRL_NEVER_CORRUPT         = 20
	SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD  = 19
	SQLITE_TESTCTRL_OPTIMIZATIONS         = 15
	SQLITE_TESTCTRL_PARSER_COVERAGE       = 26
	SQLITE_TESTCTRL_PENDING_BYTE          = 11
	SQLITE_TESTCTRL_PRNG_RESET            = 7
	SQLITE_TESTCTRL_PRNG_RESTORE          = 6
	SQLITE_TESTCTRL_PRNG_SAVE             = 5
	SQLITE_TESTCTRL_PRNG_SEED             = 28
	SQLITE_TESTCTRL_RESERVE               = 14
	SQLITE_TESTCTRL_RESULT_INTREAL        = 27
	SQLITE_TESTCTRL_SCRATCHMALLOC         = 17
	SQLITE_TESTCTRL_SEEK_COUNT            = 30
	SQLITE_TESTCTRL_SORTER_MMAP           = 24
	SQLITE_TESTCTRL_TRACEFLAGS            = 31
	SQLITE_TESTCTRL_TUNE                  = 32
	SQLITE_TESTCTRL_VDBE_COVERAGE         = 21
	SQLITE_TEXT                           = 3
	SQLITE_THREADSAFE                     = 1
	SQLITE_TOOBIG                         = 18
	SQLITE_TRACE_CLOSE                    = 0x08
	SQLITE_TRACE_PROFILE                  = 0x02
	SQLITE_TRACE_ROW                      = 0x04
	SQLITE_TRACE_STMT                     = 0x01
	SQLITE_TRANSACTION                    = 22
	SQLITE_TXN_NONE                       = 0
	SQLITE_TXN_READ                       = 1
	SQLITE_TXN_WRITE                      = 2
	SQLITE_UPDATE                         = 23
	SQLITE_UTF16                          = 4
	SQLITE_UTF16BE                        = 3
	SQLITE_UTF16LE                        = 2
	SQLITE_UTF16_ALIGNED                  = 8
	SQLITE_UTF8                           = 1
	SQLITE_VERSION                        = "3.36.0"
	SQLITE_VERSION_NUMBER                 = 3036000
	SQLITE_VTAB_CONSTRAINT_SUPPORT        = 1
	SQLITE_VTAB_DIRECTONLY                = 3
	SQLITE_VTAB_INNOCUOUS                 = 2
	SQLITE_WARNING                        = 28
	SQLITE_WARNING_AUTOINDEX              = 284
	SQLITE_WIN32_DATA_DIRECTORY_TYPE      = 1
	SQLITE_WIN32_TEMP_DIRECTORY_TYPE      = 2
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	TMP_MAX                               = 308915776
	UINT16_MAX                            = 65535
	UINT32_MAX                            = 4294967295
	UINT64_MAX                            = 18446744073709551615
	UINT8_MAX                             = 255
	UINTMAX_MAX                           = 18446744073709551615
	UINTPTR_MAX                           = 18446744073709551615
	UINT_FAST16_MAX                       = 4294967295
	UINT_FAST32_MAX                       = 4294967295
	UINT_FAST64_MAX                       = 18446744073709551615
	UINT_FAST8_MAX                        = 4294967295
	UINT_LEAST16_MAX                      = 65535
	UINT_LEAST32_MAX                      = 4294967295
	UINT_LEAST64_MAX                      = 18446744073709551615
	UINT_LEAST8_MAX                       = 255
	WCHAR_MAX                             = 0x7fffffff
	WCHAR_MIN                             = -2147483648
	WINT_MAX                              = 0x7fffffff
	WINT_MIN                              = -2147483648
	W_OK                                  = 0x02
	X_OK                                  = 0x01
	X_AMD64_BYTE_SWAP_H_                  = 0
	X_AMD64_INT_CONST_H_                  = 0
	X_AMD64_INT_LIMITS_H_                 = 0
	X_AMD64_INT_MWGWTYPES_H_              = 0
	X_AMD64_INT_TYPES_H_                  = 0
	X_AMD64_WCHAR_LIMITS_H_               = 0
	X_BIG_ENDIAN                          = 4321
	X_BSD_INT16_T_                        = 0
	X_BSD_INT32_T_                        = 0
	X_BSD_INT64_T_                        = 0
	X_BSD_INT8_T_                         = 0
	X_BSD_INTPTR_T_                       = 0
	X_BSD_UINT16_T_                       = 0
	X_BSD_UINT32_T_                       = 0
	X_BSD_UINT64_T_                       = 0
	X_BSD_UINT8_T_                        = 0
	X_BSD_UINTPTR_T_                      = 0
	X_BYTE_ORDER                          = 1234
	X_CS_PATH                             = 1
	X_CTYPE_A                             = 0x0001
	X_CTYPE_BL                            = 0x0200
	X_CTYPE_C                             = 0x0002
	X_CTYPE_D                             = 0x0004
	X_CTYPE_G                             = 0x0008
	X_CTYPE_H_                            = 0
	X_CTYPE_I                             = 0x0800
	X_CTYPE_INLINE_H_                     = 0
	X_CTYPE_L                             = 0x0010
	X_CTYPE_P                             = 0x0020
	X_CTYPE_Q                             = 0x2000
	X_CTYPE_R                             = 0x0400
	X_CTYPE_S                             = 0x0040
	X_CTYPE_T                             = 0x1000
	X_CTYPE_U                             = 0x0080
	X_CTYPE_X                             = 0x0100
	X_FILE_OFFSET_BITS                    = 64
	X_FSTDIO                              = 0
	X_FTS5_H                              = 0
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_LIB_PTHREAD_TYPES_H                 = 0
	X_LITTLE_ENDIAN                       = 1234
	X_LP64                                = 1
	X_NETBSD_SOURCE                       = 1
	X_O_SC_CLK_TCK                        = 3
	X_PC_2_SYMLINKS                       = 13
	X_PC_ACL_EXTENDED                     = 14
	X_PC_CHOWN_RESTRICTED                 = 7
	X_PC_FILESIZEBITS                     = 11
	X_PC_LINK_MAX                         = 1
	X_PC_MAX_CANON                        = 2
	X_PC_MAX_INPUT                        = 3
	X_PC_MIN_HOLE_SIZE                    = 15
	X_PC_NAME_MAX                         = 4
	X_PC_NO_TRUNC                         = 8
	X_PC_PATH_MAX                         = 5
	X_PC_PIPE_BUF                         = 6
	X_PC_SYMLINK_MAX                      = 12
	X_PC_SYNC_IO                          = 10
	X_PC_VDISABLE                         = 9
	X_PDP_ENDIAN                          = 3412
	X_POSIX2_C_BIND                       = 200112
	X_POSIX2_VERSION                      = 200112
	X_POSIX_ASYNCHRONOUS_IO               = 200112
	X_POSIX_BARRIERS                      = 200112
	X_POSIX_CHOWN_RESTRICTED              = 1
	X_POSIX_CLOCK_SELECTION               = -1
	X_POSIX_CPUTIME                       = 200112
	X_POSIX_FSYNC                         = 1
	X_POSIX_IPV6                          = 0
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_MAPPED_FILES                  = 1
	X_POSIX_MEMLOCK                       = 1
	X_POSIX_MEMLOCK_RANGE                 = 1
	X_POSIX_MEMORY_PROTECTION             = 1
	X_POSIX_MESSAGE_PASSING               = 200112
	X_POSIX_MONOTONIC_CLOCK               = 200112
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_PRIORITIZED_IO                = -1
	X_POSIX_PRIORITY_SCHEDULING           = 200112
	X_POSIX_RAW_SOCKETS                   = 200112
	X_POSIX_READER_WRITER_LOCKS           = 200112
	X_POSIX_REGEXP                        = 1
	X_POSIX_SEMAPHORES                    = 0
	X_POSIX_SHARED_MEMORY_OBJECTS         = 0
	X_POSIX_SHELL                         = 1
	X_POSIX_SPAWN                         = 200809
	X_POSIX_SPIN_LOCKS                    = 200112
	X_POSIX_SYNCHRONIZED_IO               = 1
	X_POSIX_THREADS                       = 200112
	X_POSIX_THREAD_ATTR_STACKADDR         = 200112
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200112
	X_POSIX_THREAD_CPUTIME                = 200112
	X_POSIX_THREAD_PRIO_PROTECT           = 200112
	X_POSIX_THREAD_SAFE_FUNCTIONS         = 200112
	X_POSIX_TIMERS                        = 200112
	X_POSIX_VERSION                       = 200112
	X_PT_BARRIERATTR_DEAD                 = 0xDEAD0808
	X_PT_BARRIERATTR_MAGIC                = 0x88880808
	X_PT_BARRIER_DEAD                     = 0xDEAD0008
	X_PT_BARRIER_MAGIC                    = 0x88880008
	X_PT_CONDATTR_DEAD                    = 0xDEAD0006
	X_PT_CONDATTR_MAGIC                   = 0x66660006
	X_PT_COND_DEAD                        = 0xDEAD0005
	X_PT_COND_MAGIC                       = 0x55550005
	X_PT_MUTEXATTR_DEAD                   = 0xDEAD0004
	X_PT_MUTEXATTR_MAGIC                  = 0x44440004
	X_PT_MUTEX_DEAD                       = 0xDEAD0003
	X_PT_MUTEX_MAGIC                      = 0x33330003
	X_PT_RWLOCKATTR_DEAD                  = 0xDEAD0909
	X_PT_RWLOCKATTR_MAGIC                 = 0x99990909
	X_PT_RWLOCK_DEAD                      = 0xDEAD0009
	X_PT_RWLOCK_MAGIC                     = 0x99990009
	X_PT_SPINLOCK_DEAD                    = 0xDEAD0007
	X_PT_SPINLOCK_MAGIC                   = 0x77770007
	X_PT_SPINLOCK_PSHARED                 = 0x00000001
	X_QUAD_HIGHWORD                       = 1
	X_QUAD_LOWWORD                        = 0
	X_SC_2_CHAR_TERM                      = 20
	X_SC_2_C_BIND                         = 18
	X_SC_2_C_DEV                          = 19
	X_SC_2_FORT_DEV                       = 21
	X_SC_2_FORT_RUN                       = 22
	X_SC_2_LOCALEDEF                      = 23
	X_SC_2_PBS                            = 80
	X_SC_2_PBS_ACCOUNTING                 = 81
	X_SC_2_PBS_CHECKPOINT                 = 82
	X_SC_2_PBS_LOCATE                     = 83
	X_SC_2_PBS_MESSAGE                    = 84
	X_SC_2_PBS_TRACK                      = 85
	X_SC_2_SW_DEV                         = 24
	X_SC_2_UPE                            = 25
	X_SC_2_VERSION                        = 17
	X_SC_AIO_LISTIO_MAX                   = 51
	X_SC_AIO_MAX                          = 52
	X_SC_ARG_MAX                          = 1
	X_SC_ASYNCHRONOUS_IO                  = 50
	X_SC_ATEXIT_MAX                       = 40
	X_SC_BARRIERS                         = 43
	X_SC_BC_BASE_MAX                      = 9
	X_SC_BC_DIM_MAX                       = 10
	X_SC_BC_SCALE_MAX                     = 11
	X_SC_BC_STRING_MAX                    = 12
	X_SC_CHILD_MAX                        = 2
	X_SC_CLK_TCK                          = 39
	X_SC_CLOCK_SELECTION                  = 49
	X_SC_COLL_WEIGHTS_MAX                 = 13
	X_SC_CPUTIME                          = 90
	X_SC_DELAYTIMER_MAX                   = 92
	X_SC_EXPR_NEST_MAX                    = 14
	X_SC_FSYNC                            = 29
	X_SC_GETGR_R_SIZE_MAX                 = 47
	X_SC_GETPW_R_SIZE_MAX                 = 48
	X_SC_HOST_NAME_MAX                    = 69
	X_SC_IOV_MAX                          = 32
	X_SC_JOB_CONTROL                      = 6
	X_SC_LINE_MAX                         = 15
	X_SC_LOGIN_NAME_MAX                   = 37
	X_SC_MAPPED_FILES                     = 33
	X_SC_MEMLOCK                          = 34
	X_SC_MEMLOCK_RANGE                    = 35
	X_SC_MEMORY_PROTECTION                = 36
	X_SC_MESSAGE_PASSING                  = 53
	X_SC_MONOTONIC_CLOCK                  = 38
	X_SC_MQ_OPEN_MAX                      = 54
	X_SC_MQ_PRIO_MAX                      = 55
	X_SC_NGROUPS_MAX                      = 4
	X_SC_NPROCESSORS_CONF                 = 1001
	X_SC_NPROCESSORS_ONLN                 = 1002
	X_SC_OPEN_MAX                         = 5
	X_SC_PAGESIZE                         = 28
	X_SC_PAGE_SIZE                        = 28
	X_SC_PASS_MAX                         = 70
	X_SC_PHYS_PAGES                       = 121
	X_SC_PRIORITY_SCHEDULING              = 56
	X_SC_READER_WRITER_LOCKS              = 46
	X_SC_REALTIME_SIGNALS                 = 94
	X_SC_REGEXP                           = 71
	X_SC_RE_DUP_MAX                       = 16
	X_SC_SAVED_IDS                        = 7
	X_SC_SCHED_PRI_MAX                    = 2003
	X_SC_SCHED_PRI_MIN                    = 2002
	X_SC_SCHED_RT_TS                      = 2001
	X_SC_SEMAPHORES                       = 42
	X_SC_SEM_NSEMS_MAX                    = 89
	X_SC_SHARED_MEMORY_OBJECTS            = 87
	X_SC_SHELL                            = 72
	X_SC_SIGQUEUE_MAX                     = 93
	X_SC_SPAWN                            = 86
	X_SC_SPIN_LOCKS                       = 45
	X_SC_STREAM_MAX                       = 26
	X_SC_SYMLOOP_MAX                      = 73
	X_SC_SYNCHRONIZED_IO                  = 31
	X_SC_THREADS                          = 41
	X_SC_THREAD_ATTR_STACKADDR            = 61
	X_SC_THREAD_ATTR_STACKSIZE            = 62
	X_SC_THREAD_CPUTIME                   = 91
	X_SC_THREAD_DESTRUCTOR_ITERATIONS     = 57
	X_SC_THREAD_KEYS_MAX                  = 58
	X_SC_THREAD_PRIORITY_SCHEDULING       = 63
	X_SC_THREAD_PRIO_INHERIT              = 64
	X_SC_THREAD_PRIO_PROTECT              = 65
	X_SC_THREAD_PROCESS_SHARED            = 66
	X_SC_THREAD_SAFE_FUNCTIONS            = 67
	X_SC_THREAD_STACK_MIN                 = 59
	X_SC_THREAD_THREADS_MAX               = 60
	X_SC_TIMERS                           = 44
	X_SC_TIMER_MAX                        = 88
	X_SC_TTY_NAME_MAX                     = 68
	X_SC_TZNAME_MAX                       = 27
	X_SC_V6_ILP32_OFF32                   = 74
	X_SC_V6_ILP32_OFFBIG                  = 75
	X_SC_V6_LP64_OFF64                    = 76
	X_SC_V6_LPBIG_OFFBIG                  = 77
	X_SC_VERSION                          = 8
	X_SC_XOPEN_SHM                        = 30
	X_SQLITE3RTREE_H_                     = 0
	X_STDIO_H_                            = 0
	X_STDLIB_H_                           = 0
	X_STRINGS_H_                          = 0
	X_STRING_H_                           = 0
	X_SYS_ANSI_H_                         = 0
	X_SYS_BSWAP_H_                        = 0
	X_SYS_CDEFS_ELF_H_                    = 0
	X_SYS_CDEFS_H_                        = 0
	X_SYS_COMMON_ANSI_H_                  = 0
	X_SYS_COMMON_INT_LIMITS_H_            = 0
	X_SYS_COMMON_INT_MWGWTYPES_H_         = 0
	X_SYS_COMMON_INT_TYPES_H_             = 0
	X_SYS_CTYPE_BITS_H_                   = 0
	X_SYS_ENDIAN_H_                       = 0
	X_SYS_FD_SET_H_                       = 0
	X_SYS_NULL_H_                         = 0
	X_SYS_STDARG_H_                       = 0
	X_SYS_STDINT_H_                       = 0
	X_SYS_TYPES_H_                        = 0
	X_SYS_UNISTD_H_                       = 0
	X_UNISTD_H_                           = 0
	X_X86_64_BSWAP_H_                     = 0
	X_X86_64_CDEFS_H_                     = 0
	X_X86_64_TYPES_H_                     = 0
	X_XOPEN_SHM                           = 0
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */

// A program for performance testing.
//
// The available command-line options are described below:
var zHelp = *(*[2206]int8)(unsafe.Pointer(ts /* "Usage: %s [--opt..." */)) /* speedtest1.c:6:19 */

//	$NetBSD: featuretest.h,v 1.10 2013/04/26 18:29:06 christos Exp $

// Written by Klaus Klein <kleink@NetBSD.org>, February 2, 1998.
// Public domain.
//
// NOTE: Do not protect this header against multiple inclusion.  Doing
// so can have subtle side-effects due to header file inclusion order
// and testing of e.g. _POSIX_SOURCE vs. _POSIX_C_SOURCE.  Instead,
// protect each CPP macro that we want to supply.

// Feature-test macros are defined by several standards, and allow an
// application to specify what symbols they want the system headers to
// expose, and hence what standard they want them to conform to.
// There are two classes of feature-test macros.  The first class
// specify complete standards, and if one of these is defined, header
// files will try to conform to the relevant standard.  They are:
//
// ANSI macros:
// _ANSI_SOURCE			ANSI C89
//
// POSIX macros:
// _POSIX_SOURCE == 1		IEEE Std 1003.1 (version?)
// _POSIX_C_SOURCE == 1		IEEE Std 1003.1-1990
// _POSIX_C_SOURCE == 2		IEEE Std 1003.2-1992
// _POSIX_C_SOURCE == 199309L	IEEE Std 1003.1b-1993
// _POSIX_C_SOURCE == 199506L	ISO/IEC 9945-1:1996
// _POSIX_C_SOURCE == 200112L	IEEE Std 1003.1-2001
// _POSIX_C_SOURCE == 200809L   IEEE Std 1003.1-2008
//
// X/Open macros:
// _XOPEN_SOURCE		System Interfaces and Headers, Issue 4, Ver 2
// _XOPEN_SOURCE_EXTENDED == 1	XSH4.2 UNIX extensions
// _XOPEN_SOURCE == 500		System Interfaces and Headers, Issue 5
// _XOPEN_SOURCE == 520		Networking Services (XNS), Issue 5.2
// _XOPEN_SOURCE == 600		IEEE Std 1003.1-2001, XSI option
// _XOPEN_SOURCE == 700		IEEE Std 1003.1-2008, XSI option
//
// NetBSD macros:
// _NETBSD_SOURCE == 1		Make all NetBSD features available.
//
// If more than one of these "major" feature-test macros is defined,
// then the set of facilities provided (and namespace used) is the
// union of that specified by the relevant standards, and in case of
// conflict, the earlier standard in the above list has precedence (so
// if both _POSIX_C_SOURCE and _NETBSD_SOURCE are defined, the version
// of rename() that's used is the POSIX one).  If none of the "major"
// feature-test macros is defined, _NETBSD_SOURCE is assumed.
//
// There are also "minor" feature-test macros, which enable extra
// functionality in addition to some base standard.  They should be
// defined along with one of the "major" macros.  The "minor" macros
// are:
//
// _REENTRANT
// _ISOC99_SOURCE
// _ISOC11_SOURCE
// _LARGEFILE_SOURCE		Large File Support
//		<http://ftp.sas.com/standards/large.file/x_open.20Mar96.html>

type va_list = uintptr /* stdarg.h:53:19 */

// CAPI3REF: 64-Bit Integer Types
// KEYWORDS: sqlite_int64 sqlite_uint64
//
// Because there is no cross-platform way to specify 64-bit integer types
// SQLite includes typedefs for 64-bit signed and unsigned integers.
//
// The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.
// The sqlite_int64 and sqlite_uint64 types are supported for backwards
// compatibility only.
//
// ^The sqlite3_int64 and sqlite_int64 types can store integer values
// between -9223372036854775808 and +9223372036854775807 inclusive.  ^The
// sqlite3_uint64 and sqlite_uint64 types can store integer values
// between 0 and +18446744073709551615 inclusive.
type sqlite_int64 = int64           /* sqlite3.h:278:25 */
type sqlite_uint64 = uint64         /* sqlite3.h:279:34 */
type sqlite3_int64 = sqlite_int64   /* sqlite3.h:281:22 */
type sqlite3_uint64 = sqlite_uint64 /* sqlite3.h:282:23 */

// The type for a callback function.
// This is legacy and deprecated.  It is included for historical
// compatibility and is not documented.
type sqlite3_callback = uintptr /* sqlite3.h:338:13 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file1 = struct{ pMethods uintptr } /* sqlite3.h:684:9 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file = sqlite3_file1 /* sqlite3.h:684:29 */
type sqlite3_io_methods1 = struct {
	iVersion               int32
	_                      [4]byte
	xClose                 uintptr
	xRead                  uintptr
	xWrite                 uintptr
	xTruncate              uintptr
	xSync                  uintptr
	xFileSize              uintptr
	xLock                  uintptr
	xUnlock                uintptr
	xCheckReservedLock     uintptr
	xFileControl           uintptr
	xSectorSize            uintptr
	xDeviceCharacteristics uintptr
	xShmMap                uintptr
	xShmLock               uintptr
	xShmBarrier            uintptr
	xShmUnmap              uintptr
	xFetch                 uintptr
	xUnfetch               uintptr
} /* sqlite3.h:684:9 */

// CAPI3REF: OS Interface File Virtual Methods Object
//
// Every file opened by the [sqlite3_vfs.xOpen] method populates an
// [sqlite3_file] object (or, more commonly, a subclass of the
// [sqlite3_file] object) with a pointer to an instance of this object.
// This object defines the methods used to perform various operations
// against the open file represented by the [sqlite3_file] object.
//
// If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element
// to a non-NULL pointer, then the sqlite3_io_methods.xClose method
// may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The
// only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]
// is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element
// to NULL.
//
// The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or
// [SQLITE_SYNC_FULL].  The first choice is the normal fsync().
// The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]
// flag may be ORed in to indicate that only the data of the file
// and not its inode needs to be synced.
//
// The integer values to xLock() and xUnlock() are one of
// <ul>
// <li> [SQLITE_LOCK_NONE],
// <li> [SQLITE_LOCK_SHARED],
// <li> [SQLITE_LOCK_RESERVED],
// <li> [SQLITE_LOCK_PENDING], or
// <li> [SQLITE_LOCK_EXCLUSIVE].
// </ul>
// xLock() increases the lock. xUnlock() decreases the lock.
// The xCheckReservedLock() method checks whether any database connection,
// either in this process or in some other process, is holding a RESERVED,
// PENDING, or EXCLUSIVE lock on the file.  It returns true
// if such a lock exists and false otherwise.
//
// The xFileControl() method is a generic interface that allows custom
// VFS implementations to directly control an open file using the
// [sqlite3_file_control()] interface.  The second "op" argument is an
// integer opcode.  The third argument is a generic pointer intended to
// point to a structure that may contain arguments or space in which to
// write return values.  Potential uses for xFileControl() might be
// functions to enable blocking locks with timeouts, to change the
// locking strategy (for example to use dot-file locks), to inquire
// about the status of a lock, or to break stale locks.  The SQLite
// core reserves all opcodes less than 100 for its own use.
// A [file control opcodes | list of opcodes] less than 100 is available.
// Applications that define a custom xFileControl method should use opcodes
// greater than 100 to avoid conflicts.  VFS implementations should
// return [SQLITE_NOTFOUND] for file control opcodes that they do not
// recognize.
//
// The xSectorSize() method returns the sector size of the
// device that underlies the file.  The sector size is the
// minimum write that can be performed without disturbing
// other bytes in the file.  The xDeviceCharacteristics()
// method returns a bit vector describing behaviors of the
// underlying device:
//
// <ul>
// <li> [SQLITE_IOCAP_ATOMIC]
// <li> [SQLITE_IOCAP_ATOMIC512]
// <li> [SQLITE_IOCAP_ATOMIC1K]
// <li> [SQLITE_IOCAP_ATOMIC2K]
// <li> [SQLITE_IOCAP_ATOMIC4K]
// <li> [SQLITE_IOCAP_ATOMIC8K]
// <li> [SQLITE_IOCAP_ATOMIC16K]
// <li> [SQLITE_IOCAP_ATOMIC32K]
// <li> [SQLITE_IOCAP_ATOMIC64K]
// <li> [SQLITE_IOCAP_SAFE_APPEND]
// <li> [SQLITE_IOCAP_SEQUENTIAL]
// <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]
// <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]
// <li> [SQLITE_IOCAP_IMMUTABLE]
// <li> [SQLITE_IOCAP_BATCH_ATOMIC]
// </ul>
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().
//
// If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
// in the unread portions of the buffer with zeros.  A VFS that
// fails to zero-fill short reads might seem to work.  However,
// failure to zero-fill short reads will eventually lead to
// database corruption.
type sqlite3_io_methods = sqlite3_io_methods1 /* sqlite3.h:783:35 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs1 = struct {
	iVersion          int32
	szOsFile          int32
	mxPathname        int32
	_                 [4]byte
	pNext             uintptr
	zName             uintptr
	pAppData          uintptr
	xOpen             uintptr
	xDelete           uintptr
	xAccess           uintptr
	xFullPathname     uintptr
	xDlOpen           uintptr
	xDlError          uintptr
	xDlSym            uintptr
	xDlClose          uintptr
	xRandomness       uintptr
	xSleep            uintptr
	xCurrentTime      uintptr
	xGetLastError     uintptr
	xCurrentTimeInt64 uintptr
	xSetSystemCall    uintptr
	xGetSystemCall    uintptr
	xNextSystemCall   uintptr
} /* sqlite3.h:1387:9 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs = sqlite3_vfs1    /* sqlite3.h:1387:28 */
type sqlite3_syscall_ptr = uintptr /* sqlite3.h:1388:14 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods1 = struct {
	xMalloc   uintptr
	xFree     uintptr
	xRealloc  uintptr
	xSize     uintptr
	xRoundup  uintptr
	xInit     uintptr
	xShutdown uintptr
	pAppData  uintptr
} /* sqlite3.h:1685:9 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods = sqlite3_mem_methods1 /* sqlite3.h:1685:36 */

// CAPI3REF: Constants Defining Special Destructor Behavior
//
// These are special values for the destructor that is passed in as the
// final argument to routines like [sqlite3_result_blob()].  ^If the destructor
// argument is SQLITE_STATIC, it means that the content pointer is constant
// and will never change.  It does not need to be destroyed.  ^The
// SQLITE_TRANSIENT value means that the content will likely change in
// the near future and that SQLite should make its own private copy of
// the content before returning.
//
// The typedef is necessary to work around problems in certain
// C++ compilers.
type sqlite3_destructor_type = uintptr /* sqlite3.h:5665:14 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab1 = struct {
	pModule uintptr
	nRef    int32
	_       [4]byte
	zErrMsg uintptr
} /* sqlite3.h:6784:9 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab = sqlite3_vtab1 /* sqlite3.h:6784:29 */
type sqlite3_index_info1 = struct {
	nConstraint      int32
	_                [4]byte
	aConstraint      uintptr
	nOrderBy         int32
	_                [4]byte
	aOrderBy         uintptr
	aConstraintUsage uintptr
	idxNum           int32
	_                [4]byte
	idxStr           uintptr
	needToFreeIdxStr int32
	orderByConsumed  int32
	estimatedCost    float64
	estimatedRows    sqlite3_int64
	idxFlags         int32
	_                [4]byte
	colUsed          sqlite3_uint64
} /* sqlite3.h:6785:9 */

type sqlite3_index_info = sqlite3_index_info1       /* sqlite3.h:6785:35 */
type sqlite3_vtab_cursor1 = struct{ pVtab uintptr } /* sqlite3.h:6786:9 */

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1 /* sqlite3.h:6786:36 */
type sqlite3_module1 = struct {
	iVersion      int32
	_             [4]byte
	xCreate       uintptr
	xConnect      uintptr
	xBestIndex    uintptr
	xDisconnect   uintptr
	xDestroy      uintptr
	xOpen         uintptr
	xClose        uintptr
	xFilter       uintptr
	xNext         uintptr
	xEof          uintptr
	xColumn       uintptr
	xRowid        uintptr
	xUpdate       uintptr
	xBegin        uintptr
	xSync         uintptr
	xCommit       uintptr
	xRollback     uintptr
	xFindFunction uintptr
	xRename       uintptr
	xSavepoint    uintptr
	xRelease      uintptr
	xRollbackTo   uintptr
	xShadowName   uintptr
} /* sqlite3.h:6784:9 */

type sqlite3_module = sqlite3_module1 /* sqlite3.h:6787:31 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint = struct {
	iColumn     int32
	op          uint8
	usable      uint8
	_           [2]byte
	iTermOffset int32
} /* sqlite3.h:6785:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_orderby = struct {
	iColumn int32
	desc    uint8
	_       [3]byte
} /* sqlite3.h:6785:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint_usage = struct {
	argvIndex int32
	omit      uint8
	_         [3]byte
} /* sqlite3.h:6785:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods1 = struct {
	xMutexInit    uintptr
	xMutexEnd     uintptr
	xMutexAlloc   uintptr
	xMutexFree    uintptr
	xMutexEnter   uintptr
	xMutexTry     uintptr
	xMutexLeave   uintptr
	xMutexHeld    uintptr
	xMutexNotheld uintptr
} /* sqlite3.h:7619:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods = sqlite3_mutex_methods1 /* sqlite3.h:7619:38 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page1 = struct {
	pBuf   uintptr
	pExtra uintptr
} /* sqlite3.h:8375:9 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page = sqlite3_pcache_page1 /* sqlite3.h:8375:36 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods21 = struct {
	iVersion   int32
	_          [4]byte
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
	xShrink    uintptr
} /* sqlite3.h:8540:9 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods2 = sqlite3_pcache_methods21 /* sqlite3.h:8540:40 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods1 = struct {
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
} /* sqlite3.h:8563:9 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods = sqlite3_pcache_methods1 /* sqlite3.h:8563:39 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot1 = struct{ hidden [48]uint8 } /* sqlite3.h:9630:9 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot = sqlite3_snapshot1 /* sqlite3.h:9632:3 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry1 = struct {
	pContext uintptr
	nParam   int32
	_        [4]byte
	aParam   uintptr
	pUser    uintptr
	xDelUser uintptr
} /* sqlite3.h:9957:9 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1 /* sqlite3.h:9957:39 */
type sqlite3_rtree_query_info1 = struct {
	pContext      uintptr
	nParam        int32
	_             [4]byte
	aParam        uintptr
	pUser         uintptr
	xDelUser      uintptr
	aCoord        uintptr
	anQueue       uintptr
	nCoord        int32
	iLevel        int32
	mxLevel       int32
	_             [4]byte
	iRowid        sqlite3_int64
	rParentScore  sqlite3_rtree_dbl
	eParentWithin int32
	eWithin       int32
	rScore        sqlite3_rtree_dbl
	apSqlParam    uintptr
} /* sqlite3.h:9958:9 */

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1 /* sqlite3.h:9958:41 */

// The double-precision datatype used by RTree depends on the
// SQLITE_RTREE_INT_ONLY compile-time option.
type sqlite3_rtree_dbl = float64 /* sqlite3.h:9966:18 */

// CAPI3REF: Values for sqlite3session_config().

// Make sure we can call this stuff from C++.

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi1 = struct {
	iVersion           int32
	_                  [4]byte
	xUserData          uintptr
	xColumnCount       uintptr
	xRowCount          uintptr
	xColumnTotalSize   uintptr
	xTokenize          uintptr
	xPhraseCount       uintptr
	xPhraseSize        uintptr
	xInstCount         uintptr
	xInst              uintptr
	xRowid             uintptr
	xColumnText        uintptr
	xColumnSize        uintptr
	xQueryPhrase       uintptr
	xSetAuxdata        uintptr
	xGetAuxdata        uintptr
	xPhraseFirst       uintptr
	xPhraseNext        uintptr
	xPhraseFirstColumn uintptr
	xPhraseNextColumn  uintptr
} /* sqlite3.h:11813:9 */

// CAPI3REF: Values for sqlite3session_config().

// Make sure we can call this stuff from C++.

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi = Fts5ExtensionApi1 /* sqlite3.h:11813:33 */
type Fts5PhraseIter1 = struct {
	a uintptr
	b uintptr
} /* sqlite3.h:11815:9 */

type Fts5PhraseIter = Fts5PhraseIter1 /* sqlite3.h:11815:31 */

type fts5_extension_function = uintptr /* sqlite3.h:11817:14 */
type fts5_tokenizer1 = struct {
	xCreate   uintptr
	xDelete   uintptr
	xTokenize uintptr
} /* sqlite3.h:12276:9 */

type fts5_tokenizer = fts5_tokenizer1 /* sqlite3.h:12276:31 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api1 = struct {
	iVersion         int32
	_                [4]byte
	xCreateTokenizer uintptr
	xFindTokenizer   uintptr
	xCreateFunction  uintptr
} /* sqlite3.h:12312:9 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api = fts5_api1 /* sqlite3.h:12312:25 */
type ssize_t = int64      /* stdio.h:49:23 */

//	$NetBSD: null.h,v 1.9 2010/07/06 11:56:20 kleink Exp $

// Written by Klaus Klein <kleink@NetBSD.org>, December 22, 1999.
// Public domain.

// This is fairly grotesque, but pure ANSI code must not inspect the
// innards of an fpos_t anyway.  The library internally uses off_t,
// which we assume is exactly as big as eight chars.
type __sfpos = struct {
	_pos        int64
	_mbstate_in struct {
		__mbstateL int64
		_          [120]byte
	}
	_mbstate_out struct {
		__mbstateL int64
		_          [120]byte
	}
} /* stdio.h:67:9 */

//	$NetBSD: null.h,v 1.9 2010/07/06 11:56:20 kleink Exp $

// Written by Klaus Klein <kleink@NetBSD.org>, December 22, 1999.
// Public domain.

// This is fairly grotesque, but pure ANSI code must not inspect the
// innards of an fpos_t anyway.  The library internally uses off_t,
// which we assume is exactly as big as eight chars.
type fpos_t = __sfpos /* stdio.h:70:3 */

// NB: to fit things in six character monocase externals, the stdio
// code uses the prefix `__s' for stdio objects, typically followed
// by a three-character attempt at a mnemonic.

// stdio buffers
type __sbuf = struct {
	_base uintptr
	_size int32
	_     [4]byte
} /* stdio.h:81:1 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type __sFILE = struct {
	_p     uintptr
	_r     int32
	_w     int32
	_flags uint16
	_file  int16
	_      [4]byte
	_bf    struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_lbfsize int32
	_        [4]byte
	_cookie  uintptr
	_close   uintptr
	_read    uintptr
	_seek    uintptr
	_write   uintptr
	_ext     struct {
		_base uintptr
		_size int32
		_     [4]byte
	}
	_up        uintptr
	_ur        int32
	_ubuf      [3]uint8
	_nbuf      [1]uint8
	_flush     uintptr
	_lb_unused [8]int8
	_blksize   int32
	_          [4]byte
	_offset    int64
} /* stdio.h:112:9 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// NB: see WARNING above before changing the layout of this structure!
type FILE = __sFILE /* stdio.h:146:3 */

// X/Open CAE Specification Issue 5 Version 2
type off_t = int64 /* stdio.h:376:18 */

type locale_t = uintptr /* stdio.h:543:25 */

// __cpu_simple_lock_t used to be a full word.

// The amd64 does not have strict alignment requirements.

//	$NetBSD: ansi.h,v 1.11 2019/05/07 03:49:26 kamil Exp $

//	$NetBSD: common_ansi.h,v 1.1 2014/08/19 07:27:31 matt Exp $

// -
// Copyright (c) 2014 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Matt Thomas of 3am Software Foundry.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//	$NetBSD: int_types.h,v 1.7 2014/07/25 21:43:13 joerg Exp $

// -
// Copyright (c) 1990 The Regents of the University of California.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	from: @(#)types.h	7.5 (Berkeley) 3/9/91

//	$NetBSD: ansi.h,v 1.14 2011/07/17 20:54:54 joerg Exp $

// -
// Copyright (c) 2000, 2001, 2002 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Jun-ichiro itojun Hagino and by Klaus Klein.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

type int8_t = int8 /* types.h:54:18 */

type uint8_t = uint8 /* types.h:59:19 */

type int16_t = int16 /* types.h:64:19 */

type uint16_t = uint16 /* types.h:69:20 */

type int32_t = int32 /* types.h:74:19 */

type uint32_t = uint32 /* types.h:79:20 */

type int64_t = int64 /* types.h:84:19 */

type uint64_t = uint64 /* types.h:89:20 */

type u_int8_t = uint8_t   /* types.h:93:18 */
type u_int16_t = uint16_t /* types.h:94:18 */
type u_int32_t = uint32_t /* types.h:95:18 */
type u_int64_t = uint64_t /* types.h:96:18 */

//	$NetBSD: endian.h,v 1.1 2003/04/26 18:39:40 fvdl Exp $

//	$NetBSD: endian.h,v 1.30 2016/02/27 21:37:35 christos Exp $

// Copyright (c) 1987, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)endian.h	8.1 (Berkeley) 6/11/93

//	$NetBSD: featuretest.h,v 1.10 2013/04/26 18:29:06 christos Exp $

// Written by Klaus Klein <kleink@NetBSD.org>, February 2, 1998.
// Public domain.
//
// NOTE: Do not protect this header against multiple inclusion.  Doing
// so can have subtle side-effects due to header file inclusion order
// and testing of e.g. _POSIX_SOURCE vs. _POSIX_C_SOURCE.  Instead,
// protect each CPP macro that we want to supply.

// Feature-test macros are defined by several standards, and allow an
// application to specify what symbols they want the system headers to
// expose, and hence what standard they want them to conform to.
// There are two classes of feature-test macros.  The first class
// specify complete standards, and if one of these is defined, header
// files will try to conform to the relevant standard.  They are:
//
// ANSI macros:
// _ANSI_SOURCE			ANSI C89
//
// POSIX macros:
// _POSIX_SOURCE == 1		IEEE Std 1003.1 (version?)
// _POSIX_C_SOURCE == 1		IEEE Std 1003.1-1990
// _POSIX_C_SOURCE == 2		IEEE Std 1003.2-1992
// _POSIX_C_SOURCE == 199309L	IEEE Std 1003.1b-1993
// _POSIX_C_SOURCE == 199506L	ISO/IEC 9945-1:1996
// _POSIX_C_SOURCE == 200112L	IEEE Std 1003.1-2001
// _POSIX_C_SOURCE == 200809L   IEEE Std 1003.1-2008
//
// X/Open macros:
// _XOPEN_SOURCE		System Interfaces and Headers, Issue 4, Ver 2
// _XOPEN_SOURCE_EXTENDED == 1	XSH4.2 UNIX extensions
// _XOPEN_SOURCE == 500		System Interfaces and Headers, Issue 5
// _XOPEN_SOURCE == 520		Networking Services (XNS), Issue 5.2
// _XOPEN_SOURCE == 600		IEEE Std 1003.1-2001, XSI option
// _XOPEN_SOURCE == 700		IEEE Std 1003.1-2008, XSI option
//
// NetBSD macros:
// _NETBSD_SOURCE == 1		Make all NetBSD features available.
//
// If more than one of these "major" feature-test macros is defined,
// then the set of facilities provided (and namespace used) is the
// union of that specified by the relevant standards, and in case of
// conflict, the earlier standard in the above list has precedence (so
// if both _POSIX_C_SOURCE and _NETBSD_SOURCE are defined, the version
// of rename() that's used is the POSIX one).  If none of the "major"
// feature-test macros is defined, _NETBSD_SOURCE is assumed.
//
// There are also "minor" feature-test macros, which enable extra
// functionality in addition to some base standard.  They should be
// defined along with one of the "major" macros.  The "minor" macros
// are:
//
// _REENTRANT
// _ISOC99_SOURCE
// _ISOC11_SOURCE
// _LARGEFILE_SOURCE		Large File Support
//		<http://ftp.sas.com/standards/large.file/x_open.20Mar96.html>

// Definitions for byte order, according to byte significance from low
// address to high.

// C-family endian-ness definitions

//	$NetBSD: ansi.h,v 1.14 2011/07/17 20:54:54 joerg Exp $

// -
// Copyright (c) 2000, 2001, 2002 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Jun-ichiro itojun Hagino and by Klaus Klein.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//	$NetBSD: cdefs.h,v 1.141 2019/02/21 21:34:05 christos Exp $

// * Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

//	$NetBSD: types.h,v 1.102 2018/11/06 16:26:44 maya Exp $

// -
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.4 (Berkeley) 1/21/94

type in_addr_t = uint32 /* endian.h:58:21 */

type in_port_t = uint16 /* endian.h:63:21 */

func __byte_swap_u64_variable(tls *libc.TLS, x uint64_t) uint64_t { /* byte_swap.h:48:1: */
	panic(`/usr/include/machine/byte_swap.h:50:2: assembler statements not supported`)
	return x
}

func __byte_swap_u32_variable(tls *libc.TLS, x uint32_t) uint32_t { /* byte_swap.h:57:1: */
	panic(`/usr/include/machine/byte_swap.h:59:2: assembler statements not supported`)
	return x
}

func __byte_swap_u16_variable(tls *libc.TLS, x uint16_t) uint16_t { /* byte_swap.h:66:1: */
	panic(`/usr/include/machine/byte_swap.h:68:2: assembler statements not supported`)
	return x
}

//      $NetBSD: bswap.h,v 1.19 2015/03/12 15:28:16 christos Exp $

// Written by Manuel Bouyer. Public domain

//	$NetBSD: stdint.h,v 1.8 2018/11/06 16:26:44 maya Exp $

// -
// Copyright (c) 2001, 2004 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Klaus Klein.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//	$NetBSD: cdefs.h,v 1.141 2019/02/21 21:34:05 christos Exp $

// * Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95

//	$NetBSD: int_types.h,v 1.7 2014/07/25 21:43:13 joerg Exp $

// -
// Copyright (c) 1990 The Regents of the University of California.
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	from: @(#)types.h	7.5 (Berkeley) 3/9/91

type intptr_t = int64 /* stdint.h:79:20 */

type uintptr_t = uint64 /* stdint.h:84:21 */

//	$NetBSD: int_mwgwtypes.h,v 1.8 2014/07/25 21:43:13 joerg Exp $

// -
// Copyright (c) 2001 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Klaus Klein.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

//	$NetBSD: common_int_mwgwtypes.h,v 1.1 2014/07/25 21:43:13 joerg Exp $

// -
// Copyright (c) 2014 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Joerg Sonnenberger.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// 7.18.1 Integer types

// 7.18.1.2 Minimum-width integer types

type int_least8_t = int8     /* common_int_mwgwtypes.h:45:32 */
type uint_least8_t = uint8   /* common_int_mwgwtypes.h:46:32 */
type int_least16_t = int16   /* common_int_mwgwtypes.h:47:32 */
type uint_least16_t = uint16 /* common_int_mwgwtypes.h:48:32 */
type int_least32_t = int32   /* common_int_mwgwtypes.h:49:32 */
type uint_least32_t = uint32 /* common_int_mwgwtypes.h:50:32 */
type int_least64_t = int64   /* common_int_mwgwtypes.h:51:32 */
type uint_least64_t = uint64 /* common_int_mwgwtypes.h:52:32 */

// 7.18.1.3 Fastest minimum-width integer types
type int_fast8_t = int32    /* common_int_mwgwtypes.h:55:32 */
type uint_fast8_t = uint32  /* common_int_mwgwtypes.h:56:32 */
type int_fast16_t = int32   /* common_int_mwgwtypes.h:57:32 */
type uint_fast16_t = uint32 /* common_int_mwgwtypes.h:58:32 */
type int_fast32_t = int32   /* common_int_mwgwtypes.h:59:32 */
type uint_fast32_t = uint32 /* common_int_mwgwtypes.h:60:32 */
type int_fast64_t = int64   /* common_int_mwgwtypes.h:61:32 */
type uint_fast64_t = uint64 /* common_int_mwgwtypes.h:62:32 */

// 7.18.1.5 Greatest-width integer types

type intmax_t = int64   /* common_int_mwgwtypes.h:66:33 */
type uintmax_t = uint64 /* common_int_mwgwtypes.h:67:32 */

type u_char = uint8   /* types.h:101:23 */
type u_short = uint16 /* types.h:102:24 */
type u_int = uint32   /* types.h:103:22 */
type u_long = uint64  /* types.h:104:23 */

type unchar = uint8  /* types.h:106:23 */ // Sys V compatibility
type ushort = uint16 /* types.h:107:24 */ // Sys V compatibility
type uint = uint32   /* types.h:108:22 */ // Sys V compatibility
type ulong = uint64  /* types.h:109:23 */ // Sys V compatibility

type u_quad_t = uint64_t /* types.h:112:18 */ // quads
type quad_t = int64_t    /* types.h:113:18 */
type qaddr_t = uintptr   /* types.h:114:16 */

// The types longlong_t and u_longlong_t exist for use with the
// Sun-derived XDR routines involving these types, and their usage
// in other contexts is discouraged.  Further note that these types
// may not be equivalent to "long long" and "unsigned long long",
// they are only guaranteed to be signed and unsigned 64-bit types
// respectively.  Portable programs that need 64-bit types should use
// the C99 types int64_t and uint64_t instead.

type longlong_t = int64_t    /* types.h:126:18 */ // for XDR
type u_longlong_t = uint64_t /* types.h:127:18 */ // for XDR

type blkcnt_t = int64_t  /* types.h:129:18 */ // fs block count
type blksize_t = int32_t /* types.h:130:18 */ // fs optimal block size

type fsblkcnt_t = uint64 /* types.h:133:22 */ // fs block count (statvfs)

type fsfilcnt_t = uint64 /* types.h:138:22 */ // fs file count

// We don't and shouldn't use caddr_t in the kernel anymore
type caddr_t = uintptr /* types.h:145:19 */ // core address

type daddr_t = int64_t /* types.h:154:18 */ // disk address

type dev_t = uint64_t   /* types.h:157:18 */ // device number
type fixpt_t = uint32_t /* types.h:158:18 */ // fixed point number

type gid_t = uint32 /* types.h:161:18 */ // group id

type id_t = uint32_t  /* types.h:165:18 */ // group id, process id or user id
type ino_t = uint64_t /* types.h:166:18 */ // inode number
type key_t = int64    /* types.h:167:15 */ // IPC key (for Sys V IPC)

type mode_t = uint32 /* types.h:170:18 */ // permissions

type nlink_t = uint32_t /* types.h:174:18 */ // link count

type pid_t = int32     /* types.h:182:18 */ // process id
type lwpid_t = int32_t /* types.h:185:18 */ // LWP id
type rlim_t = uint64_t /* types.h:186:18 */ // resource limit
type segsz_t = int32_t /* types.h:187:18 */ // segment size
type swblk_t = int32_t /* types.h:188:18 */ // swap offset

type uid_t = uint32 /* types.h:191:18 */ // user id

type mqd_t = int32 /* types.h:195:14 */

type cpuid_t = uint64 /* types.h:197:23 */

type psetid_t = int32 /* types.h:199:14 */

type clock_t = uint32 /* types.h:268:24 */

type time_t = int64 /* types.h:289:23 */

type clockid_t = int32 /* types.h:294:26 */

type timer_t = int32 /* types.h:299:24 */

type suseconds_t = int32 /* types.h:304:27 */

type useconds_t = uint32 /* types.h:309:26 */

// 32 = 2 ^ 5

// Select uses bit fields of file descriptors.  These macros manipulate
// such bit fields.  Note: FD_SETSIZE may be defined by the user.

type fd_set1 = struct{ fds_bits [8]uint32 } /* fd_set.h:66:9 */

// 32 = 2 ^ 5

// Select uses bit fields of file descriptors.  These macros manipulate
// such bit fields.  Note: FD_SETSIZE may be defined by the user.

type fd_set = fd_set1 /* fd_set.h:68:3 */

// Expose our internals if we are not required to hide them.

type kauth_cred_t = uintptr /* types.h:318:27 */

type pri_t = int32 /* types.h:320:13 */

//	$NetBSD: pthread_types.h,v 1.23 2017/09/09 23:21:45 kamil Exp $

// -
// Copyright (c) 2001, 2008 The NetBSD Foundation, Inc.
// All rights reserved.
//
// This code is derived from software contributed to The NetBSD Foundation
// by Nathan J. Williams.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
// ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

// We use the "pthread_spin_t" name internally; "pthread_spinlock_t" is the
// POSIX spinlock object.
//
// C++ expects to be using PTHREAD_FOO_INITIALIZER as a member initializer.
// This does not work for volatile types.  Since C++ does not touch the guts
// of those types, we do not include volatile in the C++ definitions.
type pthread_spin_t = uint8 /* pthread_types.h:43:29 */

// Copied from PTQ_HEAD in pthread_queue.h

type pthread_queue_struct_t = struct {
	ptqh_first uintptr
	ptqh_last  uintptr
} /* pthread_types.h:61:1 */

type pthread_queue_t = pthread_queue_struct_t /* pthread_types.h:62:39 */
type __pthread_attr_st = struct {
	pta_magic   uint32
	pta_flags   int32
	pta_private uintptr
} /* pthread_types.h:65:1 */

type __pthread_mutex_st = struct {
	ptm_magic      uint32
	ptm_errorcheck uint8
	ptm_pad1       [3]uint8_t
	__8            struct{ ptm_ceiling uint8 }
	ptm_pad2       [3]uint8_t
	_              [4]byte
	ptm_owner      pthread_t
	ptm_waiters    uintptr
	ptm_recursed   uint32
	_              [4]byte
	ptm_spare2     uintptr
} /* pthread_types.h:66:1 */

type __pthread_mutexattr_st = struct {
	ptma_magic   uint32
	_            [4]byte
	ptma_private uintptr
} /* pthread_types.h:67:1 */

type __pthread_cond_st = struct {
	ptc_magic   uint32
	ptc_lock    uint8
	_           [3]byte
	ptc_waiters pthread_queue_t
	ptc_mutex   uintptr
	ptc_private uintptr
} /* pthread_types.h:68:1 */

type __pthread_condattr_st = struct {
	ptca_magic   uint32
	_            [4]byte
	ptca_private uintptr
} /* pthread_types.h:69:1 */

type __pthread_rwlock_st = struct {
	ptr_magic     uint32
	ptr_interlock uint8
	_             [3]byte
	ptr_rblocked  pthread_queue_t
	ptr_wblocked  pthread_queue_t
	ptr_nreaders  uint32
	_             [4]byte
	ptr_owner     pthread_t
	ptr_private   uintptr
} /* pthread_types.h:71:1 */

type __pthread_rwlockattr_st = struct {
	ptra_magic   uint32
	_            [4]byte
	ptra_private uintptr
} /* pthread_types.h:72:1 */

type __pthread_barrier_st = struct {
	ptb_magic      uint32
	ptb_lock       pthread_spin_t
	_              [3]byte
	ptb_waiters    pthread_queue_t
	ptb_initcount  uint32
	ptb_curcount   uint32
	ptb_generation uint32
	_              [4]byte
	ptb_private    uintptr
} /* pthread_types.h:73:1 */

type __pthread_barrierattr_st = struct {
	ptba_magic   uint32
	_            [4]byte
	ptba_private uintptr
} /* pthread_types.h:74:1 */

type pthread_t = uintptr                          /* pthread_types.h:76:29 */
type pthread_attr_t = __pthread_attr_st           /* pthread_types.h:77:34 */
type pthread_mutex_t = __pthread_mutex_st         /* pthread_types.h:78:35 */
type pthread_mutexattr_t = __pthread_mutexattr_st /* pthread_types.h:79:39 */
type pthread_cond_t = __pthread_cond_st           /* pthread_types.h:80:34 */
type pthread_condattr_t = __pthread_condattr_st   /* pthread_types.h:81:38 */
type __pthread_once_st = struct {
	pto_mutex pthread_mutex_t
	pto_done  int32
	_         [4]byte
} /* pthread_types.h:82:9 */

type pthread_once_t = __pthread_once_st /* pthread_types.h:82:34 */
type __pthread_spinlock_st = struct {
	pts_magic uint32
	pts_spin  uint8
	_         [3]byte
	pts_flags int32
} /* pthread_types.h:83:9 */

type pthread_spinlock_t = __pthread_spinlock_st       /* pthread_types.h:83:38 */
type pthread_rwlock_t = __pthread_rwlock_st           /* pthread_types.h:84:36 */
type pthread_rwlockattr_t = __pthread_rwlockattr_st   /* pthread_types.h:85:40 */
type pthread_barrier_t = __pthread_barrier_st         /* pthread_types.h:86:37 */
type pthread_barrierattr_t = __pthread_barrierattr_st /* pthread_types.h:87:41 */
type pthread_key_t = int32                            /* pthread_types.h:88:13 */

type div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:59:3 */

type ldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:64:3 */

type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:74:3 */

type qdiv_t = struct {
	quot quad_t
	rem  quad_t
} /* stdlib.h:81:3 */ // getsubopt(3) external variable

type u64 = sqlite3_uint64 /* speedtest1.c:67:24 */

// State structure for a Hash hash in progress
type HashContext1 = struct {
	isInit uint8
	i      uint8
	j      uint8
	s      [256]uint8
	r      [32]uint8
} /* speedtest1.c:72:9 */

// State structure for a Hash hash in progress
type HashContext = HashContext1 /* speedtest1.c:72:28 */

// All global state is held in this structure
type Global = struct {
	db            uintptr
	pStmt         uintptr
	iStart        sqlite3_int64
	iTotal        sqlite3_int64
	bWithoutRowid int32
	bReprepare    int32
	bSqlOnly      int32
	bExplain      int32
	bVerify       int32
	bMemShrink    int32
	eTemp         int32
	szTest        int32
	nRepeat       int32
	doCheckpoint  int32
	nReserve      int32
	_             [4]byte
	zWR           uintptr
	zNN           uintptr
	zPK           uintptr
	x             uint32
	y             uint32
	nResByte      u64
	nResult       int32
	zResult       [3000]int8
	_             [4]byte
	hashFile      uintptr
	hash          HashContext
	_             [5]byte
} /* speedtest1.c:82:8 */

// All global state is held in this structure
var g Global /* speedtest1.c:109:3: */

// Return " TEMP" or "", as appropriate for creating a table.
func isTemp(tls *libc.TLS, N int32) uintptr { /* speedtest1.c:113:19: */
	if g.eTemp >= N {
		return ts + 2206 /* " TEMP" */
	}
	return ts + 2212 /* "" */
}

// Print an error message and exit
func fatal_error(tls *libc.TLS, zMsg uintptr, va uintptr) { /* speedtest1.c:118:13: */
	var ap va_list
	_ = ap
	(ap) = va
	libc.Xvfprintf(tls, (uintptr(unsafe.Pointer(&libc.X__sF)) + 2*152), zMsg, ap)
	_ = ap
	libc.Xexit(tls, 1)
}

// ***************************************************************************
//
// Hash algorithm used to verify that compilation is not miscompiled
// in such a was as to generate an incorrect result.

// Initialize a new hash.  iSize determines the size of the hash
// in bits and should be one of 224, 256, 384, or 512.  Or iSize
// can be zero to use the default hash size of 256 bits.
func HashInit(tls *libc.TLS) { /* speedtest1.c:137:13: */
	var k uint32
	g.hash.i = uint8(0)
	g.hash.j = uint8(0)
	for k = uint32(0); k < uint32(256); k++ {
		*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(k))) = uint8(k)
	}
}

// Make consecutive calls to the HashUpdate function to add new content
// to the hash
func HashUpdate(tls *libc.TLS, aData uintptr, nData uint32) { /* speedtest1.c:148:13: */
	var t uint8
	var i uint8 = g.hash.i
	var j uint8 = g.hash.j
	var k uint32
	if g.hashFile != 0 {
		libc.Xfwrite(tls, aData, uint64(1), uint64(nData), g.hashFile)
	}
	for k = uint32(0); k < nData; k++ {
		j = uint8(int32(j) + (int32(*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(i)))) + int32(*(*uint8)(unsafe.Pointer(aData + uintptr(k))))))
		t = *(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(j)))
		*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(j))) = *(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(i)))
		*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(i))) = t
		i++
	}
	g.hash.i = i
	g.hash.j = j
}

// After all content has been added, invoke HashFinal() to compute
// the final hash.  The hash result is stored in g.hash.r[].
func HashFinal(tls *libc.TLS) { /* speedtest1.c:172:13: */
	var k uint32
	var t uint8
	var i uint8
	var j uint8
	i = g.hash.i
	j = g.hash.j
	for k = uint32(0); k < uint32(32); k++ {
		i++
		t = *(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(i)))
		j = uint8(int32(j) + (int32(t)))
		*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(i))) = *(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(j)))
		*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(j))) = t
		t = uint8(int32(t) + (int32(*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(i))))))
		*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 259 /* &.r */) + uintptr(k))) = *(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 3 /* &.s */) + uintptr(t)))
	}
}

// End of the Hash hashing logic
//

// Return the value of a hexadecimal digit.  Return -1 if the input
// is not a hex digit.
func hexDigitValue(tls *libc.TLS, c int8) int32 { /* speedtest1.c:196:12: */
	if (int32(c) >= '0') && (int32(c) <= '9') {
		return (int32(c) - '0')
	}
	if (int32(c) >= 'a') && (int32(c) <= 'f') {
		return ((int32(c) - 'a') + 10)
	}
	if (int32(c) >= 'A') && (int32(c) <= 'F') {
		return ((int32(c) - 'A') + 10)
	}
	return -1
}

// Provide an alternative to sqlite3_stricmp() in older versions of
// SQLite

// Interpret zArg as an integer value, possibly with suffixes.
func integerValue(tls *libc.TLS, zArg uintptr) int32 { /* speedtest1.c:212:12: */
	var v sqlite3_int64 = int64(0)
	var i int32
	var isNeg int32 = 0
	if int32(*(*int8)(unsafe.Pointer(zArg))) == '-' {
		isNeg = 1
		zArg++
	} else if int32(*(*int8)(unsafe.Pointer(zArg))) == '+' {
		zArg++
	}
	if (int32(*(*int8)(unsafe.Pointer(zArg))) == '0') && (int32(*(*int8)(unsafe.Pointer(zArg + 1))) == 'x') {
		var x int32
		zArg += uintptr(2)
		for (libc.AssignInt32(&x, hexDigitValue(tls, *(*int8)(unsafe.Pointer(zArg))))) >= 0 {
			v = ((v << 4) + sqlite3_int64(x))
			zArg++
		}
	} else {
		for (int32(*(*uint16)(unsafe.Pointer((libc.X_ctype_tab_ + uintptr(1)*2) + uintptr(*(*int8)(unsafe.Pointer(zArg)))*2))) & X_CTYPE_D) != 0 {
			v = (((v * int64(10)) + sqlite3_int64(*(*int8)(unsafe.Pointer(zArg)))) - int64('0'))
			zArg++
		}
	}
	for i = 0; uint64(i) < (uint64(unsafe.Sizeof(aMult)) / uint64(unsafe.Sizeof(struct {
		zSuffix uintptr
		iMult   int32
		_       [4]byte
	}{}))); i++ {
		if sqlite3.Xsqlite3_stricmp(tls, aMult[i].zSuffix, zArg) == 0 {
			v = v * (sqlite3_int64(aMult[i].iMult))
			break
		}
	}
	if v > int64(0x7fffffff) {
		fatal_error(tls, ts+2213 /* "parameter too la..." */, 0)
	}
	return func() int32 {
		if isNeg != 0 {
			return int32(-v)
		}
		return int32(v)
	}()
}

var aMult = [9]struct {
	zSuffix uintptr
	iMult   int32
	_       [4]byte
}{
	{zSuffix: ts + 2250 /* "KiB" */, iMult: 1024},
	{zSuffix: ts + 2254 /* "MiB" */, iMult: (1024 * 1024)},
	{zSuffix: ts + 2258 /* "GiB" */, iMult: ((1024 * 1024) * 1024)},
	{zSuffix: ts + 2262 /* "KB" */, iMult: 1000},
	{zSuffix: ts + 2265 /* "MB" */, iMult: 1000000},
	{zSuffix: ts + 2268 /* "GB" */, iMult: 1000000000},
	{zSuffix: ts + 2271 /* "K" */, iMult: 1000},
	{zSuffix: ts + 2273 /* "M" */, iMult: 1000000},
	{zSuffix: ts + 2275 /* "G" */, iMult: 1000000000},
} /* speedtest1.c:214:53 */

// Return the current wall-clock time, in milliseconds
func speedtest1_timestamp(tls *libc.TLS) sqlite3_int64 { /* speedtest1.c:257:15: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var t sqlite3_int64 at bp, 8

	if clockVfs == uintptr(0) {
		clockVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	}
	if ((*sqlite3_vfs)(unsafe.Pointer(clockVfs)).iVersion >= 2) && ((*sqlite3_vfs)(unsafe.Pointer(clockVfs)).xCurrentTimeInt64 != uintptr(0)) {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(clockVfs)).xCurrentTimeInt64})).f(tls, clockVfs, bp /* &t */)
	} else {
		// var r float64 at bp+8, 8

		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(clockVfs)).xCurrentTime})).f(tls, clockVfs, bp+8 /* &r */)
		*(*sqlite3_int64)(unsafe.Pointer(bp /* t */)) = (libc.Int64FromFloat64(*(*float64)(unsafe.Pointer(bp + 8 /* r */)) * 86400000.0))
	}
	return *(*sqlite3_int64)(unsafe.Pointer(bp /* t */))
}

var clockVfs uintptr = uintptr(0) /* speedtest1.c:261:22 */

// Return a pseudo-random unsigned integer
func speedtest1_random(tls *libc.TLS) uint32 { /* speedtest1.c:279:14: */
	g.x = ((g.x >> 1) ^ ((uint32(1) + ^(g.x & uint32(1))) & 0xd0000001))
	g.y = ((g.y * uint32(1103515245)) + uint32(12345))
	return (g.x ^ g.y)
}

// Map the value in within the range of 1...limit into another
// number in a way that is chatic and invertable.
func swizzle(tls *libc.TLS, in uint32, limit uint32) uint32 { /* speedtest1.c:288:10: */
	var out uint32 = uint32(0)
	for limit != 0 {
		out = ((out << 1) | (in & uint32(1)))
		in >>= 1
		limit >>= 1
	}
	return out
}

// Round up a number so that it is a power of two minus one
func roundup_allones(tls *libc.TLS, limit uint32) uint32 { /* speedtest1.c:300:10: */
	var m uint32 = uint32(1)
	for m < limit {
		m = ((m << 1) + uint32(1))
	}
	return m
}

// The speedtest1_numbername procedure below converts its argment (an integer)
// into a string which is the English-language name for that number.
// The returned string should be freed with sqlite3_free().
//
// Example:
//
//     speedtest1_numbername(123)   ->  "one hundred twenty three"
func speedtest1_numbername(tls *libc.TLS, n uint32, zOut uintptr, nOut int32) int32 { /* speedtest1.c:314:5: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var i int32 = 0

	if n >= uint32(1000000000) {
		i = i + (speedtest1_numbername(tls, (n / uint32(1000000000)), (zOut + uintptr(i)), (nOut - i)))
		sqlite3.Xsqlite3_snprintf(tls, (nOut - i), (zOut + uintptr(i)), ts+2277 /* " billion" */, 0)
		i = i + (int32(libc.Xstrlen(tls, (zOut + uintptr(i)))))
		n = (n % uint32(1000000000))
	}
	if n >= uint32(1000000) {
		if (i != 0) && (i < (nOut - 1)) {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&i, 1)))) = int8(' ')
		}
		i = i + (speedtest1_numbername(tls, (n / uint32(1000000)), (zOut + uintptr(i)), (nOut - i)))
		sqlite3.Xsqlite3_snprintf(tls, (nOut - i), (zOut + uintptr(i)), ts+2286 /* " million" */, 0)
		i = i + (int32(libc.Xstrlen(tls, (zOut + uintptr(i)))))
		n = (n % uint32(1000000))
	}
	if n >= uint32(1000) {
		if (i != 0) && (i < (nOut - 1)) {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&i, 1)))) = int8(' ')
		}
		i = i + (speedtest1_numbername(tls, (n / uint32(1000)), (zOut + uintptr(i)), (nOut - i)))
		sqlite3.Xsqlite3_snprintf(tls, (nOut - i), (zOut + uintptr(i)), ts+2295 /* " thousand" */, 0)
		i = i + (int32(libc.Xstrlen(tls, (zOut + uintptr(i)))))
		n = (n % uint32(1000))
	}
	if n >= uint32(100) {
		if (i != 0) && (i < (nOut - 1)) {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&i, 1)))) = int8(' ')
		}
		sqlite3.Xsqlite3_snprintf(tls, (nOut - i), (zOut + uintptr(i)), ts+2305 /* "%s hundred" */, libc.VaList(bp, ones[(n/uint32(100))]))
		i = i + (int32(libc.Xstrlen(tls, (zOut + uintptr(i)))))
		n = (n % uint32(100))
	}
	if n >= uint32(20) {
		if (i != 0) && (i < (nOut - 1)) {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&i, 1)))) = int8(' ')
		}
		sqlite3.Xsqlite3_snprintf(tls, (nOut - i), (zOut + uintptr(i)), ts+2316 /* "%s" */, libc.VaList(bp+8, tens[(n/uint32(10))]))
		i = i + (int32(libc.Xstrlen(tls, (zOut + uintptr(i)))))
		n = (n % uint32(10))
	}
	if n > uint32(0) {
		if (i != 0) && (i < (nOut - 1)) {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&i, 1)))) = int8(' ')
		}
		sqlite3.Xsqlite3_snprintf(tls, (nOut - i), (zOut + uintptr(i)), ts+2316 /* "%s" */, libc.VaList(bp+16, ones[n]))
		i = i + (int32(libc.Xstrlen(tls, (zOut + uintptr(i)))))
	}
	if i == 0 {
		sqlite3.Xsqlite3_snprintf(tls, (nOut - i), (zOut + uintptr(i)), ts+2319 /* "zero" */, 0)
		i = i + (int32(libc.Xstrlen(tls, (zOut + uintptr(i)))))
	}
	return i
}

var ones = [20]uintptr{ts + 2319 /* "zero" */, ts + 2324 /* "one" */, ts + 2328 /* "two" */, ts + 2332 /* "three" */, ts + 2338 /* "four" */, ts + 2343, /* "five" */
	ts + 2348 /* "six" */, ts + 2352 /* "seven" */, ts + 2358 /* "eight" */, ts + 2364 /* "nine" */, ts + 2369 /* "ten" */, ts + 2373 /* "eleven" */, ts + 2380, /* "twelve" */
	ts + 2387 /* "thirteen" */, ts + 2396 /* "fourteen" */, ts + 2405 /* "fifteen" */, ts + 2413 /* "sixteen" */, ts + 2421, /* "seventeen" */
																	ts + 2431 /* "eighteen" */, ts + 2440 /* "nineteen" */} /* speedtest1.c:315:21 */
var tens = [10]uintptr{ts + 2212 /* "" */, ts + 2369 /* "ten" */, ts + 2449 /* "twenty" */, ts + 2456 /* "thirty" */, ts + 2463, /* "forty" */
	ts + 2469 /* "fifty" */, ts + 2475 /* "sixty" */, ts + 2481 /* "seventy" */, ts + 2489 /* "eighty" */, ts + 2496 /* "ninety" */} /* speedtest1.c:319:21 */

// Start a new test case
var zDots = *(*[72]int8)(unsafe.Pointer(ts + 2503 /* "..................." */)) /* speedtest1.c:370:19 */

func speedtest1_begin_test(tls *libc.TLS, iTestNum int32, zTestName uintptr, va uintptr) { /* speedtest1.c:372:6: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var n int32 = int32(libc.Xstrlen(tls, zTestName))
	var zName uintptr
	var ap va_list
	_ = ap
	(ap) = va
	zName = sqlite3.Xsqlite3_vmprintf(tls, zTestName, ap)
	_ = ap
	n = int32(libc.Xstrlen(tls, zName))
	if n > NAMEWIDTH {
		*(*int8)(unsafe.Pointer(zName + 60)) = int8(0)
		n = NAMEWIDTH
	}
	if g.bSqlOnly != 0 {
		libc.Xprintf(tls, ts+2575 /* "/* %4d - %s%.*s ..." */, libc.VaList(bp, iTestNum, zName, (NAMEWIDTH-n), uintptr(unsafe.Pointer(&zDots))))
	} else {
		libc.Xprintf(tls, ts+2595 /* "%4d - %s%.*s " */, libc.VaList(bp+32, iTestNum, zName, (NAMEWIDTH-n), uintptr(unsafe.Pointer(&zDots))))
		libc.Xfflush(tls, (uintptr(unsafe.Pointer(&libc.X__sF)) + 1*152))
	}
	sqlite3.Xsqlite3_free(tls, zName)
	g.nResult = 0
	g.iStart = speedtest1_timestamp(tls)
	g.x = 0xad131d0b
	g.y = uint32(0x44f9eac8)
}

// Complete a test case
func speedtest1_end_test(tls *libc.TLS) { /* speedtest1.c:401:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var iElapseTime sqlite3_int64 = (speedtest1_timestamp(tls) - g.iStart)
	if g.doCheckpoint != 0 {
		speedtest1_exec(tls, ts+2609 /* "PRAGMA wal_check..." */, 0)
	}
	if !(g.bSqlOnly != 0) {
		*(*sqlite3_int64)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 24 /* &.iTotal */)) += (iElapseTime)
		libc.Xprintf(tls, ts+2632 /* "%4d.%03ds\n" */, libc.VaList(bp, (int32(iElapseTime/int64(1000))), (int32(iElapseTime%int64(1000)))))
	}
	if g.pStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, g.pStmt)
		g.pStmt = uintptr(0)
	}
}

// Report end of testing
func speedtest1_final(tls *libc.TLS) { /* speedtest1.c:415:6: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	if !(g.bSqlOnly != 0) {
		libc.Xprintf(tls, ts+2643 /* "       TOTAL%.*s..." */, libc.VaList(bp, (NAMEWIDTH-5), uintptr(unsafe.Pointer(&zDots)),
			(int32(g.iTotal/int64(1000))), (int32(g.iTotal%int64(1000)))))
	}
	if g.bVerify != 0 {
		var i int32
		libc.Xprintf(tls, ts+2671 /* "Verification Has..." */, libc.VaList(bp+32, g.nResByte))
		HashUpdate(tls, ts+2696 /* "\n" */, uint32(1))
		HashFinal(tls)
		for i = 0; i < 24; i++ {
			libc.Xprintf(tls, ts+2698 /* "%02x" */, libc.VaList(bp+40, int32(*(*uint8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 3136 /* &.hash */ + 259 /* &.r */) + uintptr(i))))))
		}
		if (g.hashFile != 0) && (g.hashFile != (uintptr(unsafe.Pointer(&libc.X__sF)) + 1*152)) {
			libc.Xfclose(tls, g.hashFile)
		}
		libc.Xprintf(tls, ts+2696 /* "\n" */, 0)
	}
}

// Print an SQL statement to standard output
func printSql(tls *libc.TLS, zSql uintptr) { /* speedtest1.c:438:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var n int32 = int32(libc.Xstrlen(tls, zSql))
	for (n > 0) && ((int32(*(*int8)(unsafe.Pointer(zSql + uintptr((n - 1))))) == ';') || ((int32(*(*uint16)(unsafe.Pointer((libc.X_ctype_tab_ + uintptr(1)*2) + uintptr(uint8(*(*int8)(unsafe.Pointer(zSql + uintptr((n - 1))))))*2))) & X_CTYPE_S) != 0)) {
		n--
	}
	if g.bExplain != 0 {
		libc.Xprintf(tls, ts+2703 /* "EXPLAIN " */, 0)
	}
	libc.Xprintf(tls, ts+2712 /* "%.*s;\n" */, libc.VaList(bp, n, zSql))
	if (g.bExplain != 0) &&
		(((sqlite3.Xsqlite3_strglob(tls, ts+2719 /* "CREATE *" */, zSql) == 0) ||
			(sqlite3.Xsqlite3_strglob(tls, ts+2728 /* "DROP *" */, zSql) == 0)) ||
			(sqlite3.Xsqlite3_strglob(tls, ts+2735 /* "ALTER *" */, zSql) == 0)) {
		libc.Xprintf(tls, ts+2712 /* "%.*s;\n" */, libc.VaList(bp+16, n, zSql))
	}
}

// Shrink memory used, if appropriate and if the SQLite version is capable
// of doing so.
func speedtest1_shrink_memory(tls *libc.TLS) { /* speedtest1.c:458:6: */
	if g.bMemShrink != 0 {
		sqlite3.Xsqlite3_db_release_memory(tls, g.db)
	}
}

// Run SQL
func speedtest1_exec(tls *libc.TLS, zFormat uintptr, va uintptr) { /* speedtest1.c:465:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var ap va_list
	_ = ap
	var zSql uintptr
	(ap) = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	if g.bSqlOnly != 0 {
		printSql(tls, zSql)
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 24 /* zErrMsg */)) = uintptr(0)
		var rc int32 = sqlite3.Xsqlite3_exec(tls, g.db, zSql, uintptr(0), uintptr(0), bp+24 /* &zErrMsg */)
		if *(*uintptr)(unsafe.Pointer(bp + 24 /* zErrMsg */)) != 0 {
			fatal_error(tls, ts+2743 /* "SQL error: %s\n%s..." */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 24 /* zErrMsg */)), zSql))
		}
		if rc != SQLITE_OK {
			fatal_error(tls, ts+2761 /* "exec error: %s\n" */, libc.VaList(bp+16, sqlite3.Xsqlite3_errmsg(tls, g.db)))
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	speedtest1_shrink_memory(tls)
}

// Run SQL and return the first column of the first row as a string.  The
// returned string is obtained from sqlite_malloc() and must be freed by
// the caller.
func speedtest1_once(tls *libc.TLS, zFormat uintptr, va uintptr) uintptr { /* speedtest1.c:487:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var ap va_list
	_ = ap
	var zSql uintptr
	// var pStmt uintptr at bp+16, 8

	var zResult uintptr = uintptr(0)
	(ap) = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	if g.bSqlOnly != 0 {
		printSql(tls, zSql)
	} else {
		var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, g.db, zSql, -1, bp+16 /* &pStmt */, uintptr(0))
		if rc != 0 {
			fatal_error(tls, ts+2777 /* "SQL error: %s\n" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db)))
		}
		if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */))) == SQLITE_ROW {
			var z uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), 0)
			if z != 0 {
				zResult = sqlite3.Xsqlite3_mprintf(tls, ts+2316 /* "%s" */, libc.VaList(bp+8, z))
			}
		}
		sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	speedtest1_shrink_memory(tls)
	return zResult
}

// Prepare an SQL statement
func speedtest1_prepare(tls *libc.TLS, zFormat uintptr, va uintptr) { /* speedtest1.c:514:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var zSql uintptr
	(ap) = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	if g.bSqlOnly != 0 {
		printSql(tls, zSql)
	} else {
		var rc int32
		if g.pStmt != 0 {
			sqlite3.Xsqlite3_finalize(tls, g.pStmt)
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, g.db, zSql, -1, (uintptr(unsafe.Pointer(&g)) + 8 /* &.pStmt */), uintptr(0))
		if rc != 0 {
			fatal_error(tls, ts+2777 /* "SQL error: %s\n" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db)))
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)
}

// Run an SQL statement previously prepared
func speedtest1_run(tls *libc.TLS) { /* speedtest1.c:534:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	var n int32
	var len int32
	if g.bSqlOnly != 0 {
		return
	}

	g.nResult = 0
	for sqlite3.Xsqlite3_step(tls, g.pStmt) == SQLITE_ROW {
		n = sqlite3.Xsqlite3_column_count(tls, g.pStmt)
		for i = 0; i < n; i++ {
			var z uintptr = sqlite3.Xsqlite3_column_text(tls, g.pStmt, i)
			if z == uintptr(0) {
				z = ts + 2792 /* "nil" */
			}
			len = int32(libc.Xstrlen(tls, z))
			if g.bVerify != 0 {
				var eType int32 = sqlite3.Xsqlite3_column_type(tls, g.pStmt, i)
				// var zPrefix [2]uint8 at bp, 2

				*(*uint8)(unsafe.Pointer(bp /* &zPrefix[0] */)) = uint8('\n')
				*(*uint8)(unsafe.Pointer(bp /* &zPrefix[0] */ + 1)) = uint8(*(*int8)(unsafe.Pointer(ts + 2796 /* "-IFTBN" */ + uintptr(eType))))
				if g.nResByte != 0 {
					HashUpdate(tls, bp /* &zPrefix[0] */, uint32(2))
				} else {
					HashUpdate(tls, (bp /* &zPrefix[0] */ + uintptr(1)), uint32(1))
				}
				if eType == SQLITE_FLOAT {
					// Omit the value of floating-point results from the verification
					// hash.  The only thing we record is the fact that the result was
					// a floating-point value.
					*(*u64)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 112 /* &.nResByte */)) += (uint64(2))
				} else if eType == SQLITE_BLOB {
					var nBlob int32 = sqlite3.Xsqlite3_column_bytes(tls, g.pStmt, i)
					var iBlob int32
					// var zChar [2]uint8 at bp+2, 2

					var aBlob uintptr = sqlite3.Xsqlite3_column_blob(tls, g.pStmt, i)
					for iBlob = 0; iBlob < nBlob; iBlob++ {
						*(*uint8)(unsafe.Pointer(bp + 2 /* &zChar[0] */)) = uint8(*(*int8)(unsafe.Pointer(ts + 2803 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer(aBlob + uintptr(iBlob)))) >> 4)))))
						*(*uint8)(unsafe.Pointer(bp + 2 /* &zChar[0] */ + 1)) = uint8(*(*int8)(unsafe.Pointer(ts + 2803 /* "0123456789abcdef" */ + uintptr((int32(*(*uint8)(unsafe.Pointer(aBlob + uintptr(iBlob)))) & 15)))))
						HashUpdate(tls, bp+2 /* &zChar[0] */, uint32(2))
					}
					*(*u64)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 112 /* &.nResByte */)) += (u64((nBlob * 2) + 2))
				} else {
					HashUpdate(tls, z, uint32(len))
					*(*u64)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 112 /* &.nResByte */)) += (u64(len + 2))
				}
			}
			if (uint64(g.nResult + len)) < (uint64(unsafe.Sizeof([3000]int8{})) - uint64(2)) {
				if g.nResult > 0 {
					*(*int8)(unsafe.Pointer((uintptr(unsafe.Pointer(&g)) + 124 /* &.zResult */) + uintptr(libc.PostIncInt32(&g.nResult, 1)))) = int8(' ')
				}
				libc.Xmemcpy(tls, ((uintptr(unsafe.Pointer(&g)) + 124 /* &.zResult */) + uintptr(g.nResult)), z, (uint64(len + 1)))
				*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 120 /* &.nResult */)) += (len)
			}
		}
	}
	if g.bReprepare != 0 {
		// var pNew uintptr at bp+8, 8

		sqlite3.Xsqlite3_prepare_v2(tls, g.db, sqlite3.Xsqlite3_sql(tls, g.pStmt), -1, bp+8 /* &pNew */, uintptr(0))
		sqlite3.Xsqlite3_finalize(tls, g.pStmt)
		g.pStmt = *(*uintptr)(unsafe.Pointer(bp + 8 /* pNew */))
	} else {
		sqlite3.Xsqlite3_reset(tls, g.pStmt)
	}
	speedtest1_shrink_memory(tls)
}

// The sqlite3_trace() callback function
func traceCallback(tls *libc.TLS, NotUsed uintptr, zSql uintptr) { /* speedtest1.c:601:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var n int32 = int32(libc.Xstrlen(tls, zSql))
	for (n > 0) && ((int32(*(*int8)(unsafe.Pointer(zSql + uintptr((n - 1))))) == ';') || ((int32(*(*uint16)(unsafe.Pointer((libc.X_ctype_tab_ + uintptr(1)*2) + uintptr(uint8(*(*int8)(unsafe.Pointer(zSql + uintptr((n - 1))))))*2))) & X_CTYPE_S) != 0)) {
		n--
	}
	libc.Xfprintf(tls, (uintptr(unsafe.Pointer(&libc.X__sF)) + 2*152), ts+2712 /* "%.*s;\n" */, libc.VaList(bp, n, zSql))
}

// Substitute random() function that gives the same random
// sequence on each run, for repeatability.
func randomFunc(tls *libc.TLS, context uintptr, NotUsed int32, NotUsed2 uintptr) { /* speedtest1.c:610:13: */
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3_int64(speedtest1_random(tls)))
}

// Estimate the square root of an integer
func est_square_root(tls *libc.TLS, x int32) int32 { /* speedtest1.c:619:12: */
	var y0 int32 = (x / 2)
	var y1 int32
	var n int32
	for n = 0; (y0 > 0) && (n < 10); n++ {
		y1 = ((y0 + (x / y0)) / 2)
		if y1 == y0 {
			break
		}
		y0 = y1
	}
	return y0
}

// The main and default testset
func testset_main(tls *libc.TLS) { /* speedtest1.c:696:6: */
	bp := tls.Alloc(2568)
	defer tls.Free(2568)

	var i int32    // Loop counter
	var n int32    // iteration count
	var sz int32   // Size of the tables
	var maxb int32 // Maximum swizzled value
	var x1 uint32 = uint32(0)
	var x2 uint32 = uint32(0) // Parameters
	var len int32 = 0         // Length of the zNum[] string
	// var zNum [2000]int8 at bp+568, 2000
	// A number name

	sz = libc.AssignInt32(&n, (g.szTest * 500))
	*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */)) = int8(0)
	maxb = int32(roundup_allones(tls, uint32(sz)))
	speedtest1_begin_test(tls, 100, ts+2820 /* "%d INSERTs into ..." */, libc.VaList(bp, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls, ts+2862, /* "CREATE%s TABLE z..." */
		libc.VaList(bp+8, isTemp(tls, 9), g.zNN, g.zNN, g.zNN))
	speedtest1_prepare(tls, ts+2920 /* "INSERT INTO z1 V..." */, libc.VaList(bp+40, n))
	for i = 1; i <= n; i++ {
		x1 = swizzle(tls, uint32(i), uint32(maxb))
		speedtest1_numbername(tls, x1, bp+568 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int64(tls, g.pStmt, 1, sqlite3_int64(x1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, i)
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 3, bp+568 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = sz
	speedtest1_begin_test(tls, 110, ts+2973 /* "%d ordered INSER..." */, libc.VaList(bp+48, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls,
		ts+3010, /* "CREATE%s TABLE z..." */
		libc.VaList(bp+56, isTemp(tls, 5), g.zNN, g.zPK, g.zNN, g.zNN, g.zWR))
	speedtest1_prepare(tls, ts+3073 /* "INSERT INTO z2 V..." */, libc.VaList(bp+104, n))
	for i = 1; i <= n; i++ {
		x1 = swizzle(tls, uint32(i), uint32(maxb))
		speedtest1_numbername(tls, x1, bp+568 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, i)
		sqlite3.Xsqlite3_bind_int64(tls, g.pStmt, 2, sqlite3_int64(x1))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 3, bp+568 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = sz
	speedtest1_begin_test(tls, 120, ts+3118 /* "%d unordered INS..." */, libc.VaList(bp+112, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls,
		ts+3157, /* "CREATE%s TABLE t..." */
		libc.VaList(bp+120, isTemp(tls, 3), g.zNN, g.zPK, g.zNN, g.zNN, g.zWR))
	speedtest1_prepare(tls, ts+3220 /* "INSERT INTO t3 V..." */, libc.VaList(bp+168, n))
	for i = 1; i <= n; i++ {
		x1 = swizzle(tls, uint32(i), uint32(maxb))
		speedtest1_numbername(tls, x1, bp+568 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, i)
		sqlite3.Xsqlite3_bind_int64(tls, g.pStmt, 1, sqlite3_int64(x1))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 3, bp+568 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = 25
	speedtest1_begin_test(tls, 130, ts+3265 /* "%d SELECTS, nume..." */, libc.VaList(bp+176, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+3304 /* "SELECT count(*),..." */, libc.VaList(bp+184, n))
	for i = 1; i <= n; i++ {
		if ((i - 1) % g.nRepeat) == 0 {
			x1 = (speedtest1_random(tls) % uint32(maxb))
			x2 = (((speedtest1_random(tls) % uint32(10)) + (uint32(sz / 5000))) + x1)
		}
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, int32(x2))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = 10
	speedtest1_begin_test(tls, 140, ts+3409 /* "%d SELECTS, LIKE..." */, libc.VaList(bp+192, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+3437 /* "SELECT count(*),..." */, libc.VaList(bp+200, n))
	for i = 1; i <= n; i++ {
		if ((i - 1) % g.nRepeat) == 0 {
			x1 = (speedtest1_random(tls) % uint32(maxb))
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */)) = int8('%')
			len = speedtest1_numbername(tls, uint32(i), (bp + 568 /* &zNum[0] */ + uintptr(1)), (int32(uint64(unsafe.Sizeof([2000]int8{})) - uint64(2))))
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */ + uintptr(len))) = int8('%')
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */ + uintptr((len + 1)))) = int8(0)
		}
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+568 /* &zNum[0] */, (len + 1), uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = 10
	speedtest1_begin_test(tls, 142, ts+3532 /* "%d SELECTS w/ORD..." */, libc.VaList(bp+208, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+3565 /* "SELECT a, b, c F..." */, libc.VaList(bp+216, n))
	for i = 1; i <= n; i++ {
		if ((i - 1) % g.nRepeat) == 0 {
			x1 = (speedtest1_random(tls) % uint32(maxb))
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */)) = int8('%')
			len = speedtest1_numbername(tls, uint32(i), (bp + 568 /* &zNum[0] */ + uintptr(1)), (int32(uint64(unsafe.Sizeof([2000]int8{})) - uint64(2))))
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */ + uintptr(len))) = int8('%')
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */ + uintptr((len + 1)))) = int8(0)
		}
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+568 /* &zNum[0] */, (len + 1), uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = 10 // g.szTest/5;
	speedtest1_begin_test(tls, 145, ts+3629 /* "%d SELECTS w/ORD..." */, libc.VaList(bp+224, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+3672 /* "SELECT a, b, c F..." */, libc.VaList(bp+232, n))
	for i = 1; i <= n; i++ {
		if ((i - 1) % g.nRepeat) == 0 {
			x1 = (speedtest1_random(tls) % uint32(maxb))
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */)) = int8('%')
			len = speedtest1_numbername(tls, uint32(i), (bp + 568 /* &zNum[0] */ + uintptr(1)), (int32(uint64(unsafe.Sizeof([2000]int8{})) - uint64(2))))
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */ + uintptr(len))) = int8('%')
			*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */ + uintptr((len + 1)))) = int8(0)
		}
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+568 /* &zNum[0] */, (len + 1), uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 150, ts+3745 /* "CREATE INDEX fiv..." */, 0)
	speedtest1_exec(tls, ts+3769 /* "BEGIN;" */, 0)
	speedtest1_exec(tls, ts+3776 /* "CREATE UNIQUE IN..." */, 0)
	speedtest1_exec(tls, ts+3810 /* "CREATE INDEX t1c..." */, 0)
	speedtest1_exec(tls, ts+3837 /* "CREATE UNIQUE IN..." */, 0)
	speedtest1_exec(tls, ts+3871 /* "CREATE INDEX t2c..." */, 0)
	speedtest1_exec(tls, ts+3903 /* "CREATE INDEX t3b..." */, 0)
	speedtest1_exec(tls, ts+3933 /* "COMMIT;" */, 0)
	speedtest1_end_test(tls)

	n = (sz / 5)
	speedtest1_begin_test(tls, 160, ts+3941 /* "%d SELECTS, nume..." */, libc.VaList(bp+240, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+3978 /* "SELECT count(*),..." */, libc.VaList(bp+248, n))
	for i = 1; i <= n; i++ {
		if ((i - 1) % g.nRepeat) == 0 {
			x1 = (speedtest1_random(tls) % uint32(maxb))
			x2 = (((speedtest1_random(tls) % uint32(10)) + (uint32(sz / 5000))) + x1)
		}
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, int32(x2))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = (sz / 5)
	speedtest1_begin_test(tls, 161, ts+4083 /* "%d SELECTS, nume..." */, libc.VaList(bp+256, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+4115 /* "SELECT count(*),..." */, libc.VaList(bp+264, n))
	for i = 1; i <= n; i++ {
		if ((i - 1) % g.nRepeat) == 0 {
			x1 = (speedtest1_random(tls) % uint32(maxb))
			x2 = (((speedtest1_random(tls) % uint32(10)) + (uint32(sz / 5000))) + x1)
		}
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, int32(x2))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = (sz / 5)
	speedtest1_begin_test(tls, 170, ts+4220 /* "%d SELECTS, text..." */, libc.VaList(bp+272, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+4254 /* "SELECT count(*),..." */, libc.VaList(bp+280, n))
	for i = 1; i <= n; i++ {
		if ((i - 1) % g.nRepeat) == 0 {
			x1 = swizzle(tls, uint32(i), uint32(maxb))
			len = speedtest1_numbername(tls, x1, bp+568 /* &zNum[0] */, (int32(uint64(unsafe.Sizeof([2000]int8{})) - uint64(1))))
		}
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+568 /* &zNum[0] */, len, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = sz
	speedtest1_begin_test(tls, 180, ts+4366 /* "%d INSERTS with ..." */, libc.VaList(bp+288, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls,

		ts+4396, /* "CREATE%s TABLE t..." */
		libc.VaList(bp+296, isTemp(tls, 1), g.zNN, g.zPK, g.zNN, g.zNN, g.zWR))
	speedtest1_exec(tls, ts+4467 /* "CREATE INDEX t4b..." */, 0)
	speedtest1_exec(tls, ts+4493 /* "CREATE INDEX t4c..." */, 0)
	speedtest1_exec(tls, ts+4519 /* "INSERT INTO t4 S..." */, 0)
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = sz
	speedtest1_begin_test(tls, 190, ts+4551 /* "DELETE and REFIL..." */, libc.VaList(bp+344, n))
	speedtest1_exec(tls, ts+4579 /* "DELETE FROM z2;" */, 0)
	speedtest1_exec(tls, ts+4595 /* "INSERT INTO z2 S..." */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 200, ts+4628 /* "VACUUM" */, 0)
	speedtest1_exec(tls, ts+4628 /* "VACUUM" */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 210, ts+4635 /* "ALTER TABLE ADD ..." */, 0)
	speedtest1_exec(tls, ts+4669 /* "ALTER TABLE z2 A..." */, 0)
	speedtest1_exec(tls, ts+4709 /* "SELECT sum(d) FR..." */, 0)
	speedtest1_end_test(tls)

	n = (sz / 5)
	speedtest1_begin_test(tls, 230, ts+4731 /* "%d UPDATES, nume..." */, libc.VaList(bp+352, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,
		ts+4768 /* "UPDATE z2 SET d=..." */, libc.VaList(bp+360, n))
	for i = 1; i <= n; i++ {
		x1 = (speedtest1_random(tls) % uint32(maxb))
		x2 = (((speedtest1_random(tls) % uint32(10)) + (uint32(sz / 5000))) + x1)
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, int32(x2))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = sz
	speedtest1_begin_test(tls, 240, ts+4827 /* "%d UPDATES of in..." */, libc.VaList(bp+368, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,
		ts+4857 /* "UPDATE z2 SET d=..." */, libc.VaList(bp+376, n))
	for i = 1; i <= n; i++ {
		x1 = ((speedtest1_random(tls) % uint32(sz)) + uint32(1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 250, ts+4901 /* "One big UPDATE o..." */, libc.VaList(bp+384, sz))
	speedtest1_exec(tls, ts+4942 /* "UPDATE z2 SET d=..." */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 260, ts+4962 /* "Query added colu..." */, 0)
	speedtest1_exec(tls, ts+4709 /* "SELECT sum(d) FR..." */, 0)
	speedtest1_end_test(tls)

	n = (sz / 5)
	speedtest1_begin_test(tls, 270, ts+4995 /* "%d DELETEs, nume..." */, libc.VaList(bp+392, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,
		ts+5032 /* "DELETE FROM z2 W..." */, libc.VaList(bp+400, n))
	for i = 1; i <= n; i++ {
		x1 = ((speedtest1_random(tls) % uint32(maxb)) + uint32(1))
		x2 = (((speedtest1_random(tls) % uint32(10)) + (uint32(sz / 5000))) + x1)
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, int32(x2))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = sz
	speedtest1_begin_test(tls, 280, ts+5086 /* "%d DELETEs of in..." */, libc.VaList(bp+408, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,
		ts+5116 /* "DELETE FROM t3 W..." */, libc.VaList(bp+416, n))
	for i = 1; i <= n; i++ {
		x1 = ((speedtest1_random(tls) % uint32(sz)) + uint32(1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 290, ts+5155 /* "Refill two %d-ro..." */, libc.VaList(bp+424, sz))
	speedtest1_exec(tls, ts+5194 /* "REPLACE INTO z2(..." */, 0)
	speedtest1_exec(tls, ts+5238 /* "REPLACE INTO t3(..." */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 300, ts+5282 /* "Refill a %d-row ..." */, libc.VaList(bp+432, sz))
	speedtest1_exec(tls, ts+4579 /* "DELETE FROM z2;" */, 0)
	speedtest1_exec(tls,
		ts+5323 /* "INSERT INTO z2(a..." */, 0)
	speedtest1_exec(tls,
		ts+5388 /* "INSERT INTO z2(a..." */, 0)
	speedtest1_end_test(tls)

	n = (sz / 5)
	speedtest1_begin_test(tls, 310, ts+5453 /* "%d four-ways joi..." */, libc.VaList(bp+440, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls,

		ts+5472 /* "SELECT z1.c FROM..." */, 0)
	for i = 1; i <= n; i++ {
		x1 = ((speedtest1_random(tls) % uint32(sz)) + uint32(1))
		x2 = (((speedtest1_random(tls) % uint32(10)) + x1) + uint32(4))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, int32(x2))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 320, ts+5585 /* "subquery in resu..." */, libc.VaList(bp+448, n))
	speedtest1_prepare(tls,

		ts+5608 /* "SELECT sum(a), m..." */, 0)
	sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (est_square_root(tls, g.szTest) * 50))
	speedtest1_run(tls)
	speedtest1_end_test(tls)

	sz = libc.AssignInt32(&n, (g.szTest * 700))
	*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */)) = int8(0)
	maxb = int32(roundup_allones(tls, (uint32(sz / 3))))
	speedtest1_begin_test(tls, 400, ts+5726 /* "%d REPLACE ops o..." */, libc.VaList(bp+456, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls, ts+5751, /* "CREATE%s TABLE t..." */
		libc.VaList(bp+464, isTemp(tls, 9), g.zNN))
	speedtest1_prepare(tls, ts+5799 /* "REPLACE INTO t5 ..." */, libc.VaList(bp+480, n))
	for i = 1; i <= n; i++ {
		x1 = swizzle(tls, uint32(i), uint32(maxb))
		speedtest1_numbername(tls, uint32(i), bp+568 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(sqlite3_int64(x1)))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+568 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)
	speedtest1_begin_test(tls, 410, ts+5843 /* "%d SELECTS on an..." */, libc.VaList(bp+488, n))
	speedtest1_prepare(tls, ts+5864 /* "SELECT b FROM t5..." */, libc.VaList(bp+496, n))
	for i = 1; i <= n; i++ {
		x1 = swizzle(tls, uint32(i), uint32(maxb))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(sqlite3_int64(x1)))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	sz = libc.AssignInt32(&n, (g.szTest * 700))
	*(*int8)(unsafe.Pointer(bp + 568 /* &zNum[0] */)) = int8(0)
	maxb = int32(roundup_allones(tls, (uint32(sz / 3))))
	speedtest1_begin_test(tls, 500, ts+5906 /* "%d REPLACE on TE..." */, libc.VaList(bp+504, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls, ts+5928, /* "CREATE%s TABLE t..." */
		libc.VaList(bp+512, isTemp(tls, 9), g.zNN,
			func() uintptr {
				if sqlite3.Xsqlite3_libversion_number(tls) >= 3008002 {
					return ts + 5975 /* "WITHOUT ROWID" */
				}
				return ts + 2212 /* "" */
			}()))
	speedtest1_prepare(tls, ts+5989 /* "REPLACE INTO t6 ..." */, libc.VaList(bp+536, n))
	for i = 1; i <= n; i++ {
		x1 = swizzle(tls, uint32(i), uint32(maxb))
		speedtest1_numbername(tls, x1, bp+568 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, i)
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+568 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)
	speedtest1_begin_test(tls, 510, ts+6033 /* "%d SELECTS on a ..." */, libc.VaList(bp+544, n))
	speedtest1_prepare(tls, ts+6057 /* "SELECT b FROM t6..." */, libc.VaList(bp+552, n))
	for i = 1; i <= n; i++ {
		x1 = swizzle(tls, uint32(i), uint32(maxb))
		speedtest1_numbername(tls, x1, bp+568 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+568 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)
	speedtest1_begin_test(tls, 520, ts+6099 /* "%d SELECT DISTIN..." */, libc.VaList(bp+560, n))
	speedtest1_exec(tls, ts+6118 /* "SELECT DISTINCT ..." */, 0)
	speedtest1_exec(tls, ts+6145 /* "SELECT DISTINCT ..." */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 980, ts+6172 /* "PRAGMA integrity..." */, 0)
	speedtest1_exec(tls, ts+6172 /* "PRAGMA integrity..." */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 990, ts+6195 /* "ANALYZE" */, 0)
	speedtest1_exec(tls, ts+6195 /* "ANALYZE" */, 0)
	speedtest1_end_test(tls)
}

// A testset for common table expressions.  This exercises code
// for views, subqueries, co-routines, etc.
func testset_cte(tls *libc.TLS) { /* speedtest1.c:1146:6: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zPuz uintptr
	var rSpacing float64
	var nElem int32

	if g.szTest < 25 {
		zPuz = azPuzzle[0]
	} else if g.szTest < 70 {
		zPuz = azPuzzle[1]
	} else {
		zPuz = azPuzzle[2]
	}
	speedtest1_begin_test(tls, 100, ts+6203 /* "Sudoku with recu..." */, 0)
	speedtest1_prepare(tls,

		ts+6234 /* "WITH RECURSIVE\n ..." */, 0)
	sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, zPuz, -1, uintptr(0))
	speedtest1_run(tls)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 200, ts+7038 /* "Sudoku with VALU..." */, 0)
	speedtest1_prepare(tls,

		ts+7066 /* "WITH RECURSIVE\n ..." */, 0)
	sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, zPuz, -1, uintptr(0))
	speedtest1_run(tls)
	speedtest1_end_test(tls)

	rSpacing = (5.0 / float64(g.szTest))
	speedtest1_begin_test(tls, 300, ts+7878 /* "Mandelbrot Set w..." */, libc.VaList(bp, rSpacing))
	speedtest1_prepare(tls,

		ts+7909 /* "WITH RECURSIVE \n..." */, 0)
	sqlite3.Xsqlite3_bind_double(tls, g.pStmt, 1, (rSpacing * .05))
	sqlite3.Xsqlite3_bind_double(tls, g.pStmt, 2, rSpacing)
	speedtest1_run(tls)
	speedtest1_end_test(tls)

	nElem = (10000 * g.szTest)
	speedtest1_begin_test(tls, 400, ts+8505 /* "EXCEPT operator ..." */, libc.VaList(bp+8, nElem))
	speedtest1_prepare(tls,

		ts+8542, /* "WITH RECURSIVE \n..." */
		libc.VaList(bp+16, nElem, nElem))
	speedtest1_run(tls)
	speedtest1_end_test(tls)
}

var azPuzzle = [3]uintptr{
	// Easy

	ts + 8773, /* "534...9..67.195...." */

	// Medium

	ts + 8855, /* "53....9..6..195...." */

	// Hard

	ts + 8937, /* "53.......6..195...." */
} /* speedtest1.c:1147:21 */

// Compute a pseudo-random floating point ascii number.
func speedtest1_random_ascii_fp(tls *libc.TLS, zFP uintptr) { /* speedtest1.c:1299:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var x int32 = int32(speedtest1_random(tls))
	var y int32 = int32(speedtest1_random(tls))
	var z int32
	z = (y % 10)
	if z < 0 {
		z = -z
	}
	y = y / (10)
	sqlite3.Xsqlite3_snprintf(tls, 100, zFP, ts+9019 /* "%d.%de%d" */, libc.VaList(bp, y, z, (x%200)))
}

// A testset for floating-point numbers.
func testset_fp(tls *libc.TLS) { /* speedtest1.c:1312:6: */
	bp := tls.Alloc(272)
	defer tls.Free(272)

	var n int32
	var i int32
	// var zFP1 [100]int8 at bp+72, 100

	// var zFP2 [100]int8 at bp+172, 100

	n = (g.szTest * 5000)
	speedtest1_begin_test(tls, 100, ts+9028 /* "Fill a table wit..." */, libc.VaList(bp, (n*2)))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls, ts+9059, /* "CREATE%s TABLE z..." */
		libc.VaList(bp+8, isTemp(tls, 1), g.zNN, g.zNN))
	speedtest1_prepare(tls, ts+9100 /* "INSERT INTO z1 V..." */, libc.VaList(bp+32, n))
	for i = 1; i <= n; i++ {
		speedtest1_random_ascii_fp(tls, bp+72 /* &zFP1[0] */)
		speedtest1_random_ascii_fp(tls, bp+172 /* &zFP2[0] */)
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+72 /* &zFP1[0] */, -1, uintptr(0))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+172 /* &zFP2[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	n = ((g.szTest / 25) + 2)
	speedtest1_begin_test(tls, 110, ts+9142 /* "%d range queries" */, libc.VaList(bp+40, n))
	speedtest1_prepare(tls, ts+9159 /* "SELECT sum(b) FR..." */, 0)
	for i = 1; i <= n; i++ {
		speedtest1_random_ascii_fp(tls, bp+72 /* &zFP1[0] */)
		speedtest1_random_ascii_fp(tls, bp+172 /* &zFP2[0] */)
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+72 /* &zFP1[0] */, -1, uintptr(0))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+172 /* &zFP2[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 120, ts+9207 /* "CREATE INDEX thr..." */, 0)
	speedtest1_exec(tls, ts+3769 /* "BEGIN;" */, 0)
	speedtest1_exec(tls, ts+9232 /* "CREATE INDEX t1a..." */, 0)
	speedtest1_exec(tls, ts+9259 /* "CREATE INDEX t1b..." */, 0)
	speedtest1_exec(tls, ts+9286 /* "CREATE INDEX t1a..." */, 0)
	speedtest1_exec(tls, ts+3933 /* "COMMIT;" */, 0)
	speedtest1_end_test(tls)

	n = ((g.szTest / 3) + 2)
	speedtest1_begin_test(tls, 130, ts+9316 /* "%d indexed range..." */, libc.VaList(bp+48, n))
	speedtest1_prepare(tls, ts+9159 /* "SELECT sum(b) FR..." */, 0)
	for i = 1; i <= n; i++ {
		speedtest1_random_ascii_fp(tls, bp+72 /* &zFP1[0] */)
		speedtest1_random_ascii_fp(tls, bp+172 /* &zFP2[0] */)
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 1, bp+72 /* &zFP1[0] */, -1, uintptr(0))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+172 /* &zFP2[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	n = (g.szTest * 5000)
	speedtest1_begin_test(tls, 140, ts+9341 /* "%d calls to roun..." */, libc.VaList(bp+56, n))
	speedtest1_exec(tls, ts+9361 /* "SELECT sum(round..." */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 150, ts+9404 /* "%d printf() call..." */, libc.VaList(bp+64, (n*4)))
	speedtest1_exec(tls,

		ts+9422 /* "WITH c(fmt) AS (..." */, 0)
	speedtest1_end_test(tls)
}

// Generate two numbers between 1 and mx.  The first number is less than
// the second.  Usually the numbers are near each other but can sometimes
// be far apart.
func twoCoords(tls *libc.TLS, p1 int32, p2 int32, mx uint32, pX0 uintptr, pX1 uintptr) { /* speedtest1.c:1385:13: */
	var d uint32
	var x0 uint32
	var x1 uint32
	var span uint32

	span = ((mx / uint32(100)) + uint32(1))
	if (speedtest1_random(tls) % uint32(3)) == uint32(0) {
		span = span * (uint32(p1))
	}
	if (speedtest1_random(tls) % uint32(p2)) == uint32(0) {
		span = (mx / uint32(2))
	}
	d = ((speedtest1_random(tls) % span) + uint32(1))
	x0 = ((speedtest1_random(tls) % (mx - d)) + uint32(1))
	x1 = (x0 + d)
	*(*uint32)(unsafe.Pointer(pX0)) = x0
	*(*uint32)(unsafe.Pointer(pX1)) = x1
}

// The following routine is an R-Tree geometry callback.  It returns
// true if the object overlaps a slice on the Y coordinate between the
// two values given as arguments.  In other words
//
//     SELECT count(*) FROM rt1 WHERE id MATCH xslice(10,20);
//
// Is the same as saying:
//
//     SELECT count(*) FROM rt1 WHERE y1>=10 AND y0<=20;
func xsliceGeometryCallback(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, pRes uintptr) int32 { /* speedtest1.c:1414:12: */
	*(*int32)(unsafe.Pointer(pRes)) = (libc.Bool32((*(*float64)(unsafe.Pointer(aCoord + 3*8)) >= *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).aParam))) && (*(*float64)(unsafe.Pointer(aCoord + 2*8)) <= *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).aParam + 1*8)))))
	return SQLITE_OK
}

// A testset for the R-Tree virtual table
func testset_rtree(tls *libc.TLS, p1 int32, p2 int32) { /* speedtest1.c:1429:6: */
	bp := tls.Alloc(224)
	defer tls.Free(224)

	var i uint32
	var n uint32
	var mxCoord uint32
	// var x0 uint32 at bp+200, 4

	// var x1 uint32 at bp+204, 4

	// var y0 uint32 at bp+208, 4

	// var y1 uint32 at bp+212, 4

	// var z0 uint32 at bp+216, 4

	// var z1 uint32 at bp+220, 4

	var iStep uint32
	var mxRowid uint32
	var aCheck uintptr = sqlite3.Xsqlite3_malloc(tls, (int32((uint64(unsafe.Sizeof(int32(0))) * uint64(g.szTest)) * uint64(500))))

	mxCoord = uint32(15000)
	mxRowid = libc.AssignUint32(&n, (uint32(g.szTest * 500)))
	speedtest1_begin_test(tls, 100, ts+9517 /* "%d INSERTs into ..." */, libc.VaList(bp, n))
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_exec(tls, ts+9543 /* "CREATE VIRTUAL T..." */, 0)
	speedtest1_prepare(tls,
		ts+9602 /* "INSERT INTO rt1(..." */, 0)
	for i = uint32(1); i <= n; i++ {
		twoCoords(tls, p1, p2, mxCoord, bp+200 /* &x0 */, bp+204 /* &x1 */)
		twoCoords(tls, p1, p2, mxCoord, bp+208 /* &y0 */, bp+212 /* &y1 */)
		twoCoords(tls, p1, p2, mxCoord, bp+216 /* &z0 */, bp+220 /* &z1 */)
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(i))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, int32(*(*uint32)(unsafe.Pointer(bp + 200 /* x0 */))))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 3, int32(*(*uint32)(unsafe.Pointer(bp + 204 /* x1 */))))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 4, int32(*(*uint32)(unsafe.Pointer(bp + 208 /* y0 */))))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 5, int32(*(*uint32)(unsafe.Pointer(bp + 212 /* y1 */))))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 6, int32(*(*uint32)(unsafe.Pointer(bp + 216 /* z0 */))))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 7, int32(*(*uint32)(unsafe.Pointer(bp + 220 /* z1 */))))
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 101, ts+9668 /* "Copy from rtree ..." */, 0)
	speedtest1_exec(tls, ts+9703 /* "CREATE TABLE z1(..." */, 0)
	speedtest1_exec(tls, ts+9761 /* "INSERT INTO z1 S..." */, 0)
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 200))
	speedtest1_begin_test(tls, 110, ts+9794 /* "%d one-dimension..." */, libc.VaList(bp+8, n))
	speedtest1_prepare(tls, ts+9837 /* "SELECT count(*) ..." */, 0)
	iStep = (mxCoord / n)
	for i = uint32(0); i < n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, (int32((i + uint32(1)) * iStep)))
		speedtest1_run(tls)
		*(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) = libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)
	}
	speedtest1_end_test(tls)

	if g.bVerify != 0 {
		n = (uint32(g.szTest * 200))
		speedtest1_begin_test(tls, 111, ts+9886 /* "Verify result fr..." */, 0)
		speedtest1_prepare(tls, ts+9933 /* "SELECT count(*) ..." */, 0)
		iStep = (mxCoord / n)
		for i = uint32(0); i < n; i++ {
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, (int32((i + uint32(1)) * iStep)))
			speedtest1_run(tls)
			if *(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) != libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */) {
				fatal_error(tls, ts+9981, /* "Count disagree s..." */
					libc.VaList(bp+16, i, (i*iStep), ((i+uint32(1))*iStep), *(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)), libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)))
			}
		}
		speedtest1_end_test(tls)
	}

	n = (uint32(g.szTest * 200))
	speedtest1_begin_test(tls, 120, ts+10023 /* "%d one-dimension..." */, libc.VaList(bp+56, n))
	speedtest1_prepare(tls, ts+10064 /* "SELECT count(*) ..." */, 0)
	iStep = (mxCoord / n)
	for i = uint32(0); i < n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, (int32((i + uint32(1)) * iStep)))
		speedtest1_run(tls)
		*(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) = libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)
	}
	speedtest1_end_test(tls)

	if g.bVerify != 0 {
		n = (uint32(g.szTest * 200))
		speedtest1_begin_test(tls, 121, ts+10113 /* "Verify result fr..." */, 0)
		speedtest1_prepare(tls, ts+10158 /* "SELECT count(*) ..." */, 0)
		iStep = (mxCoord / n)
		for i = uint32(0); i < n; i++ {
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, (int32((i + uint32(1)) * iStep)))
			speedtest1_run(tls)
			if *(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) != libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */) {
				fatal_error(tls, ts+9981, /* "Count disagree s..." */
					libc.VaList(bp+64, i, (i*iStep), ((i+uint32(1))*iStep), *(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)), libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)))
			}
		}
		speedtest1_end_test(tls)
	}

	n = (uint32(g.szTest * 200))
	speedtest1_begin_test(tls, 125, ts+10206 /* "%d custom geomet..." */, libc.VaList(bp+104, n))
	sqlite3.Xsqlite3_rtree_geometry_callback(tls, g.db, ts+10242 /* "xslice" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{xsliceGeometryCallback})), uintptr(0))
	speedtest1_prepare(tls, ts+10249 /* "SELECT count(*) ..." */, 0)
	iStep = (mxCoord / n)
	for i = uint32(0); i < n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, (int32((i + uint32(1)) * iStep)))
		speedtest1_run(tls)
		if *(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) != libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */) {
			fatal_error(tls, ts+9981, /* "Count disagree s..." */
				libc.VaList(bp+112, i, (i*iStep), ((i+uint32(1))*iStep), *(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)), libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)))
		}
	}
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 400))
	speedtest1_begin_test(tls, 130, ts+10303 /* "%d three-dimensi..." */, libc.VaList(bp+152, n))
	speedtest1_prepare(tls,
		ts+10346 /* "SELECT count(*) ..." */, 0)
	iStep = (mxCoord / n)
	for i = uint32(0); i < n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 2, (int32((i + uint32(1)) * iStep)))
		speedtest1_run(tls)
		*(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) = libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)
	}
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 500))
	speedtest1_begin_test(tls, 140, ts+10439 /* "%d rowid queries" */, libc.VaList(bp+160, n))
	speedtest1_prepare(tls, ts+10456 /* "SELECT * FROM rt..." */, 0)
	for i = uint32(1); i <= n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(i))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 50))
	speedtest1_begin_test(tls, 150, ts+10486 /* "%d UPDATEs using..." */, libc.VaList(bp+168, n))
	speedtest1_prepare(tls, ts+10509 /* "UPDATE rt1 SET x..." */, 0)
	for i = uint32(1); i <= n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(((i * uint32(251)) % mxRowid) + uint32(1))))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 5))
	speedtest1_begin_test(tls, 155, ts+10557 /* "%d UPDATEs using..." */, libc.VaList(bp+176, n))
	speedtest1_prepare(tls,
		ts+10598 /* "UPDATE rt1 SET x..." */, 0)
	iStep = (mxCoord / n)
	for i = uint32(0); i < n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
		speedtest1_run(tls)
		*(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) = libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)
	}
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 50))
	speedtest1_begin_test(tls, 160, ts+10660 /* "%d DELETEs using..." */, libc.VaList(bp+184, n))
	speedtest1_prepare(tls, ts+10683 /* "DELETE FROM rt1 ..." */, 0)
	for i = uint32(1); i <= n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(((i * uint32(257)) % mxRowid) + uint32(1))))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 5))
	speedtest1_begin_test(tls, 165, ts+10711 /* "%d DELETEs using..." */, libc.VaList(bp+192, n))
	speedtest1_prepare(tls, ts+10752 /* "DELETE FROM rt1 ..." */, 0)
	iStep = (mxCoord / n)
	for i = uint32(0); i < n; i++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i * iStep)))
		speedtest1_run(tls)
		*(*int32)(unsafe.Pointer(aCheck + uintptr(i)*4)) = libc.Xatoi(tls, uintptr(unsafe.Pointer(&g))+124 /* &.zResult */)
	}
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 170, ts+10794 /* "Restore deleted ..." */, 0)
	speedtest1_exec(tls, ts+10841 /* "INSERT OR IGNORE..." */, 0)
	speedtest1_end_test(tls)
}

// A testset that does key/value storage on tables with many columns.
// This is the kind of workload generated by ORMs such as CoreData.
func testset_orm(tls *libc.TLS) { /* speedtest1.c:1614:6: */
	bp := tls.Alloc(2016)
	defer tls.Free(2016)

	var i uint32
	var j uint32
	var n uint32
	var nRow uint32
	var x1 uint32
	var len uint32
	// var zNum [2000]int8 at bp+16, 2000

	nRow = libc.AssignUint32(&n, (uint32(g.szTest * 250)))
	speedtest1_begin_test(tls, 100, ts+10884 /* "Fill %d rows" */, libc.VaList(bp, n))
	speedtest1_exec(tls,

		ts+10897 /* "BEGIN;CREATE TAB..." */, 0)
	speedtest1_prepare(tls,

		ts+14797 /* "INSERT INTO ZLOO..." */, 0)
	for i = uint32(0); i < n; i++ {
		x1 = speedtest1_random(tls)
		speedtest1_numbername(tls, (x1 % uint32(1000)), bp+16 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		len = uint32(int32(libc.Xstrlen(tls, bp+16 /* &zNum[0] */)))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (int32(i ^ uint32(0xf))))
		for j = uint32(0); zType[j] != 0; j++ {
			switch int32(zType[j]) {
			case 'I':
				fallthrough
			case 'T':
				sqlite3.Xsqlite3_bind_int64(tls, g.pStmt, (int32(j + uint32(2))), int64(x1))
				break
			case 'F':
				sqlite3.Xsqlite3_bind_double(tls, g.pStmt, (int32(j + uint32(2))), float64(x1))
				break
			case 'V':
				fallthrough
			case 'B':
				sqlite3.Xsqlite3_bind_text64(tls, g.pStmt, (int32(j + uint32(2))), bp+16 /* &zNum[0] */, uint64(len),
					uintptr(0), uint8(SQLITE_UTF8))
				break
			}
		}
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+3933 /* "COMMIT;" */, 0)
	speedtest1_end_test(tls)

	n = (uint32(g.szTest * 250))
	speedtest1_begin_test(tls, 110, ts+18041 /* "Query %d rows by..." */, libc.VaList(bp+8, n))
	speedtest1_prepare(tls,

		ts+18064 /* "SELECT ZCYANBASE..." */, 0)
	for i = uint32(0); i < n; i++ {
		x1 = (speedtest1_random(tls) % nRow)
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, int32(x1))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)
}

var zType = // Types for all non-PK columns, in order

*(*[120]int8)(unsafe.Pointer(ts + 20817 /* "IBBIIITIVVITBTBF..." */)) /* speedtest1.c:1619:21 */

//
func testset_trigger(tls *libc.TLS) { /* speedtest1.c:1881:6: */
	bp := tls.Alloc(2032)
	defer tls.Free(2032)

	var jj int32
	var ii int32
	// var zNum [2000]int8 at bp+32, 2000
	// A number name

	var NROW int32 = (500 * g.szTest)
	var NROW2 int32 = (100 * g.szTest)

	speedtest1_exec(tls,

		ts+20937 /* "BEGIN;CREATE TAB..." */, 0)
	for jj = 1; jj <= 3; jj++ {
		speedtest1_prepare(tls, ts+21265 /* "INSERT INTO t%d ..." */, libc.VaList(bp, jj))
		for ii = 0; ii < NROW; ii++ {
			var x1 int32 = (int32(speedtest1_random(tls) % uint32(NROW)))
			speedtest1_numbername(tls, uint32(x1), bp+32 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, x1)
			sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+32 /* &zNum[0] */, -1, uintptr(0))
			speedtest1_run(tls)
		}
	}
	speedtest1_exec(tls,

		ts+21300 /* "CREATE INDEX i1 ..." */, 0)

	speedtest1_begin_test(tls, 100, ts+21383 /* "speed4p-join1" */, 0)
	speedtest1_prepare(tls,
		ts+21397 /* "SELECT * FROM z1..." */, 0)
	speedtest1_run(tls)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 110, ts+21464 /* "speed4p-join2" */, 0)
	speedtest1_prepare(tls,
		ts+21478 /* "SELECT * FROM z1..." */, 0)
	speedtest1_run(tls)
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 120, ts+21537 /* "speed4p-view1" */, 0)
	for jj = 1; jj <= 3; jj++ {
		speedtest1_prepare(tls, ts+21551 /* "SELECT * FROM v%..." */, libc.VaList(bp+8, jj))
		for ii = 0; ii < NROW2; ii = ii + (3) {
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (ii * 3))
			speedtest1_run(tls)
		}
	}
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 130, ts+21585 /* "speed4p-table1" */, 0)
	for jj = 1; jj <= 3; jj++ {
		speedtest1_prepare(tls, ts+21600 /* "SELECT * FROM t%..." */, libc.VaList(bp+16, jj))
		for ii = 0; ii < NROW2; ii = ii + (3) {
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (ii * 3))
			speedtest1_run(tls)
		}
	}
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 140, ts+21585 /* "speed4p-table1" */, 0)
	for jj = 1; jj <= 3; jj++ {
		speedtest1_prepare(tls, ts+21600 /* "SELECT * FROM t%..." */, libc.VaList(bp+24, jj))
		for ii = 0; ii < NROW2; ii = ii + (3) {
			sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (ii * 3))
			speedtest1_run(tls)
		}
	}
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 150, ts+21634 /* "speed4p-subselec..." */, 0)
	speedtest1_prepare(tls,

		ts+21653 /* "SELECT (SELECT t..." */, 0)
	for jj = 0; jj < NROW2; jj++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (jj * 3))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	speedtest1_begin_test(tls, 160, ts+21768 /* "speed4p-rowid-up..." */, 0)
	speedtest1_exec(tls, ts+2856 /* "BEGIN" */, 0)
	speedtest1_prepare(tls, ts+21789 /* "UPDATE z1 SET i=..." */, 0)
	for jj = 0; jj < NROW2; jj++ {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, jj)
		speedtest1_run(tls)
	}
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
	speedtest1_end_test(tls)

	speedtest1_exec(tls, ts+21824 /* "CREATE TABLE t5(..." */, 0)
	speedtest1_begin_test(tls, 170, ts+21872 /* "speed4p-insert-i..." */, 0)
	speedtest1_exec(tls, ts+21894 /* "INSERT OR IGNORE..." */, 0)
	speedtest1_end_test(tls)

	speedtest1_exec(tls,

		ts+21939 /* "CREATE TABLE log..." */, 0)

	speedtest1_begin_test(tls, 180, ts+22429 /* "speed4p-trigger1" */, 0)
	speedtest1_prepare(tls, ts+22446 /* "INSERT INTO t4 V..." */, 0)
	for jj = 0; jj < NROW2; jj++ {
		speedtest1_numbername(tls, uint32(jj), bp+32 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, jj)
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+32 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	// Note: Of the queries, only half actually update a row. This property
	// was copied over from speed4p.test, where it was probably introduced
	// inadvertantly.
	speedtest1_begin_test(tls, 190, ts+22482 /* "speed4p-trigger2" */, 0)
	speedtest1_prepare(tls, ts+22499 /* "UPDATE t4 SET i ..." */, 0)
	for jj = 1; jj <= (NROW2 * 2); jj = jj + (2) {
		speedtest1_numbername(tls, (uint32(jj * 2)), bp+32 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (jj * 2))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+32 /* &zNum[0] */, -1, uintptr(0))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 3, jj)
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)

	// Note: Same again.
	speedtest1_begin_test(tls, 200, ts+22545 /* "speed4p-trigger3" */, 0)
	speedtest1_prepare(tls, ts+22562 /* "DELETE FROM t4 W..." */, 0)
	for jj = 1; jj <= (NROW2 * 2); jj = jj + (2) {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (jj * 2))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)

	// The following block contains the same tests as the above block that
	// tests triggers, with one crucial difference: no triggers are defined.
	// So the difference in speed between these tests and the preceding ones
	// is the amount of time taken to compile and execute the trigger programs.
	speedtest1_exec(tls,

		ts+22594 /* "DROP TABLE t4;DR..." */, 0)
	speedtest1_begin_test(tls, 210, ts+22699 /* "speed4p-notrigge..." */, 0)
	speedtest1_prepare(tls, ts+22446 /* "INSERT INTO t4 V..." */, 0)
	for jj = 0; jj < NROW2; jj++ {
		speedtest1_numbername(tls, uint32(jj), bp+32 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, jj)
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+32 /* &zNum[0] */, -1, uintptr(0))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)
	speedtest1_begin_test(tls, 210, ts+22718 /* "speed4p-notrigge..." */, 0)
	speedtest1_prepare(tls, ts+22499 /* "UPDATE t4 SET i ..." */, 0)
	for jj = 1; jj <= (NROW2 * 2); jj = jj + (2) {
		speedtest1_numbername(tls, (uint32(jj * 2)), bp+32 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (jj * 2))
		sqlite3.Xsqlite3_bind_text(tls, g.pStmt, 2, bp+32 /* &zNum[0] */, -1, uintptr(0))
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 3, jj)
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)
	speedtest1_begin_test(tls, 220, ts+22737 /* "speed4p-notrigge..." */, 0)
	speedtest1_prepare(tls, ts+22562 /* "DELETE FROM t4 W..." */, 0)
	for jj = 1; jj <= (NROW2 * 2); jj = jj + (2) {
		sqlite3.Xsqlite3_bind_int(tls, g.pStmt, 1, (jj * 2))
		speedtest1_run(tls)
	}
	speedtest1_end_test(tls)
	speedtest1_exec(tls, ts+2966 /* "COMMIT" */, 0)
}

// A testset used for debugging speedtest1 itself.
func testset_debug1(tls *libc.TLS) { /* speedtest1.c:2083:6: */
	bp := tls.Alloc(2032)
	defer tls.Free(2032)

	var i uint32
	var n uint32
	var x1 uint32
	var x2 uint32
	// var zNum [2000]int8 at bp+32, 2000
	// A number name

	n = uint32(g.szTest)
	for i = uint32(1); i <= n; i++ {
		x1 = swizzle(tls, i, n)
		x2 = swizzle(tls, x1, n)
		speedtest1_numbername(tls, x1, bp+32 /* &zNum[0] */, int32(unsafe.Sizeof([2000]int8{})))
		libc.Xprintf(tls, ts+22756 /* "%5d %5d %5d %s\n" */, libc.VaList(bp, i, x1, x2, bp+32 /* &zNum[0] */))
	}
}

func xCompileOptions(tls *libc.TLS, pCtx uintptr, nVal int32, azVal uintptr, azCol uintptr) int32 { /* speedtest1.c:2144:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	libc.Xprintf(tls, ts+22772 /* "-- Compile optio..." */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(azVal))))
	return SQLITE_OK
}

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 { /* speedtest1.c:2149:5: */
	bp := tls.Alloc(576)
	defer tls.Free(576)

	var doAutovac int32 = 0   // True for --autovacuum
	var cacheSize int32 = 0   // Desired cache size.  0 means default
	var doExclusive int32 = 0 // True for --exclusive
	var nHeap int32 = 0
	var mnHeap int32 = 0            // Heap size from --heap
	var doIncrvac int32 = 0         // True for --incrvacuum
	var zJMode uintptr = uintptr(0) // Journal mode
	var zKey uintptr = uintptr(0)   // Encryption key
	var nLook int32 = -1
	var szLook int32 = 0   // --lookaside configuration
	var noSync int32 = 0   // True for --nosync
	var pageSize int32 = 0 // Desired page size.  0 means default
	var nPCache int32 = 0
	var szPCache int32 = 0             // --pcache configuration
	var doPCache int32 = 0             // True if --pcache is seen
	var showStats int32 = 0            // True for --stats
	var nThread int32 = 0              // --threads value
	var mmapSize int32 = 0             // How big of a memory map to use
	var memDb int32 = 0                // --memdb.  Use an in-memory database
	var zTSet uintptr = ts + 22795     /* "main" */ // Which --testset torun
	var doTrace int32 = 0              // True for --trace
	var zEncoding uintptr = uintptr(0) // --utf16be or --utf16le
	var zDbName uintptr = uintptr(0)   // Name of the test database

	var pHeap uintptr = uintptr(0)   // Allocated heap space
	var pLook uintptr = uintptr(0)   // Allocated lookaside space
	var pPCache uintptr = uintptr(0) // Allocated storage for pcache
	// var iCur int32 at bp+568, 4

	// var iHi int32 at bp+572, 4
	// Stats values, current and "highwater"
	var i int32  // Loop counter
	var rc int32 // API return code

	// Display the version of SQLite being tested
	libc.Xprintf(tls, ts+22800, /* "-- Speedtest1 fo..." */
		libc.VaList(bp, sqlite3.Xsqlite3_libversion(tls), sqlite3.Xsqlite3_sourceid(tls)))

	// Process command-line arguments
	g.zWR = ts + 2212  /* "" */
	g.zNN = ts + 2212  /* "" */
	g.zPK = ts + 22835 /* "UNIQUE" */
	g.szTest = 100
	g.nRepeat = 1
	for i = 1; i < argc; i++ {
		var z uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
		if int32(*(*int8)(unsafe.Pointer(z))) == '-' {
			for ok := true; ok; ok = (int32(*(*int8)(unsafe.Pointer(z))) == '-') {
				z++
			}
			if libc.Xstrcmp(tls, z, ts+22842 /* "autovacuum" */) == 0 {
				doAutovac = 1
			} else if libc.Xstrcmp(tls, z, ts+22853 /* "cachesize" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				i++
				cacheSize = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			} else if libc.Xstrcmp(tls, z, ts+22887 /* "exclusive" */) == 0 {
				doExclusive = 1
			} else if libc.Xstrcmp(tls, z, ts+22897 /* "checkpoint" */) == 0 {
				g.doCheckpoint = 1
			} else if libc.Xstrcmp(tls, z, ts+22908 /* "explain" */) == 0 {
				g.bSqlOnly = 1
				g.bExplain = 1
			} else if libc.Xstrcmp(tls, z, ts+22916 /* "heap" */) == 0 {
				if i >= (argc - 2) {
					fatal_error(tls, ts+22921 /* "missing argument..." */, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				nHeap = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
				mnHeap = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((i+2))*8)))
				i = i + (2)
			} else if libc.Xstrcmp(tls, z, ts+22946 /* "incrvacuum" */) == 0 {
				doIncrvac = 1
			} else if libc.Xstrcmp(tls, z, ts+22957 /* "journal" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				zJMode = *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8))
			} else if libc.Xstrcmp(tls, z, ts+22965 /* "key" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+40, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				zKey = *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8))
			} else if libc.Xstrcmp(tls, z, ts+22969 /* "lookaside" */) == 0 {
				if i >= (argc - 2) {
					fatal_error(tls, ts+22921 /* "missing argument..." */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				nLook = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
				szLook = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((i+2))*8)))
				i = i + (2)
			} else if libc.Xstrcmp(tls, z, ts+22979 /* "memdb" */) == 0 {
				memDb = 1
			} else if libc.Xstrcmp(tls, z, ts+22985 /* "multithread" */) == 0 {
				sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MULTITHREAD, 0)
			} else if libc.Xstrcmp(tls, z, ts+22997 /* "nomemstat" */) == 0 {
				sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MEMSTATUS, libc.VaList(bp+56, 0))
			} else if libc.Xstrcmp(tls, z, ts+23007 /* "mmap" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				mmapSize = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8)))
			} else if libc.Xstrcmp(tls, z, ts+23012 /* "nosync" */) == 0 {
				noSync = 1
			} else if libc.Xstrcmp(tls, z, ts+23019 /* "notnull" */) == 0 {
				g.zNN = ts + 23027 /* "NOT NULL" */
			} else if libc.Xstrcmp(tls, z, ts+23036 /* "output" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+72, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				i++
				if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), ts+23043 /* "-" */) == 0 {
					g.hashFile = (uintptr(unsafe.Pointer(&libc.X__sF)) + 1*152)
				} else {
					g.hashFile = libc.Xfopen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), ts+23045 /* "wb" */)
					if g.hashFile == uintptr(0) {
						fatal_error(tls, ts+23048 /* "cannot open \"%s\"..." */, libc.VaList(bp+80, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
					}
				}
			} else if libc.Xstrcmp(tls, z, ts+23078 /* "pagesize" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+88, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				pageSize = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8)))
			} else if libc.Xstrcmp(tls, z, ts+23087 /* "pcache" */) == 0 {
				if i >= (argc - 2) {
					fatal_error(tls, ts+22921 /* "missing argument..." */, libc.VaList(bp+96, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				nPCache = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
				szPCache = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((i+2))*8)))
				doPCache = 1
				i = i + (2)
			} else if libc.Xstrcmp(tls, z, ts+23094 /* "primarykey" */) == 0 {
				g.zPK = ts + 23105 /* "PRIMARY KEY" */
			} else if libc.Xstrcmp(tls, z, ts+23117 /* "repeat" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22921 /* "missing argument..." */, libc.VaList(bp+104, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				g.nRepeat = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr((i+1))*8)))
				i = i + (1)
			} else if libc.Xstrcmp(tls, z, ts+23124 /* "reprepare" */) == 0 {
				g.bReprepare = 1
			} else if libc.Xstrcmp(tls, z, ts+23134 /* "serialized" */) == 0 {
				sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_SERIALIZED, 0)
			} else if libc.Xstrcmp(tls, z, ts+23145 /* "singlethread" */) == 0 {
				sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_SINGLETHREAD, 0)
			} else if libc.Xstrcmp(tls, z, ts+23158 /* "sqlonly" */) == 0 {
				g.bSqlOnly = 1
			} else if libc.Xstrcmp(tls, z, ts+23166 /* "shrink-memory" */) == 0 {
				g.bMemShrink = 1
			} else if libc.Xstrcmp(tls, z, ts+23180 /* "size" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+112, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				g.szTest = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8)))
			} else if libc.Xstrcmp(tls, z, ts+23185 /* "stats" */) == 0 {
				showStats = 1
			} else if libc.Xstrcmp(tls, z, ts+23191 /* "temp" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+120, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				i++
				if ((int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))) < '0') || (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))) > '9')) || (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) + 1))) != 0) {
					fatal_error(tls, ts+23196 /* "argument to --te..." */, 0)
				}
				g.eTemp = (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))) - '0')
			} else if libc.Xstrcmp(tls, z, ts+23249 /* "testset" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+128, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				zTSet = *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8))
			} else if libc.Xstrcmp(tls, z, ts+23257 /* "trace" */) == 0 {
				doTrace = 1
			} else if libc.Xstrcmp(tls, z, ts+23263 /* "threads" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+136, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				nThread = integerValue(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8)))
			} else if libc.Xstrcmp(tls, z, ts+23271 /* "utf16le" */) == 0 {
				zEncoding = ts + 23271 /* "utf16le" */
			} else if libc.Xstrcmp(tls, z, ts+23279 /* "utf16be" */) == 0 {
				zEncoding = ts + 23279 /* "utf16be" */
			} else if libc.Xstrcmp(tls, z, ts+23287 /* "verify" */) == 0 {
				g.bVerify = 1
				HashInit(tls)
			} else if libc.Xstrcmp(tls, z, ts+23294 /* "reserve" */) == 0 {
				if i >= (argc - 1) {
					fatal_error(tls, ts+22863 /* "missing argument..." */, libc.VaList(bp+144, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				}
				g.nReserve = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PreIncInt32(&i, 1))*8)))
			} else if libc.Xstrcmp(tls, z, ts+23302 /* "without-rowid" */) == 0 {
				g.zWR = ts + 5975  /* "WITHOUT ROWID" */
				g.zPK = ts + 23105 /* "PRIMARY KEY" */
			} else if (libc.Xstrcmp(tls, z, ts+23316 /* "help" */) == 0) || (libc.Xstrcmp(tls, z, ts+23321 /* "?" */) == 0) {
				libc.Xprintf(tls, uintptr(unsafe.Pointer(&zHelp)), libc.VaList(bp+152, *(*uintptr)(unsafe.Pointer(argv))))
				libc.Xexit(tls, 0)
			} else {
				fatal_error(tls, ts+23323, /* "unknown option: ..." */
					libc.VaList(bp+160, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv))))
			}
		} else if zDbName == uintptr(0) {
			zDbName = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
		} else {
			fatal_error(tls, ts+23364, /* "surplus argument..." */
				libc.VaList(bp+176, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), *(*uintptr)(unsafe.Pointer(argv))))
		}
	}
	if zDbName != uintptr(0) {
		libc.Xunlink(tls, zDbName)
	}
	if nHeap > 0 {
		pHeap = libc.Xmalloc(tls, uint64(nHeap))
		if pHeap == uintptr(0) {
			fatal_error(tls, ts+23407 /* "cannot allocate ..." */, libc.VaList(bp+192, nHeap))
		}
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_HEAP, libc.VaList(bp+200, pHeap, nHeap, mnHeap))
		if rc != 0 {
			fatal_error(tls, ts+23437 /* "heap configurati..." */, libc.VaList(bp+224, rc))
		}
	}
	if doPCache != 0 {
		if (nPCache > 0) && (szPCache > 0) {
			pPCache = libc.Xmalloc(tls, (uint64(sqlite3_int64(nPCache) * sqlite3_int64(szPCache))))
			if pPCache == uintptr(0) {
				fatal_error(tls, ts+23468, /* "cannot allocate ..." */
					libc.VaList(bp+232, (sqlite3_int64(nPCache)*sqlite3_int64(szPCache))))
			}
		}
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PAGECACHE, libc.VaList(bp+240, pPCache, szPCache, nPCache))
		if rc != 0 {
			fatal_error(tls, ts+23502 /* "pcache configura..." */, libc.VaList(bp+264, rc))
		}
	}
	if nLook >= 0 {
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOOKASIDE, libc.VaList(bp+272, 0, 0))
	}
	sqlite3.Xsqlite3_initialize(tls)

	// Open the database and the input file
	if sqlite3.Xsqlite3_open(tls, func() uintptr {
		if memDb != 0 {
			return ts + 23535 /* ":memory:" */
		}
		return zDbName
	}(), (uintptr(unsafe.Pointer(&g)) /* &.db */)) != 0 {
		fatal_error(tls, ts+23544 /* "Cannot open data..." */, libc.VaList(bp+288, zDbName))
	}
	if (nLook > 0) && (szLook > 0) {
		pLook = libc.Xmalloc(tls, (uint64(nLook * szLook)))
		rc = sqlite3.Xsqlite3_db_config(tls, g.db, SQLITE_DBCONFIG_LOOKASIDE, libc.VaList(bp+296, pLook, szLook, nLook))
		if rc != 0 {
			fatal_error(tls, ts+23575 /* "lookaside config..." */, libc.VaList(bp+320, rc))
		}
	}
	if g.nReserve > 0 {
		sqlite3.Xsqlite3_file_control(tls, g.db, uintptr(0), SQLITE_FCNTL_RESERVE_BYTES, (uintptr(unsafe.Pointer(&g)) + 72 /* &.nReserve */))
	}

	// Set database connection options
	sqlite3.Xsqlite3_create_function(tls, g.db, ts+23611 /* "random" */, 0, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{randomFunc})), uintptr(0), uintptr(0))
	if doTrace != 0 {
		sqlite3.Xsqlite3_trace(tls, g.db, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{traceCallback})), uintptr(0))
	}
	if memDb > 0 {
		speedtest1_exec(tls, ts+23618 /* "PRAGMA temp_stor..." */, 0)
	}
	if mmapSize > 0 {
		speedtest1_exec(tls, ts+23643 /* "PRAGMA mmap_size..." */, libc.VaList(bp+328, mmapSize))
	}
	speedtest1_exec(tls, ts+23663 /* "PRAGMA threads=%..." */, libc.VaList(bp+336, nThread))
	if zKey != 0 {
		speedtest1_exec(tls, ts+23681 /* "PRAGMA key('%s')" */, libc.VaList(bp+344, zKey))
	}
	if zEncoding != 0 {
		speedtest1_exec(tls, ts+23698 /* "PRAGMA encoding=..." */, libc.VaList(bp+352, zEncoding))
	}
	if doAutovac != 0 {
		speedtest1_exec(tls, ts+23717 /* "PRAGMA auto_vacu..." */, 0)
	} else if doIncrvac != 0 {
		speedtest1_exec(tls, ts+23741 /* "PRAGMA auto_vacu..." */, 0)
	}
	if pageSize != 0 {
		speedtest1_exec(tls, ts+23772 /* "PRAGMA page_size..." */, libc.VaList(bp+360, pageSize))
	}
	if cacheSize != 0 {
		speedtest1_exec(tls, ts+23792 /* "PRAGMA cache_siz..." */, libc.VaList(bp+368, cacheSize))
	}
	if noSync != 0 {
		speedtest1_exec(tls, ts+23813 /* "PRAGMA synchrono..." */, 0)
	}
	if doExclusive != 0 {
		speedtest1_exec(tls, ts+23836 /* "PRAGMA locking_m..." */, 0)
	}
	if zJMode != 0 {
		speedtest1_exec(tls, ts+23866 /* "PRAGMA journal_m..." */, libc.VaList(bp+376, zJMode))
	}

	if g.bExplain != 0 {
		libc.Xprintf(tls, ts+23889 /* ".explain\n.echo o..." */, 0)
	}
	for ok1 := true; ok1; ok1 = *(*int8)(unsafe.Pointer(zTSet)) != 0 {
		var zThisTest uintptr = zTSet
		var zComma uintptr = libc.Xstrchr(tls, zThisTest, ',')
		if zComma != 0 {
			*(*int8)(unsafe.Pointer(zComma)) = int8(0)
			zTSet = (zComma + uintptr(1))
		} else {
			zTSet = ts + 2212 /* "" */
		}
		if (g.iTotal > int64(0)) || (zComma != uintptr(0)) {
			libc.Xprintf(tls, ts+23908 /* "       Begin tes..." */, libc.VaList(bp+384, zThisTest))
		}
		if libc.Xstrcmp(tls, zThisTest, ts+22795 /* "main" */) == 0 {
			testset_main(tls)
		} else if libc.Xstrcmp(tls, zThisTest, ts+23935 /* "debug1" */) == 0 {
			testset_debug1(tls)
		} else if libc.Xstrcmp(tls, zThisTest, ts+23942 /* "orm" */) == 0 {
			testset_orm(tls)
		} else if libc.Xstrcmp(tls, zThisTest, ts+23946 /* "cte" */) == 0 {
			testset_cte(tls)
		} else if libc.Xstrcmp(tls, zThisTest, ts+23950 /* "fp" */) == 0 {
			testset_fp(tls)
		} else if libc.Xstrcmp(tls, zThisTest, ts+23953 /* "trigger" */) == 0 {
			testset_trigger(tls)
		} else if libc.Xstrcmp(tls, zThisTest, ts+23961 /* "rtree" */) == 0 {
			testset_rtree(tls, 6, 147)
		} else {
			fatal_error(tls,
				ts+23967, /* "unknown testset:..." */
				libc.VaList(bp+392, zThisTest))
		}
		if *(*int8)(unsafe.Pointer(zTSet)) != 0 {
			var zSql uintptr
			var zObj uintptr
			speedtest1_begin_test(tls, 999, ts+24036 /* "Reset the databa..." */, 0)
			for 1 != 0 {
				zObj = speedtest1_once(tls,

					ts+24055 /* "SELECT name FROM..." */, 0)
				if zObj == uintptr(0) {
					break
				}
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+24125 /* "DROP TABLE main...." */, libc.VaList(bp+400, zObj))
				speedtest1_exec(tls, zSql, 0)
				sqlite3.Xsqlite3_free(tls, zSql)
				sqlite3.Xsqlite3_free(tls, zObj)
			}
			for 1 != 0 {
				zObj = speedtest1_once(tls,

					ts+24146 /* "SELECT name FROM..." */, 0)
				if zObj == uintptr(0) {
					break
				}
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+24125 /* "DROP TABLE main...." */, libc.VaList(bp+408, zObj))
				speedtest1_exec(tls, zSql, 0)
				sqlite3.Xsqlite3_free(tls, zSql)
				sqlite3.Xsqlite3_free(tls, zObj)
			}
			speedtest1_end_test(tls)
		}
	}
	speedtest1_final(tls)

	if showStats != 0 {
		sqlite3.Xsqlite3_exec(tls, g.db, ts+24216 /* "PRAGMA compile_o..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
		}{xCompileOptions})), uintptr(0), uintptr(0))
	}

	// Database connection statistics printed after both prepared statements
	// have been finalized
	if showStats != 0 {
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_LOOKASIDE_USED, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24239 /* "-- Lookaside Slo..." */, libc.VaList(bp+416, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */)), *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_LOOKASIDE_HIT, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24284 /* "-- Successful lo..." */, libc.VaList(bp+432, *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24320 /* "-- Lookaside siz..." */, libc.VaList(bp+440, *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24356 /* "-- Lookaside OOM..." */, libc.VaList(bp+448, *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_CACHE_USED, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24392 /* "-- Pager Heap Us..." */, libc.VaList(bp+456, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_CACHE_HIT, bp+568 /* &iCur */, bp+572 /* &iHi */, 1)
		libc.Xprintf(tls, ts+24434 /* "-- Page cache hi..." */, libc.VaList(bp+464, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_CACHE_MISS, bp+568 /* &iCur */, bp+572 /* &iHi */, 1)
		libc.Xprintf(tls, ts+24470 /* "-- Page cache mi..." */, libc.VaList(bp+472, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_CACHE_WRITE, bp+568 /* &iCur */, bp+572 /* &iHi */, 1)
		libc.Xprintf(tls, ts+24506 /* "-- Page cache wr..." */, libc.VaList(bp+480, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_SCHEMA_USED, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24542 /* "-- Schema Heap U..." */, libc.VaList(bp+488, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */))))
		sqlite3.Xsqlite3_db_status(tls, g.db, SQLITE_DBSTATUS_STMT_USED, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24584 /* "-- Statement Hea..." */, libc.VaList(bp+496, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */))))
	}

	sqlite3.Xsqlite3_close(tls, g.db)

	// Global memory usage statistics printed after the database connection
	// has closed.  Memory usage should be zero at this point.
	if showStats != 0 {
		sqlite3.Xsqlite3_status(tls, SQLITE_STATUS_MEMORY_USED, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24626 /* "-- Memory Used (..." */, libc.VaList(bp+504, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */)), *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_status(tls, SQLITE_STATUS_MALLOC_COUNT, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24671 /* "-- Outstanding A..." */, libc.VaList(bp+520, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */)), *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_status(tls, SQLITE_STATUS_PAGECACHE_OVERFLOW, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24716 /* "-- Pcache Overfl..." */, libc.VaList(bp+536, *(*int32)(unsafe.Pointer(bp + 568 /* iCur */)), *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_status(tls, SQLITE_STATUS_MALLOC_SIZE, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24761 /* "-- Largest Alloc..." */, libc.VaList(bp+552, *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
		sqlite3.Xsqlite3_status(tls, SQLITE_STATUS_PAGECACHE_SIZE, bp+568 /* &iCur */, bp+572 /* &iHi */, 0)
		libc.Xprintf(tls, ts+24803 /* "-- Largest Pcach..." */, libc.VaList(bp+560, *(*int32)(unsafe.Pointer(bp + 572 /* iHi */))))
	}

	// Release memory
	libc.Xfree(tls, pLook)
	libc.Xfree(tls, pPCache)
	libc.Xfree(tls, pHeap)
	return 0
}

var ts1 = "Usage: %s [--options] DATABASE\nOptions:\n  --autovacuum        Enable AUTOVACUUM mode\n  --cachesize N       Set the cache size to N\n  --checkpoint        Run PRAGMA wal_checkpoint after each test case\n  --exclusive         Enable locking_mode=EXCLUSIVE\n  --explain           Like --sqlonly but with added EXPLAIN keywords\n  --heap SZ MIN       Memory allocator uses SZ bytes & min allocation MIN\n  --incrvacuum        Enable incremenatal vacuum mode\n  --journal M         Set the journal_mode to M\n  --key KEY           Set the encryption key to KEY\n  --lookaside N SZ    Configure lookaside for N slots of SZ bytes each\n  --memdb             Use an in-memory database\n  --mmap SZ           MMAP the first SZ bytes of the database file\n  --multithread       Set multithreaded mode\n  --nomemstat         Disable memory statistics\n  --nosync            Set PRAGMA synchronous=OFF\n  --notnull           Add NOT NULL constraints to table columns\n  --output FILE       Store SQL output in FILE\n  --pagesize N        Set the page size to N\n  --pcache N SZ       Configure N pages of pagecache each of size SZ bytes\n  --primarykey        Use PRIMARY KEY instead of UNIQUE where appropriate\n  --repeat N          Repeat each SELECT N times (default: 1)\n  --reprepare         Reprepare each statement upon every invocation\n  --reserve N         Reserve N bytes on each database page\n  --serialized        Set serialized threading mode\n  --singlethread      Set single-threaded mode - disables all mutexing\n  --sqlonly           No-op.  Only show the SQL that would have been run.\n  --shrink-memory     Invoke sqlite3_db_release_memory() frequently.\n  --size N            Relative test size.  Default=100\n  --stats             Show statistics at the end\n  --temp N            N from 0 to 9.  0: no temp table. 9: all temp tables\n  --testset T         Run test-set T (main, cte, rtree, orm, fp, debug)\n  --trace             Turn on SQL tracing\n  --threads N         Use up to N threads for sorting\n  --utf16be           Set text encoding to UTF-16BE\n  --utf16le           Set text encoding to UTF-16LE\n  --verify            Run additional verification steps.\n  --without-rowid     Use WITHOUT ROWID where appropriate\n\x00 TEMP\x00\x00parameter too large - max 2147483648\x00KiB\x00MiB\x00GiB\x00KB\x00MB\x00GB\x00K\x00M\x00G\x00 billion\x00 million\x00 thousand\x00%s hundred\x00%s\x00zero\x00one\x00two\x00three\x00four\x00five\x00six\x00seven\x00eight\x00nine\x00ten\x00eleven\x00twelve\x00thirteen\x00fourteen\x00fifteen\x00sixteen\x00seventeen\x00eighteen\x00nineteen\x00twenty\x00thirty\x00forty\x00fifty\x00sixty\x00seventy\x00eighty\x00ninety\x00.......................................................................\x00/* %4d - %s%.*s */\n\x00%4d - %s%.*s \x00PRAGMA wal_checkpoint;\x00%4d.%03ds\n\x00       TOTAL%.*s %4d.%03ds\n\x00Verification Hash: %llu \x00\n\x00%02x\x00EXPLAIN \x00%.*s;\n\x00CREATE *\x00DROP *\x00ALTER *\x00SQL error: %s\n%s\n\x00exec error: %s\n\x00SQL error: %s\n\x00nil\x00-IFTBN\x000123456789abcdef\x00%d INSERTs into table with no index\x00BEGIN\x00CREATE%s TABLE z1(a INTEGER %s, b INTEGER %s, c TEXT %s);\x00INSERT INTO z1 VALUES(?1,?2,?3); --  %d times\x00COMMIT\x00%d ordered INSERTS with one index/PK\x00CREATE%s TABLE z2(a INTEGER %s %s, b INTEGER %s, c TEXT %s) %s\x00INSERT INTO z2 VALUES(?1,?2,?3); -- %d times\x00%d unordered INSERTS with one index/PK\x00CREATE%s TABLE t3(a INTEGER %s %s, b INTEGER %s, c TEXT %s) %s\x00INSERT INTO t3 VALUES(?1,?2,?3); -- %d times\x00%d SELECTS, numeric BETWEEN, unindexed\x00SELECT count(*), avg(b), sum(length(c)), group_concat(c) FROM z1\n WHERE b BETWEEN ?1 AND ?2; -- %d times\x00%d SELECTS, LIKE, unindexed\x00SELECT count(*), avg(b), sum(length(c)), group_concat(c) FROM z1\n WHERE c LIKE ?1; -- %d times\x00%d SELECTS w/ORDER BY, unindexed\x00SELECT a, b, c FROM z1 WHERE c LIKE ?1\n ORDER BY a; -- %d times\x00%d SELECTS w/ORDER BY and LIMIT, unindexed\x00SELECT a, b, c FROM z1 WHERE c LIKE ?1\n ORDER BY a LIMIT 10; -- %d times\x00CREATE INDEX five times\x00BEGIN;\x00CREATE UNIQUE INDEX t1b ON z1(b);\x00CREATE INDEX t1c ON z1(c);\x00CREATE UNIQUE INDEX t2b ON z2(b);\x00CREATE INDEX t2c ON z2(c DESC);\x00CREATE INDEX t3bc ON t3(b,c);\x00COMMIT;\x00%d SELECTS, numeric BETWEEN, indexed\x00SELECT count(*), avg(b), sum(length(c)), group_concat(a) FROM z1\n WHERE b BETWEEN ?1 AND ?2; -- %d times\x00%d SELECTS, numeric BETWEEN, PK\x00SELECT count(*), avg(b), sum(length(c)), group_concat(a) FROM z2\n WHERE a BETWEEN ?1 AND ?2; -- %d times\x00%d SELECTS, text BETWEEN, indexed\x00SELECT count(*), avg(b), sum(length(c)), group_concat(a) FROM z1\n WHERE c BETWEEN ?1 AND (?1||'~'); -- %d times\x00%d INSERTS with three indexes\x00CREATE%s TABLE t4(\n  a INTEGER %s %s,\n  b INTEGER %s,\n  c TEXT %s\n) %s\x00CREATE INDEX t4b ON t4(b)\x00CREATE INDEX t4c ON t4(c)\x00INSERT INTO t4 SELECT * FROM z1\x00DELETE and REFILL one table\x00DELETE FROM z2;\x00INSERT INTO z2 SELECT * FROM z1;\x00VACUUM\x00ALTER TABLE ADD COLUMN, and query\x00ALTER TABLE z2 ADD COLUMN d DEFAULT 123\x00SELECT sum(d) FROM z2\x00%d UPDATES, numeric BETWEEN, indexed\x00UPDATE z2 SET d=b*2 WHERE b BETWEEN ?1 AND ?2; -- %d times\x00%d UPDATES of individual rows\x00UPDATE z2 SET d=b*3 WHERE a=?1; -- %d times\x00One big UPDATE of the whole %d-row table\x00UPDATE z2 SET d=b*4\x00Query added column after filling\x00%d DELETEs, numeric BETWEEN, indexed\x00DELETE FROM z2 WHERE b BETWEEN ?1 AND ?2; -- %d times\x00%d DELETEs of individual rows\x00DELETE FROM t3 WHERE a=?1; -- %d times\x00Refill two %d-row tables using REPLACE\x00REPLACE INTO z2(a,b,c) SELECT a,b,c FROM z1\x00REPLACE INTO t3(a,b,c) SELECT a,b,c FROM z1\x00Refill a %d-row table using (b&1)==(a&1)\x00INSERT INTO z2(a,b,c)\n SELECT a,b,c FROM z1  WHERE (b&1)==(a&1);\x00INSERT INTO z2(a,b,c)\n SELECT a,b,c FROM z1  WHERE (b&1)<>(a&1);\x00%d four-ways joins\x00SELECT z1.c FROM z1, z2, t3, t4\n WHERE t4.a BETWEEN ?1 AND ?2\n   AND t3.a=t4.b\n   AND z2.a=t3.b\n   AND z1.c=z2.c\x00subquery in result set\x00SELECT sum(a), max(c),\n       avg((SELECT a FROM z2 WHERE 5+z2.b=z1.b) AND rowid<?1), max(c)\n FROM z1 WHERE rowid<?1;\x00%d REPLACE ops on an IPK\x00CREATE%s TABLE t5(a INTEGER PRIMARY KEY, b %s);\x00REPLACE INTO t5 VALUES(?1,?2); --  %d times\x00%d SELECTS on an IPK\x00SELECT b FROM t5 WHERE a=?1; --  %d times\x00%d REPLACE on TEXT PK\x00CREATE%s TABLE t6(a TEXT PRIMARY KEY, b %s)%s;\x00WITHOUT ROWID\x00REPLACE INTO t6 VALUES(?1,?2); --  %d times\x00%d SELECTS on a TEXT PK\x00SELECT b FROM t6 WHERE a=?1; --  %d times\x00%d SELECT DISTINCT\x00SELECT DISTINCT b FROM t5;\x00SELECT DISTINCT b FROM t6;\x00PRAGMA integrity_check\x00ANALYZE\x00Sudoku with recursive 'digits'\x00WITH RECURSIVE\n  input(sud) AS (VALUES(?1)),\n  digits(z,lp) AS (\n    VALUES('1', 1)\n    UNION ALL\n    SELECT CAST(lp+1 AS TEXT), lp+1 FROM digits WHERE lp<9\n  ),\n  x(s, ind) AS (\n    SELECT sud, instr(sud, '.') FROM input\n    UNION ALL\n    SELECT\n      substr(s, 1, ind-1) || z || substr(s, ind+1),\n      instr( substr(s, 1, ind-1) || z || substr(s, ind+1), '.' )\n     FROM x, digits AS z\n    WHERE ind>0\n      AND NOT EXISTS (\n            SELECT 1\n              FROM digits AS lp\n             WHERE z.z = substr(s, ((ind-1)/9)*9 + lp, 1)\n                OR z.z = substr(s, ((ind-1)%%9) + (lp-1)*9 + 1, 1)\n                OR z.z = substr(s, (((ind-1)/3) %% 3) * 3\n                        + ((ind-1)/27) * 27 + lp\n                        + ((lp-1) / 3) * 6, 1)\n         )\n  )\nSELECT s FROM x WHERE ind=0;\x00Sudoku with VALUES 'digits'\x00WITH RECURSIVE\n  input(sud) AS (VALUES(?1)),\n  digits(z,lp) AS (VALUES('1',1),('2',2),('3',3),('4',4),('5',5),\n                         ('6',6),('7',7),('8',8),('9',9)),\n  x(s, ind) AS (\n    SELECT sud, instr(sud, '.') FROM input\n    UNION ALL\n    SELECT\n      substr(s, 1, ind-1) || z || substr(s, ind+1),\n      instr( substr(s, 1, ind-1) || z || substr(s, ind+1), '.' )\n     FROM x, digits AS z\n    WHERE ind>0\n      AND NOT EXISTS (\n            SELECT 1\n              FROM digits AS lp\n             WHERE z.z = substr(s, ((ind-1)/9)*9 + lp, 1)\n                OR z.z = substr(s, ((ind-1)%%9) + (lp-1)*9 + 1, 1)\n                OR z.z = substr(s, (((ind-1)/3) %% 3) * 3\n                        + ((ind-1)/27) * 27 + lp\n                        + ((lp-1) / 3) * 6, 1)\n         )\n  )\nSELECT s FROM x WHERE ind=0;\x00Mandelbrot Set with spacing=%f\x00WITH RECURSIVE \n  xaxis(x) AS (VALUES(-2.0) UNION ALL SELECT x+?1 FROM xaxis WHERE x<1.2),\n  yaxis(y) AS (VALUES(-1.0) UNION ALL SELECT y+?2 FROM yaxis WHERE y<1.0),\n  m(iter, cx, cy, x, y) AS (\n    SELECT 0, x, y, 0.0, 0.0 FROM xaxis, yaxis\n    UNION ALL\n    SELECT iter+1, cx, cy, x*x-y*y + cx, 2.0*x*y + cy FROM m \n     WHERE (x*x + y*y) < 4.0 AND iter<28\n  ),\n  m2(iter, cx, cy) AS (\n    SELECT max(iter), cx, cy FROM m GROUP BY cx, cy\n  ),\n  a(t) AS (\n    SELECT group_concat( substr(' .+*#', 1+min(iter/7,4), 1), '') \n    FROM m2 GROUP BY cy\n  )\nSELECT group_concat(rtrim(t),x'0a') FROM a;\x00EXCEPT operator on %d-element tables\x00WITH RECURSIVE \n  z1(x) AS (VALUES(2) UNION ALL SELECT x+2 FROM z1 WHERE x<%d),\n  z2(y) AS (VALUES(3) UNION ALL SELECT y+3 FROM z2 WHERE y<%d)\nSELECT count(x), avg(x) FROM (\n  SELECT x FROM z1 EXCEPT SELECT y FROM z2 ORDER BY 1\n);\x00534...9..67.195....98....6.8...6...34..8.3..1....2...6.6....28....419..5...28..79\x0053....9..6..195....98....6.8...6...34..8.3..1....2...6.6....28....419..5....8..79\x0053.......6..195....98....6.8...6...34..8.3..1....2...6.6....28....419..5....8..79\x00%d.%de%d\x00Fill a table with %d FP values\x00CREATE%s TABLE z1(a REAL %s, b REAL %s);\x00INSERT INTO z1 VALUES(?1,?2); -- %d times\x00%d range queries\x00SELECT sum(b) FROM z1 WHERE a BETWEEN ?1 AND ?2\x00CREATE INDEX three times\x00CREATE INDEX t1a ON z1(a);\x00CREATE INDEX t1b ON z1(b);\x00CREATE INDEX t1ab ON z1(a,b);\x00%d indexed range queries\x00%d calls to round()\x00SELECT sum(round(a,2)+round(b,4)) FROM z1;\x00%d printf() calls\x00WITH c(fmt) AS (VALUES('%%g'),('%%e'),('%%!g'),('%%.20f'))SELECT sum(printf(fmt,a)) FROM z1, c\x00%d INSERTs into an r-tree\x00CREATE VIRTUAL TABLE rt1 USING rtree(id,x0,x1,y0,y1,z0,z1)\x00INSERT INTO rt1(id,x0,x1,y0,y1,z0,z1)VALUES(?1,?2,?3,?4,?5,?6,?7)\x00Copy from rtree to a regular table\x00CREATE TABLE z1(id INTEGER PRIMARY KEY,x0,x1,y0,y1,z0,z1)\x00INSERT INTO z1 SELECT * FROM rt1\x00%d one-dimensional intersect slice queries\x00SELECT count(*) FROM rt1 WHERE x0>=?1 AND x1<=?2\x00Verify result from 1-D intersect slice queries\x00SELECT count(*) FROM z1 WHERE x0>=?1 AND x1<=?2\x00Count disagree step %d: %d..%d.  %d vs %d\x00%d one-dimensional overlap slice queries\x00SELECT count(*) FROM rt1 WHERE y1>=?1 AND y0<=?2\x00Verify result from 1-D overlap slice queries\x00SELECT count(*) FROM z1 WHERE y1>=?1 AND y0<=?2\x00%d custom geometry callback queries\x00xslice\x00SELECT count(*) FROM rt1 WHERE id MATCH xslice(?1,?2)\x00%d three-dimensional intersect box queries\x00SELECT count(*) FROM rt1 WHERE x1>=?1 AND x0<=?2 AND y1>=?1 AND y0<=?2 AND z1>=?1 AND z0<=?2\x00%d rowid queries\x00SELECT * FROM rt1 WHERE id=?1\x00%d UPDATEs using rowid\x00UPDATE rt1 SET x0=x0+100, x1=x1+100 WHERE id=?1\x00%d UPDATEs using one-dimensional overlap\x00UPDATE rt1 SET x0=x0-100, x1=x1-100 WHERE y1>=?1 AND y0<=?1+5\x00%d DELETEs using rowid\x00DELETE FROM rt1 WHERE id=?1\x00%d DELETEs using one-dimensional overlap\x00DELETE FROM rt1 WHERE y1>=?1 AND y0<=?1+5\x00Restore deleted entries using INSERT OR IGNORE\x00INSERT OR IGNORE INTO rt1 SELECT * FROM z1\x00Fill %d rows\x00BEGIN;CREATE TABLE ZLOOKSLIKECOREDATA (  ZPK INTEGER PRIMARY KEY,  ZTERMFITTINGHOUSINGCOMMAND INTEGER,  ZBRIEFGOBYDODGERHEIGHT BLOB,  ZCAPABLETRIPDOORALMOND BLOB,  ZDEPOSITPAIRCOLLEGECOMET INTEGER,  ZFRAMEENTERSIMPLEMOUTH INTEGER,  ZHOPEFULGATEHOLECHALK INTEGER,  ZSLEEPYUSERGRANDBOWL TIMESTAMP,  ZDEWPEACHCAREERCELERY INTEGER,  ZHANGERLITHIUMDINNERMEET VARCHAR,  ZCLUBRELEASELIZARDADVICE VARCHAR,  ZCHARGECLICKHUMANEHIRE INTEGER,  ZFINGERDUEPIZZAOPTION TIMESTAMP,  ZFLYINGDOCTORTABLEMELODY BLOB,  ZLONGFINLEAVEIMAGEOIL TIMESTAMP,  ZFAMILYVISUALOWNERMATTER BLOB,  ZGOLDYOUNGINITIALNOSE FLOAT,  ZCAUSESALAMITERMCYAN BLOB,  ZSPREADMOTORBISCUITBACON FLOAT,  ZGIFTICEFISHGLUEHAIR INTEGER,  ZNOTICEPEARPOLICYJUICE TIMESTAMP,  ZBANKBUFFALORECOVERORBIT TIMESTAMP,  ZLONGDIETESSAYNATURE FLOAT,  ZACTIONRANGEELEGANTNEUTRON BLOB,  ZCADETBRIGHTPLANETBANK TIMESTAMP,  ZAIRFORGIVEHEADFROG BLOB,  ZSHARKJUSTFRUITMOVIE VARCHAR,  ZFARMERMORNINGMIRRORCONCERN BLOB,  ZWOODPOETRYCOBBLERBENCH VARCHAR,  ZHAFNIUMSCRIPTSALADMOTOR INTEGER,  ZPROBLEMCLUBPOPOVERJELLY FLOAT,  ZEIGHTLEADERWORKERMOST TIMESTAMP,  ZGLASSRESERVEBARIUMMEAL BLOB,  ZCLAMBITARUGULAFAJITA BLOB,  ZDECADEJOYOUSWAVEHABIT FLOAT,  ZCOMPANYSUMMERFIBERELF INTEGER,  ZTREATTESTQUILLCHARGE TIMESTAMP,  ZBROWBALANCEKEYCHOWDER FLOAT,  ZPEACHCOPPERDINNERLAKE FLOAT,  ZDRYWALLBEYONDBROWNBOWL VARCHAR,  ZBELLYCRASHITEMLACK BLOB,  ZTENNISCYCLEBILLOFFICER INTEGER,  ZMALLEQUIPTHANKSGLUE FLOAT,  ZMISSREPLYHUMANLIVING INTEGER,  ZKIWIVISUALPRIDEAPPLE VARCHAR,  ZWISHHITSKINMOTOR BLOB,  ZCALMRACCOONPROGRAMDEBIT VARCHAR,  ZSHINYASSISTLIVINGCRAB VARCHAR,  ZRESOLVEWRISTWRAPAPPLE VARCHAR,  ZAPPEALSIMPLESECONDHOUSING BLOB,  ZCORNERANCHORTAPEDIVER TIMESTAMP,  ZMEMORYREQUESTSOURCEBIG VARCHAR,  ZTRYFACTKEEPMILK TIMESTAMP,  ZDIVERPAINTLEATHEREASY INTEGER,  ZSORTMISTYQUOTECABBAGE BLOB,  ZTUNEGASBUFFALOCAPITAL BLOB,  ZFILLSTOPLAWJOYFUL FLOAT,  ZSTEELCAREFULPLATENUMBER FLOAT,  ZGIVEVIVIDDIVINEMEANING INTEGER,  ZTREATPACKFUTURECONVERT VARCHAR,  ZCALMLYGEMFINISHEFFECT INTEGER,  ZCABBAGESOCKEASEMINUTE BLOB,  ZPLANETFAMILYPUREMEMORY TIMESTAMP,  ZMERRYCRACKTRAINLEADER BLOB,  ZMINORWAYPAPERCLASSY TIMESTAMP,  ZEAGLELINEMINEMAIL VARCHAR,  ZRESORTYARDGREENLET TIMESTAMP,  ZYARDOREGANOVIVIDJEWEL TIMESTAMP,  ZPURECAKEVIVIDNEATLY FLOAT,  ZASKCONTACTMONITORFUN TIMESTAMP,  ZMOVEWHOGAMMAINCH VARCHAR,  ZLETTUCEBIRDMEETDEBATE TIMESTAMP,  ZGENENATURALHEARINGKITE VARCHAR,  ZMUFFINDRYERDRAWFORTUNE FLOAT,  ZGRAYSURVEYWIRELOVE FLOAT,  ZPLIERSPRINTASKOREGANO INTEGER,  ZTRAVELDRIVERCONTESTLILY INTEGER,  ZHUMORSPICESANDKIDNEY TIMESTAMP,  ZARSENICSAMPLEWAITMUON INTEGER,  ZLACEADDRESSGROUNDCAREFUL FLOAT,  ZBAMBOOMESSWASABIEVENING BLOB,  ZONERELEASEAVERAGENURSE INTEGER,  ZRADIANTWHENTRYCARD TIMESTAMP,  ZREWARDINSIDEMANGOINTENSE FLOAT,  ZNEATSTEWPARTIRON TIMESTAMP,  ZOUTSIDEPEAHENCOUNTICE TIMESTAMP,  ZCREAMEVENINGLIPBRANCH FLOAT,  ZWHALEMATHAVOCADOCOPPER FLOAT,  ZLIFEUSELEAFYBELL FLOAT,  ZWEALTHLINENGLEEFULDAY VARCHAR,  ZFACEINVITETALKGOLD BLOB,  ZWESTAMOUNTAFFECTHEARING INTEGER,  ZDELAYOUTCOMEHORNAGENCY INTEGER,  ZBIGTHINKCONVERTECONOMY BLOB,  ZBASEGOUDAREGULARFORGIVE TIMESTAMP,  ZPATTERNCLORINEGRANDCOLBY TIMESTAMP,  ZCYANBASEFEEDADROIT INTEGER,  ZCARRYFLOORMINNOWDRAGON TIMESTAMP,  ZIMAGEPENCILOTHERBOTTOM FLOAT,  ZXENONFLIGHTPALEAPPLE TIMESTAMP,  ZHERRINGJOKEFEATUREHOPEFUL FLOAT,  ZCAPYEARLYRIVETBRUSH FLOAT,  ZAGEREEDFROGBASKET VARCHAR,  ZUSUALBODYHALIBUTDIAMOND VARCHAR,  ZFOOTTAPWORDENTRY VARCHAR,  ZDISHKEEPBLESTMONITOR FLOAT,  ZBROADABLESOLIDCASUAL INTEGER,  ZSQUAREGLEEFULCHILDLIGHT INTEGER,  ZHOLIDAYHEADPONYDETAIL INTEGER,  ZGENERALRESORTSKYOPEN TIMESTAMP,  ZGLADSPRAYKIDNEYGUPPY VARCHAR,  ZSWIMHEAVYMENTIONKIND BLOB,  ZMESSYSULFURDREAMFESTIVE BLOB,  ZSKYSKYCLASSICBRIEF VARCHAR,  ZDILLASKHOKILEMON FLOAT,  ZJUNIORSHOWPRESSNOVA FLOAT,  ZSIZETOEAWARDFRESH TIMESTAMP,  ZKEYFAILAPRICOTMETAL VARCHAR,  ZHANDYREPAIRPROTONAIRPORT VARCHAR,  ZPOSTPROTEINHANDLEACTOR BLOB);\x00INSERT INTO ZLOOKSLIKECOREDATA(ZPK,ZAIRFORGIVEHEADFROG,ZGIFTICEFISHGLUEHAIR,ZDELAYOUTCOMEHORNAGENCY,ZSLEEPYUSERGRANDBOWL,ZGLASSRESERVEBARIUMMEAL,ZBRIEFGOBYDODGERHEIGHT,ZBAMBOOMESSWASABIEVENING,ZFARMERMORNINGMIRRORCONCERN,ZTREATPACKFUTURECONVERT,ZCAUSESALAMITERMCYAN,ZCALMRACCOONPROGRAMDEBIT,ZHOLIDAYHEADPONYDETAIL,ZWOODPOETRYCOBBLERBENCH,ZHAFNIUMSCRIPTSALADMOTOR,ZUSUALBODYHALIBUTDIAMOND,ZOUTSIDEPEAHENCOUNTICE,ZDIVERPAINTLEATHEREASY,ZWESTAMOUNTAFFECTHEARING,ZSIZETOEAWARDFRESH,ZDEWPEACHCAREERCELERY,ZSTEELCAREFULPLATENUMBER,ZCYANBASEFEEDADROIT,ZCALMLYGEMFINISHEFFECT,ZHANDYREPAIRPROTONAIRPORT,ZGENENATURALHEARINGKITE,ZBROADABLESOLIDCASUAL,ZPOSTPROTEINHANDLEACTOR,ZLACEADDRESSGROUNDCAREFUL,ZIMAGEPENCILOTHERBOTTOM,ZPROBLEMCLUBPOPOVERJELLY,ZPATTERNCLORINEGRANDCOLBY,ZNEATSTEWPARTIRON,ZAPPEALSIMPLESECONDHOUSING,ZMOVEWHOGAMMAINCH,ZTENNISCYCLEBILLOFFICER,ZSHARKJUSTFRUITMOVIE,ZKEYFAILAPRICOTMETAL,ZCOMPANYSUMMERFIBERELF,ZTERMFITTINGHOUSINGCOMMAND,ZRESORTYARDGREENLET,ZCABBAGESOCKEASEMINUTE,ZSQUAREGLEEFULCHILDLIGHT,ZONERELEASEAVERAGENURSE,ZBIGTHINKCONVERTECONOMY,ZPLIERSPRINTASKOREGANO,ZDECADEJOYOUSWAVEHABIT,ZDRYWALLBEYONDBROWNBOWL,ZCLUBRELEASELIZARDADVICE,ZWHALEMATHAVOCADOCOPPER,ZBELLYCRASHITEMLACK,ZLETTUCEBIRDMEETDEBATE,ZCAPABLETRIPDOORALMOND,ZRADIANTWHENTRYCARD,ZCAPYEARLYRIVETBRUSH,ZAGEREEDFROGBASKET,ZSWIMHEAVYMENTIONKIND,ZTRAVELDRIVERCONTESTLILY,ZGLADSPRAYKIDNEYGUPPY,ZBANKBUFFALORECOVERORBIT,ZFINGERDUEPIZZAOPTION,ZCLAMBITARUGULAFAJITA,ZLONGFINLEAVEIMAGEOIL,ZLONGDIETESSAYNATURE,ZJUNIORSHOWPRESSNOVA,ZHOPEFULGATEHOLECHALK,ZDEPOSITPAIRCOLLEGECOMET,ZWEALTHLINENGLEEFULDAY,ZFILLSTOPLAWJOYFUL,ZTUNEGASBUFFALOCAPITAL,ZGRAYSURVEYWIRELOVE,ZCORNERANCHORTAPEDIVER,ZREWARDINSIDEMANGOINTENSE,ZCADETBRIGHTPLANETBANK,ZPLANETFAMILYPUREMEMORY,ZTREATTESTQUILLCHARGE,ZCREAMEVENINGLIPBRANCH,ZSKYSKYCLASSICBRIEF,ZARSENICSAMPLEWAITMUON,ZBROWBALANCEKEYCHOWDER,ZFLYINGDOCTORTABLEMELODY,ZHANGERLITHIUMDINNERMEET,ZNOTICEPEARPOLICYJUICE,ZSHINYASSISTLIVINGCRAB,ZLIFEUSELEAFYBELL,ZFACEINVITETALKGOLD,ZGENERALRESORTSKYOPEN,ZPURECAKEVIVIDNEATLY,ZKIWIVISUALPRIDEAPPLE,ZMESSYSULFURDREAMFESTIVE,ZCHARGECLICKHUMANEHIRE,ZHERRINGJOKEFEATUREHOPEFUL,ZYARDOREGANOVIVIDJEWEL,ZFOOTTAPWORDENTRY,ZWISHHITSKINMOTOR,ZBASEGOUDAREGULARFORGIVE,ZMUFFINDRYERDRAWFORTUNE,ZACTIONRANGEELEGANTNEUTRON,ZTRYFACTKEEPMILK,ZPEACHCOPPERDINNERLAKE,ZFRAMEENTERSIMPLEMOUTH,ZMERRYCRACKTRAINLEADER,ZMEMORYREQUESTSOURCEBIG,ZCARRYFLOORMINNOWDRAGON,ZMINORWAYPAPERCLASSY,ZDILLASKHOKILEMON,ZRESOLVEWRISTWRAPAPPLE,ZASKCONTACTMONITORFUN,ZGIVEVIVIDDIVINEMEANING,ZEIGHTLEADERWORKERMOST,ZMISSREPLYHUMANLIVING,ZXENONFLIGHTPALEAPPLE,ZSORTMISTYQUOTECABBAGE,ZEAGLELINEMINEMAIL,ZFAMILYVISUALOWNERMATTER,ZSPREADMOTORBISCUITBACON,ZDISHKEEPBLESTMONITOR,ZMALLEQUIPTHANKSGLUE,ZGOLDYOUNGINITIALNOSE,ZHUMORSPICESANDKIDNEY)VALUES(?1,?26,?20,?93,?8,?33,?3,?81,?28,?60,?18,?47,?109,?29,?30,?104,?86,?54,?92,?117,?9,?58,?97,?61,?119,?73,?107,?120,?80,?99,?31,?96,?85,?50,?71,?42,?27,?118,?36,?2,?67,?62,?108,?82,?94,?76,?35,?40,?11,?88,?41,?72,?4,?83,?102,?103,?112,?77,?111,?22,?13,?34,?15,?23,?116,?7,?5,?90,?57,?56,?75,?51,?84,?25,?63,?37,?87,?114,?79,?38,?14,?10,?21,?48,?89,?91,?110,?69,?45,?113,?12,?101,?68,?105,?46,?95,?74,?24,?53,?39,?6,?64,?52,?98,?65,?115,?49,?70,?59,?32,?44,?100,?55,?66,?16,?19,?106,?43,?17,?78);\x00Query %d rows by rowid\x00SELECT ZCYANBASEFEEDADROIT,ZJUNIORSHOWPRESSNOVA,ZCAUSESALAMITERMCYAN,ZHOPEFULGATEHOLECHALK,ZHUMORSPICESANDKIDNEY,ZSWIMHEAVYMENTIONKIND,ZMOVEWHOGAMMAINCH,ZAPPEALSIMPLESECONDHOUSING,ZHAFNIUMSCRIPTSALADMOTOR,ZNEATSTEWPARTIRON,ZLONGFINLEAVEIMAGEOIL,ZDEWPEACHCAREERCELERY,ZXENONFLIGHTPALEAPPLE,ZCALMRACCOONPROGRAMDEBIT,ZUSUALBODYHALIBUTDIAMOND,ZTRYFACTKEEPMILK,ZWEALTHLINENGLEEFULDAY,ZLONGDIETESSAYNATURE,ZLIFEUSELEAFYBELL,ZTREATPACKFUTURECONVERT,ZMEMORYREQUESTSOURCEBIG,ZYARDOREGANOVIVIDJEWEL,ZDEPOSITPAIRCOLLEGECOMET,ZSLEEPYUSERGRANDBOWL,ZBRIEFGOBYDODGERHEIGHT,ZCLUBRELEASELIZARDADVICE,ZCAPABLETRIPDOORALMOND,ZDRYWALLBEYONDBROWNBOWL,ZASKCONTACTMONITORFUN,ZKIWIVISUALPRIDEAPPLE,ZNOTICEPEARPOLICYJUICE,ZPEACHCOPPERDINNERLAKE,ZSTEELCAREFULPLATENUMBER,ZGLADSPRAYKIDNEYGUPPY,ZCOMPANYSUMMERFIBERELF,ZTENNISCYCLEBILLOFFICER,ZIMAGEPENCILOTHERBOTTOM,ZWESTAMOUNTAFFECTHEARING,ZDIVERPAINTLEATHEREASY,ZSKYSKYCLASSICBRIEF,ZMESSYSULFURDREAMFESTIVE,ZMERRYCRACKTRAINLEADER,ZBROADABLESOLIDCASUAL,ZGLASSRESERVEBARIUMMEAL,ZTUNEGASBUFFALOCAPITAL,ZBANKBUFFALORECOVERORBIT,ZTREATTESTQUILLCHARGE,ZBAMBOOMESSWASABIEVENING,ZREWARDINSIDEMANGOINTENSE,ZEAGLELINEMINEMAIL,ZCALMLYGEMFINISHEFFECT,ZKEYFAILAPRICOTMETAL,ZFINGERDUEPIZZAOPTION,ZCADETBRIGHTPLANETBANK,ZGOLDYOUNGINITIALNOSE,ZMISSREPLYHUMANLIVING,ZEIGHTLEADERWORKERMOST,ZFRAMEENTERSIMPLEMOUTH,ZBIGTHINKCONVERTECONOMY,ZFACEINVITETALKGOLD,ZPOSTPROTEINHANDLEACTOR,ZHERRINGJOKEFEATUREHOPEFUL,ZCABBAGESOCKEASEMINUTE,ZMUFFINDRYERDRAWFORTUNE,ZPROBLEMCLUBPOPOVERJELLY,ZGIVEVIVIDDIVINEMEANING,ZGENENATURALHEARINGKITE,ZGENERALRESORTSKYOPEN,ZLETTUCEBIRDMEETDEBATE,ZBASEGOUDAREGULARFORGIVE,ZCHARGECLICKHUMANEHIRE,ZPLANETFAMILYPUREMEMORY,ZMINORWAYPAPERCLASSY,ZCAPYEARLYRIVETBRUSH,ZSIZETOEAWARDFRESH,ZARSENICSAMPLEWAITMUON,ZSQUAREGLEEFULCHILDLIGHT,ZSHINYASSISTLIVINGCRAB,ZCORNERANCHORTAPEDIVER,ZDECADEJOYOUSWAVEHABIT,ZTRAVELDRIVERCONTESTLILY,ZFLYINGDOCTORTABLEMELODY,ZSHARKJUSTFRUITMOVIE,ZFAMILYVISUALOWNERMATTER,ZFARMERMORNINGMIRRORCONCERN,ZGIFTICEFISHGLUEHAIR,ZOUTSIDEPEAHENCOUNTICE,ZSPREADMOTORBISCUITBACON,ZWISHHITSKINMOTOR,ZHOLIDAYHEADPONYDETAIL,ZWOODPOETRYCOBBLERBENCH,ZAIRFORGIVEHEADFROG,ZBROWBALANCEKEYCHOWDER,ZDISHKEEPBLESTMONITOR,ZCLAMBITARUGULAFAJITA,ZPLIERSPRINTASKOREGANO,ZRADIANTWHENTRYCARD,ZDELAYOUTCOMEHORNAGENCY,ZPURECAKEVIVIDNEATLY,ZPATTERNCLORINEGRANDCOLBY,ZHANDYREPAIRPROTONAIRPORT,ZAGEREEDFROGBASKET,ZSORTMISTYQUOTECABBAGE,ZFOOTTAPWORDENTRY,ZRESOLVEWRISTWRAPAPPLE,ZDILLASKHOKILEMON,ZFILLSTOPLAWJOYFUL,ZACTIONRANGEELEGANTNEUTRON,ZRESORTYARDGREENLET,ZCREAMEVENINGLIPBRANCH,ZWHALEMATHAVOCADOCOPPER,ZGRAYSURVEYWIRELOVE,ZBELLYCRASHITEMLACK,ZHANGERLITHIUMDINNERMEET,ZCARRYFLOORMINNOWDRAGON,ZMALLEQUIPTHANKSGLUE,ZTERMFITTINGHOUSINGCOMMAND,ZONERELEASEAVERAGENURSE,ZLACEADDRESSGROUNDCAREFUL FROM ZLOOKSLIKECOREDATA WHERE ZPK=?1;\x00IBBIIITIVVITBTBFBFITTFBTBVBVIFTBBFITFFVBIFIVBVVVBTVTIBBFFIVIBTBTVTTFTVTVFFIITIFBITFTTFFFVBIIBTTITFTFFVVVFIIITVBBVFFTVVB\x00BEGIN;CREATE TABLE z1(rowid INTEGER PRIMARY KEY, i INTEGER, t TEXT);CREATE TABLE z2(rowid INTEGER PRIMARY KEY, i INTEGER, t TEXT);CREATE TABLE t3(rowid INTEGER PRIMARY KEY, i INTEGER, t TEXT);CREATE VIEW v1 AS SELECT rowid, i, t FROM z1;CREATE VIEW v2 AS SELECT rowid, i, t FROM z2;CREATE VIEW v3 AS SELECT rowid, i, t FROM t3;\x00INSERT INTO t%d VALUES(NULL,?1,?2)\x00CREATE INDEX i1 ON z1(t);CREATE INDEX i2 ON z2(t);CREATE INDEX i3 ON t3(t);COMMIT;\x00speed4p-join1\x00SELECT * FROM z1, z2, t3 WHERE z1.oid = z2.oid AND z2.oid = t3.oid\x00speed4p-join2\x00SELECT * FROM z1, z2, t3 WHERE z1.t = z2.t AND z2.t = t3.t\x00speed4p-view1\x00SELECT * FROM v%d WHERE rowid = ?\x00speed4p-table1\x00SELECT * FROM t%d WHERE rowid = ?\x00speed4p-subselect1\x00SELECT (SELECT t FROM z1 WHERE rowid = ?1),(SELECT t FROM z2 WHERE rowid = ?1),(SELECT t FROM t3 WHERE rowid = ?1)\x00speed4p-rowid-update\x00UPDATE z1 SET i=i+1 WHERE rowid=?1\x00CREATE TABLE t5(t TEXT PRIMARY KEY, i INTEGER);\x00speed4p-insert-ignore\x00INSERT OR IGNORE INTO t5 SELECT t, i FROM z1\x00CREATE TABLE log(op TEXT, r INTEGER, i INTEGER, t TEXT);CREATE TABLE t4(rowid INTEGER PRIMARY KEY, i INTEGER, t TEXT);CREATE TRIGGER t4_trigger1 AFTER INSERT ON t4 BEGIN  INSERT INTO log VALUES('INSERT INTO t4', new.rowid, new.i, new.t);END;CREATE TRIGGER t4_trigger2 AFTER UPDATE ON t4 BEGIN  INSERT INTO log VALUES('UPDATE OF t4', new.rowid, new.i, new.t);END;CREATE TRIGGER t4_trigger3 AFTER DELETE ON t4 BEGIN  INSERT INTO log VALUES('DELETE OF t4', old.rowid, old.i, old.t);END;BEGIN;\x00speed4p-trigger1\x00INSERT INTO t4 VALUES(NULL, ?1, ?2)\x00speed4p-trigger2\x00UPDATE t4 SET i = ?1, t = ?2 WHERE rowid = ?3\x00speed4p-trigger3\x00DELETE FROM t4 WHERE rowid = ?1\x00DROP TABLE t4;DROP TABLE log;VACUUM;CREATE TABLE t4(rowid INTEGER PRIMARY KEY, i INTEGER, t TEXT);BEGIN;\x00speed4p-notrigger1\x00speed4p-notrigger2\x00speed4p-notrigger3\x00%5d %5d %5d %s\n\x00-- Compile option: %s\n\x00main\x00-- Speedtest1 for SQLite %s %.48s\n\x00UNIQUE\x00autovacuum\x00cachesize\x00missing argument on %s\n\x00exclusive\x00checkpoint\x00explain\x00heap\x00missing arguments on %s\n\x00incrvacuum\x00journal\x00key\x00lookaside\x00memdb\x00multithread\x00nomemstat\x00mmap\x00nosync\x00notnull\x00NOT NULL\x00output\x00-\x00wb\x00cannot open \"%s\" for writing\n\x00pagesize\x00pcache\x00primarykey\x00PRIMARY KEY\x00repeat\x00reprepare\x00serialized\x00singlethread\x00sqlonly\x00shrink-memory\x00size\x00stats\x00temp\x00argument to --temp should be integer between 0 and 9\x00testset\x00trace\x00threads\x00utf16le\x00utf16be\x00verify\x00reserve\x00without-rowid\x00help\x00?\x00unknown option: %s\nUse \"%s -?\" for help\n\x00surplus argument: %s\nUse \"%s -?\" for help\n\x00cannot allocate %d-byte heap\n\x00heap configuration failed: %d\n\x00cannot allocate %lld-byte pcache\n\x00pcache configuration failed: %d\n\x00:memory:\x00Cannot open database file: %s\n\x00lookaside configuration failed: %d\n\x00random\x00PRAGMA temp_store=memory\x00PRAGMA mmap_size=%d\x00PRAGMA threads=%d\x00PRAGMA key('%s')\x00PRAGMA encoding=%s\x00PRAGMA auto_vacuum=FULL\x00PRAGMA auto_vacuum=INCREMENTAL\x00PRAGMA page_size=%d\x00PRAGMA cache_size=%d\x00PRAGMA synchronous=OFF\x00PRAGMA locking_mode=EXCLUSIVE\x00PRAGMA journal_mode=%s\x00.explain\n.echo on\n\x00       Begin testset \"%s\"\n\x00debug1\x00orm\x00cte\x00fp\x00trigger\x00rtree\x00unknown testset: \"%s\"\nChoices: cte debug1 fp main orm rtree trigger\n\x00Reset the database\x00SELECT name FROM main.sqlite_master WHERE sql LIKE 'CREATE %%TABLE%%'\x00DROP TABLE main.\"%w\"\x00SELECT name FROM temp.sqlite_master WHERE sql LIKE 'CREATE %%TABLE%%'\x00PRAGMA compile_options\x00-- Lookaside Slots Used:        %d (max %d)\n\x00-- Successful lookasides:       %d\n\x00-- Lookaside size faults:       %d\n\x00-- Lookaside OOM faults:        %d\n\x00-- Pager Heap Usage:            %d bytes\n\x00-- Page cache hits:             %d\n\x00-- Page cache misses:           %d\n\x00-- Page cache writes:           %d\n\x00-- Schema Heap Usage:           %d bytes\n\x00-- Statement Heap Usage:        %d bytes\n\x00-- Memory Used (bytes):         %d (max %d)\n\x00-- Outstanding Allocations:     %d (max %d)\n\x00-- Pcache Overflow Bytes:       %d (max %d)\n\x00-- Largest Allocation:          %d bytes\n\x00-- Largest Pcache Allocation:   %d bytes\n\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
