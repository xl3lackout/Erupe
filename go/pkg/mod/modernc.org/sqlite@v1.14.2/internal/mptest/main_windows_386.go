// Code generated by 'ccgo -o internal/mptest/main_windows_386.go -trace-translation-units testdata/sqlite-src-3330000/mptest/mptest.c -Itestdata/sqlite-amalgamation-3330000 -l modernc.org/sqlite/lib -DNDEBUG -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_CORE -DSQLITE_ENABLE_COLUMN_METADATA -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_GEOPOLY -DSQLITE_ENABLE_JSON1 -DSQLITE_ENABLE_MEMORY_MANAGEMENT -DSQLITE_ENABLE_OFFSET_SQL_FUNC -DSQLITE_ENABLE_PREUPDATE_HOOK -DSQLITE_ENABLE_RBU -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_SNAPSHOT -DSQLITE_ENABLE_STAT4 -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_MUTEX_NOOP -DSQLITE_SOUNDEX -DSQLITE_THREADSAFE=1 -DSQLITE_OS_WIN=1 -D_MSC_VER=1900', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/sqlite/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer

func main() { libc.Start(main1) }

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

const ( /* memoryapi.h:18:3: */
	LowMemoryResourceNotification  = 0
	HighMemoryResourceNotification = 1
)

const ( /* minwinbase.h:100:3: */
	FindExSearchNameMatch          = 0
	FindExSearchLimitToDirectories = 1
	FindExSearchLimitToDevices     = 2
	FindExSearchMaxSearchOp        = 3
)

const ( /* minwinbase.h:107:3: */
	GetFileExInfoStandard = 0
	GetFileExMaxInfoLevel = 1
)

const ( /* minwinbase.h:91:3: */
	FindExInfoStandard     = 0
	FindExInfoBasic        = 1
	FindExInfoMaxInfoLevel = 2
)

const ( /* sysinfoapi.h:70:3: */
	ComputerNameNetBIOS                   = 0
	ComputerNameDnsHostname               = 1
	ComputerNameDnsDomain                 = 2
	ComputerNameDnsFullyQualified         = 3
	ComputerNamePhysicalNetBIOS           = 4
	ComputerNamePhysicalDnsHostname       = 5
	ComputerNamePhysicalDnsDomain         = 6
	ComputerNamePhysicalDnsFullyQualified = 7
	ComputerNameMax                       = 8
)

// TODO: Add RTL_UMS... to winnt.h header and add UMS-base API.

const ( /* winbase.h:1191:3: */
	ThreadMemoryPriority      = 0
	ThreadAbsoluteCpuPriority = 1
	ThreadInformationClassMax = 2
)

const ( /* winbase.h:1197:3: */
	ProcessMemoryPriority      = 0
	ProcessInformationClassMax = 1
)

const ( /* winbase.h:1298:3: */
	DEPPolicyAlwaysOff  = 0
	DEPPolicyAlwaysOn   = 1
	DEPPolicyOptIn      = 2
	DEPPolicyOptOut     = 3
	DEPTotalPolicyCount = 4
)

const ( /* winbase.h:2147:3: */
	FindStreamInfoStandard     = 0
	FindStreamInfoMaxInfoLevel = 1
)

const ( /* winnls.h:720:3: */
	COMPARE_STRING = 1
)

const ( /* winnls.h:756:3: */
	GEO_NATION            = 1
	GEO_LATITUDE          = 2
	GEO_LONGITUDE         = 3
	GEO_ISO2              = 4
	GEO_ISO3              = 5
	GEO_RFC1766           = 6
	GEO_LCID              = 7
	GEO_FRIENDLYNAME      = 8
	GEO_OFFICIALNAME      = 9
	GEO_TIMEZONES         = 10
	GEO_OFFICIALLANGUAGES = 11
	GEO_ISO_UN_NUMBER     = 12
	GEO_PARENT            = 13
)

const ( /* winnls.h:772:3: */
	GEOCLASS_NATION = 16
	GEOCLASS_REGION = 14
	GEOCLASS_ALL    = 0
)

const ( /* winnt.h:2945:5: */
	SidTypeUser           = 1
	SidTypeGroup          = 2
	SidTypeDomain         = 3
	SidTypeAlias          = 4
	SidTypeWellKnownGroup = 5
	SidTypeDeletedAccount = 6
	SidTypeInvalid        = 7
	SidTypeUnknown        = 8
	SidTypeComputer       = 9
	SidTypeLabel          = 10
	SidTypeLogonSession   = 11
)

const ( /* winnt.h:3184:5: */
	WinNullSid                                    = 0
	WinWorldSid                                   = 1
	WinLocalSid                                   = 2
	WinCreatorOwnerSid                            = 3
	WinCreatorGroupSid                            = 4
	WinCreatorOwnerServerSid                      = 5
	WinCreatorGroupServerSid                      = 6
	WinNtAuthoritySid                             = 7
	WinDialupSid                                  = 8
	WinNetworkSid                                 = 9
	WinBatchSid                                   = 10
	WinInteractiveSid                             = 11
	WinServiceSid                                 = 12
	WinAnonymousSid                               = 13
	WinProxySid                                   = 14
	WinEnterpriseControllersSid                   = 15
	WinSelfSid                                    = 16
	WinAuthenticatedUserSid                       = 17
	WinRestrictedCodeSid                          = 18
	WinTerminalServerSid                          = 19
	WinRemoteLogonIdSid                           = 20
	WinLogonIdsSid                                = 21
	WinLocalSystemSid                             = 22
	WinLocalServiceSid                            = 23
	WinNetworkServiceSid                          = 24
	WinBuiltinDomainSid                           = 25
	WinBuiltinAdministratorsSid                   = 26
	WinBuiltinUsersSid                            = 27
	WinBuiltinGuestsSid                           = 28
	WinBuiltinPowerUsersSid                       = 29
	WinBuiltinAccountOperatorsSid                 = 30
	WinBuiltinSystemOperatorsSid                  = 31
	WinBuiltinPrintOperatorsSid                   = 32
	WinBuiltinBackupOperatorsSid                  = 33
	WinBuiltinReplicatorSid                       = 34
	WinBuiltinPreWindows2000CompatibleAccessSid   = 35
	WinBuiltinRemoteDesktopUsersSid               = 36
	WinBuiltinNetworkConfigurationOperatorsSid    = 37
	WinAccountAdministratorSid                    = 38
	WinAccountGuestSid                            = 39
	WinAccountKrbtgtSid                           = 40
	WinAccountDomainAdminsSid                     = 41
	WinAccountDomainUsersSid                      = 42
	WinAccountDomainGuestsSid                     = 43
	WinAccountComputersSid                        = 44
	WinAccountControllersSid                      = 45
	WinAccountCertAdminsSid                       = 46
	WinAccountSchemaAdminsSid                     = 47
	WinAccountEnterpriseAdminsSid                 = 48
	WinAccountPolicyAdminsSid                     = 49
	WinAccountRasAndIasServersSid                 = 50
	WinNTLMAuthenticationSid                      = 51
	WinDigestAuthenticationSid                    = 52
	WinSChannelAuthenticationSid                  = 53
	WinThisOrganizationSid                        = 54
	WinOtherOrganizationSid                       = 55
	WinBuiltinIncomingForestTrustBuildersSid      = 56
	WinBuiltinPerfMonitoringUsersSid              = 57
	WinBuiltinPerfLoggingUsersSid                 = 58
	WinBuiltinAuthorizationAccessSid              = 59
	WinBuiltinTerminalServerLicenseServersSid     = 60
	WinBuiltinDCOMUsersSid                        = 61
	WinBuiltinIUsersSid                           = 62
	WinIUserSid                                   = 63
	WinBuiltinCryptoOperatorsSid                  = 64
	WinUntrustedLabelSid                          = 65
	WinLowLabelSid                                = 66
	WinMediumLabelSid                             = 67
	WinHighLabelSid                               = 68
	WinSystemLabelSid                             = 69
	WinWriteRestrictedCodeSid                     = 70
	WinCreatorOwnerRightsSid                      = 71
	WinCacheablePrincipalsGroupSid                = 72
	WinNonCacheablePrincipalsGroupSid             = 73
	WinEnterpriseReadonlyControllersSid           = 74
	WinAccountReadonlyControllersSid              = 75
	WinBuiltinEventLogReadersGroup                = 76
	WinNewEnterpriseReadonlyControllersSid        = 77
	WinBuiltinCertSvcDComAccessGroup              = 78
	WinMediumPlusLabelSid                         = 79
	WinLocalLogonSid                              = 80
	WinConsoleLogonSid                            = 81
	WinThisOrganizationCertificateSid             = 82
	WinApplicationPackageAuthoritySid             = 83
	WinBuiltinAnyPackageSid                       = 84
	WinCapabilityInternetClientSid                = 85
	WinCapabilityInternetClientServerSid          = 86
	WinCapabilityPrivateNetworkClientServerSid    = 87
	WinCapabilityPicturesLibrarySid               = 88
	WinCapabilityVideosLibrarySid                 = 89
	WinCapabilityMusicLibrarySid                  = 90
	WinCapabilityDocumentsLibrarySid              = 91
	WinCapabilitySharedUserCertificatesSid        = 92
	WinCapabilityEnterpriseAuthenticationSid      = 93
	WinCapabilityRemovableStorageSid              = 94
	WinBuiltinRDSRemoteAccessServersSid           = 95
	WinBuiltinRDSEndpointServersSid               = 96
	WinBuiltinRDSManagementServersSid             = 97
	WinUserModeDriversSid                         = 98
	WinBuiltinHyperVAdminsSid                     = 99
	WinAccountCloneableControllersSid             = 100
	WinBuiltinAccessControlAssistanceOperatorsSid = 101
	WinBuiltinRemoteManagementUsersSid            = 102
	WinAuthenticationAuthorityAssertedSid         = 103
	WinAuthenticationServiceAssertedSid           = 104
	WinLocalAccountSid                            = 105
	WinLocalAccountAndAdministratorSid            = 106
	WinAccountProtectedUsersSid                   = 107
	WinCapabilityAppointmentsSid                  = 108
	WinCapabilityContactsSid                      = 109
	WinAccountDefaultSystemManagedSid             = 110
	WinBuiltinDefaultSystemManagedGroupSid        = 111
	WinBuiltinStorageReplicaAdminsSid             = 112
	WinAccountKeyAdminsSid                        = 113
	WinAccountEnterpriseKeyAdminsSid              = 114
	WinAuthenticationKeyTrustSid                  = 115
	WinAuthenticationKeyPropertyMFASid            = 116
	WinAuthenticationKeyPropertyAttestationSid    = 117
)

const ( /* winnt.h:3495:5: */
	AclRevisionInformation = 1
	AclSizeInformation     = 2
)

const ( /* winnt.h:3565:5: */
	AuditEventObjectAccess           = 0
	AuditEventDirectoryServiceAccess = 1
)

const ( /* winnt.h:3597:5: */
	AccessReasonNone                     = 0
	AccessReasonAllowedAce               = 65536
	AccessReasonDeniedAce                = 131072
	AccessReasonAllowedParentAce         = 196608
	AccessReasonDeniedParentAce          = 262144
	AccessReasonNotGrantedByCape         = 327680
	AccessReasonNotGrantedByParentCape   = 393216
	AccessReasonNotGrantedToAppContainer = 458752
	AccessReasonMissingPrivilege         = 1048576
	AccessReasonFromPrivilege            = 2097152
	AccessReasonIntegrityLevel           = 3145728
	AccessReasonOwnership                = 4194304
	AccessReasonNullDacl                 = 5242880
	AccessReasonEmptyDacl                = 6291456
	AccessReasonNoSD                     = 7340032
	AccessReasonNoGrant                  = 8388608
)

const ( /* winnt.h:3687:5: */
	SecurityAnonymous      = 0
	SecurityIdentification = 1
	SecurityImpersonation  = 2
	SecurityDelegation     = 3
)

const ( /* winnt.h:3714:5: */
	TokenPrimary       = 1
	TokenImpersonation = 2
)

const ( /* winnt.h:3719:5: */
	TokenElevationTypeDefault = 1
	TokenElevationTypeFull    = 2
	TokenElevationTypeLimited = 3
)

const ( /* winnt.h:3725:5: */
	TokenUser                            = 1
	TokenGroups                          = 2
	TokenPrivileges                      = 3
	TokenOwner                           = 4
	TokenPrimaryGroup                    = 5
	TokenDefaultDacl                     = 6
	TokenSource                          = 7
	TokenType                            = 8
	TokenImpersonationLevel              = 9
	TokenStatistics                      = 10
	TokenRestrictedSids                  = 11
	TokenSessionId                       = 12
	TokenGroupsAndPrivileges             = 13
	TokenSessionReference                = 14
	TokenSandBoxInert                    = 15
	TokenAuditPolicy                     = 16
	TokenOrigin                          = 17
	TokenElevationType                   = 18
	TokenLinkedToken                     = 19
	TokenElevation                       = 20
	TokenHasRestrictions                 = 21
	TokenAccessInformation               = 22
	TokenVirtualizationAllowed           = 23
	TokenVirtualizationEnabled           = 24
	TokenIntegrityLevel                  = 25
	TokenUIAccess                        = 26
	TokenMandatoryPolicy                 = 27
	TokenLogonSid                        = 28
	TokenIsAppContainer                  = 29
	TokenCapabilities                    = 30
	TokenAppContainerSid                 = 31
	TokenAppContainerNumber              = 32
	TokenUserClaimAttributes             = 33
	TokenDeviceClaimAttributes           = 34
	TokenRestrictedUserClaimAttributes   = 35
	TokenRestrictedDeviceClaimAttributes = 36
	TokenDeviceGroups                    = 37
	TokenRestrictedDeviceGroups          = 38
	TokenSecurityAttributes              = 39
	TokenIsRestricted                    = 40
	MaxTokenInfoClass                    = 41
)

const ( /* winnt.h:3893:5: */
	MandatoryLevelUntrusted     = 0
	MandatoryLevelLow           = 1
	MandatoryLevelMedium        = 2
	MandatoryLevelHigh          = 3
	MandatoryLevelSystem        = 4
	MandatoryLevelSecureProcess = 5
	MandatoryLevelCount         = 6
)

const ( /* winnt.h:4019:5: */
	SeLearningModeInvalidType = 0
	SeLearningModeSettings    = 1
	SeLearningModeMax         = 2
)

const ( /* winnt.h:4223:5: */
	PMCCounter             = 0
	MaxHardwareCounterType = 1
)

const ( /* winnt.h:4228:5: */
	ProcessDEPPolicy                   = 0
	ProcessASLRPolicy                  = 1
	ProcessDynamicCodePolicy           = 2
	ProcessStrictHandleCheckPolicy     = 3
	ProcessSystemCallDisablePolicy     = 4
	ProcessMitigationOptionsMask       = 5
	ProcessExtensionPointDisablePolicy = 6
	ProcessControlFlowGuardPolicy      = 7
	ProcessSignaturePolicy             = 8
	ProcessFontDisablePolicy           = 9
	ProcessImageLoadPolicy             = 10
	MaxProcessMitigationPolicy         = 11
)

const ( /* winnt.h:4426:5: */
	ToleranceLow    = 1
	ToleranceMedium = 2
	ToleranceHigh   = 3
)

const ( /* winnt.h:4432:5: */
	ToleranceIntervalShort  = 1
	ToleranceIntervalMedium = 2
	ToleranceIntervalLong   = 3
)

const ( /* winnt.h:4551:5: */
	JobObjectBasicAccountingInformation         = 1
	JobObjectBasicLimitInformation              = 2
	JobObjectBasicProcessIdList                 = 3
	JobObjectBasicUIRestrictions                = 4
	JobObjectSecurityLimitInformation           = 5
	JobObjectEndOfJobTimeInformation            = 6
	JobObjectAssociateCompletionPortInformation = 7
	JobObjectBasicAndIoAccountingInformation    = 8
	JobObjectExtendedLimitInformation           = 9
	JobObjectJobSetInformation                  = 10
	JobObjectGroupInformation                   = 11
	JobObjectNotificationLimitInformation       = 12
	JobObjectLimitViolationInformation          = 13
	JobObjectGroupInformationEx                 = 14
	JobObjectCpuRateControlInformation          = 15
	JobObjectCompletionFilter                   = 16
	JobObjectCompletionCounter                  = 17
	JobObjectReserved1Information               = 18
	JobObjectReserved2Information               = 19
	JobObjectReserved3Information               = 20
	JobObjectReserved4Information               = 21
	JobObjectReserved5Information               = 22
	JobObjectReserved6Information               = 23
	JobObjectReserved7Information               = 24
	JobObjectReserved8Information               = 25
	MaxJobObjectInfoClass                       = 26
)

const ( /* winnt.h:4575:5: */
	FirmwareTypeUnknown = 0
	FirmwareTypeBios    = 1
	FirmwareTypeUefi    = 2
	FirmwareTypeMax     = 3
)

const ( /* winnt.h:4600:5: */
	RelationProcessorCore    = 0
	RelationNumaNode         = 1
	RelationCache            = 2
	RelationProcessorPackage = 3
	RelationGroup            = 4
	RelationAll              = 65535
)

const ( /* winnt.h:4607:5: */
	CacheUnified     = 0
	CacheInstruction = 1
	CacheData        = 2
	CacheTrace       = 3
)

const ( /* winnt.h:467:1: */
	UNSPECIFIED_COMPARTMENT_ID = 0
	DEFAULT_COMPARTMENT_ID     = 1
)

const ( /* winnt.h:5229:3: */
	PowerSystemUnspecified = 0
	PowerSystemWorking     = 1
	PowerSystemSleeping1   = 2
	PowerSystemSleeping2   = 3
	PowerSystemSleeping3   = 4
	PowerSystemHibernate   = 5
	PowerSystemShutdown    = 6
	PowerSystemMaximum     = 7
)

const ( /* winnt.h:5235:3: */
	PowerActionNone          = 0
	PowerActionReserved      = 1
	PowerActionSleep         = 2
	PowerActionHibernate     = 3
	PowerActionShutdown      = 4
	PowerActionShutdownReset = 5
	PowerActionShutdownOff   = 6
	PowerActionWarmEject     = 7
)

const ( /* winnt.h:5241:3: */
	PowerDeviceUnspecified = 0
	PowerDeviceD0          = 1
	PowerDeviceD1          = 2
	PowerDeviceD2          = 3
	PowerDeviceD3          = 4
	PowerDeviceMaximum     = 5
)

const ( /* winnt.h:5246:3: */
	PowerMonitorOff = 0
	PowerMonitorOn  = 1
	PowerMonitorDim = 2
)

const ( /* winnt.h:5250:3: */
	PowerUserPresent    = 0
	PowerUserNotPresent = 1
	PowerUserInactive   = 2
	PowerUserMaximum    = 3
	PowerUserInvalid    = 3
)

const ( /* winnt.h:5266:3: */
	LT_DONT_CARE      = 0
	LT_LOWEST_LATENCY = 1
)

const ( /* winnt.h:5281:3: */
	PowerRequestDisplayRequired   = 0
	PowerRequestSystemRequired    = 1
	PowerRequestAwayModeRequired  = 2
	PowerRequestExecutionRequired = 3
)

const ( /* winnt.h:5309:5: */
	SystemPowerPolicyAc                = 0
	SystemPowerPolicyDc                = 1
	VerifySystemPolicyAc               = 2
	VerifySystemPolicyDc               = 3
	SystemPowerCapabilities            = 4
	SystemBatteryState                 = 5
	SystemPowerStateHandler            = 6
	ProcessorStateHandler              = 7
	SystemPowerPolicyCurrent           = 8
	AdministratorPowerPolicy           = 9
	SystemReserveHiberFile             = 10
	ProcessorInformation               = 11
	SystemPowerInformation             = 12
	ProcessorStateHandler2             = 13
	LastWakeTime                       = 14
	LastSleepTime                      = 15
	SystemExecutionState               = 16
	SystemPowerStateNotifyHandler      = 17
	ProcessorPowerPolicyAc             = 18
	ProcessorPowerPolicyDc             = 19
	VerifyProcessorPowerPolicyAc       = 20
	VerifyProcessorPowerPolicyDc       = 21
	ProcessorPowerPolicyCurrent        = 22
	SystemPowerStateLogging            = 23
	SystemPowerLoggingEntry            = 24
	SetPowerSettingValue               = 25
	NotifyUserPowerSetting             = 26
	PowerInformationLevelUnused0       = 27
	SystemMonitorHiberBootPowerOff     = 28
	SystemVideoState                   = 29
	TraceApplicationPowerMessage       = 30
	TraceApplicationPowerMessageEnd    = 31
	ProcessorPerfStates                = 32
	ProcessorIdleStates                = 33
	ProcessorCap                       = 34
	SystemWakeSource                   = 35
	SystemHiberFileInformation         = 36
	TraceServicePowerMessage           = 37
	ProcessorLoad                      = 38
	PowerShutdownNotification          = 39
	MonitorCapabilities                = 40
	SessionPowerInit                   = 41
	SessionDisplayState                = 42
	PowerRequestCreate                 = 43
	PowerRequestAction                 = 44
	GetPowerRequestList                = 45
	ProcessorInformationEx             = 46
	NotifyUserModeLegacyPowerEvent     = 47
	GroupPark                          = 48
	ProcessorIdleDomains               = 49
	WakeTimerList                      = 50
	SystemHiberFileSize                = 51
	ProcessorIdleStatesHv              = 52
	ProcessorPerfStatesHv              = 53
	ProcessorPerfCapHv                 = 54
	ProcessorSetIdle                   = 55
	LogicalProcessorIdling             = 56
	UserPresence                       = 57
	PowerSettingNotificationName       = 58
	GetPowerSettingValue               = 59
	IdleResiliency                     = 60
	SessionRITState                    = 61
	SessionConnectNotification         = 62
	SessionPowerCleanup                = 63
	SessionLockState                   = 64
	SystemHiberbootState               = 65
	PlatformInformation                = 66
	PdcInvocation                      = 67
	MonitorInvocation                  = 68
	FirmwareTableInformationRegistered = 69
	SetShutdownSelectedTime            = 70
	SuspendResumeInvocation            = 71
	PlmPowerRequestCreate              = 72
	ScreenOff                          = 73
	CsDeviceNotification               = 74
	PlatformRole                       = 75
	LastResumePerformance              = 76
	DisplayBurst                       = 77
	ExitLatencySamplingPercentage      = 78
	ApplyLowPowerScenarioSettings      = 79
	PowerInformationLevelMaximum       = 80
)

const ( /* winnt.h:5393:5: */
	UserNotPresent = 0
	UserPresent    = 1
	UserUnknown    = 255
)

const ( /* winnt.h:5429:5: */
	MonitorRequestReasonUnknown                 = 0
	MonitorRequestReasonPowerButton             = 1
	MonitorRequestReasonRemoteConnection        = 2
	MonitorRequestReasonScMonitorpower          = 3
	MonitorRequestReasonUserInput               = 4
	MonitorRequestReasonAcDcDisplayBurst        = 5
	MonitorRequestReasonUserDisplayBurst        = 6
	MonitorRequestReasonPoSetSystemState        = 7
	MonitorRequestReasonSetThreadExecutionState = 8
	MonitorRequestReasonFullWake                = 9
	MonitorRequestReasonSessionUnlock           = 10
	MonitorRequestReasonScreenOffRequest        = 11
	MonitorRequestReasonIdleTimeout             = 12
	MonitorRequestReasonPolicyChange            = 13
	MonitorRequestReasonMax                     = 14
)

const ( /* winnt.h:5459:5: */
	PoAc               = 0
	PoDc               = 1
	PoHot              = 2
	PoConditionMaximum = 3
)

const ( /* winnt.h:5486:5: */
	PlatformRoleUnspecified       = 0
	PlatformRoleDesktop           = 1
	PlatformRoleMobile            = 2
	PlatformRoleWorkstation       = 3
	PlatformRoleEnterpriseServer  = 4
	PlatformRoleSOHOServer        = 5
	PlatformRoleAppliancePC       = 6
	PlatformRolePerformanceServer = 7
	PlatformRoleSlate             = 8
	PlatformRoleMaximum           = 9
)

const ( /* winnt.h:6623:5: */
	IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1
)

const ( /* winnt.h:7494:5: */
	IMPORT_OBJECT_CODE  = 0
	IMPORT_OBJECT_DATA  = 1
	IMPORT_OBJECT_CONST = 2
)

const ( /* winnt.h:7498:5: */
	IMPORT_OBJECT_ORDINAL         = 0
	IMPORT_OBJECT_NAME            = 1
	IMPORT_OBJECT_NAME_NO_PREFIX  = 2
	IMPORT_OBJECT_NAME_UNDECORATE = 3
)

const ( /* winnt.h:7504:5: */
	COMIMAGE_FLAGS_ILONLY                = 1
	COMIMAGE_FLAGS_32BITREQUIRED         = 2
	COMIMAGE_FLAGS_IL_LIBRARY            = 4
	COMIMAGE_FLAGS_STRONGNAMESIGNED      = 8
	COMIMAGE_FLAGS_TRACKDEBUGDATA        = 65536
	COR_VERSION_MAJOR_V2                 = 2
	COR_VERSION_MAJOR                    = 2
	COR_VERSION_MINOR                    = 0
	COR_DELETED_NAME_LENGTH              = 8
	COR_VTABLEGAP_NAME_LENGTH            = 8
	NATIVE_TYPE_MAX_CB                   = 1
	COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255
	IMAGE_COR_MIH_METHODRVA              = 1
	IMAGE_COR_MIH_EHRVA                  = 2
	IMAGE_COR_MIH_BASICBLOCK             = 8
	COR_VTABLE_32BIT                     = 1
	COR_VTABLE_64BIT                     = 2
	COR_VTABLE_FROM_UNMANAGED            = 4
	COR_VTABLE_CALL_MOST_DERIVED         = 16
	IMAGE_COR_EATJ_THUNK_SIZE            = 32
	MAX_CLASS_NAME                       = 1024
	MAX_PACKAGE_NAME                     = 1024
)

const ( /* winnt.h:7909:5: */
	UmsThreadInvalidInfoClass = 0
	UmsThreadUserContext      = 1
	UmsThreadPriority         = 2
	UmsThreadAffinity         = 3
	UmsThreadTeb              = 4
	UmsThreadIsSuspended      = 5
	UmsThreadIsTerminated     = 6
	UmsThreadMaxInfoClass     = 7
)

const ( /* winnt.h:7920:5: */
	UmsSchedulerStartup       = 0
	UmsSchedulerThreadBlocked = 1
	UmsSchedulerThreadYield   = 2
)

const ( /* winnt.h:7995:5: */
	HeapCompatibilityInformation      = 0
	HeapEnableTerminationOnCorruption = 1
)

const ( /* winnt.h:8023:5: */
	ActivationContextBasicInformation                      = 1
	ActivationContextDetailedInformation                   = 2
	AssemblyDetailedInformationInActivationContext         = 3
	FileInformationInAssemblyOfAssemblyInActivationContext = 4
	RunlevelInformationInActivationContext                 = 5
	CompatibilityInformationInActivationContext            = 6
	ActivationContextManifestResourceName                  = 7
	MaxActivationContextInfoClass                          = 8
	AssemblyDetailedInformationInActivationContxt          = 3
	FileInformationInAssemblyOfAssemblyInActivationContxt  = 4
)

const ( /* winnt.h:8036:5: */
	ACTCTX_RUN_LEVEL_UNSPECIFIED       = 0
	ACTCTX_RUN_LEVEL_AS_INVOKER        = 1
	ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2
	ACTCTX_RUN_LEVEL_REQUIRE_ADMIN     = 3
	ACTCTX_RUN_LEVEL_NUMBERS           = 4
)

const ( /* winnt.h:8044:5: */
	ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN    = 0
	ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS         = 1
	ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2
)

const ( /* winnt.h:8465:5: */
	DriverType               = 1
	FileSystemType           = 2
	Win32ServiceOwnProcess   = 16
	Win32ServiceShareProcess = 32
	AdapterType              = 4
	RecognizerType           = 8
)

const ( /* winnt.h:8470:5: */
	BootLoad    = 0
	SystemLoad  = 1
	AutoLoad    = 2
	DemandLoad  = 3
	DisableLoad = 4
)

const ( /* winnt.h:8475:5: */
	IgnoreError   = 0
	NormalError   = 1
	SevereError   = 2
	CriticalError = 3
)

const ( /* winnt.h:8675:5: */
	TapeDriveProblemNone         = 0
	TapeDriveReadWriteWarning    = 1
	TapeDriveReadWriteError      = 2
	TapeDriveReadWarning         = 3
	TapeDriveWriteWarning        = 4
	TapeDriveReadError           = 5
	TapeDriveWriteError          = 6
	TapeDriveHardwareError       = 7
	TapeDriveUnsupportedMedia    = 8
	TapeDriveScsiConnectionError = 9
	TapeDriveTimetoClean         = 10
	TapeDriveCleanDriveNow       = 11
	TapeDriveMediaLifeExpired    = 12
	TapeDriveSnappedTape         = 13
)

const ( /* winnt.h:8685:3: */
	TP_CALLBACK_PRIORITY_HIGH    = 0
	TP_CALLBACK_PRIORITY_NORMAL  = 1
	TP_CALLBACK_PRIORITY_LOW     = 2
	TP_CALLBACK_PRIORITY_INVALID = 3
	TP_CALLBACK_PRIORITY_COUNT   = 3
)

const ( /* winnt.h:8878:7: */
	TransactionOutcomeUndetermined = 1
	TransactionOutcomeCommitted    = 2
	TransactionOutcomeAborted      = 3
)

const ( /* winnt.h:8884:7: */
	TransactionStateNormal          = 1
	TransactionStateIndoubt         = 2
	TransactionStateCommittedNotify = 3
)

const ( /* winnt.h:8956:7: */
	TransactionBasicInformation              = 0
	TransactionPropertiesInformation         = 1
	TransactionEnlistmentInformation         = 2
	TransactionSuperiorEnlistmentInformation = 3
	TransactionBindInformation               = 4
	TransactionDTCPrivateInformation         = 5
)

const ( /* winnt.h:8965:7: */
	TransactionManagerBasicInformation             = 0
	TransactionManagerLogInformation               = 1
	TransactionManagerLogPathInformation           = 2
	TransactionManagerOnlineProbeInformation       = 3
	TransactionManagerRecoveryInformation          = 4
	TransactionManagerOldestTransactionInformation = 5
)

const ( /* winnt.h:8974:7: */
	ResourceManagerBasicInformation      = 0
	ResourceManagerCompletionInformation = 1
)

const ( /* winnt.h:8991:7: */
	EnlistmentBasicInformation    = 0
	EnlistmentRecoveryInformation = 1
	EnlistmentCrmInformation      = 2
)

const ( /* winnt.h:9006:7: */
	KTMOBJECT_TRANSACTION         = 0
	KTMOBJECT_TRANSACTION_MANAGER = 1
	KTMOBJECT_RESOURCE_MANAGER    = 2
	KTMOBJECT_ENLISTMENT          = 3
	KTMOBJECT_INVALID             = 4
)

const ( /* winsvc.h:106:3: */
	SC_ACTION_NONE        = 0
	SC_ACTION_RESTART     = 1
	SC_ACTION_REBOOT      = 2
	SC_ACTION_RUN_COMMAND = 3
)

const ( /* winsvc.h:139:3: */
	SC_STATUS_PROCESS_INFO = 0
)

const ( /* winsvc.h:143:3: */
	SC_ENUM_PROCESS_INFO = 0
)

type ptrdiff_t = int32 /* <builtin>:3:26 */

type size_t = uint32 /* <builtin>:9:23 */

type wchar_t = uint16 /* <builtin>:15:24 */

type va_list = uintptr /* <builtin>:51:27 */

// CAPI3REF: 64-Bit Integer Types
// KEYWORDS: sqlite_int64 sqlite_uint64
//
// Because there is no cross-platform way to specify 64-bit integer types
// SQLite includes typedefs for 64-bit signed and unsigned integers.
//
// The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.
// The sqlite_int64 and sqlite_uint64 types are supported for backwards
// compatibility only.
//
// ^The sqlite3_int64 and sqlite_int64 types can store integer values
// between -9223372036854775808 and +9223372036854775807 inclusive.  ^The
// sqlite3_uint64 and sqlite_uint64 types can store integer values
// between 0 and +18446744073709551615 inclusive.
type sqlite_int64 = int64           /* sqlite3.h:275:19 */
type sqlite_uint64 = uint64         /* sqlite3.h:276:28 */
type sqlite3_int64 = sqlite_int64   /* sqlite3.h:281:22 */
type sqlite3_uint64 = sqlite_uint64 /* sqlite3.h:282:23 */

// The type for a callback function.
// This is legacy and deprecated.  It is included for historical
// compatibility and is not documented.
type sqlite3_callback = uintptr /* sqlite3.h:338:13 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file1 = struct{ pMethods uintptr } /* sqlite3.h:683:9 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file = sqlite3_file1 /* sqlite3.h:683:29 */
type sqlite3_io_methods1 = struct {
	iVersion               int32
	xClose                 uintptr
	xRead                  uintptr
	xWrite                 uintptr
	xTruncate              uintptr
	xSync                  uintptr
	xFileSize              uintptr
	xLock                  uintptr
	xUnlock                uintptr
	xCheckReservedLock     uintptr
	xFileControl           uintptr
	xSectorSize            uintptr
	xDeviceCharacteristics uintptr
	xShmMap                uintptr
	xShmLock               uintptr
	xShmBarrier            uintptr
	xShmUnmap              uintptr
	xFetch                 uintptr
	xUnfetch               uintptr
} /* sqlite3.h:683:9 */

// CAPI3REF: OS Interface File Virtual Methods Object
//
// Every file opened by the [sqlite3_vfs.xOpen] method populates an
// [sqlite3_file] object (or, more commonly, a subclass of the
// [sqlite3_file] object) with a pointer to an instance of this object.
// This object defines the methods used to perform various operations
// against the open file represented by the [sqlite3_file] object.
//
// If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element
// to a non-NULL pointer, then the sqlite3_io_methods.xClose method
// may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The
// only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]
// is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element
// to NULL.
//
// The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or
// [SQLITE_SYNC_FULL].  The first choice is the normal fsync().
// The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]
// flag may be ORed in to indicate that only the data of the file
// and not its inode needs to be synced.
//
// The integer values to xLock() and xUnlock() are one of
// <ul>
// <li> [SQLITE_LOCK_NONE],
// <li> [SQLITE_LOCK_SHARED],
// <li> [SQLITE_LOCK_RESERVED],
// <li> [SQLITE_LOCK_PENDING], or
// <li> [SQLITE_LOCK_EXCLUSIVE].
// </ul>
// xLock() increases the lock. xUnlock() decreases the lock.
// The xCheckReservedLock() method checks whether any database connection,
// either in this process or in some other process, is holding a RESERVED,
// PENDING, or EXCLUSIVE lock on the file.  It returns true
// if such a lock exists and false otherwise.
//
// The xFileControl() method is a generic interface that allows custom
// VFS implementations to directly control an open file using the
// [sqlite3_file_control()] interface.  The second "op" argument is an
// integer opcode.  The third argument is a generic pointer intended to
// point to a structure that may contain arguments or space in which to
// write return values.  Potential uses for xFileControl() might be
// functions to enable blocking locks with timeouts, to change the
// locking strategy (for example to use dot-file locks), to inquire
// about the status of a lock, or to break stale locks.  The SQLite
// core reserves all opcodes less than 100 for its own use.
// A [file control opcodes | list of opcodes] less than 100 is available.
// Applications that define a custom xFileControl method should use opcodes
// greater than 100 to avoid conflicts.  VFS implementations should
// return [SQLITE_NOTFOUND] for file control opcodes that they do not
// recognize.
//
// The xSectorSize() method returns the sector size of the
// device that underlies the file.  The sector size is the
// minimum write that can be performed without disturbing
// other bytes in the file.  The xDeviceCharacteristics()
// method returns a bit vector describing behaviors of the
// underlying device:
//
// <ul>
// <li> [SQLITE_IOCAP_ATOMIC]
// <li> [SQLITE_IOCAP_ATOMIC512]
// <li> [SQLITE_IOCAP_ATOMIC1K]
// <li> [SQLITE_IOCAP_ATOMIC2K]
// <li> [SQLITE_IOCAP_ATOMIC4K]
// <li> [SQLITE_IOCAP_ATOMIC8K]
// <li> [SQLITE_IOCAP_ATOMIC16K]
// <li> [SQLITE_IOCAP_ATOMIC32K]
// <li> [SQLITE_IOCAP_ATOMIC64K]
// <li> [SQLITE_IOCAP_SAFE_APPEND]
// <li> [SQLITE_IOCAP_SEQUENTIAL]
// <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]
// <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]
// <li> [SQLITE_IOCAP_IMMUTABLE]
// <li> [SQLITE_IOCAP_BATCH_ATOMIC]
// </ul>
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().
//
// If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
// in the unread portions of the buffer with zeros.  A VFS that
// fails to zero-fill short reads might seem to work.  However,
// failure to zero-fill short reads will eventually lead to
// database corruption.
type sqlite3_io_methods = sqlite3_io_methods1 /* sqlite3.h:782:35 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs1 = struct {
	iVersion          int32
	szOsFile          int32
	mxPathname        int32
	pNext             uintptr
	zName             uintptr
	pAppData          uintptr
	xOpen             uintptr
	xDelete           uintptr
	xAccess           uintptr
	xFullPathname     uintptr
	xDlOpen           uintptr
	xDlError          uintptr
	xDlSym            uintptr
	xDlClose          uintptr
	xRandomness       uintptr
	xSleep            uintptr
	xCurrentTime      uintptr
	xGetLastError     uintptr
	xCurrentTimeInt64 uintptr
	xSetSystemCall    uintptr
	xGetSystemCall    uintptr
	xNextSystemCall   uintptr
} /* sqlite3.h:1367:9 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs = sqlite3_vfs1    /* sqlite3.h:1367:28 */
type sqlite3_syscall_ptr = uintptr /* sqlite3.h:1368:14 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods1 = struct {
	xMalloc   uintptr
	xFree     uintptr
	xRealloc  uintptr
	xSize     uintptr
	xRoundup  uintptr
	xInit     uintptr
	xShutdown uintptr
	pAppData  uintptr
} /* sqlite3.h:1665:9 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods = sqlite3_mem_methods1 /* sqlite3.h:1665:36 */

// CAPI3REF: Constants Defining Special Destructor Behavior
//
// These are special values for the destructor that is passed in as the
// final argument to routines like [sqlite3_result_blob()].  ^If the destructor
// argument is SQLITE_STATIC, it means that the content pointer is constant
// and will never change.  It does not need to be destroyed.  ^The
// SQLITE_TRANSIENT value means that the content will likely change in
// the near future and that SQLite should make its own private copy of
// the content before returning.
//
// The typedef is necessary to work around problems in certain
// C++ compilers.
type sqlite3_destructor_type = uintptr /* sqlite3.h:5621:14 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab1 = struct {
	pModule uintptr
	nRef    int32
	zErrMsg uintptr
} /* sqlite3.h:6689:9 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab = sqlite3_vtab1 /* sqlite3.h:6689:29 */
type sqlite3_index_info1 = struct {
	nConstraint      int32
	aConstraint      uintptr
	nOrderBy         int32
	aOrderBy         uintptr
	aConstraintUsage uintptr
	idxNum           int32
	idxStr           uintptr
	needToFreeIdxStr int32
	orderByConsumed  int32
	_                [4]byte
	estimatedCost    float64
	estimatedRows    sqlite3_int64
	idxFlags         int32
	_                [4]byte
	colUsed          sqlite3_uint64
} /* sqlite3.h:6690:9 */

type sqlite3_index_info = sqlite3_index_info1       /* sqlite3.h:6690:35 */
type sqlite3_vtab_cursor1 = struct{ pVtab uintptr } /* sqlite3.h:6691:9 */

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1 /* sqlite3.h:6691:36 */
type sqlite3_module1 = struct {
	iVersion      int32
	xCreate       uintptr
	xConnect      uintptr
	xBestIndex    uintptr
	xDisconnect   uintptr
	xDestroy      uintptr
	xOpen         uintptr
	xClose        uintptr
	xFilter       uintptr
	xNext         uintptr
	xEof          uintptr
	xColumn       uintptr
	xRowid        uintptr
	xUpdate       uintptr
	xBegin        uintptr
	xSync         uintptr
	xCommit       uintptr
	xRollback     uintptr
	xFindFunction uintptr
	xRename       uintptr
	xSavepoint    uintptr
	xRelease      uintptr
	xRollbackTo   uintptr
	xShadowName   uintptr
} /* sqlite3.h:6689:9 */

type sqlite3_module = sqlite3_module1 /* sqlite3.h:6692:31 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint = struct {
	iColumn     int32
	op          uint8
	usable      uint8
	_           [2]byte
	iTermOffset int32
} /* sqlite3.h:6690:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_orderby = struct {
	iColumn int32
	desc    uint8
	_       [3]byte
} /* sqlite3.h:6690:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint_usage = struct {
	argvIndex int32
	omit      uint8
	_         [3]byte
} /* sqlite3.h:6690:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods1 = struct {
	xMutexInit    uintptr
	xMutexEnd     uintptr
	xMutexAlloc   uintptr
	xMutexFree    uintptr
	xMutexEnter   uintptr
	xMutexTry     uintptr
	xMutexLeave   uintptr
	xMutexHeld    uintptr
	xMutexNotheld uintptr
} /* sqlite3.h:7524:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods = sqlite3_mutex_methods1 /* sqlite3.h:7524:38 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page1 = struct {
	pBuf   uintptr
	pExtra uintptr
} /* sqlite3.h:8277:9 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page = sqlite3_pcache_page1 /* sqlite3.h:8277:36 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods21 = struct {
	iVersion   int32
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
	xShrink    uintptr
} /* sqlite3.h:8442:9 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods2 = sqlite3_pcache_methods21 /* sqlite3.h:8442:40 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods1 = struct {
	pArg       uintptr
	xInit      uintptr
	xShutdown  uintptr
	xCreate    uintptr
	xCachesize uintptr
	xPagecount uintptr
	xFetch     uintptr
	xUnpin     uintptr
	xRekey     uintptr
	xTruncate  uintptr
	xDestroy   uintptr
} /* sqlite3.h:8465:9 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods = sqlite3_pcache_methods1 /* sqlite3.h:8465:39 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot1 = struct{ hidden [48]uint8 } /* sqlite3.h:9512:9 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot = sqlite3_snapshot1 /* sqlite3.h:9514:3 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry1 = struct {
	pContext uintptr
	nParam   int32
	aParam   uintptr
	pUser    uintptr
	xDelUser uintptr
} /* sqlite3.h:9839:9 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1 /* sqlite3.h:9839:39 */
type sqlite3_rtree_query_info1 = struct {
	pContext      uintptr
	nParam        int32
	aParam        uintptr
	pUser         uintptr
	xDelUser      uintptr
	aCoord        uintptr
	anQueue       uintptr
	nCoord        int32
	iLevel        int32
	mxLevel       int32
	iRowid        sqlite3_int64
	rParentScore  sqlite3_rtree_dbl
	eParentWithin int32
	eWithin       int32
	rScore        sqlite3_rtree_dbl
	apSqlParam    uintptr
	_             [4]byte
} /* sqlite3.h:9840:9 */

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1 /* sqlite3.h:9840:41 */

// The double-precision datatype used by RTree depends on the
// SQLITE_RTREE_INT_ONLY compile-time option.
type sqlite3_rtree_dbl = float64 /* sqlite3.h:9848:18 */

// Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi1 = struct {
	iVersion           int32
	xUserData          uintptr
	xColumnCount       uintptr
	xRowCount          uintptr
	xColumnTotalSize   uintptr
	xTokenize          uintptr
	xPhraseCount       uintptr
	xPhraseSize        uintptr
	xInstCount         uintptr
	xInst              uintptr
	xRowid             uintptr
	xColumnText        uintptr
	xColumnSize        uintptr
	xQueryPhrase       uintptr
	xSetAuxdata        uintptr
	xGetAuxdata        uintptr
	xPhraseFirst       uintptr
	xPhraseNext        uintptr
	xPhraseFirstColumn uintptr
	xPhraseNextColumn  uintptr
} /* sqlite3.h:11634:9 */

// Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi = Fts5ExtensionApi1 /* sqlite3.h:11634:33 */
type Fts5PhraseIter1 = struct {
	a uintptr
	b uintptr
} /* sqlite3.h:11636:9 */

type Fts5PhraseIter = Fts5PhraseIter1 /* sqlite3.h:11636:31 */

type fts5_extension_function = uintptr /* sqlite3.h:11638:14 */
type fts5_tokenizer1 = struct {
	xCreate   uintptr
	xDelete   uintptr
	xTokenize uintptr
} /* sqlite3.h:12097:9 */

type fts5_tokenizer = fts5_tokenizer1 /* sqlite3.h:12097:31 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api1 = struct {
	iVersion         int32
	xCreateTokenizer uintptr
	xFindTokenizer   uintptr
	xCreateFunction  uintptr
} /* sqlite3.h:12133:9 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api = fts5_api1 /* sqlite3.h:12133:25 */

type ssize_t = int32 /* crtdefs.h:47:13 */

type rsize_t = size_t /* crtdefs.h:52:16 */

type intptr_t = int32 /* crtdefs.h:64:13 */

type uintptr_t = uint32 /* crtdefs.h:77:22 */

type wint_t = uint16   /* crtdefs.h:106:24 */
type wctype_t = uint16 /* crtdefs.h:107:24 */

type errno_t = int32 /* crtdefs.h:113:13 */

type time_t = int32 /* crtdefs.h:136:20 */

type threadlocaleinfostruct = struct {
	refcount      int32
	lc_codepage   uint32
	lc_collate_cp uint32
	lc_handle     [6]uint32
	lc_id         [6]LC_ID
	lc_category   [6]struct {
		locale    uintptr
		wlocale   uintptr
		refcount  uintptr
		wrefcount uintptr
	}
	lc_clike            int32
	mb_cur_max          int32
	lconv_intl_refcount uintptr
	lconv_num_refcount  uintptr
	lconv_mon_refcount  uintptr
	lconv               uintptr
	ctype1_refcount     uintptr
	ctype1              uintptr
	pctype              uintptr
	pclmap              uintptr
	pcumap              uintptr
	lc_time_curr        uintptr
} /* crtdefs.h:422:1 */

type pthreadlocinfo = uintptr /* crtdefs.h:424:39 */
type pthreadmbcinfo = uintptr /* crtdefs.h:425:36 */

type localeinfo_struct = struct {
	locinfo pthreadlocinfo
	mbcinfo pthreadmbcinfo
} /* crtdefs.h:428:9 */

type _locale_tstruct = localeinfo_struct /* crtdefs.h:431:3 */
type _locale_t = uintptr                 /* crtdefs.h:431:19 */

type tagLC_ID = struct {
	wLanguage uint16
	wCountry  uint16
	wCodePage uint16
} /* crtdefs.h:422:1 */

type LC_ID = tagLC_ID  /* crtdefs.h:439:3 */
type LPLC_ID = uintptr /* crtdefs.h:439:9 */

type threadlocinfo = threadlocaleinfostruct /* crtdefs.h:468:3 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Undefine __mingw_<printf> macros.

type _iobuf = struct {
	_ptr      uintptr
	_cnt      int32
	_base     uintptr
	_flag     int32
	_file     int32
	_charbuf  int32
	_bufsiz   int32
	_tmpfname uintptr
} /* stdio.h:26:3 */

type FILE = _iobuf /* stdio.h:36:25 */

type _off_t = int32  /* _mingw_off_t.h:5:16 */
type off32_t = int32 /* _mingw_off_t.h:7:16 */

type _off64_t = int64 /* _mingw_off_t.h:13:39 */
type off64_t = int64  /* _mingw_off_t.h:15:39 */

type off_t = off64_t /* _mingw_off_t.h:24:17 */ // A pointer to an array of FILE

type fpos_t = int64 /* stdio.h:104:37 */

func vsnwprintf(tls *libc.TLS, s uintptr, n size_t, format uintptr, arg va_list) int32 { /* stdio.h:1213:15: */
	return libc.X_vsnwprintf(tls, s, n, format, arg)

}

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

func vswprintf(tls *libc.TLS, __stream uintptr, __count size_t, __format uintptr, __local_argv uintptr) int32 { /* swprintf.inl:27:5: */
	return vsnwprintf(tls, __stream, __count, __format, __local_argv)
}

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Define __mingw_<printf> macros.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// sdkddkver.h: Version definitions for SDK and DDK. Originally
// from ReactOS PSDK/DDK, this file is in the public domain:
//
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// _WIN32_WINNT

// _WIN32_IE

// Mappings Between IE Version  and Windows Version

// NTDDI_VERSION

// Version Fields in NTDDI_VERSION

// Macros to Extract Version Fields From NTDDI_VERSION

// Macros to get the NTDDI for a given WIN32

// Select Default WIN32_WINNT Value

// Choose NTDDI Version

// Choose WINVER Value

// Choose IE Version

// Make Sure NTDDI_VERSION and _WIN32_WINNT Match

// Some kludge for Obj-C.
//    For Obj-C the 'interface' is a keyword, but interface is used
//    in midl-code too.  To resolve this conflict for at least the
//    main windows API header, we define it here temporary.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _EXCEPTION_POINTERS = struct {
	ExceptionRecord PEXCEPTION_RECORD
	ContextRecord   PCONTEXT
} /* excpt.h:17:3 */

type _EXCEPTION_RECORD = struct {
	ExceptionCode        DWORD
	ExceptionFlags       DWORD
	ExceptionRecord      uintptr
	ExceptionAddress     PVOID
	NumberParameters     DWORD
	ExceptionInformation [15]ULONG_PTR
} /* excpt.h:17:3 */

type _CONTEXT = struct {
	ContextFlags      DWORD
	Dr0               DWORD
	Dr1               DWORD
	Dr2               DWORD
	Dr3               DWORD
	Dr6               DWORD
	Dr7               DWORD
	FloatSave         FLOATING_SAVE_AREA
	SegGs             DWORD
	SegFs             DWORD
	SegEs             DWORD
	SegDs             DWORD
	Edi               DWORD
	Esi               DWORD
	Ebx               DWORD
	Edx               DWORD
	Ecx               DWORD
	Eax               DWORD
	Ebp               DWORD
	Eip               DWORD
	SegCs             DWORD
	EFlags            DWORD
	Esp               DWORD
	SegSs             DWORD
	ExtendedRegisters [512]BYTE
} /* excpt.h:17:3 */

// CRT stuff
type _PHNDLR = uintptr /* excpt.h:66:16 */

type _XCPT_ACTION = struct {
	XcptNum    uint32
	SigNum     int32
	XcptAction _PHNDLR
} /* excpt.h:68:3 */

// The type of function that is expected as an exception handler to be
// installed with __try1.
type PEXCEPTION_HANDLER = uintptr /* excpt.h:87:33 */

// Copyright (C) 1989, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.

// As a special exception, if you include this header file into source
//    files compiled by GCC, this header file does not by itself cause
//    the resulting executable to be covered by the GNU General Public
//    License.  This exception does not however invalidate any other
//    reasons why the executable file might be covered by the GNU General
//    Public License.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// include mingw stuff
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// WINAPI_FAMILY can be either desktop + App, or App.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Pointer parameters

// Optional pointer parameters

// Output pointer parameters

// Output reference parameters

// Return values

// Other common annotations

// Function annotations

// Success/failure annotations

// Buffer properties

// Field properties

// Structural annotations

// printf/scanf annotations

// Analysis

// FIXME: __in macro conflicts with argument names in libstdc++. For this reason,
// we disable it for C++. This should be fixed in libstdc++ so we can uncomment
// it in fixed version here.

// Renamed __null to SAL__null for avoiding private keyword conflicts between
//    gcc and MS world.

// PROJECT:         ReactOS DDK
// COPYRIGHT:       This file is in the Public Domain.
// FILE:            driverspecs.h
// ABSTRACT:        This header stubs out Driver Verifier annotations to
//                  allow drivers using them to compile with our header set.

// Stubs

type ULONG = uint32    /* minwindef.h:24:29 */
type PULONG = uintptr  /* minwindef.h:25:17 */
type USHORT = uint16   /* minwindef.h:26:26 */
type PUSHORT = uintptr /* minwindef.h:27:18 */
type UCHAR = uint8     /* minwindef.h:28:25 */
type PUCHAR = uintptr  /* minwindef.h:29:17 */
type PSZ = uintptr     /* minwindef.h:30:16 */

type WINBOOL = int32  /* minwindef.h:127:13 */
type BOOL = int32     /* minwindef.h:131:15 */
type PBOOL = uintptr  /* minwindef.h:134:14 */
type LPBOOL = uintptr /* minwindef.h:135:14 */

type BYTE = uint8      /* minwindef.h:139:25 */
type WORD = uint16     /* minwindef.h:140:26 */
type DWORD = uint32    /* minwindef.h:141:29 */
type FLOAT = float32   /* minwindef.h:142:17 */
type PFLOAT = uintptr  /* minwindef.h:143:17 */
type PBYTE = uintptr   /* minwindef.h:144:16 */
type LPBYTE = uintptr  /* minwindef.h:145:16 */
type PINT = uintptr    /* minwindef.h:146:15 */
type LPINT = uintptr   /* minwindef.h:147:15 */
type PWORD = uintptr   /* minwindef.h:148:16 */
type LPWORD = uintptr  /* minwindef.h:149:16 */
type LPLONG = uintptr  /* minwindef.h:150:20 */
type PDWORD = uintptr  /* minwindef.h:151:17 */
type LPDWORD = uintptr /* minwindef.h:152:17 */
type LPVOID = uintptr  /* minwindef.h:153:16 */
type LPCVOID = uintptr /* minwindef.h:156:22 */
type INT = int32       /* minwindef.h:158:15 */
type UINT = uint32     /* minwindef.h:159:24 */
type PUINT = uintptr   /* minwindef.h:160:24 */

// *
// sdkddkver.h: Version definitions for SDK and DDK. Originally
// from ReactOS PSDK/DDK, this file is in the public domain:
//
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type POINTER_64_INT = uint32 /* basetsd.h:13:23 */

type INT8 = int8        /* basetsd.h:29:23 */
type PINT8 = uintptr    /* basetsd.h:29:28 */
type INT16 = int16      /* basetsd.h:30:24 */
type PINT16 = uintptr   /* basetsd.h:30:30 */
type INT32 = int32      /* basetsd.h:31:22 */
type PINT32 = uintptr   /* basetsd.h:31:28 */
type INT64 = int64      /* basetsd.h:32:44 */
type PINT64 = uintptr   /* basetsd.h:32:50 */
type UINT8 = uint8      /* basetsd.h:33:25 */
type PUINT8 = uintptr   /* basetsd.h:33:31 */
type UINT16 = uint16    /* basetsd.h:34:26 */
type PUINT16 = uintptr  /* basetsd.h:34:33 */
type UINT32 = uint32    /* basetsd.h:35:24 */
type PUINT32 = uintptr  /* basetsd.h:35:31 */
type UINT64 = uint64    /* basetsd.h:36:46 */
type PUINT64 = uintptr  /* basetsd.h:36:53 */
type LONG32 = int32     /* basetsd.h:37:22 */
type PLONG32 = uintptr  /* basetsd.h:37:29 */
type ULONG32 = uint32   /* basetsd.h:38:24 */
type PULONG32 = uintptr /* basetsd.h:38:32 */
type DWORD32 = uint32   /* basetsd.h:39:24 */
type PDWORD32 = uintptr /* basetsd.h:39:32 */

type INT_PTR = int32      /* basetsd.h:52:15 */
type PINT_PTR = uintptr   /* basetsd.h:52:23 */
type UINT_PTR = uint32    /* basetsd.h:53:24 */
type PUINT_PTR = uintptr  /* basetsd.h:53:33 */
type LONG_PTR = int32     /* basetsd.h:54:16 */
type PLONG_PTR = uintptr  /* basetsd.h:54:25 */
type ULONG_PTR = uint32   /* basetsd.h:55:25 */
type PULONG_PTR = uintptr /* basetsd.h:55:35 */

type UHALF_PTR = uint16   /* basetsd.h:97:26 */
type PUHALF_PTR = uintptr /* basetsd.h:97:36 */
type HALF_PTR = int16     /* basetsd.h:98:17 */
type PHALF_PTR = uintptr  /* basetsd.h:98:26 */
type SHANDLE_PTR = int32  /* basetsd.h:99:20 */
type HANDLE_PTR = uint32  /* basetsd.h:100:29 */

type SIZE_T = ULONG_PTR /* basetsd.h:147:39 */
type PSIZE_T = uintptr  /* basetsd.h:147:46 */
type SSIZE_T = LONG_PTR /* basetsd.h:148:38 */
type PSSIZE_T = uintptr /* basetsd.h:148:46 */

type DWORD_PTR = ULONG_PTR /* basetsd.h:191:39 */
type PDWORD_PTR = uintptr  /* basetsd.h:191:49 */
type LONG64 = int64        /* basetsd.h:192:37 */
type PLONG64 = uintptr     /* basetsd.h:192:44 */
type ULONG64 = uint64      /* basetsd.h:193:46 */
type PULONG64 = uintptr    /* basetsd.h:193:54 */
type DWORD64 = uint64      /* basetsd.h:194:46 */
type PDWORD64 = uintptr    /* basetsd.h:194:54 */
type KAFFINITY = ULONG_PTR /* basetsd.h:195:39 */
type PKAFFINITY = uintptr  /* basetsd.h:196:39 */

type PVOID = uintptr   /* winnt.h:257:16 */
type PVOID64 = uintptr /* winnt.h:258:16 */

type CHAR = int8   /* winnt.h:285:16 */
type SHORT = int16 /* winnt.h:286:17 */
type LONG = int32  /* winnt.h:287:20 */

type WCHAR = wchar_t     /* winnt.h:295:19 */
type PWCHAR = uintptr    /* winnt.h:297:17 */
type LPWCH = uintptr     /* winnt.h:297:25 */
type PWCH = uintptr      /* winnt.h:297:32 */
type LPCWCH = uintptr    /* winnt.h:298:23 */
type PCWCH = uintptr     /* winnt.h:298:31 */
type NWPSTR = uintptr    /* winnt.h:299:17 */
type LPWSTR = uintptr    /* winnt.h:299:25 */
type PWSTR = uintptr     /* winnt.h:299:33 */
type PZPWSTR = uintptr   /* winnt.h:300:17 */
type PCZPWSTR = uintptr  /* winnt.h:301:23 */
type LPUWSTR = uintptr   /* winnt.h:302:27 */
type PUWSTR = uintptr    /* winnt.h:302:36 */
type LPCWSTR = uintptr   /* winnt.h:303:23 */
type PCWSTR = uintptr    /* winnt.h:303:32 */
type PZPCWSTR = uintptr  /* winnt.h:304:18 */
type LPCUWSTR = uintptr  /* winnt.h:305:33 */
type PCUWSTR = uintptr   /* winnt.h:305:43 */
type PZZWSTR = uintptr   /* winnt.h:306:17 */
type PCZZWSTR = uintptr  /* winnt.h:307:23 */
type PUZZWSTR = uintptr  /* winnt.h:308:27 */
type PCUZZWSTR = uintptr /* winnt.h:309:33 */
type PNZWCH = uintptr    /* winnt.h:310:17 */
type PCNZWCH = uintptr   /* winnt.h:311:23 */
type PUNZWCH = uintptr   /* winnt.h:312:27 */
type PCUNZWCH = uintptr  /* winnt.h:313:33 */

type PCHAR = uintptr   /* winnt.h:334:16 */
type LPCH = uintptr    /* winnt.h:334:23 */
type PCH = uintptr     /* winnt.h:334:29 */
type LPCCH = uintptr   /* winnt.h:335:22 */
type PCCH = uintptr    /* winnt.h:335:29 */
type NPSTR = uintptr   /* winnt.h:336:16 */
type LPSTR = uintptr   /* winnt.h:336:23 */
type PSTR = uintptr    /* winnt.h:336:30 */
type PZPSTR = uintptr  /* winnt.h:337:16 */
type PCZPSTR = uintptr /* winnt.h:338:22 */
type LPCSTR = uintptr  /* winnt.h:339:22 */
type PCSTR = uintptr   /* winnt.h:339:30 */
type PZPCSTR = uintptr /* winnt.h:340:17 */
type PZZSTR = uintptr  /* winnt.h:341:16 */
type PCZZSTR = uintptr /* winnt.h:342:22 */
type PNZCH = uintptr   /* winnt.h:343:16 */
type PCNZCH = uintptr  /* winnt.h:344:22 */

type TCHAR = int8     /* winnt.h:373:16 */
type PTCHAR = uintptr /* winnt.h:373:23 */
type TBYTE = uint8    /* winnt.h:374:25 */
type PTBYTE = uintptr /* winnt.h:374:32 */

type LPTCH = LPSTR       /* winnt.h:377:17 */
type PTCH = LPSTR        /* winnt.h:377:23 */
type LPCTCH = LPCCH      /* winnt.h:378:17 */
type PCTCH = LPCCH       /* winnt.h:378:24 */
type PTSTR = LPSTR       /* winnt.h:379:17 */
type LPTSTR = LPSTR      /* winnt.h:379:23 */
type PUTSTR = LPSTR      /* winnt.h:379:30 */
type LPUTSTR = LPSTR     /* winnt.h:379:37 */
type PCTSTR = LPCSTR     /* winnt.h:380:18 */
type LPCTSTR = LPCSTR    /* winnt.h:380:25 */
type PCUTSTR = LPCSTR    /* winnt.h:380:33 */
type LPCUTSTR = LPCSTR   /* winnt.h:380:41 */
type PZZTSTR = PZZSTR    /* winnt.h:381:18 */
type PUZZTSTR = PZZSTR   /* winnt.h:381:27 */
type PCZZTSTR = PCZZSTR  /* winnt.h:382:19 */
type PCUZZTSTR = PCZZSTR /* winnt.h:382:29 */
type PZPTSTR = PZPSTR    /* winnt.h:383:18 */
type PNZTCH = PNZCH      /* winnt.h:384:17 */
type PUNZTCH = PNZCH     /* winnt.h:384:25 */
type PCNZTCH = PCNZCH    /* winnt.h:385:18 */
type PCUNZTCH = PCNZCH   /* winnt.h:385:27 */

type PSHORT = uintptr /* winnt.h:392:17 */
type PLONG = uintptr  /* winnt.h:393:16 */

type _GROUP_AFFINITY = struct {
	Mask     KAFFINITY
	Group    WORD
	Reserved [3]WORD
} /* winnt.h:397:9 */

type GROUP_AFFINITY = _GROUP_AFFINITY /* winnt.h:401:3 */
type PGROUP_AFFINITY = uintptr        /* winnt.h:401:19 */

type HANDLE = uintptr /* winnt.h:405:16 */

type PHANDLE = uintptr /* winnt.h:412:18 */
type FCHAR = BYTE      /* winnt.h:413:16 */
type FSHORT = WORD     /* winnt.h:414:16 */
type FLONG = DWORD     /* winnt.h:415:17 */

type HRESULT = LONG /* winnt.h:419:16 */

// Keep in sync with basetyps.h header.

type CCHAR = int8   /* winnt.h:453:16 */
type LCID = DWORD   /* winnt.h:456:15 */
type PLCID = PDWORD /* winnt.h:458:18 */
type LANGID = WORD  /* winnt.h:461:16 */

type COMPARTMENT_ID = uint32   /* winnt.h:470:3 */
type PCOMPARTMENT_ID = uintptr /* winnt.h:470:18 */

type _FLOAT128 = struct {
	LowPart  int64
	HighPart int64
} /* winnt.h:482:13 */

type FLOAT128 = _FLOAT128 /* winnt.h:485:5 */

type PFLOAT128 = uintptr /* winnt.h:487:20 */

type LONGLONG = int64   /* winnt.h:490:37 */
type ULONGLONG = uint64 /* winnt.h:491:46 */

type PLONGLONG = uintptr  /* winnt.h:495:20 */
type PULONGLONG = uintptr /* winnt.h:496:21 */
type USN = LONGLONG       /* winnt.h:497:20 */

type _LARGE_INTEGER = struct {
	_ [0]uint64
	s struct {
		LowPart  DWORD
		HighPart LONG
	}
} /* winnt.h:505:11 */

type LARGE_INTEGER = _LARGE_INTEGER /* winnt.h:516:5 */

type PLARGE_INTEGER = uintptr /* winnt.h:518:25 */

type _ULARGE_INTEGER = struct {
	_ [0]uint64
	s struct {
		LowPart  DWORD
		HighPart DWORD
	}
} /* winnt.h:523:11 */

type ULARGE_INTEGER = _ULARGE_INTEGER /* winnt.h:534:5 */

type PULARGE_INTEGER = uintptr /* winnt.h:536:26 */

type _LUID = struct {
	LowPart  DWORD
	HighPart LONG
} /* winnt.h:538:11 */

type LUID = _LUID    /* winnt.h:541:5 */
type PLUID = uintptr /* winnt.h:541:10 */

type DWORDLONG = ULONGLONG /* winnt.h:546:21 */
type PDWORDLONG = uintptr  /* winnt.h:547:21 */

type BOOLEAN = BYTE     /* winnt.h:605:16 */
type PBOOLEAN = uintptr /* winnt.h:607:19 */

type _LIST_ENTRY = struct {
	Flink uintptr
	Blink uintptr
} /* winnt.h:612:11 */

type LIST_ENTRY = _LIST_ENTRY /* winnt.h:615:5 */
type PLIST_ENTRY = uintptr    /* winnt.h:615:16 */
type PRLIST_ENTRY = uintptr   /* winnt.h:615:29 */

type _SINGLE_LIST_ENTRY = struct{ Next uintptr } /* winnt.h:617:11 */

type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY /* winnt.h:619:5 */
type PSINGLE_LIST_ENTRY = uintptr           /* winnt.h:619:23 */

type LIST_ENTRY321 = struct {
	Flink DWORD
	Blink DWORD
} /* winnt.h:621:11 */

type LIST_ENTRY32 = LIST_ENTRY321 /* winnt.h:624:5 */
type PLIST_ENTRY32 = uintptr      /* winnt.h:625:24 */

type LIST_ENTRY641 = struct {
	Flink ULONGLONG
	Blink ULONGLONG
} /* winnt.h:627:11 */

type LIST_ENTRY64 = LIST_ENTRY641 /* winnt.h:630:5 */
type PLIST_ENTRY64 = uintptr      /* winnt.h:631:24 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// Make sure __LONG32 is defined.
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _GUID = struct {
	Data1 uint32
	Data2 uint16
	Data3 uint16
	Data4 [8]uint8
} /* guiddef.h:19:9 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// Make sure __LONG32 is defined.
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type GUID = _GUID /* guiddef.h:24:3 */

// __declspec(selectany) must be applied to initialized objects on GCC 5 hence must not be used here.

type LPGUID = uintptr /* guiddef.h:77:14 */

type LPCGUID = uintptr /* guiddef.h:82:20 */

type IID = GUID      /* guiddef.h:88:14 */
type LPIID = uintptr /* guiddef.h:89:13 */

type CLSID = GUID /* guiddef.h:96:14 */

type LPCLSID = uintptr /* guiddef.h:99:15 */

type FMTID = GUID      /* guiddef.h:103:14 */
type LPFMTID = uintptr /* guiddef.h:104:15 */

type _OBJECTID = struct {
	Lineage    GUID
	Uniquifier DWORD
} /* winnt.h:639:11 */

type OBJECTID = _OBJECTID         /* winnt.h:642:5 */
type PEXCEPTION_ROUTINE = uintptr /* winnt.h:709:31 */

// ??? #define SUBLANG_ROMANIAN_MOLDOVA                  0x01 ???

type KSPIN_LOCK = ULONG_PTR /* winnt.h:1383:21 */
type PKSPIN_LOCK = uintptr  /* winnt.h:1384:22 */

type _M128A = struct {
	Low  ULONGLONG
	High LONGLONG
} /* winnt.h:1386:13 */

type M128A = _M128A   /* winnt.h:1389:7 */
type PM128A = uintptr /* winnt.h:1389:13 */

type _XSAVE_FORMAT = struct {
	ControlWord    WORD
	StatusWord     WORD
	TagWord        BYTE
	Reserved1      BYTE
	ErrorOpcode    WORD
	ErrorOffset    DWORD
	ErrorSelector  WORD
	Reserved2      WORD
	DataOffset     DWORD
	DataSelector   WORD
	Reserved3      WORD
	MxCsr          DWORD
	MxCsr_Mask     DWORD
	FloatRegisters [8]M128A
	XmmRegisters   [8]M128A
	Reserved4      [220]BYTE
	Cr0NpxState    DWORD
} /* winnt.h:1391:13 */

type XSAVE_FORMAT = _XSAVE_FORMAT /* winnt.h:1414:7 */
type PXSAVE_FORMAT = uintptr      /* winnt.h:1414:20 */

type _XSAVE_AREA_HEADER = struct {
	Mask     DWORD64
	Reserved [7]DWORD64
} /* winnt.h:1416:13 */

type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER /* winnt.h:1419:7 */
type PXSAVE_AREA_HEADER = uintptr           /* winnt.h:1419:25 */

type _XSAVE_AREA = struct {
	LegacyState XSAVE_FORMAT
	Header      XSAVE_AREA_HEADER
} /* winnt.h:1421:13 */

type XSAVE_AREA = _XSAVE_AREA /* winnt.h:1424:7 */
type PXSAVE_AREA = uintptr    /* winnt.h:1424:18 */

type _XSTATE_CONTEXT = struct {
	Mask      DWORD64
	Length    DWORD
	Reserved1 DWORD
	Area      PXSAVE_AREA
	Reserved2 DWORD
	Buffer    PVOID
	Reserved3 DWORD
} /* winnt.h:1426:13 */

type XSTATE_CONTEXT = _XSTATE_CONTEXT /* winnt.h:1438:7 */
type PXSTATE_CONTEXT = uintptr        /* winnt.h:1438:22 */

type _SCOPE_TABLE_AMD64 = struct {
	Count       DWORD
	ScopeRecord [1]struct {
		BeginAddress   DWORD
		EndAddress     DWORD
		HandlerAddress DWORD
		JumpTarget     DWORD
	}
} /* winnt.h:1440:13 */

type SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64 /* winnt.h:1448:7 */
type PSCOPE_TABLE_AMD64 = uintptr           /* winnt.h:1448:25 */

type _FLOATING_SAVE_AREA = struct {
	ControlWord   DWORD
	StatusWord    DWORD
	TagWord       DWORD
	ErrorOffset   DWORD
	ErrorSelector DWORD
	DataOffset    DWORD
	DataSelector  DWORD
	RegisterArea  [80]BYTE
	Cr0NpxState   DWORD
} /* excpt.h:17:3 */

type FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA /* winnt.h:2371:7 */

type PFLOATING_SAVE_AREA = uintptr /* winnt.h:2373:32 */

type CONTEXT = _CONTEXT /* winnt.h:2402:7 */

type PCONTEXT = uintptr /* winnt.h:2404:21 */

// LONG WINAPI InterlockedIncrement(LONG volatile *); moved to psdk_inc/intrin-impl.h
// LONG WINAPI InterlockedDecrement(LONG volatile *); moved to psdk_inc/intrin-impl.h
// LONG WINAPI InterlockedExchange(LONG volatile *, LONG); moved to psdk_inc/intrin-impl.h

type _LDT_ENTRY = struct {
	LimitLow WORD
	BaseLow  WORD
	HighWord struct {
		_     [0]uint32
		Bytes struct {
			BaseMid BYTE
			Flags1  BYTE
			Flags2  BYTE
			BaseHi  BYTE
		}
	}
} /* winnt.h:2415:13 */

// LONG WINAPI InterlockedIncrement(LONG volatile *); moved to psdk_inc/intrin-impl.h
// LONG WINAPI InterlockedDecrement(LONG volatile *); moved to psdk_inc/intrin-impl.h
// LONG WINAPI InterlockedExchange(LONG volatile *, LONG); moved to psdk_inc/intrin-impl.h

type LDT_ENTRY = _LDT_ENTRY /* winnt.h:2438:7 */
type PLDT_ENTRY = uintptr   /* winnt.h:2438:17 */

// http://www.nynaeve.net/?p=99

type EXCEPTION_RECORD = _EXCEPTION_RECORD /* winnt.h:2783:7 */

type PEXCEPTION_RECORD = uintptr /* winnt.h:2785:30 */

type _EXCEPTION_RECORD32 = struct {
	ExceptionCode        DWORD
	ExceptionFlags       DWORD
	ExceptionRecord      DWORD
	ExceptionAddress     DWORD
	NumberParameters     DWORD
	ExceptionInformation [15]DWORD
} /* winnt.h:2787:13 */

type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32 /* winnt.h:2794:7 */
type PEXCEPTION_RECORD32 = uintptr            /* winnt.h:2794:26 */

type _EXCEPTION_RECORD64 = struct {
	ExceptionCode        DWORD
	ExceptionFlags       DWORD
	ExceptionRecord      DWORD64
	ExceptionAddress     DWORD64
	NumberParameters     DWORD
	__unusedAlignment    DWORD
	ExceptionInformation [15]DWORD64
} /* winnt.h:2796:13 */

type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64 /* winnt.h:2804:7 */
type PEXCEPTION_RECORD64 = uintptr            /* winnt.h:2804:26 */

type EXCEPTION_POINTERS = _EXCEPTION_POINTERS /* winnt.h:2809:7 */
type PEXCEPTION_POINTERS = uintptr            /* winnt.h:2809:26 */

type PACCESS_TOKEN = PVOID        /* winnt.h:2871:19 */
type PSECURITY_DESCRIPTOR = PVOID /* winnt.h:2872:19 */
type PSID = PVOID                 /* winnt.h:2873:19 */
type PCLAIMS_BLOB = PVOID         /* winnt.h:2874:19 */
type ACCESS_MASK = DWORD          /* winnt.h:2875:19 */
type PACCESS_MASK = uintptr       /* winnt.h:2876:25 */

type _GENERIC_MAPPING = struct {
	GenericRead    ACCESS_MASK
	GenericWrite   ACCESS_MASK
	GenericExecute ACCESS_MASK
	GenericAll     ACCESS_MASK
} /* winnt.h:2902:13 */

type GENERIC_MAPPING = _GENERIC_MAPPING /* winnt.h:2907:7 */
type PGENERIC_MAPPING = uintptr         /* winnt.h:2908:29 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type _LUID_AND_ATTRIBUTES = struct {
	Luid       LUID
	Attributes DWORD
} /* winnt.h:2911:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES         /* winnt.h:2914:7 */
type PLUID_AND_ATTRIBUTES = uintptr                     /* winnt.h:2914:27 */
type LUID_AND_ATTRIBUTES_ARRAY = [1]LUID_AND_ATTRIBUTES /* winnt.h:2915:33 */
type PLUID_AND_ATTRIBUTES_ARRAY = uintptr               /* winnt.h:2916:39 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _SID_IDENTIFIER_AUTHORITY = struct{ Value [6]BYTE } /* winnt.h:2921:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY /* winnt.h:2923:7 */
type PSID_IDENTIFIER_AUTHORITY = uintptr                  /* winnt.h:2923:32 */

type _SID = struct {
	Revision            BYTE
	SubAuthorityCount   BYTE
	IdentifierAuthority SID_IDENTIFIER_AUTHORITY
	SubAuthority        [1]DWORD
} /* winnt.h:2928:13 */

type SID = _SID      /* winnt.h:2933:7 */
type PISID = uintptr /* winnt.h:2933:11 */

type SID_NAME_USE = uint32   /* winnt.h:2947:7 */
type PSID_NAME_USE = uintptr /* winnt.h:2947:20 */

type _SID_AND_ATTRIBUTES = struct {
	Sid        PSID
	Attributes DWORD
} /* winnt.h:2949:13 */

type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES /* winnt.h:2956:7 */
type PSID_AND_ATTRIBUTES = uintptr            /* winnt.h:2956:26 */

type SID_AND_ATTRIBUTES_ARRAY = [1]SID_AND_ATTRIBUTES /* winnt.h:2958:32 */
type PSID_AND_ATTRIBUTES_ARRAY = uintptr              /* winnt.h:2959:38 */

type SID_HASH_ENTRY = ULONG_PTR /* winnt.h:2961:23 */
type PSID_HASH_ENTRY = uintptr  /* winnt.h:2961:39 */

type _SID_AND_ATTRIBUTES_HASH = struct {
	SidCount DWORD
	SidAttr  PSID_AND_ATTRIBUTES
	Hash     [32]SID_HASH_ENTRY
} /* winnt.h:2963:13 */

type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH /* winnt.h:2967:7 */
type PSID_AND_ATTRIBUTES_HASH = uintptr                 /* winnt.h:2967:32 */

type WELL_KNOWN_SID_TYPE = uint32 /* winnt.h:3251:3 */

type _ACL = struct {
	AclRevision BYTE
	Sbz1        BYTE
	AclSize     WORD
	AceCount    WORD
	Sbz2        WORD
} /* winnt.h:3281:13 */

type ACL = _ACL     /* winnt.h:3287:7 */
type PACL = uintptr /* winnt.h:3288:17 */

type _ACE_HEADER = struct {
	AceType  BYTE
	AceFlags BYTE
	AceSize  WORD
} /* winnt.h:3290:13 */

type ACE_HEADER = _ACE_HEADER /* winnt.h:3294:7 */
type PACE_HEADER = uintptr    /* winnt.h:3295:24 */

type _ACCESS_ALLOWED_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3341:13 */

type ACCESS_ALLOWED_ACE = _ACCESS_ALLOWED_ACE /* winnt.h:3345:7 */

type PACCESS_ALLOWED_ACE = uintptr /* winnt.h:3347:32 */

type _ACCESS_DENIED_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3349:13 */

type ACCESS_DENIED_ACE = _ACCESS_DENIED_ACE /* winnt.h:3353:7 */
type PACCESS_DENIED_ACE = uintptr           /* winnt.h:3354:31 */

type _SYSTEM_AUDIT_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3356:13 */

type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE /* winnt.h:3360:7 */
type PSYSTEM_AUDIT_ACE = uintptr          /* winnt.h:3361:30 */

type _SYSTEM_ALARM_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3363:13 */

type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE /* winnt.h:3367:7 */
type PSYSTEM_ALARM_ACE = uintptr          /* winnt.h:3368:30 */

type _SYSTEM_RESOURCE_ATTRIBUTE_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3370:13 */

type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE /* winnt.h:3374:7 */
type PSYSTEM_RESOURCE_ATTRIBUTE_ACE = uintptr                       /* winnt.h:3374:37 */

type _SYSTEM_SCOPED_POLICY_ID_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3376:13 */

type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE /* winnt.h:3380:7 */
type PSYSTEM_SCOPED_POLICY_ID_ACE = uintptr                     /* winnt.h:3380:35 */

type _SYSTEM_MANDATORY_LABEL_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3382:13 */

type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE /* winnt.h:3386:7 */
type PSYSTEM_MANDATORY_LABEL_ACE = uintptr                    /* winnt.h:3386:35 */

type _ACCESS_ALLOWED_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3394:13 */

type ACCESS_ALLOWED_OBJECT_ACE = _ACCESS_ALLOWED_OBJECT_ACE /* winnt.h:3401:7 */
type PACCESS_ALLOWED_OBJECT_ACE = uintptr                   /* winnt.h:3401:33 */

type _ACCESS_DENIED_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3403:13 */

type ACCESS_DENIED_OBJECT_ACE = _ACCESS_DENIED_OBJECT_ACE /* winnt.h:3410:7 */
type PACCESS_DENIED_OBJECT_ACE = uintptr                  /* winnt.h:3410:32 */

type _SYSTEM_AUDIT_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3412:13 */

type SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE /* winnt.h:3419:7 */
type PSYSTEM_AUDIT_OBJECT_ACE = uintptr                 /* winnt.h:3419:31 */

type _SYSTEM_ALARM_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3421:13 */

type SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE /* winnt.h:3428:7 */
type PSYSTEM_ALARM_OBJECT_ACE = uintptr                 /* winnt.h:3428:31 */

type _ACCESS_ALLOWED_CALLBACK_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3430:13 */

type ACCESS_ALLOWED_CALLBACK_ACE = _ACCESS_ALLOWED_CALLBACK_ACE /* winnt.h:3434:7 */
type PACCESS_ALLOWED_CALLBACK_ACE = uintptr                     /* winnt.h:3434:35 */

type _ACCESS_DENIED_CALLBACK_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3436:13 */

type ACCESS_DENIED_CALLBACK_ACE = _ACCESS_DENIED_CALLBACK_ACE /* winnt.h:3440:7 */
type PACCESS_DENIED_CALLBACK_ACE = uintptr                    /* winnt.h:3440:34 */

type _SYSTEM_AUDIT_CALLBACK_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3442:13 */

type SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE /* winnt.h:3446:7 */
type PSYSTEM_AUDIT_CALLBACK_ACE = uintptr                   /* winnt.h:3446:33 */

type _SYSTEM_ALARM_CALLBACK_ACE = struct {
	Header   ACE_HEADER
	Mask     ACCESS_MASK
	SidStart DWORD
} /* winnt.h:3448:13 */

type SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE /* winnt.h:3452:7 */
type PSYSTEM_ALARM_CALLBACK_ACE = uintptr                   /* winnt.h:3452:33 */

type _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3454:13 */

type ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE /* winnt.h:3462:7 */
type PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = uintptr                            /* winnt.h:3462:42 */

type _ACCESS_DENIED_CALLBACK_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3464:13 */

type ACCESS_DENIED_CALLBACK_OBJECT_ACE = _ACCESS_DENIED_CALLBACK_OBJECT_ACE /* winnt.h:3471:7 */
type PACCESS_DENIED_CALLBACK_OBJECT_ACE = uintptr                           /* winnt.h:3471:41 */

type _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3473:13 */

type SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE /* winnt.h:3480:7 */
type PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = uintptr                          /* winnt.h:3480:40 */

type _SYSTEM_ALARM_CALLBACK_OBJECT_ACE = struct {
	Header              ACE_HEADER
	Mask                ACCESS_MASK
	Flags               DWORD
	ObjectType          GUID
	InheritedObjectType GUID
	SidStart            DWORD
} /* winnt.h:3482:13 */

type SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE /* winnt.h:3490:7 */
type PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = uintptr                          /* winnt.h:3490:40 */

type ACL_INFORMATION_CLASS = uint32 /* winnt.h:3497:7 */

type _ACL_REVISION_INFORMATION = struct{ AclRevision DWORD } /* winnt.h:3499:13 */

type ACL_REVISION_INFORMATION = _ACL_REVISION_INFORMATION /* winnt.h:3501:7 */
type PACL_REVISION_INFORMATION = uintptr                  /* winnt.h:3502:38 */

type _ACL_SIZE_INFORMATION = struct {
	AceCount      DWORD
	AclBytesInUse DWORD
	AclBytesFree  DWORD
} /* winnt.h:3504:13 */

type ACL_SIZE_INFORMATION = _ACL_SIZE_INFORMATION /* winnt.h:3508:7 */
type PACL_SIZE_INFORMATION = uintptr              /* winnt.h:3509:34 */

type SECURITY_DESCRIPTOR_CONTROL = WORD     /* winnt.h:3516:18 */
type PSECURITY_DESCRIPTOR_CONTROL = uintptr /* winnt.h:3516:46 */

type _SECURITY_DESCRIPTOR_RELATIVE = struct {
	Revision BYTE
	Sbz1     BYTE
	Control  SECURITY_DESCRIPTOR_CONTROL
	Owner    DWORD
	Group    DWORD
	Sacl     DWORD
	Dacl     DWORD
} /* winnt.h:3533:13 */

type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE /* winnt.h:3541:7 */
type PISECURITY_DESCRIPTOR_RELATIVE = uintptr                     /* winnt.h:3541:36 */

type _SECURITY_DESCRIPTOR = struct {
	Revision BYTE
	Sbz1     BYTE
	Control  SECURITY_DESCRIPTOR_CONTROL
	Owner    PSID
	Group    PSID
	Sacl     PACL
	Dacl     PACL
} /* winnt.h:3543:13 */

type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR /* winnt.h:3551:7 */
type PISECURITY_DESCRIPTOR = uintptr            /* winnt.h:3551:27 */

type _OBJECT_TYPE_LIST = struct {
	Level      WORD
	Sbz        WORD
	ObjectType uintptr
} /* winnt.h:3553:13 */

type OBJECT_TYPE_LIST = _OBJECT_TYPE_LIST /* winnt.h:3557:7 */
type POBJECT_TYPE_LIST = uintptr          /* winnt.h:3557:24 */

type AUDIT_EVENT_TYPE = uint32   /* winnt.h:3567:7 */
type PAUDIT_EVENT_TYPE = uintptr /* winnt.h:3567:24 */

type _PRIVILEGE_SET = struct {
	PrivilegeCount DWORD
	Control        DWORD
	Privilege      [1]LUID_AND_ATTRIBUTES
} /* winnt.h:3585:13 */

type PRIVILEGE_SET = _PRIVILEGE_SET /* winnt.h:3589:7 */
type PPRIVILEGE_SET = uintptr       /* winnt.h:3589:21 */

type ACCESS_REASON_TYPE = uint32 /* winnt.h:3614:7 */
type ACCESS_REASON = DWORD       /* winnt.h:3615:19 */

type _ACCESS_REASONS = struct{ Data [32]ACCESS_REASON } /* winnt.h:3617:13 */

type ACCESS_REASONS = _ACCESS_REASONS /* winnt.h:3619:7 */
type PACCESS_REASONS = uintptr        /* winnt.h:3619:22 */

type _SE_SECURITY_DESCRIPTOR = struct {
	Size               DWORD
	Flags              DWORD
	SecurityDescriptor PSECURITY_DESCRIPTOR
} /* winnt.h:3625:13 */

type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR /* winnt.h:3629:7 */
type PSE_SECURITY_DESCRIPTOR = uintptr                /* winnt.h:3629:30 */

type _SE_ACCESS_REQUEST = struct {
	Size                    DWORD
	SeSecurityDescriptor    PSE_SECURITY_DESCRIPTOR
	DesiredAccess           ACCESS_MASK
	PreviouslyGrantedAccess ACCESS_MASK
	PrincipalSelfSid        PSID
	GenericMapping          PGENERIC_MAPPING
	ObjectTypeListCount     DWORD
	ObjectTypeList          POBJECT_TYPE_LIST
} /* winnt.h:3631:13 */

type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST /* winnt.h:3640:7 */
type PSE_ACCESS_REQUEST = uintptr           /* winnt.h:3640:25 */

type _SE_ACCESS_REPLY = struct {
	Size            DWORD
	ResultListCount DWORD
	GrantedAccess   PACCESS_MASK
	AccessStatus    PDWORD
	AccessReason    PACCESS_REASONS
	Privileges      uintptr
} /* winnt.h:3642:13 */

type SE_ACCESS_REPLY = _SE_ACCESS_REPLY /* winnt.h:3649:7 */
type PSE_ACCESS_REPLY = uintptr         /* winnt.h:3649:23 */

type SECURITY_IMPERSONATION_LEVEL = uint32   /* winnt.h:3689:7 */
type PSECURITY_IMPERSONATION_LEVEL = uintptr /* winnt.h:3689:36 */

type TOKEN_TYPE = uint32   /* winnt.h:3716:7 */
type PTOKEN_TYPE = uintptr /* winnt.h:3717:24 */

type TOKEN_ELEVATION_TYPE = uint32   /* winnt.h:3723:7 */
type PTOKEN_ELEVATION_TYPE = uintptr /* winnt.h:3723:29 */

type TOKEN_INFORMATION_CLASS = uint32   /* winnt.h:3767:7 */
type PTOKEN_INFORMATION_CLASS = uintptr /* winnt.h:3767:31 */

type _TOKEN_USER = struct{ User SID_AND_ATTRIBUTES } /* winnt.h:3769:13 */

type TOKEN_USER = _TOKEN_USER /* winnt.h:3771:7 */
type PTOKEN_USER = uintptr    /* winnt.h:3771:18 */

type _TOKEN_GROUPS = struct {
	GroupCount DWORD
	Groups     [1]SID_AND_ATTRIBUTES
} /* winnt.h:3773:13 */

type TOKEN_GROUPS = _TOKEN_GROUPS /* winnt.h:3780:7 */
type PTOKEN_GROUPS = uintptr      /* winnt.h:3780:20 */

type _TOKEN_PRIVILEGES = struct {
	PrivilegeCount DWORD
	Privileges     [1]LUID_AND_ATTRIBUTES
} /* winnt.h:3782:13 */

type TOKEN_PRIVILEGES = _TOKEN_PRIVILEGES /* winnt.h:3785:7 */
type PTOKEN_PRIVILEGES = uintptr          /* winnt.h:3785:24 */

type _TOKEN_OWNER = struct{ Owner PSID } /* winnt.h:3787:13 */

type TOKEN_OWNER = _TOKEN_OWNER /* winnt.h:3789:7 */
type PTOKEN_OWNER = uintptr     /* winnt.h:3789:19 */

type _TOKEN_PRIMARY_GROUP = struct{ PrimaryGroup PSID } /* winnt.h:3791:13 */

type TOKEN_PRIMARY_GROUP = _TOKEN_PRIMARY_GROUP /* winnt.h:3793:7 */
type PTOKEN_PRIMARY_GROUP = uintptr             /* winnt.h:3793:27 */

type _TOKEN_DEFAULT_DACL = struct{ DefaultDacl PACL } /* winnt.h:3795:13 */

type TOKEN_DEFAULT_DACL = _TOKEN_DEFAULT_DACL /* winnt.h:3797:7 */
type PTOKEN_DEFAULT_DACL = uintptr            /* winnt.h:3797:26 */

type _TOKEN_USER_CLAIMS = struct{ UserClaims PCLAIMS_BLOB } /* winnt.h:3799:13 */

type TOKEN_USER_CLAIMS = _TOKEN_USER_CLAIMS /* winnt.h:3801:7 */
type PTOKEN_USER_CLAIMS = uintptr           /* winnt.h:3801:25 */

type _TOKEN_DEVICE_CLAIMS = struct{ DeviceClaims PCLAIMS_BLOB } /* winnt.h:3803:13 */

type TOKEN_DEVICE_CLAIMS = _TOKEN_DEVICE_CLAIMS /* winnt.h:3805:7 */
type PTOKEN_DEVICE_CLAIMS = uintptr             /* winnt.h:3805:27 */

type _TOKEN_GROUPS_AND_PRIVILEGES = struct {
	SidCount            DWORD
	SidLength           DWORD
	Sids                PSID_AND_ATTRIBUTES
	RestrictedSidCount  DWORD
	RestrictedSidLength DWORD
	RestrictedSids      PSID_AND_ATTRIBUTES
	PrivilegeCount      DWORD
	PrivilegeLength     DWORD
	Privileges          PLUID_AND_ATTRIBUTES
	AuthenticationId    LUID
} /* winnt.h:3807:13 */

type TOKEN_GROUPS_AND_PRIVILEGES = _TOKEN_GROUPS_AND_PRIVILEGES /* winnt.h:3818:7 */
type PTOKEN_GROUPS_AND_PRIVILEGES = uintptr                     /* winnt.h:3818:35 */

type _TOKEN_LINKED_TOKEN = struct{ LinkedToken HANDLE } /* winnt.h:3820:13 */

type TOKEN_LINKED_TOKEN = _TOKEN_LINKED_TOKEN /* winnt.h:3822:7 */
type PTOKEN_LINKED_TOKEN = uintptr            /* winnt.h:3822:26 */

type _TOKEN_ELEVATION = struct{ TokenIsElevated DWORD } /* winnt.h:3824:13 */

type TOKEN_ELEVATION = _TOKEN_ELEVATION /* winnt.h:3826:7 */
type PTOKEN_ELEVATION = uintptr         /* winnt.h:3826:23 */

type _TOKEN_MANDATORY_LABEL = struct{ Label SID_AND_ATTRIBUTES } /* winnt.h:3828:13 */

type TOKEN_MANDATORY_LABEL = _TOKEN_MANDATORY_LABEL /* winnt.h:3830:7 */
type PTOKEN_MANDATORY_LABEL = uintptr               /* winnt.h:3830:29 */

type _TOKEN_MANDATORY_POLICY = struct{ Policy DWORD } /* winnt.h:3838:13 */

type TOKEN_MANDATORY_POLICY = _TOKEN_MANDATORY_POLICY /* winnt.h:3840:7 */
type PTOKEN_MANDATORY_POLICY = uintptr                /* winnt.h:3840:30 */

type _TOKEN_ACCESS_INFORMATION = struct {
	SidHash            PSID_AND_ATTRIBUTES_HASH
	RestrictedSidHash  PSID_AND_ATTRIBUTES_HASH
	Privileges         PTOKEN_PRIVILEGES
	AuthenticationId   LUID
	TokenType          TOKEN_TYPE
	ImpersonationLevel SECURITY_IMPERSONATION_LEVEL
	MandatoryPolicy    TOKEN_MANDATORY_POLICY
	Flags              DWORD
	AppContainerNumber DWORD
	PackageSid         PSID
	CapabilitiesHash   PSID_AND_ATTRIBUTES_HASH
} /* winnt.h:3842:13 */

type TOKEN_ACCESS_INFORMATION = _TOKEN_ACCESS_INFORMATION /* winnt.h:3854:7 */
type PTOKEN_ACCESS_INFORMATION = uintptr                  /* winnt.h:3854:32 */

type _TOKEN_AUDIT_POLICY = struct{ PerUserPolicy [29]UCHAR } /* winnt.h:3858:13 */

type TOKEN_AUDIT_POLICY = _TOKEN_AUDIT_POLICY /* winnt.h:3860:7 */
type PTOKEN_AUDIT_POLICY = uintptr            /* winnt.h:3860:27 */

type _TOKEN_SOURCE = struct {
	SourceName       [8]CHAR
	SourceIdentifier LUID
} /* winnt.h:3864:13 */

type TOKEN_SOURCE = _TOKEN_SOURCE /* winnt.h:3867:7 */
type PTOKEN_SOURCE = uintptr      /* winnt.h:3867:20 */

type _TOKEN_STATISTICS = struct {
	TokenId            LUID
	AuthenticationId   LUID
	ExpirationTime     LARGE_INTEGER
	TokenType          TOKEN_TYPE
	ImpersonationLevel SECURITY_IMPERSONATION_LEVEL
	DynamicCharged     DWORD
	DynamicAvailable   DWORD
	GroupCount         DWORD
	PrivilegeCount     DWORD
	ModifiedId         LUID
} /* winnt.h:3869:13 */

type TOKEN_STATISTICS = _TOKEN_STATISTICS /* winnt.h:3880:7 */
type PTOKEN_STATISTICS = uintptr          /* winnt.h:3880:24 */

type _TOKEN_CONTROL = struct {
	TokenId          LUID
	AuthenticationId LUID
	ModifiedId       LUID
	TokenSource      TOKEN_SOURCE
} /* winnt.h:3882:13 */

type TOKEN_CONTROL = _TOKEN_CONTROL /* winnt.h:3887:7 */
type PTOKEN_CONTROL = uintptr       /* winnt.h:3887:21 */

type _TOKEN_ORIGIN = struct{ OriginatingLogonSession LUID } /* winnt.h:3889:13 */

type TOKEN_ORIGIN = _TOKEN_ORIGIN /* winnt.h:3891:7 */
type PTOKEN_ORIGIN = uintptr      /* winnt.h:3891:20 */

type MANDATORY_LEVEL = uint32   /* winnt.h:3901:7 */
type PMANDATORY_LEVEL = uintptr /* winnt.h:3901:23 */

type _TOKEN_APPCONTAINER_INFORMATION = struct{ TokenAppContainer PSID } /* winnt.h:3903:13 */

type TOKEN_APPCONTAINER_INFORMATION = _TOKEN_APPCONTAINER_INFORMATION /* winnt.h:3905:7 */
type PTOKEN_APPCONTAINER_INFORMATION = uintptr                        /* winnt.h:3905:38 */

type _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = struct {
	Version DWORD64
	Name    PWSTR
	_       [4]byte
} /* winnt.h:3915:13 */

type CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE /* winnt.h:3918:7 */
type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = uintptr                             /* winnt.h:3918:43 */

type _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = struct {
	pValue      PVOID
	ValueLength DWORD
} /* winnt.h:3920:13 */

type CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE /* winnt.h:3923:7 */
type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = uintptr                                     /* winnt.h:3923:52 */

type _CLAIM_SECURITY_ATTRIBUTE_V1 = struct {
	Name       PWSTR
	ValueType  WORD
	Reserved   WORD
	Flags      DWORD
	ValueCount DWORD
	Values     struct{ pInt64 PLONG64 }
} /* winnt.h:3936:13 */

type CLAIM_SECURITY_ATTRIBUTE_V1 = _CLAIM_SECURITY_ATTRIBUTE_V1 /* winnt.h:3949:7 */
type PCLAIM_SECURITY_ATTRIBUTE_V1 = uintptr                     /* winnt.h:3949:35 */

type _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = struct {
	Name       DWORD
	ValueType  WORD
	Reserved   WORD
	Flags      DWORD
	ValueCount DWORD
	Values     struct{ pInt64 [1]DWORD }
} /* winnt.h:3951:13 */

type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 /* winnt.h:3964:7 */
type PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = uintptr                              /* winnt.h:3964:44 */

type _CLAIM_SECURITY_ATTRIBUTES_INFORMATION = struct {
	Version        WORD
	Reserved       WORD
	AttributeCount DWORD
	Attribute      struct{ pAttributeV1 PCLAIM_SECURITY_ATTRIBUTE_V1 }
} /* winnt.h:3970:13 */

type CLAIM_SECURITY_ATTRIBUTES_INFORMATION = _CLAIM_SECURITY_ATTRIBUTES_INFORMATION /* winnt.h:3977:7 */
type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = uintptr                               /* winnt.h:3977:45 */

type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN  /* winnt.h:3982:21 */
type PSECURITY_CONTEXT_TRACKING_MODE = uintptr /* winnt.h:3982:52 */

type _SECURITY_QUALITY_OF_SERVICE = struct {
	Length              DWORD
	ImpersonationLevel  SECURITY_IMPERSONATION_LEVEL
	ContextTrackingMode SECURITY_CONTEXT_TRACKING_MODE
	EffectiveOnly       BOOLEAN
	_                   [2]byte
} /* winnt.h:3984:13 */

type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE /* winnt.h:3989:7 */
type PSECURITY_QUALITY_OF_SERVICE = uintptr                     /* winnt.h:3989:35 */

type _SE_IMPERSONATION_STATE = struct {
	Token         PACCESS_TOKEN
	CopyOnOpen    BOOLEAN
	EffectiveOnly BOOLEAN
	_             [2]byte
	Level         SECURITY_IMPERSONATION_LEVEL
} /* winnt.h:3991:13 */

type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE /* winnt.h:3996:7 */
type PSE_IMPERSONATION_STATE = uintptr                /* winnt.h:3996:30 */

type SECURITY_INFORMATION = DWORD    /* winnt.h:4003:19 */
type PSECURITY_INFORMATION = uintptr /* winnt.h:4003:40 */

type SE_LEARNING_MODE_DATA_TYPE = uint32 /* winnt.h:4023:7 */

type _SECURITY_CAPABILITIES = struct {
	AppContainerSid PSID
	Capabilities    PSID_AND_ATTRIBUTES
	CapabilityCount DWORD
	Reserved        DWORD
} /* winnt.h:4027:13 */

type SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES /* winnt.h:4032:7 */
type PSECURITY_CAPABILITIES = uintptr               /* winnt.h:4032:29 */
type LPSECURITY_CAPABILITIES = uintptr              /* winnt.h:4032:53 */

type _JOB_SET_ARRAY = struct {
	JobHandle   HANDLE
	MemberLevel DWORD
	Flags       DWORD
} /* winnt.h:4087:13 */

type JOB_SET_ARRAY = _JOB_SET_ARRAY /* winnt.h:4091:7 */
type PJOB_SET_ARRAY = uintptr       /* winnt.h:4091:21 */

type _EXCEPTION_REGISTRATION_RECORD = struct {
	__0 struct{ Next uintptr }
	__4 struct{ Handler PEXCEPTION_ROUTINE }
} /* winnt.h:4097:13 */

type EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD /* winnt.h:4106:7 */

type PEXCEPTION_REGISTRATION_RECORD = uintptr /* winnt.h:4108:43 */

type EXCEPTION_REGISTRATION = EXCEPTION_REGISTRATION_RECORD   /* winnt.h:4110:43 */
type PEXCEPTION_REGISTRATION = PEXCEPTION_REGISTRATION_RECORD /* winnt.h:4111:44 */

type _NT_TIB = struct {
	ExceptionList        uintptr
	StackBase            PVOID
	StackLimit           PVOID
	SubSystemTib         PVOID
	__16                 struct{ FiberData PVOID }
	ArbitraryUserPointer PVOID
	Self                 uintptr
} /* winnt.h:4116:28 */

type NT_TIB = _NT_TIB  /* winnt.h:4127:7 */
type PNT_TIB = uintptr /* winnt.h:4128:20 */

type _NT_TIB32 = struct {
	ExceptionList        DWORD
	StackBase            DWORD
	StackLimit           DWORD
	SubSystemTib         DWORD
	__16                 struct{ FiberData DWORD }
	ArbitraryUserPointer DWORD
	Self                 DWORD
} /* winnt.h:4131:28 */

type NT_TIB32 = _NT_TIB32 /* winnt.h:4142:7 */
type PNT_TIB32 = uintptr  /* winnt.h:4142:16 */

type _NT_TIB64 = struct {
	ExceptionList        DWORD64
	StackBase            DWORD64
	StackLimit           DWORD64
	SubSystemTib         DWORD64
	__32                 struct{ FiberData DWORD64 }
	ArbitraryUserPointer DWORD64
	Self                 DWORD64
} /* winnt.h:4144:28 */

type NT_TIB64 = _NT_TIB64 /* winnt.h:4155:7 */
type PNT_TIB64 = uintptr  /* winnt.h:4155:16 */

type _UMS_CREATE_THREAD_ATTRIBUTES = struct {
	UmsVersion        DWORD
	UmsContext        PVOID
	UmsCompletionList PVOID
} /* winnt.h:4166:13 */

type UMS_CREATE_THREAD_ATTRIBUTES = _UMS_CREATE_THREAD_ATTRIBUTES /* winnt.h:4170:7 */
type PUMS_CREATE_THREAD_ATTRIBUTES = uintptr                      /* winnt.h:4170:36 */

type _QUOTA_LIMITS = struct {
	PagedPoolLimit        SIZE_T
	NonPagedPoolLimit     SIZE_T
	MinimumWorkingSetSize SIZE_T
	MaximumWorkingSetSize SIZE_T
	PagefileLimit         SIZE_T
	_                     [4]byte
	TimeLimit             LARGE_INTEGER
} /* winnt.h:4172:13 */

type QUOTA_LIMITS = _QUOTA_LIMITS /* winnt.h:4179:7 */
type PQUOTA_LIMITS = uintptr      /* winnt.h:4179:20 */

type _RATE_QUOTA_LIMIT = struct{ RateData DWORD } /* winnt.h:4187:13 */

type RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT /* winnt.h:4193:7 */
type PRATE_QUOTA_LIMIT = uintptr          /* winnt.h:4193:25 */

type _QUOTA_LIMITS_EX = struct {
	PagedPoolLimit        SIZE_T
	NonPagedPoolLimit     SIZE_T
	MinimumWorkingSetSize SIZE_T
	MaximumWorkingSetSize SIZE_T
	PagefileLimit         SIZE_T
	_                     [4]byte
	TimeLimit             LARGE_INTEGER
	WorkingSetLimit       SIZE_T
	Reserved2             SIZE_T
	Reserved3             SIZE_T
	Reserved4             SIZE_T
	Flags                 DWORD
	CpuRateLimit          RATE_QUOTA_LIMIT
} /* winnt.h:4195:13 */

type QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX /* winnt.h:4208:7 */
type PQUOTA_LIMITS_EX = uintptr         /* winnt.h:4208:23 */

type _IO_COUNTERS = struct {
	ReadOperationCount  ULONGLONG
	WriteOperationCount ULONGLONG
	OtherOperationCount ULONGLONG
	ReadTransferCount   ULONGLONG
	WriteTransferCount  ULONGLONG
	OtherTransferCount  ULONGLONG
} /* winnt.h:4210:13 */

type IO_COUNTERS = _IO_COUNTERS /* winnt.h:4217:7 */
type PIO_COUNTERS = uintptr     /* winnt.h:4218:25 */

type HARDWARE_COUNTER_TYPE = uint32   /* winnt.h:4226:7 */
type PHARDWARE_COUNTER_TYPE = uintptr /* winnt.h:4226:30 */

type PROCESS_MITIGATION_POLICY = uint32   /* winnt.h:4241:7 */
type PPROCESS_MITIGATION_POLICY = uintptr /* winnt.h:4241:33 */

type _PROCESS_MITIGATION_ASLR_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4243:13 */

type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY /* winnt.h:4254:7 */
type PPROCESS_MITIGATION_ASLR_POLICY = uintptr                        /* winnt.h:4254:38 */

type _PROCESS_MITIGATION_DEP_POLICY = struct {
	__0       struct{ Flags DWORD }
	Permanent BOOLEAN
	_         [3]byte
} /* winnt.h:4256:13 */

type PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY /* winnt.h:4266:7 */
type PPROCESS_MITIGATION_DEP_POLICY = uintptr                       /* winnt.h:4266:37 */

type _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4268:13 */

type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY /* winnt.h:4277:7 */
type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = uintptr                                       /* winnt.h:4277:53 */

type _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4279:13 */

type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY /* winnt.h:4287:7 */
type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = uintptr                                       /* winnt.h:4287:53 */

type _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4289:13 */

type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY /* winnt.h:4297:7 */
type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = uintptr                                           /* winnt.h:4297:57 */

type _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4299:13 */

type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY /* winnt.h:4309:7 */
type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = uintptr                                      /* winnt.h:4309:53 */

type _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4311:13 */

type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY /* winnt.h:4321:7 */
type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = uintptr                                    /* winnt.h:4321:51 */

type _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = struct {
	__0 struct {
		Flags DWORD
		_     [4]byte
	}
} /* winnt.h:4323:13 */

type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY /* winnt.h:4333:7 */
type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = uintptr                                /* winnt.h:4333:47 */

type _PROCESS_MITIGATION_FONT_DISABLE_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4335:13 */

type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY /* winnt.h:4344:7 */
type PPROCESS_MITIGATION_FONT_DISABLE_POLICY = uintptr                                /* winnt.h:4344:47 */

type _PROCESS_MITIGATION_IMAGE_LOAD_POLICY = struct{ __0 struct{ Flags DWORD } } /* winnt.h:4346:13 */

type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY /* winnt.h:4356:7 */
type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = uintptr                              /* winnt.h:4356:45 */

type _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = struct {
	TotalUserTime             LARGE_INTEGER
	TotalKernelTime           LARGE_INTEGER
	ThisPeriodTotalUserTime   LARGE_INTEGER
	ThisPeriodTotalKernelTime LARGE_INTEGER
	TotalPageFaultCount       DWORD
	TotalProcesses            DWORD
	ActiveProcesses           DWORD
	TotalTerminatedProcesses  DWORD
} /* winnt.h:4358:13 */

type JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION /* winnt.h:4367:7 */
type PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = uintptr                                /* winnt.h:4367:46 */

type _JOBOBJECT_BASIC_LIMIT_INFORMATION = struct {
	PerProcessUserTimeLimit LARGE_INTEGER
	PerJobUserTimeLimit     LARGE_INTEGER
	LimitFlags              DWORD
	MinimumWorkingSetSize   SIZE_T
	MaximumWorkingSetSize   SIZE_T
	ActiveProcessLimit      DWORD
	Affinity                ULONG_PTR
	PriorityClass           DWORD
	SchedulingClass         DWORD
	_                       [4]byte
} /* winnt.h:4369:13 */

type JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION /* winnt.h:4379:7 */
type PJOBOBJECT_BASIC_LIMIT_INFORMATION = uintptr                           /* winnt.h:4379:41 */

type _JOBOBJECT_EXTENDED_LIMIT_INFORMATION = struct {
	BasicLimitInformation JOBOBJECT_BASIC_LIMIT_INFORMATION
	IoInfo                IO_COUNTERS
	ProcessMemoryLimit    SIZE_T
	JobMemoryLimit        SIZE_T
	PeakProcessMemoryUsed SIZE_T
	PeakJobMemoryUsed     SIZE_T
} /* winnt.h:4381:13 */

type JOBOBJECT_EXTENDED_LIMIT_INFORMATION = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION /* winnt.h:4388:7 */
type PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = uintptr                              /* winnt.h:4388:44 */

type _JOBOBJECT_BASIC_PROCESS_ID_LIST = struct {
	NumberOfAssignedProcesses DWORD
	NumberOfProcessIdsInList  DWORD
	ProcessIdList             [1]ULONG_PTR
} /* winnt.h:4390:13 */

type JOBOBJECT_BASIC_PROCESS_ID_LIST = _JOBOBJECT_BASIC_PROCESS_ID_LIST /* winnt.h:4394:7 */
type PJOBOBJECT_BASIC_PROCESS_ID_LIST = uintptr                         /* winnt.h:4394:39 */

type _JOBOBJECT_BASIC_UI_RESTRICTIONS = struct{ UIRestrictionsClass DWORD } /* winnt.h:4396:13 */

type JOBOBJECT_BASIC_UI_RESTRICTIONS = _JOBOBJECT_BASIC_UI_RESTRICTIONS /* winnt.h:4398:7 */
type PJOBOBJECT_BASIC_UI_RESTRICTIONS = uintptr                         /* winnt.h:4398:39 */

type _JOBOBJECT_SECURITY_LIMIT_INFORMATION = struct {
	SecurityLimitFlags DWORD
	JobToken           HANDLE
	SidsToDisable      PTOKEN_GROUPS
	PrivilegesToDelete PTOKEN_PRIVILEGES
	RestrictedSids     PTOKEN_GROUPS
} /* winnt.h:4400:13 */

type JOBOBJECT_SECURITY_LIMIT_INFORMATION = _JOBOBJECT_SECURITY_LIMIT_INFORMATION /* winnt.h:4406:7 */
type PJOBOBJECT_SECURITY_LIMIT_INFORMATION = uintptr                              /* winnt.h:4406:44 */

type _JOBOBJECT_END_OF_JOB_TIME_INFORMATION = struct{ EndOfJobTimeAction DWORD } /* winnt.h:4408:13 */

type JOBOBJECT_END_OF_JOB_TIME_INFORMATION = _JOBOBJECT_END_OF_JOB_TIME_INFORMATION /* winnt.h:4410:7 */
type PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = uintptr                               /* winnt.h:4410:45 */

type _JOBOBJECT_ASSOCIATE_COMPLETION_PORT = struct {
	CompletionKey  PVOID
	CompletionPort HANDLE
} /* winnt.h:4412:13 */

type JOBOBJECT_ASSOCIATE_COMPLETION_PORT = _JOBOBJECT_ASSOCIATE_COMPLETION_PORT /* winnt.h:4415:7 */
type PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = uintptr                             /* winnt.h:4415:43 */

type _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = struct {
	BasicInfo JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
	IoInfo    IO_COUNTERS
} /* winnt.h:4417:13 */

type JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION /* winnt.h:4420:7 */
type PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = uintptr                                       /* winnt.h:4420:53 */

type _JOBOBJECT_JOBSET_INFORMATION = struct{ MemberLevel DWORD } /* winnt.h:4422:13 */

type JOBOBJECT_JOBSET_INFORMATION = _JOBOBJECT_JOBSET_INFORMATION /* winnt.h:4424:7 */
type PJOBOBJECT_JOBSET_INFORMATION = uintptr                      /* winnt.h:4424:36 */

type JOBOBJECT_RATE_CONTROL_TOLERANCE = uint32 /* winnt.h:4430:7 */

type JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = uint32 /* winnt.h:4436:7 */

type _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = struct {
	IoReadBytesLimit             DWORD64
	IoWriteBytesLimit            DWORD64
	PerJobUserTimeLimit          LARGE_INTEGER
	JobMemoryLimit               DWORD64
	RateControlTolerance         JOBOBJECT_RATE_CONTROL_TOLERANCE
	RateControlToleranceInterval JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
	LimitFlags                   DWORD
	_                            [4]byte
} /* winnt.h:4438:13 */

type JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION /* winnt.h:4446:7 */
type PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = uintptr                                  /* winnt.h:4446:48 */

type _JOBOBJECT_LIMIT_VIOLATION_INFORMATION = struct {
	LimitFlags                DWORD
	ViolationLimitFlags       DWORD
	IoReadBytes               DWORD64
	IoReadBytesLimit          DWORD64
	IoWriteBytes              DWORD64
	IoWriteBytesLimit         DWORD64
	PerJobUserTime            LARGE_INTEGER
	PerJobUserTimeLimit       LARGE_INTEGER
	JobMemory                 DWORD64
	JobMemoryLimit            DWORD64
	RateControlTolerance      JOBOBJECT_RATE_CONTROL_TOLERANCE
	RateControlToleranceLimit JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
} /* winnt.h:4448:13 */

type JOBOBJECT_LIMIT_VIOLATION_INFORMATION = _JOBOBJECT_LIMIT_VIOLATION_INFORMATION /* winnt.h:4461:7 */
type PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = uintptr                               /* winnt.h:4461:45 */

type _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = struct {
	ControlFlags DWORD
	__4          struct{ CpuRate DWORD }
} /* winnt.h:4463:13 */

type JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION /* winnt.h:4469:7 */
type PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = uintptr                                /* winnt.h:4469:46 */

type JOBOBJECTINFOCLASS = uint32 /* winnt.h:4573:7 */

type FIRMWARE_TYPE = uint32   /* winnt.h:4580:7 */
type PFIRMWARE_TYPE = uintptr /* winnt.h:4580:21 */

type LOGICAL_PROCESSOR_RELATIONSHIP = uint32 /* winnt.h:4603:7 */

type PROCESSOR_CACHE_TYPE = uint32 /* winnt.h:4609:7 */

type _CACHE_DESCRIPTOR = struct {
	Level         BYTE
	Associativity BYTE
	LineSize      WORD
	Size          DWORD
	Type          PROCESSOR_CACHE_TYPE
} /* winnt.h:4613:13 */

type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR /* winnt.h:4619:7 */
type PCACHE_DESCRIPTOR = uintptr          /* winnt.h:4619:24 */

type _SYSTEM_LOGICAL_PROCESSOR_INFORMATION = struct {
	ProcessorMask ULONG_PTR
	Relationship  LOGICAL_PROCESSOR_RELATIONSHIP
	u             struct {
		_             [0]uint64
		ProcessorCore struct{ Flags BYTE }
		_             [15]byte
	}
} /* winnt.h:4621:13 */

type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION /* winnt.h:4634:7 */
type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = uintptr                              /* winnt.h:4634:44 */

type _PROCESSOR_RELATIONSHIP = struct {
	Flags      BYTE
	Reserved   [21]BYTE
	GroupCount WORD
	GroupMask  [1]GROUP_AFFINITY
} /* winnt.h:4636:13 */

type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP /* winnt.h:4641:7 */
type PPROCESSOR_RELATIONSHIP = uintptr                /* winnt.h:4641:30 */

type _NUMA_NODE_RELATIONSHIP = struct {
	NodeNumber DWORD
	Reserved   [20]BYTE
	GroupMask  GROUP_AFFINITY
} /* winnt.h:4643:13 */

type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP /* winnt.h:4647:7 */
type PNUMA_NODE_RELATIONSHIP = uintptr                /* winnt.h:4647:30 */

type _CACHE_RELATIONSHIP = struct {
	Level         BYTE
	Associativity BYTE
	LineSize      WORD
	CacheSize     DWORD
	Type          PROCESSOR_CACHE_TYPE
	Reserved      [20]BYTE
	GroupMask     GROUP_AFFINITY
} /* winnt.h:4649:13 */

type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP /* winnt.h:4657:7 */
type PCACHE_RELATIONSHIP = uintptr            /* winnt.h:4657:26 */

type _PROCESSOR_GROUP_INFO = struct {
	MaximumProcessorCount BYTE
	ActiveProcessorCount  BYTE
	Reserved              [38]BYTE
	ActiveProcessorMask   KAFFINITY
} /* winnt.h:4659:13 */

type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO /* winnt.h:4664:7 */
type PPROCESSOR_GROUP_INFO = uintptr              /* winnt.h:4664:28 */

type _GROUP_RELATIONSHIP = struct {
	MaximumGroupCount WORD
	ActiveGroupCount  WORD
	Reserved          [20]BYTE
	GroupInfo         [1]PROCESSOR_GROUP_INFO
} /* winnt.h:4666:13 */

type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP /* winnt.h:4671:7 */
type PGROUP_RELATIONSHIP = uintptr            /* winnt.h:4671:26 */

type _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = struct {
	Relationship LOGICAL_PROCESSOR_RELATIONSHIP
	Size         DWORD
	u            struct {
		Processor PROCESSOR_RELATIONSHIP
		_         [32]byte
	}
} /* winnt.h:4673:5 */

type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX /* winnt.h:4684:61 */
type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = uintptr                                 /* winnt.h:4684:101 */

type _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = struct{ CycleTime DWORD64 } /* winnt.h:4686:13 */

type SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION /* winnt.h:4688:7 */
type PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = uintptr                                 /* winnt.h:4688:47 */

type _XSTATE_FEATURE = struct {
	Offset DWORD
	Size   DWORD
} /* winnt.h:4771:13 */

type XSTATE_FEATURE = _XSTATE_FEATURE /* winnt.h:4774:7 */
type PXSTATE_FEATURE = uintptr        /* winnt.h:4774:22 */

type _XSTATE_CONFIGURATION = struct {
	EnabledFeatures         DWORD64
	EnabledVolatileFeatures DWORD64
	Size                    DWORD
	OptimizedSave           uint8 /* DWORD OptimizedSave: 1 */
	_                       [3]byte
	Features                [64]XSTATE_FEATURE
} /* winnt.h:4776:13 */

type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION /* winnt.h:4782:7 */
type PXSTATE_CONFIGURATION = uintptr              /* winnt.h:4782:28 */

type _MEMORY_BASIC_INFORMATION = struct {
	BaseAddress       PVOID
	AllocationBase    PVOID
	AllocationProtect DWORD
	RegionSize        SIZE_T
	State             DWORD
	Protect           DWORD
	Type              DWORD
} /* winnt.h:4784:13 */

type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION /* winnt.h:4792:7 */
type PMEMORY_BASIC_INFORMATION = uintptr                  /* winnt.h:4792:32 */

type _MEMORY_BASIC_INFORMATION32 = struct {
	BaseAddress       DWORD
	AllocationBase    DWORD
	AllocationProtect DWORD
	RegionSize        DWORD
	State             DWORD
	Protect           DWORD
	Type              DWORD
} /* winnt.h:4794:13 */

type MEMORY_BASIC_INFORMATION32 = _MEMORY_BASIC_INFORMATION32 /* winnt.h:4802:7 */
type PMEMORY_BASIC_INFORMATION32 = uintptr                    /* winnt.h:4802:34 */

type _MEMORY_BASIC_INFORMATION64 = struct {
	BaseAddress       ULONGLONG
	AllocationBase    ULONGLONG
	AllocationProtect DWORD
	__alignment1      DWORD
	RegionSize        ULONGLONG
	State             DWORD
	Protect           DWORD
	Type              DWORD
	__alignment2      DWORD
} /* winnt.h:4804:13 */

type MEMORY_BASIC_INFORMATION64 = _MEMORY_BASIC_INFORMATION64 /* winnt.h:4814:7 */
type PMEMORY_BASIC_INFORMATION64 = uintptr                    /* winnt.h:4814:34 */

type FILE_ID_1281 = struct {
	LowPart  ULONGLONG
	HighPart ULONGLONG
} /* winnt.h:4981:13 */

type FILE_ID_128 = FILE_ID_1281 /* winnt.h:4984:7 */
type PFILE_ID_128 = uintptr     /* winnt.h:4984:20 */

type _FILE_NOTIFY_INFORMATION = struct {
	NextEntryOffset DWORD
	Action          DWORD
	FileNameLength  DWORD
	FileName        [1]WCHAR
	_               [2]byte
} /* winnt.h:4986:13 */

type FILE_NOTIFY_INFORMATION = _FILE_NOTIFY_INFORMATION /* winnt.h:4991:7 */
type PFILE_NOTIFY_INFORMATION = uintptr                 /* winnt.h:4991:31 */

type _FILE_SEGMENT_ELEMENT = struct {
	_      [0]uint64
	Buffer PVOID64
	_      [4]byte
} /* winnt.h:4993:13 */

type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT /* winnt.h:4996:7 */
type PFILE_SEGMENT_ELEMENT = uintptr              /* winnt.h:4996:28 */

type _REPARSE_GUID_DATA_BUFFER = struct {
	ReparseTag           DWORD
	ReparseDataLength    WORD
	Reserved             WORD
	ReparseGuid          GUID
	GenericReparseBuffer struct{ DataBuffer [1]BYTE }
	_                    [3]byte
} /* winnt.h:4998:13 */

type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER /* winnt.h:5006:7 */
type PREPARSE_GUID_DATA_BUFFER = uintptr                  /* winnt.h:5006:32 */

type SYSTEM_POWER_STATE = uint32   /* winnt.h:5231:5 */
type PSYSTEM_POWER_STATE = uintptr /* winnt.h:5231:24 */

type POWER_ACTION = uint32   /* winnt.h:5239:5 */
type PPOWER_ACTION = uintptr /* winnt.h:5239:18 */

type DEVICE_POWER_STATE = uint32   /* winnt.h:5244:5 */
type PDEVICE_POWER_STATE = uintptr /* winnt.h:5244:24 */

type MONITOR_DISPLAY_STATE = uint32   /* winnt.h:5248:5 */
type PMONITOR_DISPLAY_STATE = uintptr /* winnt.h:5248:28 */

type USER_ACTIVITY_PRESENCE = uint32   /* winnt.h:5256:5 */
type PUSER_ACTIVITY_PRESENCE = uintptr /* winnt.h:5256:28 */

type EXECUTION_STATE = DWORD    /* winnt.h:5264:17 */
type PEXECUTION_STATE = uintptr /* winnt.h:5264:34 */

type LATENCY_TIME = uint32 /* winnt.h:5268:5 */

type POWER_REQUEST_TYPE = uint32   /* winnt.h:5286:5 */
type PPOWER_REQUEST_TYPE = uintptr /* winnt.h:5286:24 */

type CM_Power_Data_s = struct {
	PD_Size                 DWORD
	PD_MostRecentPowerState DEVICE_POWER_STATE
	PD_Capabilities         DWORD
	PD_D1Latency            DWORD
	PD_D2Latency            DWORD
	PD_D3Latency            DWORD
	PD_PowerStateMapping    [7]DEVICE_POWER_STATE
	PD_DeepestSystemWake    SYSTEM_POWER_STATE
} /* winnt.h:5298:13 */

type CM_POWER_DATA = CM_Power_Data_s /* winnt.h:5307:7 */
type PCM_POWER_DATA = uintptr        /* winnt.h:5307:21 */

type POWER_INFORMATION_LEVEL = uint32 /* winnt.h:5391:7 */

type POWER_USER_PRESENCE_TYPE = uint32   /* winnt.h:5397:7 */
type PPOWER_USER_PRESENCE_TYPE = uintptr /* winnt.h:5397:32 */

type _POWER_USER_PRESENCE = struct{ UserPresence POWER_USER_PRESENCE_TYPE } /* winnt.h:5399:13 */

type POWER_USER_PRESENCE = _POWER_USER_PRESENCE /* winnt.h:5401:7 */
type PPOWER_USER_PRESENCE = uintptr             /* winnt.h:5401:27 */

type _POWER_SESSION_CONNECT = struct {
	Connected BOOLEAN
	Console   BOOLEAN
} /* winnt.h:5403:13 */

type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT /* winnt.h:5406:7 */
type PPOWER_SESSION_CONNECT = uintptr               /* winnt.h:5406:29 */

type _POWER_SESSION_TIMEOUTS = struct {
	InputTimeout   DWORD
	DisplayTimeout DWORD
} /* winnt.h:5408:13 */

type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS /* winnt.h:5411:7 */
type PPOWER_SESSION_TIMEOUTS = uintptr                /* winnt.h:5411:30 */

type _POWER_SESSION_RIT_STATE = struct {
	Active        BOOLEAN
	_             [3]byte
	LastInputTime DWORD
} /* winnt.h:5413:13 */

type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE /* winnt.h:5416:7 */
type PPOWER_SESSION_RIT_STATE = uintptr                 /* winnt.h:5416:31 */

type _POWER_SESSION_WINLOGON = struct {
	SessionId DWORD
	Console   BOOLEAN
	Locked    BOOLEAN
	_         [2]byte
} /* winnt.h:5418:13 */

type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON /* winnt.h:5422:7 */
type PPOWER_SESSION_WINLOGON = uintptr                /* winnt.h:5422:30 */

type _POWER_IDLE_RESILIENCY = struct {
	CoalescingTimeout    DWORD
	IdleResiliencyPeriod DWORD
} /* winnt.h:5424:13 */

type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY /* winnt.h:5427:7 */
type PPOWER_IDLE_RESILIENCY = uintptr               /* winnt.h:5427:29 */

type POWER_MONITOR_REQUEST_REASON = uint32 /* winnt.h:5445:7 */

type _POWER_MONITOR_INVOCATION = struct {
	On            BOOLEAN
	Console       BOOLEAN
	_             [2]byte
	RequestReason POWER_MONITOR_REQUEST_REASON
} /* winnt.h:5447:13 */

type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION /* winnt.h:5451:7 */
type PPOWER_MONITOR_INVOCATION = uintptr                  /* winnt.h:5451:32 */

type _RESUME_PERFORMANCE = struct {
	PostTimeMs              DWORD
	_                       [4]byte
	TotalResumeTimeMs       ULONGLONG
	ResumeCompleteTimestamp ULONGLONG
} /* winnt.h:5453:13 */

type RESUME_PERFORMANCE = _RESUME_PERFORMANCE /* winnt.h:5457:7 */
type PRESUME_PERFORMANCE = uintptr            /* winnt.h:5457:26 */

type SYSTEM_POWER_CONDITION = uint32 /* winnt.h:5464:7 */

type SET_POWER_SETTING_VALUE = struct {
	Version        DWORD
	Guid           GUID
	PowerCondition SYSTEM_POWER_CONDITION
	DataLength     DWORD
	Data           [1]BYTE
	_              [3]byte
}                                       /* winnt.h:5472:7 */
type PSET_POWER_SETTING_VALUE = uintptr /* winnt.h:5472:31 */

type NOTIFY_USER_POWER_SETTING = struct{ Guid GUID } /* winnt.h:5478:7 */
type PNOTIFY_USER_POWER_SETTING = uintptr            /* winnt.h:5478:33 */

type _APPLICATIONLAUNCH_SETTING_VALUE = struct {
	ActivationTime   LARGE_INTEGER
	Flags            DWORD
	ButtonInstanceID DWORD
} /* winnt.h:5480:13 */

type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE /* winnt.h:5484:7 */
type PAPPLICATIONLAUNCH_SETTING_VALUE = uintptr                         /* winnt.h:5484:39 */

type POWER_PLATFORM_ROLE = uint32   /* winnt.h:5497:7 */
type PPOWER_PLATFORM_ROLE = uintptr /* winnt.h:5497:27 */

type _POWER_PLATFORM_INFORMATION = struct{ AoAc BOOLEAN } /* winnt.h:5499:13 */

type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION /* winnt.h:5501:7 */
type PPOWER_PLATFORM_INFORMATION = uintptr                    /* winnt.h:5501:34 */

type BATTERY_REPORTING_SCALE = struct {
	Granularity DWORD
	Capacity    DWORD
}                                       /* winnt.h:5520:7 */
type PBATTERY_REPORTING_SCALE = uintptr /* winnt.h:5520:31 */

type PPM_WMI_LEGACY_PERFSTATE = struct {
	Frequency        DWORD
	Flags            DWORD
	PercentFrequency DWORD
}                                        /* winnt.h:5526:7 */
type PPPM_WMI_LEGACY_PERFSTATE = uintptr /* winnt.h:5526:32 */

type PPM_WMI_IDLE_STATE = struct {
	Latency        DWORD
	Power          DWORD
	TimeCheck      DWORD
	PromotePercent BYTE
	DemotePercent  BYTE
	StateType      BYTE
	Reserved       BYTE
	StateFlags     DWORD
	Context        DWORD
	IdleHandler    DWORD
	Reserved1      DWORD
}                                  /* winnt.h:5540:7 */
type PPPM_WMI_IDLE_STATE = uintptr /* winnt.h:5540:26 */

type PPM_WMI_IDLE_STATES = struct {
	Type             DWORD
	Count            DWORD
	TargetState      DWORD
	OldState         DWORD
	TargetProcessors DWORD64
	State            [1]PPM_WMI_IDLE_STATE
}                                   /* winnt.h:5549:7 */
type PPPM_WMI_IDLE_STATES = uintptr /* winnt.h:5549:27 */

type PPM_WMI_IDLE_STATES_EX = struct {
	Type             DWORD
	Count            DWORD
	TargetState      DWORD
	OldState         DWORD
	TargetProcessors PVOID
	State            [1]PPM_WMI_IDLE_STATE
}                                      /* winnt.h:5558:7 */
type PPPM_WMI_IDLE_STATES_EX = uintptr /* winnt.h:5558:30 */

type PPM_WMI_PERF_STATE = struct {
	Frequency        DWORD
	Power            DWORD
	PercentFrequency BYTE
	IncreaseLevel    BYTE
	DecreaseLevel    BYTE
	Type             BYTE
	IncreaseTime     DWORD
	DecreaseTime     DWORD
	_                [4]byte
	Control          DWORD64
	Status           DWORD64
	HitCount         DWORD
	Reserved1        DWORD
	Reserved2        DWORD64
	Reserved3        DWORD64
}                                  /* winnt.h:5575:7 */
type PPPM_WMI_PERF_STATE = uintptr /* winnt.h:5575:26 */

type PPM_WMI_PERF_STATES = struct {
	Count             DWORD
	MaxFrequency      DWORD
	CurrentState      DWORD
	MaxPerfState      DWORD
	MinPerfState      DWORD
	LowestPerfState   DWORD
	ThermalConstraint DWORD
	BusyAdjThreshold  BYTE
	PolicyType        BYTE
	Type              BYTE
	Reserved          BYTE
	TimerInterval     DWORD
	_                 [4]byte
	TargetProcessors  DWORD64
	PStateHandler     DWORD
	PStateContext     DWORD
	TStateHandler     DWORD
	TStateContext     DWORD
	FeedbackHandler   DWORD
	Reserved1         DWORD
	Reserved2         DWORD64
	State             [1]PPM_WMI_PERF_STATE
}                                   /* winnt.h:5599:7 */
type PPPM_WMI_PERF_STATES = uintptr /* winnt.h:5599:27 */

type PPM_WMI_PERF_STATES_EX = struct {
	Count             DWORD
	MaxFrequency      DWORD
	CurrentState      DWORD
	MaxPerfState      DWORD
	MinPerfState      DWORD
	LowestPerfState   DWORD
	ThermalConstraint DWORD
	BusyAdjThreshold  BYTE
	PolicyType        BYTE
	Type              BYTE
	Reserved          BYTE
	TimerInterval     DWORD
	TargetProcessors  PVOID
	PStateHandler     DWORD
	PStateContext     DWORD
	TStateHandler     DWORD
	TStateContext     DWORD
	FeedbackHandler   DWORD
	Reserved1         DWORD
	Reserved2         DWORD64
	State             [1]PPM_WMI_PERF_STATE
}                                      /* winnt.h:5623:7 */
type PPPM_WMI_PERF_STATES_EX = uintptr /* winnt.h:5623:30 */

type PPM_IDLE_STATE_ACCOUNTING = struct {
	IdleTransitions    DWORD
	FailedTransitions  DWORD
	InvalidBucketIndex DWORD
	_                  [4]byte
	TotalTime          DWORD64
	IdleTimeBuckets    [6]DWORD
}                                         /* winnt.h:5634:7 */
type PPPM_IDLE_STATE_ACCOUNTING = uintptr /* winnt.h:5634:33 */

type PPM_IDLE_ACCOUNTING = struct {
	StateCount       DWORD
	TotalTransitions DWORD
	ResetCount       DWORD
	_                [4]byte
	StartTime        DWORD64
	State            [1]PPM_IDLE_STATE_ACCOUNTING
}                                   /* winnt.h:5642:7 */
type PPPM_IDLE_ACCOUNTING = uintptr /* winnt.h:5642:27 */

type PPM_IDLE_STATE_BUCKET_EX = struct {
	TotalTimeUs DWORD64
	MinTimeUs   DWORD
	MaxTimeUs   DWORD
	Count       DWORD
	_           [4]byte
}                                        /* winnt.h:5649:7 */
type PPPM_IDLE_STATE_BUCKET_EX = uintptr /* winnt.h:5649:32 */

type PPM_IDLE_STATE_ACCOUNTING_EX = struct {
	TotalTime            DWORD64
	IdleTransitions      DWORD
	FailedTransitions    DWORD
	InvalidBucketIndex   DWORD
	MinTimeUs            DWORD
	MaxTimeUs            DWORD
	CancelledTransitions DWORD
	IdleTimeBuckets      [16]PPM_IDLE_STATE_BUCKET_EX
}                                            /* winnt.h:5660:7 */
type PPPM_IDLE_STATE_ACCOUNTING_EX = uintptr /* winnt.h:5660:36 */

type PPM_IDLE_ACCOUNTING_EX = struct {
	StateCount       DWORD
	TotalTransitions DWORD
	ResetCount       DWORD
	AbortCount       DWORD
	StartTime        DWORD64
	State            [1]PPM_IDLE_STATE_ACCOUNTING_EX
}                                      /* winnt.h:5669:7 */
type PPPM_IDLE_ACCOUNTING_EX = uintptr /* winnt.h:5669:30 */

type PPM_PERFSTATE_EVENT = struct {
	State     DWORD
	Status    DWORD
	Latency   DWORD
	Speed     DWORD
	Processor DWORD
}                                   /* winnt.h:5713:7 */
type PPPM_PERFSTATE_EVENT = uintptr /* winnt.h:5713:27 */

type PPM_PERFSTATE_DOMAIN_EVENT = struct {
	State      DWORD
	Latency    DWORD
	Speed      DWORD
	_          [4]byte
	Processors DWORD64
}                                          /* winnt.h:5720:7 */
type PPPM_PERFSTATE_DOMAIN_EVENT = uintptr /* winnt.h:5720:34 */

type PPM_IDLESTATE_EVENT = struct {
	NewState   DWORD
	OldState   DWORD
	Processors DWORD64
}                                   /* winnt.h:5726:7 */
type PPPM_IDLESTATE_EVENT = uintptr /* winnt.h:5726:27 */

type PPM_THERMALCHANGE_EVENT = struct {
	ThermalConstraint DWORD
	_                 [4]byte
	Processors        DWORD64
}                                       /* winnt.h:5731:7 */
type PPPM_THERMALCHANGE_EVENT = uintptr /* winnt.h:5731:31 */
type PPM_THERMAL_POLICY_EVENT = struct {
	Mode       BYTE
	_          [7]byte
	Processors DWORD64
}                                        /* winnt.h:5735:7 */
type PPPM_THERMAL_POLICY_EVENT = uintptr /* winnt.h:5735:32 */

type POWER_ACTION_POLICY = struct {
	Action    POWER_ACTION
	Flags     DWORD
	EventCode DWORD
}                                   /* winnt.h:5752:7 */
type PPOWER_ACTION_POLICY = uintptr /* winnt.h:5752:27 */

type PROCESSOR_IDLESTATE_INFO = struct {
	TimeCheck      DWORD
	DemotePercent  BYTE
	PromotePercent BYTE
	Spare          [2]BYTE
}                                        /* winnt.h:5787:7 */
type PPROCESSOR_IDLESTATE_INFO = uintptr /* winnt.h:5787:32 */

type SYSTEM_POWER_LEVEL = struct {
	Enable         BOOLEAN
	Spare          [3]BYTE
	BatteryLevel   DWORD
	PowerPolicy    POWER_ACTION_POLICY
	MinSystemState SYSTEM_POWER_STATE
}                                  /* winnt.h:5795:7 */
type PSYSTEM_POWER_LEVEL = uintptr /* winnt.h:5795:26 */

type _SYSTEM_POWER_POLICY = struct {
	Revision                    DWORD
	PowerButton                 POWER_ACTION_POLICY
	SleepButton                 POWER_ACTION_POLICY
	LidClose                    POWER_ACTION_POLICY
	LidOpenWake                 SYSTEM_POWER_STATE
	Reserved                    DWORD
	Idle                        POWER_ACTION_POLICY
	IdleTimeout                 DWORD
	IdleSensitivity             BYTE
	DynamicThrottle             BYTE
	Spare2                      [2]BYTE
	MinSleep                    SYSTEM_POWER_STATE
	MaxSleep                    SYSTEM_POWER_STATE
	ReducedLatencySleep         SYSTEM_POWER_STATE
	WinLogonFlags               DWORD
	Spare3                      DWORD
	DozeS4Timeout               DWORD
	BroadcastCapacityResolution DWORD
	DischargePolicy             [4]SYSTEM_POWER_LEVEL
	VideoTimeout                DWORD
	VideoDimDisplay             BOOLEAN
	_                           [3]byte
	VideoReserved               [3]DWORD
	SpindownTimeout             DWORD
	OptimizeForPower            BOOLEAN
	FanThrottleTolerance        BYTE
	ForcedThrottle              BYTE
	MinThrottle                 BYTE
	OverThrottled               POWER_ACTION_POLICY
} /* winnt.h:5797:13 */

type SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY /* winnt.h:5826:7 */
type PSYSTEM_POWER_POLICY = uintptr             /* winnt.h:5826:27 */

type PROCESSOR_IDLESTATE_POLICY = struct {
	Revision    WORD
	Flags       struct{ AsWORD WORD }
	PolicyCount DWORD
	Policy      [3]PROCESSOR_IDLESTATE_INFO
}                                          /* winnt.h:5846:7 */
type PPROCESSOR_IDLESTATE_POLICY = uintptr /* winnt.h:5846:34 */

type _PROCESSOR_POWER_POLICY_INFO = struct {
	TimeCheck      DWORD
	DemoteLimit    DWORD
	PromoteLimit   DWORD
	DemotePercent  BYTE
	PromotePercent BYTE
	Spare          [2]BYTE
	AllowDemotion  uint32 /* DWORD AllowDemotion: 1, DWORD AllowPromotion: 1, DWORD Reserved: 30 */
} /* winnt.h:5848:13 */

type PROCESSOR_POWER_POLICY_INFO = _PROCESSOR_POWER_POLICY_INFO /* winnt.h:5858:7 */
type PPROCESSOR_POWER_POLICY_INFO = uintptr                     /* winnt.h:5858:35 */

type _PROCESSOR_POWER_POLICY = struct {
	Revision        DWORD
	DynamicThrottle BYTE
	Spare           [3]BYTE
	DisableCStates  uint32 /* DWORD DisableCStates: 1, DWORD Reserved: 31 */
	PolicyCount     DWORD
	Policy          [3]PROCESSOR_POWER_POLICY_INFO
} /* winnt.h:5860:13 */

type PROCESSOR_POWER_POLICY = _PROCESSOR_POWER_POLICY /* winnt.h:5868:7 */
type PPROCESSOR_POWER_POLICY = uintptr                /* winnt.h:5868:30 */

type PROCESSOR_PERFSTATE_POLICY = struct {
	Revision         DWORD
	MaxThrottle      BYTE
	MinThrottle      BYTE
	BusyAdjThreshold BYTE
	u                struct{ Spare BYTE }
	TimeCheck        DWORD
	IncreaseTime     DWORD
	DecreaseTime     DWORD
	IncreasePercent  DWORD
	DecreasePercent  DWORD
}                                          /* winnt.h:5892:7 */
type PPROCESSOR_PERFSTATE_POLICY = uintptr /* winnt.h:5892:34 */

type _ADMINISTRATOR_POWER_POLICY = struct {
	MinSleep           SYSTEM_POWER_STATE
	MaxSleep           SYSTEM_POWER_STATE
	MinVideoTimeout    DWORD
	MaxVideoTimeout    DWORD
	MinSpindownTimeout DWORD
	MaxSpindownTimeout DWORD
} /* winnt.h:5894:13 */

type ADMINISTRATOR_POWER_POLICY = _ADMINISTRATOR_POWER_POLICY /* winnt.h:5901:7 */
type PADMINISTRATOR_POWER_POLICY = uintptr                    /* winnt.h:5901:34 */

type SYSTEM_POWER_CAPABILITIES = struct {
	PowerButtonPresent     BOOLEAN
	SleepButtonPresent     BOOLEAN
	LidPresent             BOOLEAN
	SystemS1               BOOLEAN
	SystemS2               BOOLEAN
	SystemS3               BOOLEAN
	SystemS4               BOOLEAN
	SystemS5               BOOLEAN
	HiberFilePresent       BOOLEAN
	FullWake               BOOLEAN
	VideoDimPresent        BOOLEAN
	ApmPresent             BOOLEAN
	UpsPresent             BOOLEAN
	ThermalControl         BOOLEAN
	ProcessorThrottle      BOOLEAN
	ProcessorMinThrottle   BYTE
	ProcessorMaxThrottle   BYTE
	FastSystemS4           BOOLEAN
	spare2                 [3]BYTE
	DiskSpinDown           BOOLEAN
	spare3                 [8]BYTE
	SystemBatteriesPresent BOOLEAN
	BatteriesAreShortTerm  BOOLEAN
	BatteryScale           [3]BATTERY_REPORTING_SCALE
	AcOnLineWake           SYSTEM_POWER_STATE
	SoftLidWake            SYSTEM_POWER_STATE
	RtcWake                SYSTEM_POWER_STATE
	MinDeviceWakeState     SYSTEM_POWER_STATE
	DefaultLowLatencyWake  SYSTEM_POWER_STATE
}                                         /* winnt.h:5933:7 */
type PSYSTEM_POWER_CAPABILITIES = uintptr /* winnt.h:5933:33 */

type SYSTEM_BATTERY_STATE = struct {
	AcOnLine          BOOLEAN
	BatteryPresent    BOOLEAN
	Charging          BOOLEAN
	Discharging       BOOLEAN
	Spare1            [4]BOOLEAN
	MaxCapacity       DWORD
	RemainingCapacity DWORD
	Rate              DWORD
	EstimatedTime     DWORD
	DefaultAlert1     DWORD
	DefaultAlert2     DWORD
}                                    /* winnt.h:5947:7 */
type PSYSTEM_BATTERY_STATE = uintptr /* winnt.h:5947:28 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _IMAGE_DOS_HEADER = struct {
	e_magic    WORD
	e_cblp     WORD
	e_cp       WORD
	e_crlc     WORD
	e_cparhdr  WORD
	e_minalloc WORD
	e_maxalloc WORD
	e_ss       WORD
	e_sp       WORD
	e_csum     WORD
	e_ip       WORD
	e_cs       WORD
	e_lfarlc   WORD
	e_ovno     WORD
	e_res      [4]WORD
	e_oemid    WORD
	e_oeminfo  WORD
	e_res2     [10]WORD
	e_lfanew   LONG
} /* winnt.h:5959:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER /* winnt.h:5979:7 */
type PIMAGE_DOS_HEADER = uintptr          /* winnt.h:5979:24 */

type _IMAGE_OS2_HEADER = struct {
	ne_magic        WORD
	ne_ver          CHAR
	ne_rev          CHAR
	ne_enttab       WORD
	ne_cbenttab     WORD
	ne_crc          LONG
	ne_flags        WORD
	ne_autodata     WORD
	ne_heap         WORD
	ne_stack        WORD
	ne_csip         LONG
	ne_sssp         LONG
	ne_cseg         WORD
	ne_cmod         WORD
	ne_cbnrestab    WORD
	ne_segtab       WORD
	ne_rsrctab      WORD
	ne_restab       WORD
	ne_modtab       WORD
	ne_imptab       WORD
	ne_nrestab      LONG
	ne_cmovent      WORD
	ne_align        WORD
	ne_cres         WORD
	ne_exetyp       BYTE
	ne_flagsothers  BYTE
	ne_pretthunks   WORD
	ne_psegrefbytes WORD
	ne_swaparea     WORD
	ne_expver       WORD
} /* winnt.h:5981:13 */

type IMAGE_OS2_HEADER = _IMAGE_OS2_HEADER /* winnt.h:6012:7 */
type PIMAGE_OS2_HEADER = uintptr          /* winnt.h:6012:24 */

type _IMAGE_VXD_HEADER = struct {
	e32_magic        WORD
	e32_border       BYTE
	e32_worder       BYTE
	e32_level        DWORD
	e32_cpu          WORD
	e32_os           WORD
	e32_ver          DWORD
	e32_mflags       DWORD
	e32_mpages       DWORD
	e32_startobj     DWORD
	e32_eip          DWORD
	e32_stackobj     DWORD
	e32_esp          DWORD
	e32_pagesize     DWORD
	e32_lastpagesize DWORD
	e32_fixupsize    DWORD
	e32_fixupsum     DWORD
	e32_ldrsize      DWORD
	e32_ldrsum       DWORD
	e32_objtab       DWORD
	e32_objcnt       DWORD
	e32_objmap       DWORD
	e32_itermap      DWORD
	e32_rsrctab      DWORD
	e32_rsrccnt      DWORD
	e32_restab       DWORD
	e32_enttab       DWORD
	e32_dirtab       DWORD
	e32_dircnt       DWORD
	e32_fpagetab     DWORD
	e32_frectab      DWORD
	e32_impmod       DWORD
	e32_impmodcnt    DWORD
	e32_impproc      DWORD
	e32_pagesum      DWORD
	e32_datapage     DWORD
	e32_preload      DWORD
	e32_nrestab      DWORD
	e32_cbnrestab    DWORD
	e32_nressum      DWORD
	e32_autodata     DWORD
	e32_debuginfo    DWORD
	e32_debuglen     DWORD
	e32_instpreload  DWORD
	e32_instdemand   DWORD
	e32_heapsize     DWORD
	e32_res3         [12]BYTE
	e32_winresoff    DWORD
	e32_winreslen    DWORD
	e32_devid        WORD
	e32_ddkver       WORD
} /* winnt.h:6014:13 */

type IMAGE_VXD_HEADER = _IMAGE_VXD_HEADER /* winnt.h:6066:7 */
type PIMAGE_VXD_HEADER = uintptr          /* winnt.h:6066:24 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _IMAGE_FILE_HEADER = struct {
	Machine              WORD
	NumberOfSections     WORD
	TimeDateStamp        DWORD
	PointerToSymbolTable DWORD
	NumberOfSymbols      DWORD
	SizeOfOptionalHeader WORD
	Characteristics      WORD
} /* winnt.h:6070:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER /* winnt.h:6078:7 */
type PIMAGE_FILE_HEADER = uintptr           /* winnt.h:6078:25 */

type _IMAGE_DATA_DIRECTORY = struct {
	VirtualAddress DWORD
	Size           DWORD
} /* winnt.h:6131:13 */

type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY /* winnt.h:6134:7 */
type PIMAGE_DATA_DIRECTORY = uintptr              /* winnt.h:6134:28 */

type _IMAGE_OPTIONAL_HEADER = struct {
	Magic                       WORD
	MajorLinkerVersion          BYTE
	MinorLinkerVersion          BYTE
	SizeOfCode                  DWORD
	SizeOfInitializedData       DWORD
	SizeOfUninitializedData     DWORD
	AddressOfEntryPoint         DWORD
	BaseOfCode                  DWORD
	BaseOfData                  DWORD
	ImageBase                   DWORD
	SectionAlignment            DWORD
	FileAlignment               DWORD
	MajorOperatingSystemVersion WORD
	MinorOperatingSystemVersion WORD
	MajorImageVersion           WORD
	MinorImageVersion           WORD
	MajorSubsystemVersion       WORD
	MinorSubsystemVersion       WORD
	Win32VersionValue           DWORD
	SizeOfImage                 DWORD
	SizeOfHeaders               DWORD
	CheckSum                    DWORD
	Subsystem                   WORD
	DllCharacteristics          WORD
	SizeOfStackReserve          DWORD
	SizeOfStackCommit           DWORD
	SizeOfHeapReserve           DWORD
	SizeOfHeapCommit            DWORD
	LoaderFlags                 DWORD
	NumberOfRvaAndSizes         DWORD
	DataDirectory               [16]IMAGE_DATA_DIRECTORY
} /* winnt.h:6138:13 */

type IMAGE_OPTIONAL_HEADER32 = _IMAGE_OPTIONAL_HEADER /* winnt.h:6171:7 */
type PIMAGE_OPTIONAL_HEADER32 = uintptr               /* winnt.h:6171:31 */

type _IMAGE_ROM_OPTIONAL_HEADER = struct {
	Magic                   WORD
	MajorLinkerVersion      BYTE
	MinorLinkerVersion      BYTE
	SizeOfCode              DWORD
	SizeOfInitializedData   DWORD
	SizeOfUninitializedData DWORD
	AddressOfEntryPoint     DWORD
	BaseOfCode              DWORD
	BaseOfData              DWORD
	BaseOfBss               DWORD
	GprMask                 DWORD
	CprMask                 [4]DWORD
	GpValue                 DWORD
} /* winnt.h:6173:13 */

type IMAGE_ROM_OPTIONAL_HEADER = _IMAGE_ROM_OPTIONAL_HEADER /* winnt.h:6187:7 */
type PIMAGE_ROM_OPTIONAL_HEADER = uintptr                   /* winnt.h:6187:33 */

type _IMAGE_OPTIONAL_HEADER64 = struct {
	Magic                       WORD
	MajorLinkerVersion          BYTE
	MinorLinkerVersion          BYTE
	SizeOfCode                  DWORD
	SizeOfInitializedData       DWORD
	SizeOfUninitializedData     DWORD
	AddressOfEntryPoint         DWORD
	BaseOfCode                  DWORD
	ImageBase                   ULONGLONG
	SectionAlignment            DWORD
	FileAlignment               DWORD
	MajorOperatingSystemVersion WORD
	MinorOperatingSystemVersion WORD
	MajorImageVersion           WORD
	MinorImageVersion           WORD
	MajorSubsystemVersion       WORD
	MinorSubsystemVersion       WORD
	Win32VersionValue           DWORD
	SizeOfImage                 DWORD
	SizeOfHeaders               DWORD
	CheckSum                    DWORD
	Subsystem                   WORD
	DllCharacteristics          WORD
	SizeOfStackReserve          ULONGLONG
	SizeOfStackCommit           ULONGLONG
	SizeOfHeapReserve           ULONGLONG
	SizeOfHeapCommit            ULONGLONG
	LoaderFlags                 DWORD
	NumberOfRvaAndSizes         DWORD
	DataDirectory               [16]IMAGE_DATA_DIRECTORY
} /* winnt.h:6189:13 */

type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64 /* winnt.h:6220:7 */
type PIMAGE_OPTIONAL_HEADER64 = uintptr                 /* winnt.h:6220:31 */

type IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER32   /* winnt.h:6237:37 */
type PIMAGE_OPTIONAL_HEADER = PIMAGE_OPTIONAL_HEADER32 /* winnt.h:6238:38 */

type _IMAGE_NT_HEADERS64 = struct {
	Signature      DWORD
	FileHeader     IMAGE_FILE_HEADER
	OptionalHeader IMAGE_OPTIONAL_HEADER64
} /* winnt.h:6243:13 */

type IMAGE_NT_HEADERS64 = _IMAGE_NT_HEADERS64 /* winnt.h:6247:7 */
type PIMAGE_NT_HEADERS64 = uintptr            /* winnt.h:6247:26 */

type _IMAGE_NT_HEADERS = struct {
	Signature      DWORD
	FileHeader     IMAGE_FILE_HEADER
	OptionalHeader IMAGE_OPTIONAL_HEADER32
} /* winnt.h:6249:13 */

type IMAGE_NT_HEADERS32 = _IMAGE_NT_HEADERS /* winnt.h:6253:7 */
type PIMAGE_NT_HEADERS32 = uintptr          /* winnt.h:6253:26 */

type _IMAGE_ROM_HEADERS = struct {
	FileHeader     IMAGE_FILE_HEADER
	OptionalHeader IMAGE_ROM_OPTIONAL_HEADER
} /* winnt.h:6255:13 */

type IMAGE_ROM_HEADERS = _IMAGE_ROM_HEADERS /* winnt.h:6258:7 */
type PIMAGE_ROM_HEADERS = uintptr           /* winnt.h:6258:25 */

type IMAGE_NT_HEADERS = IMAGE_NT_HEADERS32   /* winnt.h:6264:32 */
type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS32 /* winnt.h:6265:33 */

type ANON_OBJECT_HEADER1 = struct {
	Sig1          WORD
	Sig2          WORD
	Version       WORD
	Machine       WORD
	TimeDateStamp DWORD
	ClassID       CLSID
	SizeOfData    DWORD
} /* winnt.h:6313:13 */

type ANON_OBJECT_HEADER = ANON_OBJECT_HEADER1 /* winnt.h:6321:7 */

type ANON_OBJECT_HEADER_V21 = struct {
	Sig1           WORD
	Sig2           WORD
	Version        WORD
	Machine        WORD
	TimeDateStamp  DWORD
	ClassID        CLSID
	SizeOfData     DWORD
	Flags          DWORD
	MetaDataSize   DWORD
	MetaDataOffset DWORD
} /* winnt.h:6323:13 */

type ANON_OBJECT_HEADER_V2 = ANON_OBJECT_HEADER_V21 /* winnt.h:6334:7 */

type ANON_OBJECT_HEADER_BIGOBJ1 = struct {
	Sig1                 WORD
	Sig2                 WORD
	Version              WORD
	Machine              WORD
	TimeDateStamp        DWORD
	ClassID              CLSID
	SizeOfData           DWORD
	Flags                DWORD
	MetaDataSize         DWORD
	MetaDataOffset       DWORD
	NumberOfSections     DWORD
	PointerToSymbolTable DWORD
	NumberOfSymbols      DWORD
} /* winnt.h:6336:13 */

type ANON_OBJECT_HEADER_BIGOBJ = ANON_OBJECT_HEADER_BIGOBJ1 /* winnt.h:6350:7 */

type _IMAGE_SECTION_HEADER = struct {
	Name                 [8]BYTE
	Misc                 struct{ PhysicalAddress DWORD }
	VirtualAddress       DWORD
	SizeOfRawData        DWORD
	PointerToRawData     DWORD
	PointerToRelocations DWORD
	PointerToLinenumbers DWORD
	NumberOfRelocations  WORD
	NumberOfLinenumbers  WORD
	Characteristics      DWORD
} /* winnt.h:6354:13 */

type IMAGE_SECTION_HEADER = _IMAGE_SECTION_HEADER /* winnt.h:6368:7 */
type PIMAGE_SECTION_HEADER = uintptr              /* winnt.h:6368:28 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type _IMAGE_SYMBOL = struct {
	N struct {
		_         [0]uint32
		ShortName [8]BYTE
	}
	Value              DWORD
	SectionNumber      SHORT
	Type               WORD
	StorageClass       BYTE
	NumberOfAuxSymbols BYTE
	_                  [2]byte
} /* winnt.h:6418:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type IMAGE_SYMBOL = _IMAGE_SYMBOL /* winnt.h:6432:7 */
type PIMAGE_SYMBOL = uintptr      /* winnt.h:6433:36 */

type _IMAGE_SYMBOL_EX = struct {
	N struct {
		_         [0]uint32
		ShortName [8]BYTE
	}
	Value              DWORD
	SectionNumber      LONG
	Type               WORD
	StorageClass       BYTE
	NumberOfAuxSymbols BYTE
} /* winnt.h:6437:13 */

type IMAGE_SYMBOL_EX = _IMAGE_SYMBOL_EX /* winnt.h:6451:7 */
type PIMAGE_SYMBOL_EX = uintptr         /* winnt.h:6451:33 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type IMAGE_AUX_SYMBOL_TOKEN_DEF1 = struct {
	bAuxType         BYTE
	bReserved        BYTE
	_                [2]byte
	SymbolTableIndex DWORD
	rgbReserved      [12]BYTE
} /* winnt.h:6544:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type IMAGE_AUX_SYMBOL_TOKEN_DEF = IMAGE_AUX_SYMBOL_TOKEN_DEF1 /* winnt.h:6549:7 */
type PIMAGE_AUX_SYMBOL_TOKEN_DEF = uintptr                    /* winnt.h:6549:44 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _IMAGE_AUX_SYMBOL = struct {
	Sym struct {
		TagIndex DWORD
		Misc     struct {
			_    [0]uint32
			LnSz struct {
				Linenumber WORD
				Size       WORD
			}
		}
		FcnAry struct {
			Function struct {
				PointerToLinenumber   DWORD
				PointerToNextFunction DWORD
			}
		}
		TvIndex WORD
		_       [2]byte
	}
} /* winnt.h:6552:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMAGE_AUX_SYMBOL = _IMAGE_AUX_SYMBOL /* winnt.h:6589:7 */
type PIMAGE_AUX_SYMBOL = uintptr          /* winnt.h:6589:34 */

type _IMAGE_AUX_SYMBOL_EX = struct {
	Sym struct {
		WeakDefaultSymIndex DWORD
		WeakSearchType      DWORD
		rgbReserved         [12]BYTE
	}
	_ [4]byte
} /* winnt.h:6591:13 */

type IMAGE_AUX_SYMBOL_EX = _IMAGE_AUX_SYMBOL_EX /* winnt.h:6619:7 */
type PIMAGE_AUX_SYMBOL_EX = uintptr             /* winnt.h:6619:37 */

type IMAGE_AUX_SYMBOL_TYPE = uint32 /* winnt.h:6625:7 */

type _IMAGE_RELOCATION = struct {
	u                struct{ VirtualAddress DWORD }
	SymbolTableIndex DWORD
	Type             WORD
	_                [2]byte
} /* winnt.h:6639:13 */

type IMAGE_RELOCATION = _IMAGE_RELOCATION /* winnt.h:6646:7 */
type PIMAGE_RELOCATION = uintptr          /* winnt.h:6647:40 */

type _IMAGE_LINENUMBER = struct {
	Type       struct{ SymbolTableIndex DWORD }
	Linenumber WORD
	_          [2]byte
} /* winnt.h:6977:13 */

type IMAGE_LINENUMBER = _IMAGE_LINENUMBER /* winnt.h:6983:7 */
type PIMAGE_LINENUMBER = uintptr          /* winnt.h:6984:40 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _IMAGE_BASE_RELOCATION = struct {
	VirtualAddress DWORD
	SizeOfBlock    DWORD
} /* winnt.h:6990:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION /* winnt.h:6993:7 */
type PIMAGE_BASE_RELOCATION = uintptr               /* winnt.h:6994:45 */

type _IMAGE_ARCHIVE_MEMBER_HEADER = struct {
	Name      [16]BYTE
	Date      [12]BYTE
	UserID    [6]BYTE
	GroupID   [6]BYTE
	Mode      [8]BYTE
	Size      [10]BYTE
	EndHeader [2]BYTE
} /* winnt.h:7017:13 */

type IMAGE_ARCHIVE_MEMBER_HEADER = _IMAGE_ARCHIVE_MEMBER_HEADER /* winnt.h:7025:7 */
type PIMAGE_ARCHIVE_MEMBER_HEADER = uintptr                     /* winnt.h:7025:35 */

type _IMAGE_EXPORT_DIRECTORY = struct {
	Characteristics       DWORD
	TimeDateStamp         DWORD
	MajorVersion          WORD
	MinorVersion          WORD
	Name                  DWORD
	Base                  DWORD
	NumberOfFunctions     DWORD
	NumberOfNames         DWORD
	AddressOfFunctions    DWORD
	AddressOfNames        DWORD
	AddressOfNameOrdinals DWORD
} /* winnt.h:7029:13 */

type IMAGE_EXPORT_DIRECTORY = _IMAGE_EXPORT_DIRECTORY /* winnt.h:7041:7 */
type PIMAGE_EXPORT_DIRECTORY = uintptr                /* winnt.h:7041:30 */

type _IMAGE_IMPORT_BY_NAME = struct {
	Hint WORD
	Name [1]CHAR
	_    [1]byte
} /* winnt.h:7043:13 */

type IMAGE_IMPORT_BY_NAME = _IMAGE_IMPORT_BY_NAME /* winnt.h:7046:7 */
type PIMAGE_IMPORT_BY_NAME = uintptr              /* winnt.h:7046:28 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _IMAGE_THUNK_DATA64 = struct {
	u1 struct{ ForwarderString ULONGLONG }
} /* winnt.h:7050:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64 /* winnt.h:7057:7 */
type PIMAGE_THUNK_DATA64 = uintptr            /* winnt.h:7058:32 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _IMAGE_THUNK_DATA32 = struct {
	u1 struct{ ForwarderString DWORD }
} /* winnt.h:7062:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32 /* winnt.h:7069:7 */
type PIMAGE_THUNK_DATA32 = uintptr            /* winnt.h:7070:32 */

type PIMAGE_TLS_CALLBACK = uintptr /* winnt.h:7079:18 */

type _IMAGE_TLS_DIRECTORY64 = struct {
	StartAddressOfRawData ULONGLONG
	EndAddressOfRawData   ULONGLONG
	AddressOfIndex        ULONGLONG
	AddressOfCallBacks    ULONGLONG
	SizeOfZeroFill        DWORD
	Characteristics       DWORD
} /* winnt.h:7081:13 */

type IMAGE_TLS_DIRECTORY64 = _IMAGE_TLS_DIRECTORY64 /* winnt.h:7088:7 */
type PIMAGE_TLS_DIRECTORY64 = uintptr               /* winnt.h:7089:35 */

type _IMAGE_TLS_DIRECTORY32 = struct {
	StartAddressOfRawData DWORD
	EndAddressOfRawData   DWORD
	AddressOfIndex        DWORD
	AddressOfCallBacks    DWORD
	SizeOfZeroFill        DWORD
	Characteristics       DWORD
} /* winnt.h:7091:13 */

type IMAGE_TLS_DIRECTORY32 = _IMAGE_TLS_DIRECTORY32 /* winnt.h:7098:7 */
type PIMAGE_TLS_DIRECTORY32 = uintptr               /* winnt.h:7099:35 */

type IMAGE_THUNK_DATA = IMAGE_THUNK_DATA32         /* winnt.h:7112:32 */
type PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA32       /* winnt.h:7113:33 */
type IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY32   /* winnt.h:7115:35 */
type PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY32 /* winnt.h:7116:36 */

type _IMAGE_IMPORT_DESCRIPTOR = struct {
	u              struct{ Characteristics DWORD }
	TimeDateStamp  DWORD
	ForwarderChain DWORD
	Name           DWORD
	FirstThunk     DWORD
} /* winnt.h:7119:13 */

type IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR /* winnt.h:7129:7 */
type PIMAGE_IMPORT_DESCRIPTOR = uintptr                 /* winnt.h:7130:47 */

type _IMAGE_BOUND_IMPORT_DESCRIPTOR = struct {
	TimeDateStamp               DWORD
	OffsetModuleName            WORD
	NumberOfModuleForwarderRefs WORD
} /* winnt.h:7132:13 */

type IMAGE_BOUND_IMPORT_DESCRIPTOR = _IMAGE_BOUND_IMPORT_DESCRIPTOR /* winnt.h:7136:7 */
type PIMAGE_BOUND_IMPORT_DESCRIPTOR = uintptr                       /* winnt.h:7136:37 */

type _IMAGE_BOUND_FORWARDER_REF = struct {
	TimeDateStamp    DWORD
	OffsetModuleName WORD
	Reserved         WORD
} /* winnt.h:7138:13 */

type IMAGE_BOUND_FORWARDER_REF = _IMAGE_BOUND_FORWARDER_REF /* winnt.h:7142:7 */
type PIMAGE_BOUND_FORWARDER_REF = uintptr                   /* winnt.h:7142:33 */

type _IMAGE_DELAYLOAD_DESCRIPTOR = struct {
	Attributes                 struct{ AllAttributes DWORD }
	DllNameRVA                 DWORD
	ModuleHandleRVA            DWORD
	ImportAddressTableRVA      DWORD
	ImportNameTableRVA         DWORD
	BoundImportAddressTableRVA DWORD
	UnloadInformationTableRVA  DWORD
	TimeDateStamp              DWORD
} /* winnt.h:7144:13 */

type IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR /* winnt.h:7159:7 */
type PIMAGE_DELAYLOAD_DESCRIPTOR = uintptr                    /* winnt.h:7159:34 */
type PCIMAGE_DELAYLOAD_DESCRIPTOR = uintptr                   /* winnt.h:7160:46 */

type _IMAGE_RESOURCE_DIRECTORY = struct {
	Characteristics      DWORD
	TimeDateStamp        DWORD
	MajorVersion         WORD
	MinorVersion         WORD
	NumberOfNamedEntries WORD
	NumberOfIdEntries    WORD
} /* winnt.h:7162:13 */

type IMAGE_RESOURCE_DIRECTORY = _IMAGE_RESOURCE_DIRECTORY /* winnt.h:7169:7 */
type PIMAGE_RESOURCE_DIRECTORY = uintptr                  /* winnt.h:7169:32 */

type _IMAGE_RESOURCE_DIRECTORY_ENTRY = struct {
	u struct {
		s struct {
			_          [0]uint32
			NameOffset uint32 /* DWORD NameOffset: 31, DWORD NameIsString: 1 */
		}
	}
	u2 struct{ OffsetToData DWORD }
} /* winnt.h:7174:13 */

type IMAGE_RESOURCE_DIRECTORY_ENTRY = _IMAGE_RESOURCE_DIRECTORY_ENTRY /* winnt.h:7190:7 */
type PIMAGE_RESOURCE_DIRECTORY_ENTRY = uintptr                        /* winnt.h:7190:38 */

type _IMAGE_RESOURCE_DIRECTORY_STRING = struct {
	Length     WORD
	NameString [1]CHAR
	_          [1]byte
} /* winnt.h:7192:13 */

type IMAGE_RESOURCE_DIRECTORY_STRING = _IMAGE_RESOURCE_DIRECTORY_STRING /* winnt.h:7195:7 */
type PIMAGE_RESOURCE_DIRECTORY_STRING = uintptr                         /* winnt.h:7195:39 */

type _IMAGE_RESOURCE_DIR_STRING_U = struct {
	Length     WORD
	NameString [1]WCHAR
} /* winnt.h:7197:13 */

type IMAGE_RESOURCE_DIR_STRING_U = _IMAGE_RESOURCE_DIR_STRING_U /* winnt.h:7200:7 */
type PIMAGE_RESOURCE_DIR_STRING_U = uintptr                     /* winnt.h:7200:35 */

type _IMAGE_RESOURCE_DATA_ENTRY = struct {
	OffsetToData DWORD
	Size         DWORD
	CodePage     DWORD
	Reserved     DWORD
} /* winnt.h:7202:13 */

type IMAGE_RESOURCE_DATA_ENTRY = _IMAGE_RESOURCE_DATA_ENTRY /* winnt.h:7207:7 */
type PIMAGE_RESOURCE_DATA_ENTRY = uintptr                   /* winnt.h:7207:33 */

type IMAGE_LOAD_CONFIG_DIRECTORY32 = struct {
	Size                          DWORD
	TimeDateStamp                 DWORD
	MajorVersion                  WORD
	MinorVersion                  WORD
	GlobalFlagsClear              DWORD
	GlobalFlagsSet                DWORD
	CriticalSectionDefaultTimeout DWORD
	DeCommitFreeBlockThreshold    DWORD
	DeCommitTotalFreeThreshold    DWORD
	LockPrefixTable               DWORD
	MaximumAllocationSize         DWORD
	VirtualMemoryThreshold        DWORD
	ProcessHeapFlags              DWORD
	ProcessAffinityMask           DWORD
	CSDVersion                    WORD
	Reserved1                     WORD
	EditList                      DWORD
	SecurityCookie                DWORD
	SEHandlerTable                DWORD
	SEHandlerCount                DWORD
}                                             /* winnt.h:7230:7 */
type PIMAGE_LOAD_CONFIG_DIRECTORY32 = uintptr /* winnt.h:7230:37 */

type IMAGE_LOAD_CONFIG_DIRECTORY64 = struct {
	Size                          DWORD
	TimeDateStamp                 DWORD
	MajorVersion                  WORD
	MinorVersion                  WORD
	GlobalFlagsClear              DWORD
	GlobalFlagsSet                DWORD
	CriticalSectionDefaultTimeout DWORD
	DeCommitFreeBlockThreshold    ULONGLONG
	DeCommitTotalFreeThreshold    ULONGLONG
	LockPrefixTable               ULONGLONG
	MaximumAllocationSize         ULONGLONG
	VirtualMemoryThreshold        ULONGLONG
	ProcessAffinityMask           ULONGLONG
	ProcessHeapFlags              DWORD
	CSDVersion                    WORD
	Reserved1                     WORD
	EditList                      ULONGLONG
	SecurityCookie                ULONGLONG
	SEHandlerTable                ULONGLONG
	SEHandlerCount                ULONGLONG
}                                             /* winnt.h:7253:7 */
type PIMAGE_LOAD_CONFIG_DIRECTORY64 = uintptr /* winnt.h:7253:37 */

type IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY32   /* winnt.h:7259:43 */
type PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY32 /* winnt.h:7260:44 */

type _IMAGE_CE_RUNTIME_FUNCTION_ENTRY = struct {
	FuncStart DWORD
	PrologLen uint32 /* DWORD PrologLen: 8, DWORD FuncLen: 22, DWORD ThirtyTwoBit: 1, DWORD ExceptionFlag: 1 */
} /* winnt.h:7263:13 */

type IMAGE_CE_RUNTIME_FUNCTION_ENTRY = _IMAGE_CE_RUNTIME_FUNCTION_ENTRY /* winnt.h:7269:7 */
type PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = uintptr                         /* winnt.h:7269:39 */

type _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = struct {
	BeginAddress     ULONGLONG
	EndAddress       ULONGLONG
	ExceptionHandler ULONGLONG
	HandlerData      ULONGLONG
	PrologEndAddress ULONGLONG
} /* winnt.h:7271:13 */

type IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY /* winnt.h:7277:7 */
type PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = uintptr                              /* winnt.h:7277:44 */

type _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = struct {
	BeginAddress     DWORD
	EndAddress       DWORD
	ExceptionHandler DWORD
	HandlerData      DWORD
	PrologEndAddress DWORD
} /* winnt.h:7279:13 */

type IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY /* winnt.h:7285:7 */
type PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = uintptr                            /* winnt.h:7285:42 */

type _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = struct {
	BeginAddress DWORD
	u            struct{ UnwindData DWORD }
} /* winnt.h:7287:13 */

type IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY /* winnt.h:7303:7 */
type PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = uintptr                          /* winnt.h:7303:40 */

type _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = struct {
	BeginAddress DWORD
	u            struct{ UnwindData DWORD }
} /* winnt.h:7305:13 */

type IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY /* winnt.h:7319:7 */
type PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = uintptr                            /* winnt.h:7319:42 */

type _IMAGE_RUNTIME_FUNCTION_ENTRY1 = struct {
	BeginAddress DWORD
	EndAddress   DWORD
	u            struct{ UnwindInfoAddress DWORD }
} /* winnt.h:7321:13 */

type _IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY1 /* winnt.h:7328:7 */
type _PIMAGE_RUNTIME_FUNCTION_ENTRY = uintptr                       /* winnt.h:7328:37 */

type IMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY   /* winnt.h:7330:43 */
type PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY /* winnt.h:7331:44 */

type IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY   /* winnt.h:7345:43 */
type PIMAGE_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY /* winnt.h:7346:44 */

type _IMAGE_DEBUG_DIRECTORY = struct {
	Characteristics  DWORD
	TimeDateStamp    DWORD
	MajorVersion     WORD
	MinorVersion     WORD
	Type             DWORD
	SizeOfData       DWORD
	AddressOfRawData DWORD
	PointerToRawData DWORD
} /* winnt.h:7349:13 */

type IMAGE_DEBUG_DIRECTORY = _IMAGE_DEBUG_DIRECTORY /* winnt.h:7358:7 */
type PIMAGE_DEBUG_DIRECTORY = uintptr               /* winnt.h:7358:29 */

type _IMAGE_COFF_SYMBOLS_HEADER = struct {
	NumberOfSymbols      DWORD
	LvaToFirstSymbol     DWORD
	NumberOfLinenumbers  DWORD
	LvaToFirstLinenumber DWORD
	RvaToFirstByteOfCode DWORD
	RvaToLastByteOfCode  DWORD
	RvaToFirstByteOfData DWORD
	RvaToLastByteOfData  DWORD
} /* winnt.h:7373:13 */

type IMAGE_COFF_SYMBOLS_HEADER = _IMAGE_COFF_SYMBOLS_HEADER /* winnt.h:7382:7 */
type PIMAGE_COFF_SYMBOLS_HEADER = uintptr                   /* winnt.h:7382:33 */

type _FPO_DATA = struct {
	ulOffStart DWORD
	cbProcSize DWORD
	cdwLocals  DWORD
	cdwParams  WORD
	cbProlog   uint16 /* WORD cbProlog: 8, WORD cbRegs: 3, WORD fHasSEH: 1, WORD fUseBP: 1, WORD reserved: 1, WORD cbFrame: 2 */
} /* winnt.h:7389:13 */

type FPO_DATA = _FPO_DATA /* winnt.h:7400:7 */
type PFPO_DATA = uintptr  /* winnt.h:7400:16 */

type _IMAGE_DEBUG_MISC = struct {
	DataType DWORD
	Length   DWORD
	Unicode  BOOLEAN
	Reserved [3]BYTE
	Data     [1]BYTE
	_        [3]byte
} /* winnt.h:7405:13 */

type IMAGE_DEBUG_MISC = _IMAGE_DEBUG_MISC /* winnt.h:7411:7 */
type PIMAGE_DEBUG_MISC = uintptr          /* winnt.h:7411:24 */

type _IMAGE_FUNCTION_ENTRY = struct {
	StartingAddress DWORD
	EndingAddress   DWORD
	EndOfPrologue   DWORD
} /* winnt.h:7413:13 */

type IMAGE_FUNCTION_ENTRY = _IMAGE_FUNCTION_ENTRY /* winnt.h:7417:7 */
type PIMAGE_FUNCTION_ENTRY = uintptr              /* winnt.h:7417:28 */

type _IMAGE_FUNCTION_ENTRY64 = struct {
	StartingAddress ULONGLONG
	EndingAddress   ULONGLONG
	u               struct{ EndOfPrologue ULONGLONG }
} /* winnt.h:7419:13 */

type IMAGE_FUNCTION_ENTRY64 = _IMAGE_FUNCTION_ENTRY64 /* winnt.h:7426:7 */
type PIMAGE_FUNCTION_ENTRY64 = uintptr                /* winnt.h:7426:30 */

type _IMAGE_SEPARATE_DEBUG_HEADER = struct {
	Signature          WORD
	Flags              WORD
	Machine            WORD
	Characteristics    WORD
	TimeDateStamp      DWORD
	CheckSum           DWORD
	ImageBase          DWORD
	SizeOfImage        DWORD
	NumberOfSections   DWORD
	ExportedNamesSize  DWORD
	DebugDirectorySize DWORD
	SectionAlignment   DWORD
	Reserved           [2]DWORD
} /* winnt.h:7428:13 */

type IMAGE_SEPARATE_DEBUG_HEADER = _IMAGE_SEPARATE_DEBUG_HEADER /* winnt.h:7442:7 */
type PIMAGE_SEPARATE_DEBUG_HEADER = uintptr                     /* winnt.h:7442:35 */

type _NON_PAGED_DEBUG_INFO = struct {
	Signature       WORD
	Flags           WORD
	Size            DWORD
	Machine         WORD
	Characteristics WORD
	TimeDateStamp   DWORD
	CheckSum        DWORD
	SizeOfImage     DWORD
	ImageBase       ULONGLONG
} /* winnt.h:7444:13 */

type NON_PAGED_DEBUG_INFO = _NON_PAGED_DEBUG_INFO /* winnt.h:7454:7 */
type PNON_PAGED_DEBUG_INFO = uintptr              /* winnt.h:7454:28 */

type _ImageArchitectureHeader = struct {
	AmaskValue    uint32 /* unsigned AmaskValue: 1, int Adummy1: 7, unsigned AmaskShift: 8, int Adummy2: 16 */
	FirstEntryRVA DWORD
} /* winnt.h:7462:13 */

type IMAGE_ARCHITECTURE_HEADER = _ImageArchitectureHeader /* winnt.h:7468:7 */
type PIMAGE_ARCHITECTURE_HEADER = uintptr                 /* winnt.h:7468:33 */

type _ImageArchitectureEntry = struct {
	FixupInstRVA DWORD
	NewInst      DWORD
} /* winnt.h:7470:13 */

type IMAGE_ARCHITECTURE_ENTRY = _ImageArchitectureEntry /* winnt.h:7473:7 */
type PIMAGE_ARCHITECTURE_ENTRY = uintptr                /* winnt.h:7473:32 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMPORT_OBJECT_HEADER1 = struct {
	Sig1          WORD
	Sig2          WORD
	Version       WORD
	Machine       WORD
	TimeDateStamp DWORD
	SizeOfData    DWORD
	__16          struct{ Ordinal WORD }
	Type          uint16 /* WORD Type: 2, WORD NameType: 3, WORD Reserved: 11 */
} /* winnt.h:7478:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type IMPORT_OBJECT_HEADER = IMPORT_OBJECT_HEADER1 /* winnt.h:7492:7 */

type IMPORT_OBJECT_TYPE = uint32 /* winnt.h:7496:7 */

type IMPORT_OBJECT_NAME_TYPE = uint32 /* winnt.h:7500:7 */

type ReplacesCorHdrNumericDefines = uint32 /* winnt.h:7511:7 */

type IMAGE_COR20_HEADER1 = struct {
	cb                      DWORD
	MajorRuntimeVersion     WORD
	MinorRuntimeVersion     WORD
	MetaData                IMAGE_DATA_DIRECTORY
	Flags                   DWORD
	u                       struct{ EntryPointToken DWORD }
	Resources               IMAGE_DATA_DIRECTORY
	StrongNameSignature     IMAGE_DATA_DIRECTORY
	CodeManagerTable        IMAGE_DATA_DIRECTORY
	VTableFixups            IMAGE_DATA_DIRECTORY
	ExportAddressTableJumps IMAGE_DATA_DIRECTORY
	ManagedNativeHeader     IMAGE_DATA_DIRECTORY
} /* winnt.h:7513:13 */

type IMAGE_COR20_HEADER = IMAGE_COR20_HEADER1 /* winnt.h:7529:7 */
type PIMAGE_COR20_HEADER = uintptr            /* winnt.h:7529:26 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type SLIST_ENTRY = _SINGLE_LIST_ENTRY /* winnt.h:7634:39 */
type PSLIST_ENTRY = uintptr           /* winnt.h:7634:51 */

type _SLIST_HEADER = struct{ Alignment ULONGLONG } /* winnt.h:7636:13 */

type SLIST_HEADER = _SLIST_HEADER /* winnt.h:7643:7 */
type PSLIST_HEADER = uintptr      /* winnt.h:7643:20 */

type _RTL_RUN_ONCE = struct{ Ptr PVOID } /* winnt.h:7661:9 */

type RTL_RUN_ONCE = _RTL_RUN_ONCE    /* winnt.h:7661:45 */
type PRTL_RUN_ONCE = uintptr         /* winnt.h:7661:59 */
type PRTL_RUN_ONCE_INIT_FN = uintptr /* winnt.h:7662:15 */

type _RTL_BARRIER = struct {
	Reserved1 DWORD
	Reserved2 DWORD
	Reserved3 [2]ULONG_PTR
	Reserved4 DWORD
	Reserved5 DWORD
} /* winnt.h:7671:11 */

type RTL_BARRIER = _RTL_BARRIER /* winnt.h:7677:5 */
type PRTL_BARRIER = uintptr     /* winnt.h:7677:17 */

type _MESSAGE_RESOURCE_ENTRY = struct {
	Length WORD
	Flags  WORD
	Text   [1]BYTE
	_      [1]byte
} /* winnt.h:7780:13 */

type MESSAGE_RESOURCE_ENTRY = _MESSAGE_RESOURCE_ENTRY /* winnt.h:7784:7 */
type PMESSAGE_RESOURCE_ENTRY = uintptr                /* winnt.h:7784:30 */

type _MESSAGE_RESOURCE_BLOCK = struct {
	LowId           DWORD
	HighId          DWORD
	OffsetToEntries DWORD
} /* winnt.h:7802:13 */

type MESSAGE_RESOURCE_BLOCK = _MESSAGE_RESOURCE_BLOCK /* winnt.h:7806:7 */
type PMESSAGE_RESOURCE_BLOCK = uintptr                /* winnt.h:7806:30 */

type _MESSAGE_RESOURCE_DATA = struct {
	NumberOfBlocks DWORD
	Blocks         [1]MESSAGE_RESOURCE_BLOCK
} /* winnt.h:7808:13 */

type MESSAGE_RESOURCE_DATA = _MESSAGE_RESOURCE_DATA /* winnt.h:7811:7 */
type PMESSAGE_RESOURCE_DATA = uintptr               /* winnt.h:7811:29 */

type _OSVERSIONINFOA = struct {
	dwOSVersionInfoSize DWORD
	dwMajorVersion      DWORD
	dwMinorVersion      DWORD
	dwBuildNumber       DWORD
	dwPlatformId        DWORD
	szCSDVersion        [128]CHAR
} /* winnt.h:7813:13 */

type OSVERSIONINFOA = _OSVERSIONINFOA /* winnt.h:7820:7 */
type POSVERSIONINFOA = uintptr        /* winnt.h:7820:22 */
type LPOSVERSIONINFOA = uintptr       /* winnt.h:7820:39 */

type _OSVERSIONINFOW = struct {
	dwOSVersionInfoSize DWORD
	dwMajorVersion      DWORD
	dwMinorVersion      DWORD
	dwBuildNumber       DWORD
	dwPlatformId        DWORD
	szCSDVersion        [128]WCHAR
} /* winnt.h:7822:13 */

type OSVERSIONINFOW = _OSVERSIONINFOW     /* winnt.h:7829:7 */
type POSVERSIONINFOW = uintptr            /* winnt.h:7829:22 */
type LPOSVERSIONINFOW = uintptr           /* winnt.h:7829:39 */
type RTL_OSVERSIONINFOW = _OSVERSIONINFOW /* winnt.h:7829:57 */
type PRTL_OSVERSIONINFOW = uintptr        /* winnt.h:7829:76 */

type OSVERSIONINFO = OSVERSIONINFOA     /* winnt.h:7831:5 */
type POSVERSIONINFO = POSVERSIONINFOA   /* winnt.h:7832:5 */
type LPOSVERSIONINFO = LPOSVERSIONINFOA /* winnt.h:7833:5 */

type _OSVERSIONINFOEXA = struct {
	dwOSVersionInfoSize DWORD
	dwMajorVersion      DWORD
	dwMinorVersion      DWORD
	dwBuildNumber       DWORD
	dwPlatformId        DWORD
	szCSDVersion        [128]CHAR
	wServicePackMajor   WORD
	wServicePackMinor   WORD
	wSuiteMask          WORD
	wProductType        BYTE
	wReserved           BYTE
} /* winnt.h:7835:13 */

type OSVERSIONINFOEXA = _OSVERSIONINFOEXA /* winnt.h:7847:7 */
type POSVERSIONINFOEXA = uintptr          /* winnt.h:7847:24 */
type LPOSVERSIONINFOEXA = uintptr         /* winnt.h:7847:43 */

type _OSVERSIONINFOEXW = struct {
	dwOSVersionInfoSize DWORD
	dwMajorVersion      DWORD
	dwMinorVersion      DWORD
	dwBuildNumber       DWORD
	dwPlatformId        DWORD
	szCSDVersion        [128]WCHAR
	wServicePackMajor   WORD
	wServicePackMinor   WORD
	wSuiteMask          WORD
	wProductType        BYTE
	wReserved           BYTE
} /* winnt.h:7849:13 */

type OSVERSIONINFOEXW = _OSVERSIONINFOEXW     /* winnt.h:7861:7 */
type POSVERSIONINFOEXW = uintptr              /* winnt.h:7861:24 */
type LPOSVERSIONINFOEXW = uintptr             /* winnt.h:7861:43 */
type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW /* winnt.h:7861:63 */
type PRTL_OSVERSIONINFOEXW = uintptr          /* winnt.h:7861:84 */

type OSVERSIONINFOEX = OSVERSIONINFOEXA     /* winnt.h:7863:5 */
type POSVERSIONINFOEX = POSVERSIONINFOEXA   /* winnt.h:7864:5 */
type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA /* winnt.h:7865:5 */

type RTL_UMS_THREAD_INFO_CLASS = uint32   /* winnt.h:7918:7 */
type PRTL_UMS_THREAD_INFO_CLASS = uintptr /* winnt.h:7918:33 */

type RTL_UMS_SCHEDULER_REASON = uint32        /* winnt.h:7924:7 */
type PRTL_UMS_SCHEDULER_REASON = uintptr      /* winnt.h:7924:32 */
type PRTL_UMS_SCHEDULER_ENTRY_POINT = uintptr /* winnt.h:7927:43 */

type _RTL_CRITICAL_SECTION_DEBUG = struct {
	Type                      WORD
	CreatorBackTraceIndex     WORD
	CriticalSection           uintptr
	ProcessLocksList          LIST_ENTRY
	EntryCount                DWORD
	ContentionCount           DWORD
	Flags                     DWORD
	CreatorBackTraceIndexHigh WORD
	SpareWORD                 WORD
} /* winnt.h:7947:13 */

type _RTL_CRITICAL_SECTION = struct {
	DebugInfo      PRTL_CRITICAL_SECTION_DEBUG
	LockCount      LONG
	RecursionCount LONG
	OwningThread   HANDLE
	LockSemaphore  HANDLE
	SpinCount      ULONG_PTR
} /* winnt.h:7947:13 */

type RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG /* winnt.h:7957:7 */
type PRTL_CRITICAL_SECTION_DEBUG = uintptr                    /* winnt.h:7957:34 */
type RTL_RESOURCE_DEBUG = _RTL_CRITICAL_SECTION_DEBUG         /* winnt.h:7957:63 */
type PRTL_RESOURCE_DEBUG = uintptr                            /* winnt.h:7957:82 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION /* winnt.h:7981:7 */
type PRTL_CRITICAL_SECTION = uintptr              /* winnt.h:7981:28 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _RTL_SRWLOCK = struct{ Ptr PVOID } /* winnt.h:7984:13 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type RTL_SRWLOCK = _RTL_SRWLOCK                    /* winnt.h:7984:48 */
type PRTL_SRWLOCK = uintptr                        /* winnt.h:7984:60 */
type _RTL_CONDITION_VARIABLE = struct{ Ptr PVOID } /* winnt.h:7985:13 */

type RTL_CONDITION_VARIABLE = _RTL_CONDITION_VARIABLE /* winnt.h:7985:59 */
type PRTL_CONDITION_VARIABLE = uintptr                /* winnt.h:7985:82 */

type PAPCFUNC = uintptr                    /* winnt.h:7992:18 */
type PVECTORED_EXCEPTION_HANDLER = uintptr /* winnt.h:7993:18 */

type HEAP_INFORMATION_CLASS = uint32 /* winnt.h:7998:7 */

type WORKERCALLBACKFUNC = uintptr                  /* winnt.h:8000:18 */
type APC_CALLBACK_FUNCTION = uintptr               /* winnt.h:8001:18 */
type WAITORTIMERCALLBACKFUNC = uintptr             /* winnt.h:8002:18 */
type WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC /* winnt.h:8003:37 */
type PFLS_CALLBACK_FUNCTION = uintptr              /* winnt.h:8004:18 */
type PSECURE_MEMORY_CACHE_CALLBACK = uintptr       /* winnt.h:8005:21 */

type ACTIVATION_CONTEXT_INFO_CLASS = uint32 /* winnt.h:8034:7 */

type ACTCTX_REQUESTED_RUN_LEVEL = uint32 /* winnt.h:8042:7 */

type ACTCTX_COMPATIBILITY_ELEMENT_TYPE = uint32 /* winnt.h:8048:7 */

type _ACTIVATION_CONTEXT_QUERY_INDEX = struct {
	ulAssemblyIndex       DWORD
	ulFileIndexInAssembly DWORD
} /* winnt.h:8050:13 */

type ACTIVATION_CONTEXT_QUERY_INDEX = _ACTIVATION_CONTEXT_QUERY_INDEX /* winnt.h:8053:7 */
type PACTIVATION_CONTEXT_QUERY_INDEX = uintptr                        /* winnt.h:8053:38 */

type _ASSEMBLY_FILE_DETAILED_INFORMATION = struct {
	ulFlags          DWORD
	ulFilenameLength DWORD
	ulPathLength     DWORD
	lpFileName       PCWSTR
	lpFilePath       PCWSTR
} /* winnt.h:8055:13 */

type ASSEMBLY_FILE_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION /* winnt.h:8061:7 */
type PASSEMBLY_FILE_DETAILED_INFORMATION = uintptr                            /* winnt.h:8061:42 */

type _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = struct {
	ulFlags                           DWORD
	ulEncodedAssemblyIdentityLength   DWORD
	ulManifestPathType                DWORD
	ulManifestPathLength              DWORD
	liManifestLastWriteTime           LARGE_INTEGER
	ulPolicyPathType                  DWORD
	ulPolicyPathLength                DWORD
	liPolicyLastWriteTime             LARGE_INTEGER
	ulMetadataSatelliteRosterIndex    DWORD
	ulManifestVersionMajor            DWORD
	ulManifestVersionMinor            DWORD
	ulPolicyVersionMajor              DWORD
	ulPolicyVersionMinor              DWORD
	ulAssemblyDirectoryNameLength     DWORD
	lpAssemblyEncodedAssemblyIdentity PCWSTR
	lpAssemblyManifestPath            PCWSTR
	lpAssemblyPolicyPath              PCWSTR
	lpAssemblyDirectoryName           PCWSTR
	ulFileCount                       DWORD
	_                                 [4]byte
} /* winnt.h:8063:13 */

type ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION /* winnt.h:8083:7 */
type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = uintptr                                          /* winnt.h:8083:56 */

type _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = struct {
	ulFlags  DWORD
	RunLevel ACTCTX_REQUESTED_RUN_LEVEL
	UiAccess DWORD
} /* winnt.h:8085:13 */

type ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION /* winnt.h:8089:7 */
type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = uintptr                                  /* winnt.h:8089:48 */

type _COMPATIBILITY_CONTEXT_ELEMENT = struct {
	Id   GUID
	Type ACTCTX_COMPATIBILITY_ELEMENT_TYPE
} /* winnt.h:8091:13 */

type COMPATIBILITY_CONTEXT_ELEMENT = _COMPATIBILITY_CONTEXT_ELEMENT /* winnt.h:8094:7 */
type PCOMPATIBILITY_CONTEXT_ELEMENT = uintptr                       /* winnt.h:8094:37 */

//Vista: {e2011457-1546-43c5-a5fe-008deee3d3f0}
//Seven: {35138b9a-5d96-4fbd-8e2d-a2440225f93a}
type _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = struct {
	_            [0]uint32
	ElementCount DWORD
} /* winnt.h:8098:13 */

//Vista: {e2011457-1546-43c5-a5fe-008deee3d3f0}
//Seven: {35138b9a-5d96-4fbd-8e2d-a2440225f93a}
type ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION /* winnt.h:8101:7 */
type PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = uintptr                                      /* winnt.h:8101:52 */

type _SUPPORTED_OS_INFO = struct {
	OsCount         WORD
	MitigationExist WORD
	OsList          [4]WORD
} /* winnt.h:8105:13 */

type SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO /* winnt.h:8109:7 */
type PSUPPORTED_OS_INFO = uintptr           /* winnt.h:8109:25 */

type _ACTIVATION_CONTEXT_DETAILED_INFORMATION = struct {
	dwFlags                      DWORD
	ulFormatVersion              DWORD
	ulAssemblyCount              DWORD
	ulRootManifestPathType       DWORD
	ulRootManifestPathChars      DWORD
	ulRootConfigurationPathType  DWORD
	ulRootConfigurationPathChars DWORD
	ulAppDirPathType             DWORD
	ulAppDirPathChars            DWORD
	lpRootManifestPath           PCWSTR
	lpRootConfigurationPath      PCWSTR
	lpAppDirPath                 PCWSTR
} /* winnt.h:8111:13 */

type ACTIVATION_CONTEXT_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_DETAILED_INFORMATION /* winnt.h:8124:7 */
type PACTIVATION_CONTEXT_DETAILED_INFORMATION = uintptr                                 /* winnt.h:8124:47 */

type PCACTIVATION_CONTEXT_QUERY_INDEX = uintptr                   /* winnt.h:8126:58 */
type PCASSEMBLY_FILE_DETAILED_INFORMATION = uintptr               /* winnt.h:8127:54 */
type PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = uintptr /* winnt.h:8128:76 */
type PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = uintptr         /* winnt.h:8129:68 */
type PCCOMPATIBILITY_CONTEXT_ELEMENT = uintptr                    /* winnt.h:8130:57 */
type PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = uintptr     /* winnt.h:8131:72 */
type PCACTIVATION_CONTEXT_DETAILED_INFORMATION = uintptr          /* winnt.h:8132:67 */

type RTL_VERIFIER_DLL_LOAD_CALLBACK = uintptr      /* winnt.h:8149:18 */
type RTL_VERIFIER_DLL_UNLOAD_CALLBACK = uintptr    /* winnt.h:8150:18 */
type RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK = uintptr /* winnt.h:8151:18 */

type _RTL_VERIFIER_THUNK_DESCRIPTOR = struct {
	ThunkName       PCHAR
	ThunkOldAddress PVOID
	ThunkNewAddress PVOID
} /* winnt.h:8153:13 */

type RTL_VERIFIER_THUNK_DESCRIPTOR = _RTL_VERIFIER_THUNK_DESCRIPTOR /* winnt.h:8157:7 */
type PRTL_VERIFIER_THUNK_DESCRIPTOR = uintptr                       /* winnt.h:8157:37 */

type _RTL_VERIFIER_DLL_DESCRIPTOR = struct {
	DllName    PWCHAR
	DllFlags   DWORD
	DllAddress PVOID
	DllThunks  PRTL_VERIFIER_THUNK_DESCRIPTOR
} /* winnt.h:8159:13 */

type RTL_VERIFIER_DLL_DESCRIPTOR = _RTL_VERIFIER_DLL_DESCRIPTOR /* winnt.h:8164:7 */
type PRTL_VERIFIER_DLL_DESCRIPTOR = uintptr                     /* winnt.h:8164:35 */

type _RTL_VERIFIER_PROVIDER_DESCRIPTOR = struct {
	Length                        DWORD
	ProviderDlls                  PRTL_VERIFIER_DLL_DESCRIPTOR
	ProviderDllLoadCallback       RTL_VERIFIER_DLL_LOAD_CALLBACK
	ProviderDllUnloadCallback     RTL_VERIFIER_DLL_UNLOAD_CALLBACK
	VerifierImage                 PWSTR
	VerifierFlags                 DWORD
	VerifierDebug                 DWORD
	RtlpGetStackTraceAddress      PVOID
	RtlpDebugPageHeapCreate       PVOID
	RtlpDebugPageHeapDestroy      PVOID
	ProviderNtdllHeapFreeCallback RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK
} /* winnt.h:8166:13 */

type RTL_VERIFIER_PROVIDER_DESCRIPTOR = _RTL_VERIFIER_PROVIDER_DESCRIPTOR /* winnt.h:8178:7 */
type PRTL_VERIFIER_PROVIDER_DESCRIPTOR = uintptr                          /* winnt.h:8178:40 */

type _HARDWARE_COUNTER_DATA = struct {
	Type     HARDWARE_COUNTER_TYPE
	Reserved DWORD
	Value    DWORD64
} /* winnt.h:8291:13 */

type HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA /* winnt.h:8295:7 */
type PHARDWARE_COUNTER_DATA = uintptr               /* winnt.h:8295:29 */

type _PERFORMANCE_DATA = struct {
	Size               WORD
	Version            BYTE
	HwCountersCount    BYTE
	ContextSwitchCount DWORD
	WaitReasonBitMap   DWORD64
	CycleTime          DWORD64
	RetryCount         DWORD
	Reserved           DWORD
	HwCounters         [16]HARDWARE_COUNTER_DATA
} /* winnt.h:8297:13 */

type PERFORMANCE_DATA = _PERFORMANCE_DATA /* winnt.h:8307:7 */
type PPERFORMANCE_DATA = uintptr          /* winnt.h:8307:24 */

type _EVENTLOGRECORD = struct {
	Length              DWORD
	Reserved            DWORD
	RecordNumber        DWORD
	TimeGenerated       DWORD
	TimeWritten         DWORD
	EventID             DWORD
	EventType           WORD
	NumStrings          WORD
	EventCategory       WORD
	ReservedFlags       WORD
	ClosingRecordNumber DWORD
	StringOffset        DWORD
	UserSidLength       DWORD
	UserSidOffset       DWORD
	DataLength          DWORD
	DataOffset          DWORD
} /* winnt.h:8338:13 */

type EVENTLOGRECORD = _EVENTLOGRECORD /* winnt.h:8355:7 */
type PEVENTLOGRECORD = uintptr        /* winnt.h:8355:22 */

type _EVENTSFORLOGFILE = struct {
	_                [0]uint32
	ulSize           DWORD
	szLogicalLogFile [256]WCHAR
	ulNumRecords     DWORD
} /* winnt.h:8359:13 */

type EVENTSFORLOGFILE = _EVENTSFORLOGFILE /* winnt.h:8364:7 */
type PEVENTSFORLOGFILE = uintptr          /* winnt.h:8364:24 */

type _PACKEDEVENTINFO = struct {
	_                     [0]uint32
	ulSize                DWORD
	ulNumEventsForLogFile DWORD
} /* winnt.h:8366:13 */

type PACKEDEVENTINFO = _PACKEDEVENTINFO /* winnt.h:8370:7 */
type PPACKEDEVENTINFO = uintptr         /* winnt.h:8370:23 */

type SERVICE_NODE_TYPE = uint32 /* winnt.h:8468:7 */

type SERVICE_LOAD_TYPE = uint32 /* winnt.h:8473:7 */

type SERVICE_ERROR_TYPE = uint32 /* winnt.h:8477:7 */

type _TAPE_ERASE = struct {
	Type      DWORD
	Immediate BOOLEAN
	_         [3]byte
} /* winnt.h:8496:13 */

type TAPE_ERASE = _TAPE_ERASE /* winnt.h:8499:7 */
type PTAPE_ERASE = uintptr    /* winnt.h:8499:18 */

type _TAPE_PREPARE = struct {
	Operation DWORD
	Immediate BOOLEAN
	_         [3]byte
} /* winnt.h:8508:13 */

type TAPE_PREPARE = _TAPE_PREPARE /* winnt.h:8511:7 */
type PTAPE_PREPARE = uintptr      /* winnt.h:8511:20 */

type _TAPE_WRITE_MARKS = struct {
	Type      DWORD
	Count     DWORD
	Immediate BOOLEAN
	_         [3]byte
} /* winnt.h:8518:13 */

type TAPE_WRITE_MARKS = _TAPE_WRITE_MARKS /* winnt.h:8522:7 */
type PTAPE_WRITE_MARKS = uintptr          /* winnt.h:8522:24 */

type _TAPE_GET_POSITION = struct {
	Type      DWORD
	Partition DWORD
	Offset    LARGE_INTEGER
} /* winnt.h:8528:13 */

type TAPE_GET_POSITION = _TAPE_GET_POSITION /* winnt.h:8532:7 */
type PTAPE_GET_POSITION = uintptr           /* winnt.h:8532:25 */

type _TAPE_SET_POSITION = struct {
	Method    DWORD
	Partition DWORD
	Offset    LARGE_INTEGER
	Immediate BOOLEAN
	_         [7]byte
} /* winnt.h:8545:13 */

type TAPE_SET_POSITION = _TAPE_SET_POSITION /* winnt.h:8550:7 */
type PTAPE_SET_POSITION = uintptr           /* winnt.h:8550:25 */

type _TAPE_GET_DRIVE_PARAMETERS = struct {
	ECC                   BOOLEAN
	Compression           BOOLEAN
	DataPadding           BOOLEAN
	ReportSetmarks        BOOLEAN
	DefaultBlockSize      DWORD
	MaximumBlockSize      DWORD
	MinimumBlockSize      DWORD
	MaximumPartitionCount DWORD
	FeaturesLow           DWORD
	FeaturesHigh          DWORD
	EOTWarningZoneSize    DWORD
} /* winnt.h:8619:13 */

type TAPE_GET_DRIVE_PARAMETERS = _TAPE_GET_DRIVE_PARAMETERS /* winnt.h:8631:7 */
type PTAPE_GET_DRIVE_PARAMETERS = uintptr                   /* winnt.h:8631:33 */

type _TAPE_SET_DRIVE_PARAMETERS = struct {
	ECC                BOOLEAN
	Compression        BOOLEAN
	DataPadding        BOOLEAN
	ReportSetmarks     BOOLEAN
	EOTWarningZoneSize DWORD
} /* winnt.h:8633:13 */

type TAPE_SET_DRIVE_PARAMETERS = _TAPE_SET_DRIVE_PARAMETERS /* winnt.h:8639:7 */
type PTAPE_SET_DRIVE_PARAMETERS = uintptr                   /* winnt.h:8639:33 */

type _TAPE_GET_MEDIA_PARAMETERS = struct {
	Capacity       LARGE_INTEGER
	Remaining      LARGE_INTEGER
	BlockSize      DWORD
	PartitionCount DWORD
	WriteProtected BOOLEAN
	_              [7]byte
} /* winnt.h:8641:13 */

type TAPE_GET_MEDIA_PARAMETERS = _TAPE_GET_MEDIA_PARAMETERS /* winnt.h:8647:7 */
type PTAPE_GET_MEDIA_PARAMETERS = uintptr                   /* winnt.h:8647:33 */

type _TAPE_SET_MEDIA_PARAMETERS = struct{ BlockSize DWORD } /* winnt.h:8649:13 */

type TAPE_SET_MEDIA_PARAMETERS = _TAPE_SET_MEDIA_PARAMETERS /* winnt.h:8651:7 */
type PTAPE_SET_MEDIA_PARAMETERS = uintptr                   /* winnt.h:8651:33 */

type _TAPE_CREATE_PARTITION = struct {
	Method DWORD
	Count  DWORD
	Size   DWORD
} /* winnt.h:8657:13 */

type TAPE_CREATE_PARTITION = _TAPE_CREATE_PARTITION /* winnt.h:8661:7 */
type PTAPE_CREATE_PARTITION = uintptr               /* winnt.h:8661:29 */

type _TAPE_WMI_OPERATIONS = struct {
	Method         DWORD
	DataBufferSize DWORD
	DataBuffer     PVOID
} /* winnt.h:8669:13 */

type TAPE_WMI_OPERATIONS = _TAPE_WMI_OPERATIONS /* winnt.h:8673:7 */
type PTAPE_WMI_OPERATIONS = uintptr             /* winnt.h:8673:27 */

type TAPE_DRIVE_PROBLEM_TYPE = uint32 /* winnt.h:8677:7 */

type TP_VERSION = DWORD              /* winnt.h:8680:17 */
type PTP_VERSION = uintptr           /* winnt.h:8680:28 */
type PTP_CALLBACK_INSTANCE = uintptr /* winnt.h:8681:61 */
type PTP_SIMPLE_CALLBACK = uintptr   /* winnt.h:8682:16 */
type PTP_POOL = uintptr              /* winnt.h:8683:35 */

type TP_CALLBACK_PRIORITY = uint32 /* winnt.h:8691:5 */

type _TP_POOL_STACK_INFORMATION = struct {
	StackReserve SIZE_T
	StackCommit  SIZE_T
} /* winnt.h:8693:11 */

type TP_POOL_STACK_INFORMATION = _TP_POOL_STACK_INFORMATION /* winnt.h:8696:5 */
type PTP_POOL_STACK_INFORMATION = uintptr                   /* winnt.h:8696:32 */
type PTP_CLEANUP_GROUP = uintptr                            /* winnt.h:8698:53 */
type PTP_CLEANUP_GROUP_CANCEL_CALLBACK = uintptr            /* winnt.h:8699:16 */

type _TP_CALLBACK_ENVIRON_V1 = struct {
	Version                    TP_VERSION
	Pool                       PTP_POOL
	CleanupGroup               PTP_CLEANUP_GROUP
	CleanupGroupCancelCallback PTP_CLEANUP_GROUP_CANCEL_CALLBACK
	RaceDll                    PVOID
	ActivationContext          uintptr
	FinalizationCallback       PTP_SIMPLE_CALLBACK
	u                          struct{ Flags DWORD }
} /* winnt.h:8723:11 */

type TP_CALLBACK_ENVIRON_V1 = _TP_CALLBACK_ENVIRON_V1 /* winnt.h:8739:5 */
type TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V1     /* winnt.h:8740:34 */
type PTP_CALLBACK_ENVIRON = uintptr                   /* winnt.h:8740:54 */
type PTP_WORK = uintptr                               /* winnt.h:8743:35 */
type PTP_WORK_CALLBACK = uintptr                      /* winnt.h:8744:16 */
type PTP_TIMER = uintptr                              /* winnt.h:8745:37 */
type PTP_TIMER_CALLBACK = uintptr                     /* winnt.h:8746:16 */
type TP_WAIT_RESULT = DWORD                           /* winnt.h:8747:17 */
type PTP_WAIT = uintptr                               /* winnt.h:8748:35 */
type PTP_WAIT_CALLBACK = uintptr                      /* winnt.h:8749:16 */
type PTP_IO = uintptr                                 /* winnt.h:8750:31 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type CRM_PROTOCOL_ID = GUID     /* ktmtypes.h:13:16 */
type PCRM_PROTOCOL_ID = uintptr /* ktmtypes.h:13:32 */

type NOTIFICATION_MASK = ULONG /* ktmtypes.h:38:17 */

type _TRANSACTION_NOTIFICATION = struct {
	TransactionKey          PVOID
	TransactionNotification ULONG
	TmVirtualClock          LARGE_INTEGER
	ArgumentLength          ULONG
	_                       [4]byte
} /* ktmtypes.h:78:11 */

type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION /* ktmtypes.h:83:5 */
type PTRANSACTION_NOTIFICATION = uintptr                  /* ktmtypes.h:83:30 */

type _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = struct {
	EnlistmentId GUID
	UOW          GUID
} /* ktmtypes.h:85:11 */

type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT /* ktmtypes.h:88:5 */
type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = uintptr                                    /* ktmtypes.h:88:48 */

type _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = struct {
	TmIdentity GUID
	Flags      ULONG
} /* ktmtypes.h:92:11 */

type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT /* ktmtypes.h:95:5 */
type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = uintptr                                     /* ktmtypes.h:95:49 */

type SAVEPOINT_ID = ULONG    /* ktmtypes.h:97:17 */
type PSAVEPOINT_ID = uintptr /* ktmtypes.h:97:30 */

type _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = struct{ SavepointId SAVEPOINT_ID } /* ktmtypes.h:99:11 */

type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT /* ktmtypes.h:101:5 */
type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = uintptr                                     /* ktmtypes.h:101:49 */

type _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = struct {
	PropagationCookie ULONG
	UOW               GUID
	TmIdentity        GUID
	BufferLength      ULONG
} /* ktmtypes.h:103:11 */

type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT /* ktmtypes.h:108:5 */
type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = uintptr                                     /* ktmtypes.h:108:49 */

type _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = struct {
	MarshalCookie ULONG
	UOW           GUID
} /* ktmtypes.h:110:11 */

type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT /* ktmtypes.h:113:5 */
type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = uintptr                                   /* ktmtypes.h:113:47 */

type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT /* ktmtypes.h:115:55 */
type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = uintptr                                    /* ktmtypes.h:115:97 */

type _KCRM_MARSHAL_HEADER = struct {
	VersionMajor ULONG
	VersionMinor ULONG
	NumProtocols ULONG
	Unused       ULONG
} /* ktmtypes.h:123:11 */

type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER /* ktmtypes.h:128:5 */
type PKCRM_MARSHAL_HEADER = uintptr             /* ktmtypes.h:128:25 */
type PRKCRM_MARSHAL_HEADER = uintptr            /* ktmtypes.h:128:47 */

type _KCRM_TRANSACTION_BLOB = struct {
	UOW            GUID
	TmIdentity     GUID
	IsolationLevel ULONG
	IsolationFlags ULONG
	Timeout        ULONG
	Description    [64]WCHAR
} /* ktmtypes.h:130:11 */

type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB /* ktmtypes.h:137:5 */
type PKCRM_TRANSACTION_BLOB = uintptr               /* ktmtypes.h:137:27 */
type PRKCRM_TRANSACTION_BLOB = uintptr              /* ktmtypes.h:137:51 */

type _KCRM_PROTOCOL_BLOB = struct {
	ProtocolId              CRM_PROTOCOL_ID
	StaticInfoLength        ULONG
	TransactionIdInfoLength ULONG
	Unused1                 ULONG
	Unused2                 ULONG
} /* ktmtypes.h:139:11 */

type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB /* ktmtypes.h:145:5 */
type PKCRM_PROTOCOL_BLOB = uintptr            /* ktmtypes.h:145:24 */
type PRKCRM_PROTOCOL_BLOB = uintptr           /* ktmtypes.h:145:45 */

type TRANSACTION_OUTCOME = uint32 /* winnt.h:8882:9 */

type TRANSACTION_STATE = uint32 /* winnt.h:8888:9 */

type _TRANSACTION_BASIC_INFORMATION = struct {
	TransactionId GUID
	State         DWORD
	Outcome       DWORD
} /* winnt.h:8890:15 */

type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION /* winnt.h:8894:9 */
type PTRANSACTION_BASIC_INFORMATION = uintptr                       /* winnt.h:8894:39 */

type _TRANSACTIONMANAGER_BASIC_INFORMATION = struct {
	TmIdentity   GUID
	VirtualClock LARGE_INTEGER
} /* winnt.h:8896:15 */

type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION /* winnt.h:8899:9 */
type PTRANSACTIONMANAGER_BASIC_INFORMATION = uintptr                              /* winnt.h:8899:46 */

type _TRANSACTIONMANAGER_LOG_INFORMATION = struct{ LogIdentity GUID } /* winnt.h:8901:15 */

type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION /* winnt.h:8903:9 */
type PTRANSACTIONMANAGER_LOG_INFORMATION = uintptr                            /* winnt.h:8903:44 */

type _TRANSACTIONMANAGER_LOGPATH_INFORMATION = struct {
	LogPathLength DWORD
	LogPath       [1]WCHAR
	_             [2]byte
} /* winnt.h:8905:15 */

type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION /* winnt.h:8908:9 */
type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = uintptr                                /* winnt.h:8908:48 */

type _TRANSACTIONMANAGER_RECOVERY_INFORMATION = struct{ LastRecoveredLsn ULONGLONG } /* winnt.h:8910:15 */

type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION /* winnt.h:8912:9 */
type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = uintptr                                 /* winnt.h:8912:49 */

type _TRANSACTIONMANAGER_OLDEST_INFORMATION = struct{ OldestTransactionGuid GUID } /* winnt.h:8914:15 */

type TRANSACTIONMANAGER_OLDEST_INFORMATION = _TRANSACTIONMANAGER_OLDEST_INFORMATION /* winnt.h:8916:9 */
type PTRANSACTIONMANAGER_OLDEST_INFORMATION = uintptr                               /* winnt.h:8916:47 */

type _TRANSACTION_PROPERTIES_INFORMATION = struct {
	IsolationLevel    DWORD
	IsolationFlags    DWORD
	Timeout           LARGE_INTEGER
	Outcome           DWORD
	DescriptionLength DWORD
	Description       [1]WCHAR
	_                 [6]byte
} /* winnt.h:8918:15 */

type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION /* winnt.h:8925:9 */
type PTRANSACTION_PROPERTIES_INFORMATION = uintptr                            /* winnt.h:8925:44 */

type _TRANSACTION_BIND_INFORMATION = struct{ TmHandle HANDLE } /* winnt.h:8927:15 */

type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION /* winnt.h:8929:9 */
type PTRANSACTION_BIND_INFORMATION = uintptr                      /* winnt.h:8929:38 */

type _TRANSACTION_ENLISTMENT_PAIR = struct {
	EnlistmentId      GUID
	ResourceManagerId GUID
} /* winnt.h:8931:15 */

type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR /* winnt.h:8934:9 */
type PTRANSACTION_ENLISTMENT_PAIR = uintptr                     /* winnt.h:8934:37 */

type _TRANSACTION_ENLISTMENTS_INFORMATION = struct {
	NumberOfEnlistments DWORD
	EnlistmentPair      [1]TRANSACTION_ENLISTMENT_PAIR
} /* winnt.h:8936:15 */

type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION /* winnt.h:8939:9 */
type PTRANSACTION_ENLISTMENTS_INFORMATION = uintptr                             /* winnt.h:8939:45 */

type _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = struct{ SuperiorEnlistmentPair TRANSACTION_ENLISTMENT_PAIR } /* winnt.h:8941:15 */

type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION /* winnt.h:8943:9 */
type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = uintptr                                     /* winnt.h:8943:53 */

type _RESOURCEMANAGER_BASIC_INFORMATION = struct {
	ResourceManagerId GUID
	DescriptionLength DWORD
	Description       [1]WCHAR
	_                 [2]byte
} /* winnt.h:8945:15 */

type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION /* winnt.h:8949:9 */
type PRESOURCEMANAGER_BASIC_INFORMATION = uintptr                           /* winnt.h:8949:43 */

type _RESOURCEMANAGER_COMPLETION_INFORMATION = struct {
	IoCompletionPortHandle HANDLE
	CompletionKey          ULONG_PTR
} /* winnt.h:8951:15 */

type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION /* winnt.h:8954:9 */
type PRESOURCEMANAGER_COMPLETION_INFORMATION = uintptr                                /* winnt.h:8954:48 */

type TRANSACTION_INFORMATION_CLASS = uint32 /* winnt.h:8963:9 */

type TRANSACTIONMANAGER_INFORMATION_CLASS = uint32 /* winnt.h:8972:9 */

type RESOURCEMANAGER_INFORMATION_CLASS = uint32 /* winnt.h:8977:9 */

type _ENLISTMENT_BASIC_INFORMATION = struct {
	EnlistmentId      GUID
	TransactionId     GUID
	ResourceManagerId GUID
} /* winnt.h:8979:15 */

type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION /* winnt.h:8983:9 */
type PENLISTMENT_BASIC_INFORMATION = uintptr                      /* winnt.h:8983:38 */

type _ENLISTMENT_CRM_INFORMATION = struct {
	CrmTransactionManagerId GUID
	CrmResourceManagerId    GUID
	CrmEnlistmentId         GUID
} /* winnt.h:8985:15 */

type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION /* winnt.h:8989:9 */
type PENLISTMENT_CRM_INFORMATION = uintptr                    /* winnt.h:8989:36 */

type ENLISTMENT_INFORMATION_CLASS = uint32 /* winnt.h:8995:9 */

type _TRANSACTION_LIST_ENTRY = struct{ UOW GUID } /* winnt.h:8997:15 */

type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY /* winnt.h:8999:9 */
type PTRANSACTION_LIST_ENTRY = uintptr                /* winnt.h:8999:32 */

type _TRANSACTION_LIST_INFORMATION = struct {
	NumberOfTransactions   DWORD
	TransactionInformation [1]TRANSACTION_LIST_ENTRY
} /* winnt.h:9001:15 */

type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION /* winnt.h:9004:9 */
type PTRANSACTION_LIST_INFORMATION = uintptr                      /* winnt.h:9004:38 */

type KTMOBJECT_TYPE = uint32   /* winnt.h:9012:9 */
type PKTMOBJECT_TYPE = uintptr /* winnt.h:9012:24 */

type _KTMOBJECT_CURSOR = struct {
	LastQuery     GUID
	ObjectIdCount DWORD
	ObjectIds     [1]GUID
} /* winnt.h:9014:15 */

type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR /* winnt.h:9018:9 */
type PKTMOBJECT_CURSOR = uintptr          /* winnt.h:9018:26 */

// Field Names From (See _fields_ section)
// FIXME: Verify these against documentation
// -- These documentation describes Win32 Constants and Structures in Python --
// Constants - http://packages.python.org/winappdbg/winappdbg.win32.context_i386-pysrc.html
// WOW64_FLOATING_SAVE_AREA - http://packages.python.org/winappdbg/winappdbg.win32.context_amd64.WOW64_FLOATING_SAVE_AREA-class.html
// WOW64_CONTEXT - http://packages.python.org/winappdbg/winappdbg.win32.context_amd64.WOW64_CONTEXT-class.html

type _WOW64_FLOATING_SAVE_AREA = struct {
	ControlWord   DWORD
	StatusWord    DWORD
	TagWord       DWORD
	ErrorOffset   DWORD
	ErrorSelector DWORD
	DataOffset    DWORD
	DataSelector  DWORD
	RegisterArea  [80]BYTE
	Cr0NpxState   DWORD
} /* winnt.h:9055:9 */

// Field Names From (See _fields_ section)
// FIXME: Verify these against documentation
// -- These documentation describes Win32 Constants and Structures in Python --
// Constants - http://packages.python.org/winappdbg/winappdbg.win32.context_i386-pysrc.html
// WOW64_FLOATING_SAVE_AREA - http://packages.python.org/winappdbg/winappdbg.win32.context_amd64.WOW64_FLOATING_SAVE_AREA-class.html
// WOW64_CONTEXT - http://packages.python.org/winappdbg/winappdbg.win32.context_amd64.WOW64_CONTEXT-class.html

type WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA /* winnt.h:9065:3 */
type PWOW64_FLOATING_SAVE_AREA = uintptr                  /* winnt.h:9065:29 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type _WOW64_CONTEXT = struct {
	ContextFlags      DWORD
	Dr0               DWORD
	Dr1               DWORD
	Dr2               DWORD
	Dr3               DWORD
	Dr6               DWORD
	Dr7               DWORD
	FloatSave         WOW64_FLOATING_SAVE_AREA
	SegGs             DWORD
	SegFs             DWORD
	SegEs             DWORD
	SegDs             DWORD
	Edi               DWORD
	Esi               DWORD
	Ebx               DWORD
	Edx               DWORD
	Ecx               DWORD
	Eax               DWORD
	Ebp               DWORD
	Eip               DWORD
	SegCs             DWORD
	EFlags            DWORD
	Esp               DWORD
	SegSs             DWORD
	ExtendedRegisters [512]BYTE
} /* winnt.h:9068:9 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type WOW64_CONTEXT = _WOW64_CONTEXT /* winnt.h:9094:3 */
type PWOW64_CONTEXT = uintptr       /* winnt.h:9094:18 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _WOW64_LDT_ENTRY = struct {
	LimitLow WORD
	BaseLow  WORD
	HighWord struct {
		_     [0]uint32
		Bytes struct {
			BaseMid BYTE
			Flags1  BYTE
			Flags2  BYTE
			BaseHi  BYTE
		}
	}
} /* winnt.h:9097:9 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type WOW64_LDT_ENTRY = _WOW64_LDT_ENTRY /* winnt.h:9120:3 */
type PWOW64_LDT_ENTRY = uintptr         /* winnt.h:9120:20 */

type _WOW64_DESCRIPTOR_TABLE_ENTRY = struct {
	Selector   DWORD
	Descriptor WOW64_LDT_ENTRY
} /* winnt.h:9122:13 */

type WOW64_DESCRIPTOR_TABLE_ENTRY = _WOW64_DESCRIPTOR_TABLE_ENTRY /* winnt.h:9125:7 */
type PWOW64_DESCRIPTOR_TABLE_ENTRY = uintptr                      /* winnt.h:9125:36 */

type WPARAM = UINT_PTR  /* minwindef.h:166:20 */
type LPARAM = LONG_PTR  /* minwindef.h:167:20 */
type LRESULT = LONG_PTR /* minwindef.h:168:20 */

type SPHANDLE = uintptr    /* minwindef.h:189:18 */
type LPHANDLE = uintptr    /* minwindef.h:190:18 */
type HGLOBAL = HANDLE      /* minwindef.h:191:18 */
type HLOCAL = HANDLE       /* minwindef.h:192:18 */
type GLOBALHANDLE = HANDLE /* minwindef.h:193:18 */
type LOCALHANDLE = HANDLE  /* minwindef.h:194:18 */
type FARPROC = uintptr     /* minwindef.h:200:15 */
type NEARPROC = uintptr    /* minwindef.h:201:15 */
type PROC = uintptr        /* minwindef.h:202:15 */

type ATOM = WORD /* minwindef.h:205:16 */

type HFILE = int32                        /* minwindef.h:207:15 */
type HINSTANCE__ = struct{ unused int32 } /* minwindef.h:208:3 */

type HINSTANCE = uintptr             /* minwindef.h:208:3 */
type HKEY__ = struct{ unused int32 } /* minwindef.h:209:3 */

type HKEY = uintptr                 /* minwindef.h:209:3 */
type PHKEY = uintptr                /* minwindef.h:210:16 */
type HKL__ = struct{ unused int32 } /* minwindef.h:211:3 */

type HKL = uintptr                     /* minwindef.h:211:3 */
type HLSURF__ = struct{ unused int32 } /* minwindef.h:212:3 */

type HLSURF = uintptr                     /* minwindef.h:212:3 */
type HMETAFILE__ = struct{ unused int32 } /* minwindef.h:213:3 */

type HMETAFILE = uintptr             /* minwindef.h:213:3 */
type HMODULE = HINSTANCE             /* minwindef.h:214:21 */
type HRGN__ = struct{ unused int32 } /* minwindef.h:215:3 */

type HRGN = uintptr                   /* minwindef.h:215:3 */
type HRSRC__ = struct{ unused int32 } /* minwindef.h:216:3 */

type HRSRC = uintptr                    /* minwindef.h:216:3 */
type HSPRITE__ = struct{ unused int32 } /* minwindef.h:217:3 */

type HSPRITE = uintptr               /* minwindef.h:217:3 */
type HSTR__ = struct{ unused int32 } /* minwindef.h:218:3 */

type HSTR = uintptr                   /* minwindef.h:218:3 */
type HTASK__ = struct{ unused int32 } /* minwindef.h:219:3 */

type HTASK = uintptr                    /* minwindef.h:219:3 */
type HWINSTA__ = struct{ unused int32 } /* minwindef.h:220:3 */

type HWINSTA = uintptr /* minwindef.h:220:3 */

type _FILETIME = struct {
	dwLowDateTime  DWORD
	dwHighDateTime DWORD
} /* minwindef.h:222:11 */

type FILETIME = _FILETIME /* minwindef.h:225:5 */
type PFILETIME = uintptr  /* minwindef.h:225:14 */
type LPFILETIME = uintptr /* minwindef.h:225:25 */

// Make sure winnt.h is included.
// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type HWND__ = struct{ unused int32 } /* windef.h:25:1 */

type HWND = uintptr                   /* windef.h:25:1 */
type HHOOK__ = struct{ unused int32 } /* windef.h:26:1 */

type HHOOK = uintptr /* windef.h:26:1 */

type HGDIOBJ = uintptr /* windef.h:37:16 */

type HACCEL__ = struct{ unused int32 } /* windef.h:42:1 */

type HACCEL = uintptr                   /* windef.h:42:1 */
type HBITMAP__ = struct{ unused int32 } /* windef.h:43:1 */

type HBITMAP = uintptr                 /* windef.h:43:1 */
type HBRUSH__ = struct{ unused int32 } /* windef.h:44:1 */

type HBRUSH = uintptr                       /* windef.h:44:1 */
type HCOLORSPACE__ = struct{ unused int32 } /* windef.h:45:1 */

type HCOLORSPACE = uintptr          /* windef.h:45:1 */
type HDC__ = struct{ unused int32 } /* windef.h:46:1 */

type HDC = uintptr                    /* windef.h:46:1 */
type HGLRC__ = struct{ unused int32 } /* windef.h:47:1 */

type HGLRC = uintptr                  /* windef.h:47:1 */
type HDESK__ = struct{ unused int32 } /* windef.h:48:1 */

type HDESK = uintptr                         /* windef.h:48:1 */
type HENHMETAFILE__ = struct{ unused int32 } /* windef.h:49:1 */

type HENHMETAFILE = uintptr           /* windef.h:49:1 */
type HFONT__ = struct{ unused int32 } /* windef.h:50:1 */

type HFONT = uintptr                  /* windef.h:50:1 */
type HICON__ = struct{ unused int32 } /* windef.h:51:1 */

type HICON = uintptr                  /* windef.h:51:1 */
type HMENU__ = struct{ unused int32 } /* windef.h:52:1 */

type HMENU = uintptr                     /* windef.h:52:1 */
type HPALETTE__ = struct{ unused int32 } /* windef.h:53:1 */

type HPALETTE = uintptr              /* windef.h:53:1 */
type HPEN__ = struct{ unused int32 } /* windef.h:54:1 */

type HPEN = uintptr                      /* windef.h:54:1 */
type HMONITOR__ = struct{ unused int32 } /* windef.h:55:1 */

type HMONITOR = uintptr                       /* windef.h:55:1 */
type HWINEVENTHOOK__ = struct{ unused int32 } /* windef.h:57:1 */

type HWINEVENTHOOK = uintptr /* windef.h:57:1 */

type HCURSOR = HICON  /* windef.h:59:15 */
type COLORREF = DWORD /* windef.h:60:15 */

type HUMPD__ = struct{ unused int32 } /* windef.h:64:1 */

type HUMPD = uintptr /* windef.h:64:1 */

type LPCOLORREF = uintptr /* windef.h:66:15 */

type tagRECT = struct {
	left   LONG
	top    LONG
	right  LONG
	bottom LONG
} /* windef.h:72:9 */

type RECT = tagRECT   /* windef.h:77:3 */
type PRECT = uintptr  /* windef.h:77:8 */
type NPRECT = uintptr /* windef.h:77:15 */
type LPRECT = uintptr /* windef.h:77:23 */

type LPCRECT = uintptr /* windef.h:79:20 */

type _RECTL = struct {
	left   LONG
	top    LONG
	right  LONG
	bottom LONG
} /* windef.h:81:9 */

type RECTL = _RECTL    /* windef.h:86:3 */
type PRECTL = uintptr  /* windef.h:86:9 */
type LPRECTL = uintptr /* windef.h:86:17 */

type LPCRECTL = uintptr /* windef.h:88:21 */

type tagPOINT = struct {
	x LONG
	y LONG
} /* windef.h:90:9 */

type POINT = tagPOINT  /* windef.h:93:3 */
type PPOINT = uintptr  /* windef.h:93:9 */
type NPPOINT = uintptr /* windef.h:93:17 */
type LPPOINT = uintptr /* windef.h:93:26 */

type _POINTL = struct {
	x LONG
	y LONG
} /* windef.h:95:9 */

type POINTL = _POINTL  /* windef.h:98:3 */
type PPOINTL = uintptr /* windef.h:98:10 */

type tagSIZE = struct {
	cx LONG
	cy LONG
} /* windef.h:100:9 */

type SIZE = tagSIZE   /* windef.h:103:3 */
type PSIZE = uintptr  /* windef.h:103:8 */
type LPSIZE = uintptr /* windef.h:103:15 */

type SIZEL = SIZE      /* windef.h:105:14 */
type PSIZEL = uintptr  /* windef.h:106:14 */
type LPSIZEL = uintptr /* windef.h:106:22 */

type tagPOINTS = struct {
	x SHORT
	y SHORT
} /* windef.h:108:9 */

type POINTS = tagPOINTS /* windef.h:111:3 */
type PPOINTS = uintptr  /* windef.h:111:10 */
type LPPOINTS = uintptr /* windef.h:111:19 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type _SECURITY_ATTRIBUTES = struct {
	nLength              DWORD
	lpSecurityDescriptor LPVOID
	bInheritHandle       WINBOOL
} /* minwinbase.h:13:11 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES /* minwinbase.h:17:5 */
type PSECURITY_ATTRIBUTES = uintptr             /* minwinbase.h:17:26 */
type LPSECURITY_ATTRIBUTES = uintptr            /* minwinbase.h:17:49 */

type _OVERLAPPED = struct {
	Internal     ULONG_PTR
	InternalHigh ULONG_PTR
	u            struct {
		s struct {
			Offset     DWORD
			OffsetHigh DWORD
		}
	}
	hEvent HANDLE
} /* minwinbase.h:19:11 */

type OVERLAPPED = _OVERLAPPED /* minwinbase.h:30:5 */
type LPOVERLAPPED = uintptr   /* minwinbase.h:30:17 */

type _OVERLAPPED_ENTRY = struct {
	lpCompletionKey            ULONG_PTR
	lpOverlapped               LPOVERLAPPED
	Internal                   ULONG_PTR
	dwNumberOfBytesTransferred DWORD
} /* minwinbase.h:32:11 */

type OVERLAPPED_ENTRY = _OVERLAPPED_ENTRY /* minwinbase.h:37:5 */
type LPOVERLAPPED_ENTRY = uintptr         /* minwinbase.h:37:23 */

type _SYSTEMTIME = struct {
	wYear         WORD
	wMonth        WORD
	wDayOfWeek    WORD
	wDay          WORD
	wHour         WORD
	wMinute       WORD
	wSecond       WORD
	wMilliseconds WORD
} /* minwinbase.h:49:11 */

type SYSTEMTIME = _SYSTEMTIME /* minwinbase.h:58:5 */
type PSYSTEMTIME = uintptr    /* minwinbase.h:58:17 */
type LPSYSTEMTIME = uintptr   /* minwinbase.h:58:31 */

type _WIN32_FIND_DATAA = struct {
	dwFileAttributes   DWORD
	ftCreationTime     FILETIME
	ftLastAccessTime   FILETIME
	ftLastWriteTime    FILETIME
	nFileSizeHigh      DWORD
	nFileSizeLow       DWORD
	dwReserved0        DWORD
	dwReserved1        DWORD
	cFileName          [260]CHAR
	cAlternateFileName [14]CHAR
	_                  [2]byte
} /* minwinbase.h:61:11 */

type WIN32_FIND_DATAA = _WIN32_FIND_DATAA /* minwinbase.h:72:5 */
type PWIN32_FIND_DATAA = uintptr          /* minwinbase.h:72:23 */
type LPWIN32_FIND_DATAA = uintptr         /* minwinbase.h:72:43 */

type _WIN32_FIND_DATAW = struct {
	dwFileAttributes   DWORD
	ftCreationTime     FILETIME
	ftLastAccessTime   FILETIME
	ftLastWriteTime    FILETIME
	nFileSizeHigh      DWORD
	nFileSizeLow       DWORD
	dwReserved0        DWORD
	dwReserved1        DWORD
	cFileName          [260]WCHAR
	cAlternateFileName [14]WCHAR
} /* minwinbase.h:74:11 */

type WIN32_FIND_DATAW = _WIN32_FIND_DATAW /* minwinbase.h:85:5 */
type PWIN32_FIND_DATAW = uintptr          /* minwinbase.h:85:23 */
type LPWIN32_FIND_DATAW = uintptr         /* minwinbase.h:85:43 */

type WIN32_FIND_DATA = WIN32_FIND_DATAA     /* minwinbase.h:87:3 */
type PWIN32_FIND_DATA = PWIN32_FIND_DATAA   /* minwinbase.h:88:3 */
type LPWIN32_FIND_DATA = LPWIN32_FIND_DATAA /* minwinbase.h:89:3 */

type FINDEX_INFO_LEVELS = uint32 /* minwinbase.h:95:5 */

type FINDEX_SEARCH_OPS = uint32 /* minwinbase.h:105:5 */

type GET_FILEEX_INFO_LEVELS = uint32 /* minwinbase.h:110:5 */

type CRITICAL_SECTION = RTL_CRITICAL_SECTION                /* minwinbase.h:141:32 */
type PCRITICAL_SECTION = PRTL_CRITICAL_SECTION              /* minwinbase.h:142:33 */
type LPCRITICAL_SECTION = PRTL_CRITICAL_SECTION             /* minwinbase.h:143:33 */
type CRITICAL_SECTION_DEBUG = RTL_CRITICAL_SECTION_DEBUG    /* minwinbase.h:144:38 */
type PCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG  /* minwinbase.h:145:39 */
type LPCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG /* minwinbase.h:146:39 */

type LPOVERLAPPED_COMPLETION_ROUTINE = uintptr /* minwinbase.h:148:16 */

type _PROCESS_HEAP_ENTRY = struct {
	lpData       PVOID
	cbData       DWORD
	cbOverhead   BYTE
	iRegionIndex BYTE
	wFlags       WORD
	u            struct {
		Block struct {
			hMem       HANDLE
			dwReserved [3]DWORD
		}
	}
} /* minwinbase.h:153:11 */

type PROCESS_HEAP_ENTRY = _PROCESS_HEAP_ENTRY /* minwinbase.h:171:5 */
type LPPROCESS_HEAP_ENTRY = uintptr           /* minwinbase.h:171:24 */
type PPROCESS_HEAP_ENTRY = uintptr            /* minwinbase.h:171:46 */

type _REASON_CONTEXT = struct {
	Version ULONG
	Flags   DWORD
	Reason  struct {
		Detailed struct {
			LocalizedReasonModule HMODULE
			LocalizedReasonId     ULONG
			ReasonStringCount     ULONG
			ReasonStrings         uintptr
		}
	}
} /* minwinbase.h:179:11 */

type REASON_CONTEXT = _REASON_CONTEXT /* minwinbase.h:191:5 */
type PREASON_CONTEXT = uintptr        /* minwinbase.h:191:21 */

type PTHREAD_START_ROUTINE = uintptr                /* minwinbase.h:203:17 */
type LPTHREAD_START_ROUTINE = PTHREAD_START_ROUTINE /* minwinbase.h:204:33 */

type _EXCEPTION_DEBUG_INFO = struct {
	ExceptionRecord EXCEPTION_RECORD
	dwFirstChance   DWORD
} /* minwinbase.h:206:11 */

type EXCEPTION_DEBUG_INFO = _EXCEPTION_DEBUG_INFO /* minwinbase.h:209:5 */
type LPEXCEPTION_DEBUG_INFO = uintptr             /* minwinbase.h:209:27 */

type _CREATE_THREAD_DEBUG_INFO = struct {
	hThread           HANDLE
	lpThreadLocalBase LPVOID
	lpStartAddress    LPTHREAD_START_ROUTINE
} /* minwinbase.h:211:11 */

type CREATE_THREAD_DEBUG_INFO = _CREATE_THREAD_DEBUG_INFO /* minwinbase.h:215:5 */
type LPCREATE_THREAD_DEBUG_INFO = uintptr                 /* minwinbase.h:215:31 */

type _CREATE_PROCESS_DEBUG_INFO = struct {
	hFile                 HANDLE
	hProcess              HANDLE
	hThread               HANDLE
	lpBaseOfImage         LPVOID
	dwDebugInfoFileOffset DWORD
	nDebugInfoSize        DWORD
	lpThreadLocalBase     LPVOID
	lpStartAddress        LPTHREAD_START_ROUTINE
	lpImageName           LPVOID
	fUnicode              WORD
	_                     [2]byte
} /* minwinbase.h:217:11 */

type CREATE_PROCESS_DEBUG_INFO = _CREATE_PROCESS_DEBUG_INFO /* minwinbase.h:228:5 */
type LPCREATE_PROCESS_DEBUG_INFO = uintptr                  /* minwinbase.h:228:32 */

type _EXIT_THREAD_DEBUG_INFO = struct{ dwExitCode DWORD } /* minwinbase.h:230:11 */

type EXIT_THREAD_DEBUG_INFO = _EXIT_THREAD_DEBUG_INFO /* minwinbase.h:232:5 */
type LPEXIT_THREAD_DEBUG_INFO = uintptr               /* minwinbase.h:232:29 */

type _EXIT_PROCESS_DEBUG_INFO = struct{ dwExitCode DWORD } /* minwinbase.h:234:11 */

type EXIT_PROCESS_DEBUG_INFO = _EXIT_PROCESS_DEBUG_INFO /* minwinbase.h:236:5 */
type LPEXIT_PROCESS_DEBUG_INFO = uintptr                /* minwinbase.h:236:30 */

type _LOAD_DLL_DEBUG_INFO = struct {
	hFile                 HANDLE
	lpBaseOfDll           LPVOID
	dwDebugInfoFileOffset DWORD
	nDebugInfoSize        DWORD
	lpImageName           LPVOID
	fUnicode              WORD
	_                     [2]byte
} /* minwinbase.h:238:11 */

type LOAD_DLL_DEBUG_INFO = _LOAD_DLL_DEBUG_INFO /* minwinbase.h:245:5 */
type LPLOAD_DLL_DEBUG_INFO = uintptr            /* minwinbase.h:245:26 */

type _UNLOAD_DLL_DEBUG_INFO = struct{ lpBaseOfDll LPVOID } /* minwinbase.h:247:11 */

type UNLOAD_DLL_DEBUG_INFO = _UNLOAD_DLL_DEBUG_INFO /* minwinbase.h:249:5 */
type LPUNLOAD_DLL_DEBUG_INFO = uintptr              /* minwinbase.h:249:28 */

type _OUTPUT_DEBUG_STRING_INFO = struct {
	lpDebugStringData  LPSTR
	fUnicode           WORD
	nDebugStringLength WORD
} /* minwinbase.h:251:11 */

type OUTPUT_DEBUG_STRING_INFO = _OUTPUT_DEBUG_STRING_INFO /* minwinbase.h:255:5 */
type LPOUTPUT_DEBUG_STRING_INFO = uintptr                 /* minwinbase.h:255:31 */

type _RIP_INFO = struct {
	dwError DWORD
	dwType  DWORD
} /* minwinbase.h:257:11 */

type RIP_INFO = _RIP_INFO /* minwinbase.h:260:5 */
type LPRIP_INFO = uintptr /* minwinbase.h:260:15 */

type _DEBUG_EVENT = struct {
	dwDebugEventCode DWORD
	dwProcessId      DWORD
	dwThreadId       DWORD
	u                struct{ Exception EXCEPTION_DEBUG_INFO }
} /* minwinbase.h:262:11 */

type DEBUG_EVENT = _DEBUG_EVENT /* minwinbase.h:277:5 */
type LPDEBUG_EVENT = uintptr    /* minwinbase.h:277:18 */

type LPCONTEXT = PCONTEXT                  /* minwinbase.h:280:20 */
type BEM_FREE_INTERFACE_CALLBACK = uintptr /* bemapiset.h:21:16 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type PTOP_LEVEL_EXCEPTION_FILTER = uintptr                      /* errhandlingapi.h:17:14 */
type LPTOP_LEVEL_EXCEPTION_FILTER = PTOP_LEVEL_EXCEPTION_FILTER /* errhandlingapi.h:18:37 */
type _BY_HANDLE_FILE_INFORMATION = struct {
	dwFileAttributes     DWORD
	ftCreationTime       FILETIME
	ftLastAccessTime     FILETIME
	ftLastWriteTime      FILETIME
	dwVolumeSerialNumber DWORD
	nFileSizeHigh        DWORD
	nFileSizeLow         DWORD
	nNumberOfLinks       DWORD
	nFileIndexHigh       DWORD
	nFileIndexLow        DWORD
} /* fileapi.h:38:11 */

type BY_HANDLE_FILE_INFORMATION = _BY_HANDLE_FILE_INFORMATION /* fileapi.h:49:5 */
type PBY_HANDLE_FILE_INFORMATION = uintptr                    /* fileapi.h:49:33 */
type LPBY_HANDLE_FILE_INFORMATION = uintptr                   /* fileapi.h:50:5 */

type _WIN32_FILE_ATTRIBUTE_DATA = struct {
	dwFileAttributes DWORD
	ftCreationTime   FILETIME
	ftLastAccessTime FILETIME
	ftLastWriteTime  FILETIME
	nFileSizeHigh    DWORD
	nFileSizeLow     DWORD
} /* fileapi.h:129:11 */

type WIN32_FILE_ATTRIBUTE_DATA = _WIN32_FILE_ATTRIBUTE_DATA /* fileapi.h:136:5 */
type LPWIN32_FILE_ATTRIBUTE_DATA = uintptr                  /* fileapi.h:136:32 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type _HEAP_SUMMARY = struct {
	cb           DWORD
	cbAllocated  SIZE_T
	cbCommitted  SIZE_T
	cbReserved   SIZE_T
	cbMaxReserve SIZE_T
} /* heapapi.h:18:11 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type HEAP_SUMMARY = _HEAP_SUMMARY /* heapapi.h:24:5 */
type PHEAP_SUMMARY = uintptr      /* heapapi.h:24:18 */

type LPHEAP_SUMMARY = PHEAP_SUMMARY /* heapapi.h:26:25 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type tagENUMUILANG = struct {
	NumOfEnumUILang    ULONG
	SizeOfEnumUIBuffer ULONG
	pEnumUIBuffer      uintptr
} /* libloaderapi.h:18:11 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type ENUMUILANG = tagENUMUILANG /* libloaderapi.h:22:5 */
type PENUMUILANG = uintptr      /* libloaderapi.h:22:17 */

type ENUMRESLANGPROCA = uintptr /* libloaderapi.h:25:19 */
type ENUMRESLANGPROCW = uintptr /* libloaderapi.h:26:19 */
type ENUMRESNAMEPROCA = uintptr /* libloaderapi.h:27:19 */
type ENUMRESNAMEPROCW = uintptr /* libloaderapi.h:28:19 */
type ENUMRESTYPEPROCA = uintptr /* libloaderapi.h:29:19 */
type ENUMRESTYPEPROCW = uintptr /* libloaderapi.h:30:19 */

type PGET_MODULE_HANDLE_EXA = uintptr /* libloaderapi.h:41:19 */
type PGET_MODULE_HANDLE_EXW = uintptr /* libloaderapi.h:42:19 */

type DLL_DIRECTORY_COOKIE = PVOID    /* libloaderapi.h:45:17 */
type PDLL_DIRECTORY_COOKIE = uintptr /* libloaderapi.h:45:39 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type MEMORY_RESOURCE_NOTIFICATION_TYPE = uint32 /* memoryapi.h:21:5 */

type _PROCESS_INFORMATION = struct {
	hProcess    HANDLE
	hThread     HANDLE
	dwProcessId DWORD
	dwThreadId  DWORD
} /* processthreadsapi.h:28:11 */

type PROCESS_INFORMATION = _PROCESS_INFORMATION /* processthreadsapi.h:33:5 */
type PPROCESS_INFORMATION = uintptr             /* processthreadsapi.h:33:26 */
type LPPROCESS_INFORMATION = uintptr            /* processthreadsapi.h:33:49 */

type _STARTUPINFOA = struct {
	cb              DWORD
	lpReserved      LPSTR
	lpDesktop       LPSTR
	lpTitle         LPSTR
	dwX             DWORD
	dwY             DWORD
	dwXSize         DWORD
	dwYSize         DWORD
	dwXCountChars   DWORD
	dwYCountChars   DWORD
	dwFillAttribute DWORD
	dwFlags         DWORD
	wShowWindow     WORD
	cbReserved2     WORD
	lpReserved2     LPBYTE
	hStdInput       HANDLE
	hStdOutput      HANDLE
	hStdError       HANDLE
} /* processthreadsapi.h:35:11 */

type STARTUPINFOA = _STARTUPINFOA /* processthreadsapi.h:54:5 */
type LPSTARTUPINFOA = uintptr     /* processthreadsapi.h:54:19 */

type _STARTUPINFOW = struct {
	cb              DWORD
	lpReserved      LPWSTR
	lpDesktop       LPWSTR
	lpTitle         LPWSTR
	dwX             DWORD
	dwY             DWORD
	dwXSize         DWORD
	dwYSize         DWORD
	dwXCountChars   DWORD
	dwYCountChars   DWORD
	dwFillAttribute DWORD
	dwFlags         DWORD
	wShowWindow     WORD
	cbReserved2     WORD
	lpReserved2     LPBYTE
	hStdInput       HANDLE
	hStdOutput      HANDLE
	hStdError       HANDLE
} /* processthreadsapi.h:56:11 */

type STARTUPINFOW = _STARTUPINFOW /* processthreadsapi.h:75:5 */
type LPSTARTUPINFOW = uintptr     /* processthreadsapi.h:75:19 */

type STARTUPINFO = STARTUPINFOA     /* processthreadsapi.h:77:3 */
type LPSTARTUPINFO = LPSTARTUPINFOA /* processthreadsapi.h:78:3 */

type PPROC_THREAD_ATTRIBUTE_LIST = uintptr  /* processthreadsapi.h:80:46 */
type LPPROC_THREAD_ATTRIBUTE_LIST = uintptr /* processthreadsapi.h:80:76 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type SRWLOCK = RTL_SRWLOCK /* synchapi.h:34:23 */
type PSRWLOCK = uintptr    /* synchapi.h:34:32 */

type INIT_ONCE = RTL_RUN_ONCE    /* synchapi.h:36:24 */
type PINIT_ONCE = PRTL_RUN_ONCE  /* synchapi.h:37:25 */
type LPINIT_ONCE = PRTL_RUN_ONCE /* synchapi.h:38:25 */

type PINIT_ONCE_FN = uintptr                     /* synchapi.h:40:19 */
type CONDITION_VARIABLE = RTL_CONDITION_VARIABLE /* synchapi.h:41:34 */
type PCONDITION_VARIABLE = uintptr               /* synchapi.h:41:54 */

type PTIMERAPCROUTINE = uintptr /* synchapi.h:102:16 */

type SYNCHRONIZATION_BARRIER = RTL_BARRIER    /* synchapi.h:104:23 */
type PSYNCHRONIZATION_BARRIER = PRTL_BARRIER  /* synchapi.h:105:24 */
type LPSYNCHRONIZATION_BARRIER = PRTL_BARRIER /* synchapi.h:106:24 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type _SYSTEM_INFO = struct {
	u                           struct{ dwOemId DWORD }
	dwPageSize                  DWORD
	lpMinimumApplicationAddress LPVOID
	lpMaximumApplicationAddress LPVOID
	dwActiveProcessorMask       DWORD_PTR
	dwNumberOfProcessors        DWORD
	dwProcessorType             DWORD
	dwAllocationGranularity     DWORD
	wProcessorLevel             WORD
	wProcessorRevision          WORD
} /* sysinfoapi.h:18:11 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type SYSTEM_INFO = _SYSTEM_INFO /* sysinfoapi.h:35:5 */
type LPSYSTEM_INFO = uintptr    /* sysinfoapi.h:35:18 */

type _MEMORYSTATUSEX = struct {
	dwLength                DWORD
	dwMemoryLoad            DWORD
	ullTotalPhys            DWORDLONG
	ullAvailPhys            DWORDLONG
	ullTotalPageFile        DWORDLONG
	ullAvailPageFile        DWORDLONG
	ullTotalVirtual         DWORDLONG
	ullAvailVirtual         DWORDLONG
	ullAvailExtendedVirtual DWORDLONG
} /* sysinfoapi.h:48:11 */

type MEMORYSTATUSEX = _MEMORYSTATUSEX /* sysinfoapi.h:58:5 */
type LPMEMORYSTATUSEX = uintptr       /* sysinfoapi.h:58:20 */

type COMPUTER_NAME_FORMAT = uint32 /* sysinfoapi.h:80:5 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type PTP_WIN32_IO_CALLBACK = uintptr /* threadpoolapiset.h:18:16 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// There are 3 separate ways this file is intended to be used:
//
//    1) Included from intrin.h.  In this case, all intrinsics in this file get declarations and
//       implementations.  No special #defines are needed for this case.
//
//    2) Included from the library versions of these functions (ie mingw-w64-crt\intrincs\*.c).  All
//       intrinsics in this file must also be included in the library.  In this case, only the
//       specific functions requested will get defined, and they will not be defined as inline.  If
//       you have followed the instructions (below) for adding functions to this file, then all you
//       need to have in the .c file is the following:
//
//       #define __INTRINSIC_ONLYSPECIAL
//       #define __INTRINSIC_SPECIAL___stosb // Causes code generation in intrin-impl.h
//
//       #include <intrin.h>
//
//    3) Included from various platform sdk headers.  Some platform sdk headers (such as winnt.h)
//       define a subset of intrinsics.  To avoid potential conflicts, this file is designed to
//       allow for specific subsets of functions to be defined.  This is done by defining the
//       appropriate variable before including this file:
//
//       #define __INTRINSIC_GROUP_WINNT
//       #include <psdk_inc/intrin-impl.h>
//
//    In all cases, it is acceptable to include this file multiple times in any order (ie include
//    winnt.h to get its subset, then include intrin.h to get everything, or vice versa).
//
//    See also the comments at the top of intrin.h.

// To add an implementation for a new intrinsic to this file, you should comment out the current prototype in intrin.h.
//    If the function you are adding is not in intrin.h, you should not be adding it to this file.  This file is only
//    for MSVC intrinsics.
//
//    Make sure you put your definition in the right section (x86 vs x64), and use this outline when adding definitions
//    to this file:
//
// #if __INTRINSIC_PROLOG(__int2c)
//
// <prototype goes here>
//
// __INTRINSICS_USEINLINE
// <code goes here>
//
// #define __INTRINSIC_DEFINED___int2c
// #endif

// Note that there is no file-wide #if to prevent intrin-impl.h from being
//    included multiple times.  This is because this file might be included multiple
//    times to define various subsets of the functions it contains.

// However we do check for __MINGW_INTRIN_INLINE.  In theory this means we
//    can work with other compilers.

// Clang has support for MSVC builtins, GCC doesn't

// These macros are used by the routines below.  While this file may be included
//    multiple times, these macros only need to be defined once.

// The Barrier functions can never be in the library.  Since gcc only
// supports ReadWriteBarrier, map all 3 to do the same.

// The logic for this macro is:
//    if the function is not yet defined AND
//    (
//        (if we are not just defining special OR
//            (we are defining special AND this is one of the ones we are defining)
//        )
//    )

// Normally __INTRINSIC_ONLYSPECIAL is used to indicate that we are
//    being included in the library version of the intrinsic (case 2).  However,
//    that really only affects the definition of __INTRINSICS_USEINLINE.
//    So here we are letting it serve an additional purpose of only defining
//    the intrinsics for a certain file (case 3).  For example, to create the
//    intrinsics for the functions in winnt.h, define __INTRINSIC_GROUP_WINNT.
//
//    Note that this file can be included multiple times, and as a result
//    there can be overlap (definitions that appear in more than one
//    file).  This is handled by __INTRINSIC_DEFINED_*
//
//    If no groups are defined (such as what happens when including intrin.h),
//    all intrinsics are defined.

// If __INTRINSIC_ONLYSPECIAL is defined at this point, we are processing case 2.  In
//    that case, don't go looking for groups

// Note that this gets undefined at the end of this file

// To add an additional group, put the #ifdef and definitions here.

// Before 4.9.2, ia32intrin.h had broken versions of these.

// *****************************************************

// *****************************************************

// *****************************************************

type PFIBER_START_ROUTINE = uintptr               /* winbase.h:160:16 */
type LPFIBER_START_ROUTINE = PFIBER_START_ROUTINE /* winbase.h:161:32 */

type LPLDT_ENTRY = PLDT_ENTRY /* winbase.h:164:22 */

type _COMMPROP = struct {
	wPacketLength       WORD
	wPacketVersion      WORD
	dwServiceMask       DWORD
	dwReserved1         DWORD
	dwMaxTxQueue        DWORD
	dwMaxRxQueue        DWORD
	dwMaxBaud           DWORD
	dwProvSubType       DWORD
	dwProvCapabilities  DWORD
	dwSettableParams    DWORD
	dwSettableBaud      DWORD
	wSettableData       WORD
	wSettableStopParity WORD
	dwCurrentTxQueue    DWORD
	dwCurrentRxQueue    DWORD
	dwProvSpec1         DWORD
	dwProvSpec2         DWORD
	wcProvChar          [1]WCHAR
	_                   [2]byte
} /* winbase.h:240:11 */

type COMMPROP = _COMMPROP /* winbase.h:259:5 */
type LPCOMMPROP = uintptr /* winbase.h:259:14 */

type _COMSTAT = struct {
	fCtsHold uint32 /* DWORD fCtsHold: 1, DWORD fDsrHold: 1, DWORD fRlsdHold: 1, DWORD fXoffHold: 1, DWORD fXoffSent: 1, DWORD fEof: 1, DWORD fTxim: 1, DWORD fReserved: 25 */
	cbInQue  DWORD
	cbOutQue DWORD
} /* winbase.h:263:11 */

type COMSTAT = _COMSTAT  /* winbase.h:274:5 */
type LPCOMSTAT = uintptr /* winbase.h:274:13 */

type _DCB = struct {
	DCBlength  DWORD
	BaudRate   DWORD
	fBinary    uint32 /* DWORD fBinary: 1, DWORD fParity: 1, DWORD fOutxCtsFlow: 1, DWORD fOutxDsrFlow: 1, DWORD fDtrControl: 2, DWORD fDsrSensitivity: 1, DWORD fTXContinueOnXoff: 1, DWORD fOutX: 1, DWORD fInX: 1, DWORD fErrorChar: 1, DWORD fNull: 1, DWORD fRtsControl: 2, DWORD fAbortOnError: 1, DWORD fDummy2: 17 */
	wReserved  WORD
	XonLim     WORD
	XoffLim    WORD
	ByteSize   BYTE
	Parity     BYTE
	StopBits   BYTE
	XonChar    int8
	XoffChar   int8
	ErrorChar  int8
	EofChar    int8
	EvtChar    int8
	wReserved1 WORD
} /* winbase.h:285:11 */

type DCB = _DCB      /* winbase.h:314:5 */
type LPDCB = uintptr /* winbase.h:314:9 */

type _COMMTIMEOUTS = struct {
	ReadIntervalTimeout         DWORD
	ReadTotalTimeoutMultiplier  DWORD
	ReadTotalTimeoutConstant    DWORD
	WriteTotalTimeoutMultiplier DWORD
	WriteTotalTimeoutConstant   DWORD
} /* winbase.h:316:11 */

type COMMTIMEOUTS = _COMMTIMEOUTS /* winbase.h:322:5 */
type LPCOMMTIMEOUTS = uintptr     /* winbase.h:322:18 */

type _COMMCONFIG = struct {
	dwSize            DWORD
	wVersion          WORD
	wReserved         WORD
	dcb               DCB
	dwProviderSubType DWORD
	dwProviderOffset  DWORD
	dwProviderSize    DWORD
	wcProviderData    [1]WCHAR
	_                 [2]byte
} /* winbase.h:324:11 */

type COMMCONFIG = _COMMCONFIG /* winbase.h:333:5 */
type LPCOMMCONFIG = uintptr   /* winbase.h:333:16 */

type _MEMORYSTATUS = struct {
	dwLength        DWORD
	dwMemoryLoad    DWORD
	dwTotalPhys     SIZE_T
	dwAvailPhys     SIZE_T
	dwTotalPageFile SIZE_T
	dwAvailPageFile SIZE_T
	dwTotalVirtual  SIZE_T
	dwAvailVirtual  SIZE_T
} /* winbase.h:364:11 */

type MEMORYSTATUS = _MEMORYSTATUS /* winbase.h:373:5 */
type LPMEMORYSTATUS = uintptr     /* winbase.h:373:18 */

type _JIT_DEBUG_INFO = struct {
	dwSize                  DWORD
	dwProcessorArchitecture DWORD
	dwThreadID              DWORD
	dwReserved0             DWORD
	lpExceptionAddress      ULONG64
	lpExceptionRecord       ULONG64
	lpContextRecord         ULONG64
} /* winbase.h:431:11 */

type JIT_DEBUG_INFO = _JIT_DEBUG_INFO /* winbase.h:439:5 */
type LPJIT_DEBUG_INFO = uintptr       /* winbase.h:439:20 */

type JIT_DEBUG_INFO32 = JIT_DEBUG_INFO /* winbase.h:441:26 */
type LPJIT_DEBUG_INFO32 = uintptr      /* winbase.h:441:44 */
type JIT_DEBUG_INFO64 = JIT_DEBUG_INFO /* winbase.h:442:26 */
type LPJIT_DEBUG_INFO64 = uintptr      /* winbase.h:442:44 */

type LPEXCEPTION_RECORD = PEXCEPTION_RECORD     /* winbase.h:445:29 */
type LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS /* winbase.h:446:31 */

type _OFSTRUCT = struct {
	cBytes     BYTE
	fFixedDisk BYTE
	nErrCode   WORD
	Reserved1  WORD
	Reserved2  WORD
	szPathName [128]CHAR
} /* winbase.h:620:11 */

type OFSTRUCT = _OFSTRUCT /* winbase.h:627:5 */
type LPOFSTRUCT = uintptr /* winbase.h:627:15 */
type POFSTRUCT = uintptr  /* winbase.h:627:27 */

// TODO: Add RTL_UMS... to winnt.h header and add UMS-base API.

type THREAD_INFORMATION_CLASS = uint32 /* winbase.h:1195:5 */

type PROCESS_INFORMATION_CLASS = uint32 /* winbase.h:1200:5 */

type DEP_SYSTEM_POLICY_TYPE = uint32 /* winbase.h:1304:5 */

type PFE_EXPORT_FUNC = uintptr /* winbase.h:1387:17 */
type PFE_IMPORT_FUNC = uintptr /* winbase.h:1388:17 */

type _WIN32_STREAM_ID = struct {
	dwStreamId         DWORD
	dwStreamAttributes DWORD
	Size               LARGE_INTEGER
	dwStreamNameSize   DWORD
	cStreamName        [1]WCHAR
	_                  [2]byte
} /* winbase.h:1465:11 */

type WIN32_STREAM_ID = _WIN32_STREAM_ID /* winbase.h:1471:5 */
type LPWIN32_STREAM_ID = uintptr        /* winbase.h:1471:21 */

type PGET_SYSTEM_WOW64_DIRECTORY_A = uintptr /* winbase.h:1856:16 */
type PGET_SYSTEM_WOW64_DIRECTORY_W = uintptr /* winbase.h:1857:16 */

type LPPROGRESS_ROUTINE = uintptr /* winbase.h:1960:17 */

type STREAM_INFO_LEVELS = uint32 /* winbase.h:2150:5 */

type _WIN32_FIND_STREAM_DATA = struct {
	StreamSize  LARGE_INTEGER
	cStreamName [296]WCHAR
} /* winbase.h:2152:11 */

type WIN32_FIND_STREAM_DATA = _WIN32_FIND_STREAM_DATA /* winbase.h:2155:5 */
type PWIN32_FIND_STREAM_DATA = uintptr                /* winbase.h:2155:28 */

type _EVENTLOG_FULL_INFORMATION = struct{ dwFull DWORD } /* winbase.h:2227:11 */

type EVENTLOG_FULL_INFORMATION = _EVENTLOG_FULL_INFORMATION /* winbase.h:2229:5 */
type LPEVENTLOG_FULL_INFORMATION = uintptr                  /* winbase.h:2229:31 */

type tagHW_PROFILE_INFOA = struct {
	dwDockInfo      DWORD
	szHwProfileGuid [39]CHAR
	szHwProfileName [80]CHAR
	_               [1]byte
} /* winbase.h:2444:11 */

type HW_PROFILE_INFOA = tagHW_PROFILE_INFOA /* winbase.h:2448:5 */
type LPHW_PROFILE_INFOA = uintptr           /* winbase.h:2448:22 */

type tagHW_PROFILE_INFOW = struct {
	dwDockInfo      DWORD
	szHwProfileGuid [39]WCHAR
	szHwProfileName [80]WCHAR
	_               [2]byte
} /* winbase.h:2450:11 */

type HW_PROFILE_INFOW = tagHW_PROFILE_INFOW /* winbase.h:2454:5 */
type LPHW_PROFILE_INFOW = uintptr           /* winbase.h:2454:22 */

type HW_PROFILE_INFO = HW_PROFILE_INFOA     /* winbase.h:2456:3 */
type LPHW_PROFILE_INFO = LPHW_PROFILE_INFOA /* winbase.h:2457:3 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// ********************   WARNING   ********************
// This is inconsistent with MSDN!
// In MSDN:
//     ERROR_IPSEC_IKE_QM_LIMIT => 13884 (here not defined)
//     ERROR_IPSEC_IKE_NEG_STATUS_END => 13897 (here 13884)
// Source:
//     WinINet Reference -> WinINet Constants -> Error Messages
//     https://msdn.microsoft.com/en-us/library/windows/desktop/aa385465%28v=vs.85%29.aspx
// ******************** END WARNING ********************
//#define ERROR_IPSEC_IKE_NEG_STATUS_END __MSABI_LONG(13884)

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type _TIME_ZONE_INFORMATION = struct {
	Bias         LONG
	StandardName [32]WCHAR
	StandardDate SYSTEMTIME
	StandardBias LONG
	DaylightName [32]WCHAR
	DaylightDate SYSTEMTIME
	DaylightBias LONG
} /* timezoneapi.h:21:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// ********************   WARNING   ********************
// This is inconsistent with MSDN!
// In MSDN:
//     ERROR_IPSEC_IKE_QM_LIMIT => 13884 (here not defined)
//     ERROR_IPSEC_IKE_NEG_STATUS_END => 13897 (here 13884)
// Source:
//     WinINet Reference -> WinINet Constants -> Error Messages
//     https://msdn.microsoft.com/en-us/library/windows/desktop/aa385465%28v=vs.85%29.aspx
// ******************** END WARNING ********************
//#define ERROR_IPSEC_IKE_NEG_STATUS_END __MSABI_LONG(13884)

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type TIME_ZONE_INFORMATION = _TIME_ZONE_INFORMATION /* timezoneapi.h:29:5 */
type PTIME_ZONE_INFORMATION = uintptr               /* timezoneapi.h:29:27 */
type LPTIME_ZONE_INFORMATION = uintptr              /* timezoneapi.h:29:51 */

type _TIME_DYNAMIC_ZONE_INFORMATION = struct {
	Bias                        LONG
	StandardName                [32]WCHAR
	StandardDate                SYSTEMTIME
	StandardBias                LONG
	DaylightName                [32]WCHAR
	DaylightDate                SYSTEMTIME
	DaylightBias                LONG
	TimeZoneKeyName             [128]WCHAR
	DynamicDaylightTimeDisabled BOOLEAN
	_                           [3]byte
} /* timezoneapi.h:31:11 */

type DYNAMIC_TIME_ZONE_INFORMATION = _TIME_DYNAMIC_ZONE_INFORMATION /* timezoneapi.h:41:5 */
type PDYNAMIC_TIME_ZONE_INFORMATION = uintptr                       /* timezoneapi.h:41:35 */

type _SYSTEM_POWER_STATUS = struct {
	ACLineStatus        BYTE
	BatteryFlag         BYTE
	BatteryLifePercent  BYTE
	Reserved1           BYTE
	BatteryLifeTime     DWORD
	BatteryFullLifeTime DWORD
} /* winbase.h:2495:11 */

type SYSTEM_POWER_STATUS = _SYSTEM_POWER_STATUS /* winbase.h:2502:5 */
type LPSYSTEM_POWER_STATUS = uintptr            /* winbase.h:2502:25 */

type tagACTCTXA = struct {
	cbSize                 ULONG
	dwFlags                DWORD
	lpSource               LPCSTR
	wProcessorArchitecture USHORT
	wLangId                LANGID
	lpAssemblyDirectory    LPCSTR
	lpResourceName         LPCSTR
	lpApplicationName      LPCSTR
	hModule                HMODULE
} /* winbase.h:2573:11 */

type ACTCTXA = tagACTCTXA /* winbase.h:2583:5 */
type PACTCTXA = uintptr   /* winbase.h:2583:13 */

type tagACTCTXW = struct {
	cbSize                 ULONG
	dwFlags                DWORD
	lpSource               LPCWSTR
	wProcessorArchitecture USHORT
	wLangId                LANGID
	lpAssemblyDirectory    LPCWSTR
	lpResourceName         LPCWSTR
	lpApplicationName      LPCWSTR
	hModule                HMODULE
} /* winbase.h:2585:11 */

type ACTCTXW = tagACTCTXW /* winbase.h:2595:5 */
type PACTCTXW = uintptr   /* winbase.h:2595:13 */

type ACTCTX = ACTCTXA   /* winbase.h:2597:3 */
type PACTCTX = PACTCTXA /* winbase.h:2598:3 */

type PCACTCTXA = uintptr /* winbase.h:2600:25 */
type PCACTCTXW = uintptr /* winbase.h:2601:25 */

type PCACTCTX = PCACTCTXA /* winbase.h:2603:3 */

type tagACTCTX_SECTION_KEYED_DATA_2600 = struct {
	cbSize                    ULONG
	ulDataFormatVersion       ULONG
	lpData                    PVOID
	ulLength                  ULONG
	lpSectionGlobalData       PVOID
	ulSectionGlobalDataLength ULONG
	lpSectionBase             PVOID
	ulSectionTotalLength      ULONG
	hActCtx                   HANDLE
	ulAssemblyRosterIndex     ULONG
} /* winbase.h:2617:11 */

type ACTCTX_SECTION_KEYED_DATA_2600 = tagACTCTX_SECTION_KEYED_DATA_2600 /* winbase.h:2628:5 */
type PACTCTX_SECTION_KEYED_DATA_2600 = uintptr                          /* winbase.h:2628:36 */

type PCACTCTX_SECTION_KEYED_DATA_2600 = uintptr /* winbase.h:2630:48 */

type tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = struct {
	lpInformation             PVOID
	lpSectionBase             PVOID
	ulSectionLength           ULONG
	lpSectionGlobalDataBase   PVOID
	ulSectionGlobalDataLength ULONG
} /* winbase.h:2632:11 */

type ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA /* winbase.h:2638:5 */
type PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = uintptr                                       /* winbase.h:2638:49 */

type PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = uintptr /* winbase.h:2640:61 */

type tagACTCTX_SECTION_KEYED_DATA = struct {
	cbSize                    ULONG
	ulDataFormatVersion       ULONG
	lpData                    PVOID
	ulLength                  ULONG
	lpSectionGlobalData       PVOID
	ulSectionGlobalDataLength ULONG
	lpSectionBase             PVOID
	ulSectionTotalLength      ULONG
	hActCtx                   HANDLE
	ulAssemblyRosterIndex     ULONG
	ulFlags                   ULONG
	AssemblyMetadata          ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
} /* winbase.h:2642:11 */

type ACTCTX_SECTION_KEYED_DATA = tagACTCTX_SECTION_KEYED_DATA /* winbase.h:2655:5 */
type PACTCTX_SECTION_KEYED_DATA = uintptr                     /* winbase.h:2655:31 */

type PCACTCTX_SECTION_KEYED_DATA = uintptr /* winbase.h:2657:43 */

type _ACTIVATION_CONTEXT_BASIC_INFORMATION = struct {
	hActCtx HANDLE
	dwFlags DWORD
} /* winbase.h:2670:11 */

type ACTIVATION_CONTEXT_BASIC_INFORMATION = _ACTIVATION_CONTEXT_BASIC_INFORMATION /* winbase.h:2673:5 */
type PACTIVATION_CONTEXT_BASIC_INFORMATION = uintptr                              /* winbase.h:2673:42 */

type PCACTIVATION_CONTEXT_BASIC_INFORMATION = uintptr /* winbase.h:2675:62 */

type PQUERYACTCTXW_FUNC = uintptr /* winbase.h:2687:19 */

type APPLICATION_RECOVERY_CALLBACK = uintptr /* winbase.h:2707:17 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _DRAWPATRECT = struct {
	ptPosition POINT
	ptSize     POINT
	wStyle     WORD
	wPattern   WORD
} /* wingdi.h:224:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type DRAWPATRECT = _DRAWPATRECT /* wingdi.h:229:5 */
type PDRAWPATRECT = uintptr     /* wingdi.h:229:17 */

type _PSINJECTDATA = struct {
	DataBytes      DWORD
	InjectionPoint WORD
	PageNumber     WORD
} /* wingdi.h:335:11 */

type PSINJECTDATA = _PSINJECTDATA /* wingdi.h:339:5 */
type PPSINJECTDATA = uintptr      /* wingdi.h:339:18 */

type _PSFEATURE_OUTPUT = struct {
	bPageIndependent WINBOOL
	bSetPageDevice   WINBOOL
} /* wingdi.h:391:11 */

type PSFEATURE_OUTPUT = _PSFEATURE_OUTPUT /* wingdi.h:394:5 */
type PPSFEATURE_OUTPUT = uintptr          /* wingdi.h:394:22 */

type _PSFEATURE_CUSTPAPER = struct {
	lOrientation  LONG
	lWidth        LONG
	lHeight       LONG
	lWidthOffset  LONG
	lHeightOffset LONG
} /* wingdi.h:396:11 */

type PSFEATURE_CUSTPAPER = _PSFEATURE_CUSTPAPER /* wingdi.h:402:5 */
type PPSFEATURE_CUSTPAPER = uintptr             /* wingdi.h:402:25 */

type tagXFORM = struct {
	eM11 FLOAT
	eM12 FLOAT
	eM21 FLOAT
	eM22 FLOAT
	eDx  FLOAT
	eDy  FLOAT
} /* wingdi.h:450:11 */

type XFORM = tagXFORM  /* wingdi.h:457:5 */
type PXFORM = uintptr  /* wingdi.h:457:11 */
type LPXFORM = uintptr /* wingdi.h:457:19 */

type tagBITMAP = struct {
	bmType       LONG
	bmWidth      LONG
	bmHeight     LONG
	bmWidthBytes LONG
	bmPlanes     WORD
	bmBitsPixel  WORD
	bmBits       LPVOID
} /* wingdi.h:459:11 */

type BITMAP = tagBITMAP /* wingdi.h:467:5 */
type PBITMAP = uintptr  /* wingdi.h:467:12 */
type NPBITMAP = uintptr /* wingdi.h:467:21 */
type LPBITMAP = uintptr /* wingdi.h:467:31 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type tagRGBTRIPLE = struct {
	rgbtBlue  BYTE
	rgbtGreen BYTE
	rgbtRed   BYTE
} /* wingdi.h:470:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type RGBTRIPLE = tagRGBTRIPLE /* wingdi.h:474:5 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type tagRGBQUAD = struct {
	rgbBlue     BYTE
	rgbGreen    BYTE
	rgbRed      BYTE
	rgbReserved BYTE
} /* wingdi.h:477:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type RGBQUAD = tagRGBQUAD /* wingdi.h:482:5 */

type LPRGBQUAD = uintptr /* wingdi.h:486:19 */

type LCSCSTYPE = LONG /* wingdi.h:499:16 */

type LCSGAMUTMATCH = LONG /* wingdi.h:502:16 */

type FXPT16DOT16 = int32     /* wingdi.h:526:20 */
type LPFXPT16DOT16 = uintptr /* wingdi.h:526:32 */
type FXPT2DOT30 = int32      /* wingdi.h:527:20 */
type LPFXPT2DOT30 = uintptr  /* wingdi.h:527:31 */

type tagCIEXYZ = struct {
	ciexyzX FXPT2DOT30
	ciexyzY FXPT2DOT30
	ciexyzZ FXPT2DOT30
} /* wingdi.h:529:11 */

type CIEXYZ = tagCIEXYZ /* wingdi.h:533:5 */
type LPCIEXYZ = uintptr /* wingdi.h:536:18 */
type tagICEXYZTRIPLE = struct {
	ciexyzRed   CIEXYZ
	ciexyzGreen CIEXYZ
	ciexyzBlue  CIEXYZ
} /* wingdi.h:539:11 */

type CIEXYZTRIPLE = tagICEXYZTRIPLE /* wingdi.h:543:5 */
type LPCIEXYZTRIPLE = uintptr       /* wingdi.h:546:24 */

type tagLOGCOLORSPACEA = struct {
	lcsSignature  DWORD
	lcsVersion    DWORD
	lcsSize       DWORD
	lcsCSType     LCSCSTYPE
	lcsIntent     LCSGAMUTMATCH
	lcsEndpoints  CIEXYZTRIPLE
	lcsGammaRed   DWORD
	lcsGammaGreen DWORD
	lcsGammaBlue  DWORD
	lcsFilename   [260]CHAR
} /* wingdi.h:550:11 */

type LOGCOLORSPACEA = tagLOGCOLORSPACEA /* wingdi.h:561:5 */
type LPLOGCOLORSPACEA = uintptr         /* wingdi.h:561:20 */

type tagLOGCOLORSPACEW = struct {
	lcsSignature  DWORD
	lcsVersion    DWORD
	lcsSize       DWORD
	lcsCSType     LCSCSTYPE
	lcsIntent     LCSGAMUTMATCH
	lcsEndpoints  CIEXYZTRIPLE
	lcsGammaRed   DWORD
	lcsGammaGreen DWORD
	lcsGammaBlue  DWORD
	lcsFilename   [260]WCHAR
} /* wingdi.h:563:11 */

type LOGCOLORSPACEW = tagLOGCOLORSPACEW /* wingdi.h:574:5 */
type LPLOGCOLORSPACEW = uintptr         /* wingdi.h:574:20 */

type LOGCOLORSPACE = LOGCOLORSPACEA     /* wingdi.h:576:3 */
type LPLOGCOLORSPACE = LPLOGCOLORSPACEA /* wingdi.h:577:3 */

type tagBITMAPCOREHEADER = struct {
	bcSize     DWORD
	bcWidth    WORD
	bcHeight   WORD
	bcPlanes   WORD
	bcBitCount WORD
} /* wingdi.h:581:11 */

type BITMAPCOREHEADER = tagBITMAPCOREHEADER /* wingdi.h:587:5 */
type LPBITMAPCOREHEADER = uintptr           /* wingdi.h:587:22 */
type PBITMAPCOREHEADER = uintptr            /* wingdi.h:587:42 */

type tagBITMAPINFOHEADER = struct {
	biSize          DWORD
	biWidth         LONG
	biHeight        LONG
	biPlanes        WORD
	biBitCount      WORD
	biCompression   DWORD
	biSizeImage     DWORD
	biXPelsPerMeter LONG
	biYPelsPerMeter LONG
	biClrUsed       DWORD
	biClrImportant  DWORD
} /* wingdi.h:591:11 */

type BITMAPINFOHEADER = tagBITMAPINFOHEADER /* wingdi.h:603:5 */
type LPBITMAPINFOHEADER = uintptr           /* wingdi.h:603:22 */
type PBITMAPINFOHEADER = uintptr            /* wingdi.h:603:42 */

type BITMAPV4HEADER = struct {
	bV4Size          DWORD
	bV4Width         LONG
	bV4Height        LONG
	bV4Planes        WORD
	bV4BitCount      WORD
	bV4V4Compression DWORD
	bV4SizeImage     DWORD
	bV4XPelsPerMeter LONG
	bV4YPelsPerMeter LONG
	bV4ClrUsed       DWORD
	bV4ClrImportant  DWORD
	bV4RedMask       DWORD
	bV4GreenMask     DWORD
	bV4BlueMask      DWORD
	bV4AlphaMask     DWORD
	bV4CSType        DWORD
	bV4Endpoints     CIEXYZTRIPLE
	bV4GammaRed      DWORD
	bV4GammaGreen    DWORD
	bV4GammaBlue     DWORD
}                               /* wingdi.h:628:5 */
type LPBITMAPV4HEADER = uintptr /* wingdi.h:628:20 */
type PBITMAPV4HEADER = uintptr  /* wingdi.h:628:38 */

type BITMAPV5HEADER = struct {
	bV5Size          DWORD
	bV5Width         LONG
	bV5Height        LONG
	bV5Planes        WORD
	bV5BitCount      WORD
	bV5Compression   DWORD
	bV5SizeImage     DWORD
	bV5XPelsPerMeter LONG
	bV5YPelsPerMeter LONG
	bV5ClrUsed       DWORD
	bV5ClrImportant  DWORD
	bV5RedMask       DWORD
	bV5GreenMask     DWORD
	bV5BlueMask      DWORD
	bV5AlphaMask     DWORD
	bV5CSType        DWORD
	bV5Endpoints     CIEXYZTRIPLE
	bV5GammaRed      DWORD
	bV5GammaGreen    DWORD
	bV5GammaBlue     DWORD
	bV5Intent        DWORD
	bV5ProfileData   DWORD
	bV5ProfileSize   DWORD
	bV5Reserved      DWORD
}                               /* wingdi.h:655:5 */
type LPBITMAPV5HEADER = uintptr /* wingdi.h:655:20 */
type PBITMAPV5HEADER = uintptr  /* wingdi.h:655:38 */

type tagBITMAPINFO = struct {
	bmiHeader BITMAPINFOHEADER
	bmiColors [1]RGBQUAD
} /* wingdi.h:669:11 */

type BITMAPINFO = tagBITMAPINFO /* wingdi.h:672:5 */
type LPBITMAPINFO = uintptr     /* wingdi.h:672:16 */
type PBITMAPINFO = uintptr      /* wingdi.h:672:30 */

type tagBITMAPCOREINFO = struct {
	bmciHeader BITMAPCOREHEADER
	bmciColors [1]RGBTRIPLE
	_          [1]byte
} /* wingdi.h:676:11 */

type BITMAPCOREINFO = tagBITMAPCOREINFO /* wingdi.h:679:5 */
type LPBITMAPCOREINFO = uintptr         /* wingdi.h:679:20 */
type PBITMAPCOREINFO = uintptr          /* wingdi.h:679:38 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type tagBITMAPFILEHEADER = struct {
	bfType      WORD
	_           [2]byte
	bfSize      DWORD
	bfReserved1 WORD
	bfReserved2 WORD
	bfOffBits   DWORD
} /* wingdi.h:682:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type BITMAPFILEHEADER = tagBITMAPFILEHEADER /* wingdi.h:688:5 */
type LPBITMAPFILEHEADER = uintptr           /* wingdi.h:688:22 */
type PBITMAPFILEHEADER = uintptr            /* wingdi.h:688:42 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type tagFONTSIGNATURE = struct {
	fsUsb [4]DWORD
	fsCsb [2]DWORD
} /* wingdi.h:697:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type FONTSIGNATURE = tagFONTSIGNATURE /* wingdi.h:700:5 */
type PFONTSIGNATURE = uintptr         /* wingdi.h:700:19 */
type LPFONTSIGNATURE = uintptr        /* wingdi.h:700:35 */

type tagCHARSETINFO = struct {
	ciCharset UINT
	ciACP     UINT
	fs        FONTSIGNATURE
} /* wingdi.h:702:11 */

type CHARSETINFO = tagCHARSETINFO /* wingdi.h:706:5 */
type PCHARSETINFO = uintptr       /* wingdi.h:706:17 */
type NPCHARSETINFO = uintptr      /* wingdi.h:706:31 */
type LPCHARSETINFO = uintptr      /* wingdi.h:706:46 */

type tagLOCALESIGNATURE = struct {
	lsUsb          [4]DWORD
	lsCsbDefault   [2]DWORD
	lsCsbSupported [2]DWORD
} /* wingdi.h:715:11 */

type LOCALESIGNATURE = tagLOCALESIGNATURE /* wingdi.h:719:5 */
type PLOCALESIGNATURE = uintptr           /* wingdi.h:719:21 */
type LPLOCALESIGNATURE = uintptr          /* wingdi.h:719:39 */

type tagHANDLETABLE = struct{ objectHandle [1]HGDIOBJ } /* wingdi.h:725:11 */

type HANDLETABLE = tagHANDLETABLE /* wingdi.h:727:5 */
type PHANDLETABLE = uintptr       /* wingdi.h:727:17 */
type LPHANDLETABLE = uintptr      /* wingdi.h:727:31 */

type tagMETARECORD = struct {
	rdSize     DWORD
	rdFunction WORD
	rdParm     [1]WORD
} /* wingdi.h:729:11 */

type METARECORD = tagMETARECORD /* wingdi.h:733:5 */
type PMETARECORD = uintptr      /* wingdi.h:736:42 */
type LPMETARECORD = uintptr     /* wingdi.h:739:42 */

type tagMETAFILEPICT = struct {
	mm   LONG
	xExt LONG
	yExt LONG
	hMF  HMETAFILE
} /* wingdi.h:741:11 */

type METAFILEPICT = tagMETAFILEPICT /* wingdi.h:746:5 */
type LPMETAFILEPICT = uintptr       /* wingdi.h:746:18 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type tagMETAHEADER = struct {
	mtType         WORD
	mtHeaderSize   WORD
	mtVersion      WORD
	_              [2]byte
	mtSize         DWORD
	mtNoObjects    WORD
	_              [2]byte
	mtMaxRecord    DWORD
	mtNoParameters WORD
	_              [2]byte
} /* wingdi.h:751:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type METAHEADER = tagMETAHEADER /* wingdi.h:759:5 */
type PMETAHEADER = uintptr      /* wingdi.h:760:42 */
type LPMETAHEADER = uintptr     /* wingdi.h:761:42 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type tagENHMETARECORD = struct {
	iType DWORD
	nSize DWORD
	dParm [1]DWORD
} /* wingdi.h:767:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type ENHMETARECORD = tagENHMETARECORD /* wingdi.h:771:5 */
type PENHMETARECORD = uintptr         /* wingdi.h:771:19 */
type LPENHMETARECORD = uintptr        /* wingdi.h:771:35 */

type tagENHMETAHEADER = struct {
	iType          DWORD
	nSize          DWORD
	rclBounds      RECTL
	rclFrame       RECTL
	dSignature     DWORD
	nVersion       DWORD
	nBytes         DWORD
	nRecords       DWORD
	nHandles       WORD
	sReserved      WORD
	nDescription   DWORD
	offDescription DWORD
	nPalEntries    DWORD
	szlDevice      SIZEL
	szlMillimeters SIZEL
	cbPixelFormat  DWORD
	offPixelFormat DWORD
	bOpenGL        DWORD
	szlMicrometers SIZEL
} /* wingdi.h:773:11 */

type ENHMETAHEADER = tagENHMETAHEADER /* wingdi.h:793:5 */
type PENHMETAHEADER = uintptr         /* wingdi.h:793:19 */
type LPENHMETAHEADER = uintptr        /* wingdi.h:793:35 */

type BCHAR = BYTE /* wingdi.h:807:16 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type tagTEXTMETRICA = struct {
	tmHeight           LONG
	tmAscent           LONG
	tmDescent          LONG
	tmInternalLeading  LONG
	tmExternalLeading  LONG
	tmAveCharWidth     LONG
	tmMaxCharWidth     LONG
	tmWeight           LONG
	tmOverhang         LONG
	tmDigitizedAspectX LONG
	tmDigitizedAspectY LONG
	tmFirstChar        BYTE
	tmLastChar         BYTE
	tmDefaultChar      BYTE
	tmBreakChar        BYTE
	tmItalic           BYTE
	tmUnderlined       BYTE
	tmStruckOut        BYTE
	tmPitchAndFamily   BYTE
	tmCharSet          BYTE
	_                  [3]byte
} /* wingdi.h:816:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type TEXTMETRICA = tagTEXTMETRICA /* wingdi.h:837:5 */
type PTEXTMETRICA = uintptr       /* wingdi.h:837:17 */
type NPTEXTMETRICA = uintptr      /* wingdi.h:837:31 */
type LPTEXTMETRICA = uintptr      /* wingdi.h:837:46 */

type tagTEXTMETRICW = struct {
	tmHeight           LONG
	tmAscent           LONG
	tmDescent          LONG
	tmInternalLeading  LONG
	tmExternalLeading  LONG
	tmAveCharWidth     LONG
	tmMaxCharWidth     LONG
	tmWeight           LONG
	tmOverhang         LONG
	tmDigitizedAspectX LONG
	tmDigitizedAspectY LONG
	tmFirstChar        WCHAR
	tmLastChar         WCHAR
	tmDefaultChar      WCHAR
	tmBreakChar        WCHAR
	tmItalic           BYTE
	tmUnderlined       BYTE
	tmStruckOut        BYTE
	tmPitchAndFamily   BYTE
	tmCharSet          BYTE
	_                  [3]byte
} /* wingdi.h:839:11 */

type TEXTMETRICW = tagTEXTMETRICW /* wingdi.h:860:5 */
type PTEXTMETRICW = uintptr       /* wingdi.h:860:17 */
type NPTEXTMETRICW = uintptr      /* wingdi.h:860:31 */
type LPTEXTMETRICW = uintptr      /* wingdi.h:860:46 */

type TEXTMETRIC = TEXTMETRICA     /* wingdi.h:862:3 */
type PTEXTMETRIC = PTEXTMETRICA   /* wingdi.h:863:3 */
type NPTEXTMETRIC = NPTEXTMETRICA /* wingdi.h:864:3 */
type LPTEXTMETRIC = LPTEXTMETRICA /* wingdi.h:865:3 */
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type tagNEWTEXTMETRICA = struct {
	tmHeight           LONG
	tmAscent           LONG
	tmDescent          LONG
	tmInternalLeading  LONG
	tmExternalLeading  LONG
	tmAveCharWidth     LONG
	tmMaxCharWidth     LONG
	tmWeight           LONG
	tmOverhang         LONG
	tmDigitizedAspectX LONG
	tmDigitizedAspectY LONG
	tmFirstChar        BYTE
	tmLastChar         BYTE
	tmDefaultChar      BYTE
	tmBreakChar        BYTE
	tmItalic           BYTE
	tmUnderlined       BYTE
	tmStruckOut        BYTE
	tmPitchAndFamily   BYTE
	tmCharSet          BYTE
	_                  [3]byte
	ntmFlags           DWORD
	ntmSizeEM          UINT
	ntmCellHeight      UINT
	ntmAvgWidth        UINT
} /* wingdi.h:883:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
type NEWTEXTMETRICA = tagNEWTEXTMETRICA /* wingdi.h:908:5 */
type PNEWTEXTMETRICA = uintptr          /* wingdi.h:908:20 */
type NPNEWTEXTMETRICA = uintptr         /* wingdi.h:908:37 */
type LPNEWTEXTMETRICA = uintptr         /* wingdi.h:908:55 */

type tagNEWTEXTMETRICW = struct {
	tmHeight           LONG
	tmAscent           LONG
	tmDescent          LONG
	tmInternalLeading  LONG
	tmExternalLeading  LONG
	tmAveCharWidth     LONG
	tmMaxCharWidth     LONG
	tmWeight           LONG
	tmOverhang         LONG
	tmDigitizedAspectX LONG
	tmDigitizedAspectY LONG
	tmFirstChar        WCHAR
	tmLastChar         WCHAR
	tmDefaultChar      WCHAR
	tmBreakChar        WCHAR
	tmItalic           BYTE
	tmUnderlined       BYTE
	tmStruckOut        BYTE
	tmPitchAndFamily   BYTE
	tmCharSet          BYTE
	_                  [3]byte
	ntmFlags           DWORD
	ntmSizeEM          UINT
	ntmCellHeight      UINT
	ntmAvgWidth        UINT
} /* wingdi.h:910:11 */

type NEWTEXTMETRICW = tagNEWTEXTMETRICW /* wingdi.h:935:5 */
type PNEWTEXTMETRICW = uintptr          /* wingdi.h:935:20 */
type NPNEWTEXTMETRICW = uintptr         /* wingdi.h:935:37 */
type LPNEWTEXTMETRICW = uintptr         /* wingdi.h:935:55 */

type NEWTEXTMETRIC = NEWTEXTMETRICA     /* wingdi.h:937:3 */
type PNEWTEXTMETRIC = PNEWTEXTMETRICA   /* wingdi.h:938:3 */
type NPNEWTEXTMETRIC = NPNEWTEXTMETRICA /* wingdi.h:939:3 */
type LPNEWTEXTMETRIC = LPNEWTEXTMETRICA /* wingdi.h:940:3 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type tagNEWTEXTMETRICEXA = struct {
	ntmTm      NEWTEXTMETRICA
	ntmFontSig FONTSIGNATURE
} /* wingdi.h:944:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type NEWTEXTMETRICEXA = tagNEWTEXTMETRICEXA /* wingdi.h:947:5 */

type tagNEWTEXTMETRICEXW = struct {
	ntmTm      NEWTEXTMETRICW
	ntmFontSig FONTSIGNATURE
} /* wingdi.h:949:11 */

type NEWTEXTMETRICEXW = tagNEWTEXTMETRICEXW /* wingdi.h:952:5 */

type NEWTEXTMETRICEX = NEWTEXTMETRICEXA /* wingdi.h:954:3 */

type tagPELARRAY = struct {
	paXCount LONG
	paYCount LONG
	paXExt   LONG
	paYExt   LONG
	paRGBs   BYTE
	_        [3]byte
} /* wingdi.h:959:11 */

type PELARRAY = tagPELARRAY /* wingdi.h:965:5 */
type PPELARRAY = uintptr    /* wingdi.h:965:14 */
type NPPELARRAY = uintptr   /* wingdi.h:965:25 */
type LPPELARRAY = uintptr   /* wingdi.h:965:37 */
type tagLOGBRUSH = struct {
	lbStyle UINT
	lbColor COLORREF
	lbHatch ULONG_PTR
} /* wingdi.h:968:11 */

type LOGBRUSH = tagLOGBRUSH /* wingdi.h:972:5 */
type PLOGBRUSH = uintptr    /* wingdi.h:972:14 */
type NPLOGBRUSH = uintptr   /* wingdi.h:972:25 */
type LPLOGBRUSH = uintptr   /* wingdi.h:972:37 */

type tagLOGBRUSH32 = struct {
	lbStyle UINT
	lbColor COLORREF
	lbHatch ULONG
} /* wingdi.h:974:11 */

type LOGBRUSH32 = tagLOGBRUSH32 /* wingdi.h:978:5 */
type PLOGBRUSH32 = uintptr      /* wingdi.h:978:16 */
type NPLOGBRUSH32 = uintptr     /* wingdi.h:978:29 */
type LPLOGBRUSH32 = uintptr     /* wingdi.h:978:43 */
type PATTERN = LOGBRUSH         /* wingdi.h:981:20 */
type PPATTERN = uintptr         /* wingdi.h:982:19 */
type NPPATTERN = uintptr        /* wingdi.h:983:19 */
type LPPATTERN = uintptr        /* wingdi.h:984:19 */

type tagLOGPEN = struct {
	lopnStyle UINT
	lopnWidth POINT
	lopnColor COLORREF
} /* wingdi.h:988:11 */

type LOGPEN = tagLOGPEN /* wingdi.h:992:5 */
type PLOGPEN = uintptr  /* wingdi.h:992:12 */
type NPLOGPEN = uintptr /* wingdi.h:992:21 */
type LPLOGPEN = uintptr /* wingdi.h:992:31 */

type tagEXTLOGPEN = struct {
	elpPenStyle   DWORD
	elpWidth      DWORD
	elpBrushStyle UINT
	elpColor      COLORREF
	elpHatch      ULONG_PTR
	elpNumEntries DWORD
	elpStyleEntry [1]DWORD
} /* wingdi.h:996:11 */

type EXTLOGPEN = tagEXTLOGPEN /* wingdi.h:1004:5 */
type PEXTLOGPEN = uintptr     /* wingdi.h:1004:15 */
type NPEXTLOGPEN = uintptr    /* wingdi.h:1004:27 */
type LPEXTLOGPEN = uintptr    /* wingdi.h:1004:40 */

type tagEXTLOGPEN32 = struct {
	elpPenStyle   DWORD
	elpWidth      DWORD
	elpBrushStyle UINT
	elpColor      COLORREF
	elpHatch      ULONG
	elpNumEntries DWORD
	elpStyleEntry [1]DWORD
} /* wingdi.h:1008:11 */

type EXTLOGPEN32 = tagEXTLOGPEN32 /* wingdi.h:1016:5 */
type PEXTLOGPEN32 = uintptr       /* wingdi.h:1016:18 */
type NPEXTLOGPEN32 = uintptr      /* wingdi.h:1016:33 */
type LPEXTLOGPEN32 = uintptr      /* wingdi.h:1016:49 */

type tagPALETTEENTRY = struct {
	peRed   BYTE
	peGreen BYTE
	peBlue  BYTE
	peFlags BYTE
} /* wingdi.h:1020:11 */

type PALETTEENTRY = tagPALETTEENTRY /* wingdi.h:1025:5 */
type PPALETTEENTRY = uintptr        /* wingdi.h:1025:18 */
type LPPALETTEENTRY = uintptr       /* wingdi.h:1025:33 */

type tagLOGPALETTE = struct {
	palVersion    WORD
	palNumEntries WORD
	palPalEntry   [1]PALETTEENTRY
} /* wingdi.h:1030:11 */

type LOGPALETTE = tagLOGPALETTE /* wingdi.h:1034:5 */
type PLOGPALETTE = uintptr      /* wingdi.h:1034:16 */
type NPLOGPALETTE = uintptr     /* wingdi.h:1034:29 */
type LPLOGPALETTE = uintptr     /* wingdi.h:1034:43 */

type tagLOGFONTA = struct {
	lfHeight         LONG
	lfWidth          LONG
	lfEscapement     LONG
	lfOrientation    LONG
	lfWeight         LONG
	lfItalic         BYTE
	lfUnderline      BYTE
	lfStrikeOut      BYTE
	lfCharSet        BYTE
	lfOutPrecision   BYTE
	lfClipPrecision  BYTE
	lfQuality        BYTE
	lfPitchAndFamily BYTE
	lfFaceName       [32]CHAR
} /* wingdi.h:1041:11 */

type LOGFONTA = tagLOGFONTA /* wingdi.h:1056:5 */
type PLOGFONTA = uintptr    /* wingdi.h:1056:14 */
type NPLOGFONTA = uintptr   /* wingdi.h:1056:25 */
type LPLOGFONTA = uintptr   /* wingdi.h:1056:37 */

type tagLOGFONTW = struct {
	lfHeight         LONG
	lfWidth          LONG
	lfEscapement     LONG
	lfOrientation    LONG
	lfWeight         LONG
	lfItalic         BYTE
	lfUnderline      BYTE
	lfStrikeOut      BYTE
	lfCharSet        BYTE
	lfOutPrecision   BYTE
	lfClipPrecision  BYTE
	lfQuality        BYTE
	lfPitchAndFamily BYTE
	lfFaceName       [32]WCHAR
} /* wingdi.h:1058:11 */

type LOGFONTW = tagLOGFONTW /* wingdi.h:1073:5 */
type PLOGFONTW = uintptr    /* wingdi.h:1073:14 */
type NPLOGFONTW = uintptr   /* wingdi.h:1073:25 */
type LPLOGFONTW = uintptr   /* wingdi.h:1073:37 */

type LOGFONT = LOGFONTA     /* wingdi.h:1075:3 */
type PLOGFONT = PLOGFONTA   /* wingdi.h:1076:3 */
type NPLOGFONT = NPLOGFONTA /* wingdi.h:1077:3 */
type LPLOGFONT = LPLOGFONTA /* wingdi.h:1078:3 */

type tagENUMLOGFONTA = struct {
	elfLogFont  LOGFONTA
	elfFullName [64]BYTE
	elfStyle    [32]BYTE
} /* wingdi.h:1084:11 */

type ENUMLOGFONTA = tagENUMLOGFONTA /* wingdi.h:1088:5 */
type LPENUMLOGFONTA = uintptr       /* wingdi.h:1088:18 */

type tagENUMLOGFONTW = struct {
	elfLogFont  LOGFONTW
	elfFullName [64]WCHAR
	elfStyle    [32]WCHAR
} /* wingdi.h:1090:11 */

type ENUMLOGFONTW = tagENUMLOGFONTW /* wingdi.h:1094:5 */
type LPENUMLOGFONTW = uintptr       /* wingdi.h:1094:18 */

type ENUMLOGFONT = ENUMLOGFONTA     /* wingdi.h:1096:3 */
type LPENUMLOGFONT = LPENUMLOGFONTA /* wingdi.h:1097:3 */

type tagENUMLOGFONTEXA = struct {
	elfLogFont  LOGFONTA
	elfFullName [64]BYTE
	elfStyle    [32]BYTE
	elfScript   [32]BYTE
} /* wingdi.h:1099:11 */

type ENUMLOGFONTEXA = tagENUMLOGFONTEXA /* wingdi.h:1104:5 */
type LPENUMLOGFONTEXA = uintptr         /* wingdi.h:1104:20 */

type tagENUMLOGFONTEXW = struct {
	elfLogFont  LOGFONTW
	elfFullName [64]WCHAR
	elfStyle    [32]WCHAR
	elfScript   [32]WCHAR
} /* wingdi.h:1106:11 */

type ENUMLOGFONTEXW = tagENUMLOGFONTEXW /* wingdi.h:1111:5 */
type LPENUMLOGFONTEXW = uintptr         /* wingdi.h:1111:20 */

type ENUMLOGFONTEX = ENUMLOGFONTEXA     /* wingdi.h:1113:3 */
type LPENUMLOGFONTEX = LPENUMLOGFONTEXA /* wingdi.h:1114:3 */

type tagPANOSE = struct {
	bFamilyType      BYTE
	bSerifStyle      BYTE
	bWeight          BYTE
	bProportion      BYTE
	bContrast        BYTE
	bStrokeVariation BYTE
	bArmStyle        BYTE
	bLetterform      BYTE
	bMidline         BYTE
	bXHeight         BYTE
} /* wingdi.h:1235:11 */

type PANOSE = tagPANOSE /* wingdi.h:1246:5 */
type LPPANOSE = uintptr /* wingdi.h:1246:12 */

type tagEXTLOGFONTA = struct {
	elfLogFont   LOGFONTA
	elfFullName  [64]BYTE
	elfStyle     [32]BYTE
	elfVersion   DWORD
	elfStyleSize DWORD
	elfMatch     DWORD
	elfReserved  DWORD
	elfVendorId  [4]BYTE
	elfCulture   DWORD
	elfPanose    PANOSE
	_            [2]byte
} /* wingdi.h:1356:11 */

type EXTLOGFONTA = tagEXTLOGFONTA /* wingdi.h:1367:5 */
type PEXTLOGFONTA = uintptr       /* wingdi.h:1367:17 */
type NPEXTLOGFONTA = uintptr      /* wingdi.h:1367:31 */
type LPEXTLOGFONTA = uintptr      /* wingdi.h:1367:46 */

type tagEXTLOGFONTW = struct {
	elfLogFont   LOGFONTW
	elfFullName  [64]WCHAR
	elfStyle     [32]WCHAR
	elfVersion   DWORD
	elfStyleSize DWORD
	elfMatch     DWORD
	elfReserved  DWORD
	elfVendorId  [4]BYTE
	elfCulture   DWORD
	elfPanose    PANOSE
	_            [2]byte
} /* wingdi.h:1369:11 */

type EXTLOGFONTW = tagEXTLOGFONTW /* wingdi.h:1380:5 */
type PEXTLOGFONTW = uintptr       /* wingdi.h:1380:17 */
type NPEXTLOGFONTW = uintptr      /* wingdi.h:1380:31 */
type LPEXTLOGFONTW = uintptr      /* wingdi.h:1380:46 */

type EXTLOGFONT = EXTLOGFONTA     /* wingdi.h:1382:3 */
type PEXTLOGFONT = PEXTLOGFONTA   /* wingdi.h:1383:3 */
type NPEXTLOGFONT = NPEXTLOGFONTA /* wingdi.h:1384:3 */
type LPEXTLOGFONT = LPEXTLOGFONTA /* wingdi.h:1385:3 */

type _devicemodeA = struct {
	dmDeviceName    [32]BYTE
	dmSpecVersion   WORD
	dmDriverVersion WORD
	dmSize          WORD
	dmDriverExtra   WORD
	dmFields        DWORD
	__44            struct {
		_   [0]uint32
		__0 struct {
			dmOrientation   int16
			dmPaperSize     int16
			dmPaperLength   int16
			dmPaperWidth    int16
			dmScale         int16
			dmCopies        int16
			dmDefaultSource int16
			dmPrintQuality  int16
		}
	}
	dmColor            int16
	dmDuplex           int16
	dmYResolution      int16
	dmTTOption         int16
	dmCollate          int16
	dmFormName         [32]BYTE
	dmLogPixels        WORD
	dmBitsPerPel       DWORD
	dmPelsWidth        DWORD
	dmPelsHeight       DWORD
	__116              struct{ dmDisplayFlags DWORD }
	dmDisplayFrequency DWORD
	dmICMMethod        DWORD
	dmICMIntent        DWORD
	dmMediaType        DWORD
	dmDitherType       DWORD
	dmReserved1        DWORD
	dmReserved2        DWORD
	dmPanningWidth     DWORD
	dmPanningHeight    DWORD
} /* wingdi.h:1669:11 */

type DEVMODEA = _devicemodeA /* wingdi.h:1716:5 */
type PDEVMODEA = uintptr     /* wingdi.h:1716:14 */
type NPDEVMODEA = uintptr    /* wingdi.h:1716:25 */
type LPDEVMODEA = uintptr    /* wingdi.h:1716:37 */

type _devicemodeW = struct {
	dmDeviceName    [32]WCHAR
	dmSpecVersion   WORD
	dmDriverVersion WORD
	dmSize          WORD
	dmDriverExtra   WORD
	dmFields        DWORD
	__76            struct {
		_   [0]uint32
		__0 struct {
			dmOrientation   int16
			dmPaperSize     int16
			dmPaperLength   int16
			dmPaperWidth    int16
			dmScale         int16
			dmCopies        int16
			dmDefaultSource int16
			dmPrintQuality  int16
		}
	}
	dmColor            int16
	dmDuplex           int16
	dmYResolution      int16
	dmTTOption         int16
	dmCollate          int16
	dmFormName         [32]WCHAR
	dmLogPixels        WORD
	dmBitsPerPel       DWORD
	dmPelsWidth        DWORD
	dmPelsHeight       DWORD
	__180              struct{ dmDisplayFlags DWORD }
	dmDisplayFrequency DWORD
	dmICMMethod        DWORD
	dmICMIntent        DWORD
	dmMediaType        DWORD
	dmDitherType       DWORD
	dmReserved1        DWORD
	dmReserved2        DWORD
	dmPanningWidth     DWORD
	dmPanningHeight    DWORD
} /* wingdi.h:1718:11 */

type DEVMODEW = _devicemodeW /* wingdi.h:1765:5 */
type PDEVMODEW = uintptr     /* wingdi.h:1765:14 */
type NPDEVMODEW = uintptr    /* wingdi.h:1765:25 */
type LPDEVMODEW = uintptr    /* wingdi.h:1765:37 */

type DEVMODE = DEVMODEA     /* wingdi.h:1767:3 */
type PDEVMODE = PDEVMODEA   /* wingdi.h:1768:3 */
type NPDEVMODE = NPDEVMODEA /* wingdi.h:1769:3 */
type LPDEVMODE = LPDEVMODEA /* wingdi.h:1770:3 */

type _DISPLAY_DEVICEA = struct {
	cb           DWORD
	DeviceName   [32]CHAR
	DeviceString [128]CHAR
	StateFlags   DWORD
	DeviceID     [128]CHAR
	DeviceKey    [128]CHAR
} /* wingdi.h:2021:11 */

type DISPLAY_DEVICEA = _DISPLAY_DEVICEA /* wingdi.h:2028:5 */
type PDISPLAY_DEVICEA = uintptr         /* wingdi.h:2028:21 */
type LPDISPLAY_DEVICEA = uintptr        /* wingdi.h:2028:39 */

type _DISPLAY_DEVICEW = struct {
	cb           DWORD
	DeviceName   [32]WCHAR
	DeviceString [128]WCHAR
	StateFlags   DWORD
	DeviceID     [128]WCHAR
	DeviceKey    [128]WCHAR
} /* wingdi.h:2030:11 */

type DISPLAY_DEVICEW = _DISPLAY_DEVICEW /* wingdi.h:2037:5 */
type PDISPLAY_DEVICEW = uintptr         /* wingdi.h:2037:21 */
type LPDISPLAY_DEVICEW = uintptr        /* wingdi.h:2037:39 */

type DISPLAY_DEVICE = DISPLAY_DEVICEA     /* wingdi.h:2039:3 */
type PDISPLAY_DEVICE = PDISPLAY_DEVICEA   /* wingdi.h:2040:3 */
type LPDISPLAY_DEVICE = LPDISPLAY_DEVICEA /* wingdi.h:2041:3 */

type _RGNDATAHEADER = struct {
	dwSize   DWORD
	iType    DWORD
	nCount   DWORD
	nRgnSize DWORD
	rcBound  RECT
} /* wingdi.h:2315:11 */

type RGNDATAHEADER = _RGNDATAHEADER /* wingdi.h:2321:5 */
type PRGNDATAHEADER = uintptr       /* wingdi.h:2321:19 */

type _RGNDATA = struct {
	rdh    RGNDATAHEADER
	Buffer [1]int8
	_      [3]byte
} /* wingdi.h:2323:11 */

type RGNDATA = _RGNDATA  /* wingdi.h:2326:5 */
type PRGNDATA = uintptr  /* wingdi.h:2326:13 */
type NPRGNDATA = uintptr /* wingdi.h:2326:23 */
type LPRGNDATA = uintptr /* wingdi.h:2326:34 */

type _ABC = struct {
	abcA int32
	abcB UINT
	abcC int32
} /* wingdi.h:2332:11 */

type ABC = _ABC      /* wingdi.h:2336:5 */
type PABC = uintptr  /* wingdi.h:2336:9 */
type NPABC = uintptr /* wingdi.h:2336:15 */
type LPABC = uintptr /* wingdi.h:2336:22 */

type _ABCFLOAT = struct {
	abcfA FLOAT
	abcfB FLOAT
	abcfC FLOAT
} /* wingdi.h:2338:11 */

type ABCFLOAT = _ABCFLOAT /* wingdi.h:2342:5 */
type PABCFLOAT = uintptr  /* wingdi.h:2342:14 */
type NPABCFLOAT = uintptr /* wingdi.h:2342:25 */
type LPABCFLOAT = uintptr /* wingdi.h:2342:37 */

type _OUTLINETEXTMETRICA = struct {
	otmSize                UINT
	otmTextMetrics         TEXTMETRICA
	otmFiller              BYTE
	otmPanoseNumber        PANOSE
	_                      [1]byte
	otmfsSelection         UINT
	otmfsType              UINT
	otmsCharSlopeRise      int32
	otmsCharSlopeRun       int32
	otmItalicAngle         int32
	otmEMSquare            UINT
	otmAscent              int32
	otmDescent             int32
	otmLineGap             UINT
	otmsCapEmHeight        UINT
	otmsXHeight            UINT
	otmrcFontBox           RECT
	otmMacAscent           int32
	otmMacDescent          int32
	otmMacLineGap          UINT
	otmusMinimumPPEM       UINT
	otmptSubscriptSize     POINT
	otmptSubscriptOffset   POINT
	otmptSuperscriptSize   POINT
	otmptSuperscriptOffset POINT
	otmsStrikeoutSize      UINT
	otmsStrikeoutPosition  int32
	otmsUnderscoreSize     int32
	otmsUnderscorePosition int32
	otmpFamilyName         PSTR
	otmpFaceName           PSTR
	otmpStyleName          PSTR
	otmpFullName           PSTR
} /* wingdi.h:2348:11 */

type OUTLINETEXTMETRICA = _OUTLINETEXTMETRICA /* wingdi.h:2381:5 */
type POUTLINETEXTMETRICA = uintptr            /* wingdi.h:2381:24 */
type NPOUTLINETEXTMETRICA = uintptr           /* wingdi.h:2381:45 */
type LPOUTLINETEXTMETRICA = uintptr           /* wingdi.h:2381:67 */

type _OUTLINETEXTMETRICW = struct {
	otmSize                UINT
	otmTextMetrics         TEXTMETRICW
	otmFiller              BYTE
	otmPanoseNumber        PANOSE
	_                      [1]byte
	otmfsSelection         UINT
	otmfsType              UINT
	otmsCharSlopeRise      int32
	otmsCharSlopeRun       int32
	otmItalicAngle         int32
	otmEMSquare            UINT
	otmAscent              int32
	otmDescent             int32
	otmLineGap             UINT
	otmsCapEmHeight        UINT
	otmsXHeight            UINT
	otmrcFontBox           RECT
	otmMacAscent           int32
	otmMacDescent          int32
	otmMacLineGap          UINT
	otmusMinimumPPEM       UINT
	otmptSubscriptSize     POINT
	otmptSubscriptOffset   POINT
	otmptSuperscriptSize   POINT
	otmptSuperscriptOffset POINT
	otmsStrikeoutSize      UINT
	otmsStrikeoutPosition  int32
	otmsUnderscoreSize     int32
	otmsUnderscorePosition int32
	otmpFamilyName         PSTR
	otmpFaceName           PSTR
	otmpStyleName          PSTR
	otmpFullName           PSTR
} /* wingdi.h:2383:11 */

type OUTLINETEXTMETRICW = _OUTLINETEXTMETRICW /* wingdi.h:2416:5 */
type POUTLINETEXTMETRICW = uintptr            /* wingdi.h:2416:24 */
type NPOUTLINETEXTMETRICW = uintptr           /* wingdi.h:2416:45 */
type LPOUTLINETEXTMETRICW = uintptr           /* wingdi.h:2416:67 */

type OUTLINETEXTMETRIC = OUTLINETEXTMETRICA     /* wingdi.h:2418:3 */
type POUTLINETEXTMETRIC = POUTLINETEXTMETRICA   /* wingdi.h:2419:3 */
type NPOUTLINETEXTMETRIC = NPOUTLINETEXTMETRICA /* wingdi.h:2420:3 */
type LPOUTLINETEXTMETRIC = LPOUTLINETEXTMETRICA /* wingdi.h:2421:3 */

type tagPOLYTEXTA = struct {
	x       int32
	y       int32
	n       UINT
	lpstr   LPCSTR
	uiFlags UINT
	rcl     RECT
	pdx     uintptr
} /* wingdi.h:2426:11 */

type POLYTEXTA = tagPOLYTEXTA /* wingdi.h:2434:5 */
type PPOLYTEXTA = uintptr     /* wingdi.h:2434:15 */
type NPPOLYTEXTA = uintptr    /* wingdi.h:2434:27 */
type LPPOLYTEXTA = uintptr    /* wingdi.h:2434:40 */

type tagPOLYTEXTW = struct {
	x       int32
	y       int32
	n       UINT
	lpstr   LPCWSTR
	uiFlags UINT
	rcl     RECT
	pdx     uintptr
} /* wingdi.h:2436:11 */

type POLYTEXTW = tagPOLYTEXTW /* wingdi.h:2444:5 */
type PPOLYTEXTW = uintptr     /* wingdi.h:2444:15 */
type NPPOLYTEXTW = uintptr    /* wingdi.h:2444:27 */
type LPPOLYTEXTW = uintptr    /* wingdi.h:2444:40 */

type POLYTEXT = POLYTEXTA     /* wingdi.h:2446:3 */
type PPOLYTEXT = PPOLYTEXTA   /* wingdi.h:2447:3 */
type NPPOLYTEXT = NPPOLYTEXTA /* wingdi.h:2448:3 */
type LPPOLYTEXT = LPPOLYTEXTA /* wingdi.h:2449:3 */

type _FIXED = struct {
	fract WORD
	value int16
} /* wingdi.h:2453:11 */

type FIXED = _FIXED /* wingdi.h:2456:5 */

type _MAT2 = struct {
	eM11 FIXED
	eM12 FIXED
	eM21 FIXED
	eM22 FIXED
} /* wingdi.h:2458:11 */

type MAT2 = _MAT2     /* wingdi.h:2463:5 */
type LPMAT2 = uintptr /* wingdi.h:2463:10 */

type _GLYPHMETRICS = struct {
	gmBlackBoxX     UINT
	gmBlackBoxY     UINT
	gmptGlyphOrigin POINT
	gmCellIncX      int16
	gmCellIncY      int16
} /* wingdi.h:2465:11 */

type GLYPHMETRICS = _GLYPHMETRICS /* wingdi.h:2471:5 */
type LPGLYPHMETRICS = uintptr     /* wingdi.h:2471:18 */

type tagPOINTFX = struct {
	x FIXED
	y FIXED
} /* wingdi.h:2491:11 */

type POINTFX = tagPOINTFX /* wingdi.h:2494:5 */
type LPPOINTFX = uintptr  /* wingdi.h:2494:13 */

type tagTTPOLYCURVE = struct {
	wType WORD
	cpfx  WORD
	apfx  [1]POINTFX
} /* wingdi.h:2496:11 */

type TTPOLYCURVE = tagTTPOLYCURVE /* wingdi.h:2500:5 */
type LPTTPOLYCURVE = uintptr      /* wingdi.h:2500:17 */

type tagTTPOLYGONHEADER = struct {
	cb       DWORD
	dwType   DWORD
	pfxStart POINTFX
} /* wingdi.h:2502:11 */

type TTPOLYGONHEADER = tagTTPOLYGONHEADER /* wingdi.h:2506:5 */
type LPTTPOLYGONHEADER = uintptr          /* wingdi.h:2506:21 */

type tagGCP_RESULTSA = struct {
	lStructSize DWORD
	lpOutString LPSTR
	lpOrder     uintptr
	lpDx        uintptr
	lpCaretPos  uintptr
	lpClass     LPSTR
	lpGlyphs    LPWSTR
	nGlyphs     UINT
	nMaxFit     int32
} /* wingdi.h:2549:11 */

type GCP_RESULTSA = tagGCP_RESULTSA /* wingdi.h:2559:5 */
type LPGCP_RESULTSA = uintptr       /* wingdi.h:2559:18 */
type tagGCP_RESULTSW = struct {
	lStructSize DWORD
	lpOutString LPWSTR
	lpOrder     uintptr
	lpDx        uintptr
	lpCaretPos  uintptr
	lpClass     LPSTR
	lpGlyphs    LPWSTR
	nGlyphs     UINT
	nMaxFit     int32
} /* wingdi.h:2560:11 */

type GCP_RESULTSW = tagGCP_RESULTSW /* wingdi.h:2570:5 */
type LPGCP_RESULTSW = uintptr       /* wingdi.h:2570:18 */

type GCP_RESULTS = GCP_RESULTSA     /* wingdi.h:2572:3 */
type LPGCP_RESULTS = LPGCP_RESULTSA /* wingdi.h:2573:3 */

type _RASTERIZER_STATUS = struct {
	nSize       int16
	wFlags      int16
	nLanguageID int16
} /* wingdi.h:2575:11 */

type RASTERIZER_STATUS = _RASTERIZER_STATUS /* wingdi.h:2579:5 */
type LPRASTERIZER_STATUS = uintptr          /* wingdi.h:2579:23 */

type tagPIXELFORMATDESCRIPTOR = struct {
	nSize           WORD
	nVersion        WORD
	dwFlags         DWORD
	iPixelType      BYTE
	cColorBits      BYTE
	cRedBits        BYTE
	cRedShift       BYTE
	cGreenBits      BYTE
	cGreenShift     BYTE
	cBlueBits       BYTE
	cBlueShift      BYTE
	cAlphaBits      BYTE
	cAlphaShift     BYTE
	cAccumBits      BYTE
	cAccumRedBits   BYTE
	cAccumGreenBits BYTE
	cAccumBlueBits  BYTE
	cAccumAlphaBits BYTE
	cDepthBits      BYTE
	cStencilBits    BYTE
	cAuxBuffers     BYTE
	iLayerType      BYTE
	bReserved       BYTE
	dwLayerMask     DWORD
	dwVisibleMask   DWORD
	dwDamageMask    DWORD
} /* wingdi.h:2586:11 */

type PIXELFORMATDESCRIPTOR = tagPIXELFORMATDESCRIPTOR /* wingdi.h:2613:5 */
type PPIXELFORMATDESCRIPTOR = uintptr                 /* wingdi.h:2613:27 */
type LPPIXELFORMATDESCRIPTOR = uintptr                /* wingdi.h:2613:51 */

type OLDFONTENUMPROCA = uintptr /* wingdi.h:2646:15 */
type OLDFONTENUMPROCW = uintptr /* wingdi.h:2647:15 */

type FONTENUMPROCA = OLDFONTENUMPROCA /* wingdi.h:2657:28 */
type FONTENUMPROCW = OLDFONTENUMPROCW /* wingdi.h:2658:28 */

type FONTENUMPROC = FONTENUMPROCA /* wingdi.h:2660:3 */

type GOBJENUMPROC = uintptr /* wingdi.h:2662:15 */
type LINEDDAPROC = uintptr  /* wingdi.h:2663:16 */

type LPFNDEVMODE = uintptr /* wingdi.h:2725:16 */
type LPFNDEVCAPS = uintptr /* wingdi.h:2726:17 */

type tagWCRANGE = struct {
	wcLow   WCHAR
	cGlyphs USHORT
} /* wingdi.h:2906:11 */

type WCRANGE = tagWCRANGE /* wingdi.h:2909:5 */
type PWCRANGE = uintptr   /* wingdi.h:2909:13 */
type LPWCRANGE = uintptr  /* wingdi.h:2909:23 */

type tagGLYPHSET = struct {
	cbThis           DWORD
	flAccel          DWORD
	cGlyphsSupported DWORD
	cRanges          DWORD
	ranges           [1]WCRANGE
} /* wingdi.h:2911:11 */

type GLYPHSET = tagGLYPHSET /* wingdi.h:2917:5 */
type PGLYPHSET = uintptr    /* wingdi.h:2917:14 */
type LPGLYPHSET = uintptr   /* wingdi.h:2917:25 */

type tagDESIGNVECTOR = struct {
	dvReserved DWORD
	dvNumAxes  DWORD
	dvValues   [16]LONG
} /* wingdi.h:2937:11 */

type DESIGNVECTOR = tagDESIGNVECTOR /* wingdi.h:2941:5 */
type PDESIGNVECTOR = uintptr        /* wingdi.h:2941:18 */
type LPDESIGNVECTOR = uintptr       /* wingdi.h:2941:33 */

type tagAXISINFOA = struct {
	axMinValue LONG
	axMaxValue LONG
	axAxisName [16]BYTE
} /* wingdi.h:2958:11 */

type AXISINFOA = tagAXISINFOA /* wingdi.h:2962:5 */
type PAXISINFOA = uintptr     /* wingdi.h:2962:15 */
type LPAXISINFOA = uintptr    /* wingdi.h:2962:27 */

type tagAXISINFOW = struct {
	axMinValue LONG
	axMaxValue LONG
	axAxisName [16]WCHAR
} /* wingdi.h:2964:11 */

type AXISINFOW = tagAXISINFOW /* wingdi.h:2968:5 */
type PAXISINFOW = uintptr     /* wingdi.h:2968:15 */
type LPAXISINFOW = uintptr    /* wingdi.h:2968:27 */

type AXISINFO = AXISINFOA     /* wingdi.h:2970:3 */
type PAXISINFO = PAXISINFOA   /* wingdi.h:2971:3 */
type LPAXISINFO = LPAXISINFOA /* wingdi.h:2972:3 */

type tagAXESLISTA = struct {
	axlReserved DWORD
	axlNumAxes  DWORD
	axlAxisInfo [16]AXISINFOA
} /* wingdi.h:2974:11 */

type AXESLISTA = tagAXESLISTA /* wingdi.h:2978:5 */
type PAXESLISTA = uintptr     /* wingdi.h:2978:15 */
type LPAXESLISTA = uintptr    /* wingdi.h:2978:27 */

type tagAXESLISTW = struct {
	axlReserved DWORD
	axlNumAxes  DWORD
	axlAxisInfo [16]AXISINFOW
} /* wingdi.h:2980:11 */

type AXESLISTW = tagAXESLISTW /* wingdi.h:2984:5 */
type PAXESLISTW = uintptr     /* wingdi.h:2984:15 */
type LPAXESLISTW = uintptr    /* wingdi.h:2984:27 */

type AXESLIST = AXESLISTA     /* wingdi.h:2986:3 */
type PAXESLIST = PAXESLISTA   /* wingdi.h:2987:3 */
type LPAXESLIST = LPAXESLISTA /* wingdi.h:2988:3 */

type tagENUMLOGFONTEXDVA = struct {
	elfEnumLogfontEx ENUMLOGFONTEXA
	elfDesignVector  DESIGNVECTOR
} /* wingdi.h:2990:11 */

type ENUMLOGFONTEXDVA = tagENUMLOGFONTEXDVA /* wingdi.h:2993:5 */
type PENUMLOGFONTEXDVA = uintptr            /* wingdi.h:2993:22 */
type LPENUMLOGFONTEXDVA = uintptr           /* wingdi.h:2993:41 */

type tagENUMLOGFONTEXDVW = struct {
	elfEnumLogfontEx ENUMLOGFONTEXW
	elfDesignVector  DESIGNVECTOR
} /* wingdi.h:2995:11 */

type ENUMLOGFONTEXDVW = tagENUMLOGFONTEXDVW /* wingdi.h:2998:5 */
type PENUMLOGFONTEXDVW = uintptr            /* wingdi.h:2998:22 */
type LPENUMLOGFONTEXDVW = uintptr           /* wingdi.h:2998:41 */

type ENUMLOGFONTEXDV = ENUMLOGFONTEXDVA     /* wingdi.h:3000:3 */
type PENUMLOGFONTEXDV = PENUMLOGFONTEXDVA   /* wingdi.h:3001:3 */
type LPENUMLOGFONTEXDV = LPENUMLOGFONTEXDVA /* wingdi.h:3002:3 */

type tagENUMTEXTMETRICA = struct {
	etmNewTextMetricEx NEWTEXTMETRICEXA
	etmAxesList        AXESLISTA
} /* wingdi.h:3010:11 */

type ENUMTEXTMETRICA = tagENUMTEXTMETRICA /* wingdi.h:3013:5 */
type PENUMTEXTMETRICA = uintptr           /* wingdi.h:3013:21 */
type LPENUMTEXTMETRICA = uintptr          /* wingdi.h:3013:39 */
type tagENUMTEXTMETRICW = struct {
	etmNewTextMetricEx NEWTEXTMETRICEXW
	etmAxesList        AXESLISTW
} /* wingdi.h:3014:11 */

type ENUMTEXTMETRICW = tagENUMTEXTMETRICW /* wingdi.h:3018:5 */
type PENUMTEXTMETRICW = uintptr           /* wingdi.h:3018:21 */
type LPENUMTEXTMETRICW = uintptr          /* wingdi.h:3018:39 */

type ENUMTEXTMETRIC = ENUMTEXTMETRICA     /* wingdi.h:3020:3 */
type PENUMTEXTMETRIC = PENUMTEXTMETRICA   /* wingdi.h:3021:3 */
type LPENUMTEXTMETRIC = LPENUMTEXTMETRICA /* wingdi.h:3022:3 */

type COLOR16 = USHORT /* wingdi.h:3124:18 */

type _TRIVERTEX = struct {
	x     LONG
	y     LONG
	Red   COLOR16
	Green COLOR16
	Blue  COLOR16
	Alpha COLOR16
} /* wingdi.h:3126:11 */

type TRIVERTEX = _TRIVERTEX /* wingdi.h:3133:5 */
type PTRIVERTEX = uintptr   /* wingdi.h:3133:15 */
type LPTRIVERTEX = uintptr  /* wingdi.h:3133:27 */
type _GRADIENT_TRIANGLE = struct {
	Vertex1 ULONG
	Vertex2 ULONG
	Vertex3 ULONG
} /* wingdi.h:3136:11 */

type GRADIENT_TRIANGLE = _GRADIENT_TRIANGLE /* wingdi.h:3140:5 */
type PGRADIENT_TRIANGLE = uintptr           /* wingdi.h:3140:23 */
type LPGRADIENT_TRIANGLE = uintptr          /* wingdi.h:3140:43 */

type _GRADIENT_RECT = struct {
	UpperLeft  ULONG
	LowerRight ULONG
} /* wingdi.h:3142:11 */

type GRADIENT_RECT = _GRADIENT_RECT /* wingdi.h:3145:5 */
type PGRADIENT_RECT = uintptr       /* wingdi.h:3145:19 */
type LPGRADIENT_RECT = uintptr      /* wingdi.h:3145:35 */
type _BLENDFUNCTION = struct {
	BlendOp             BYTE
	BlendFlags          BYTE
	SourceConstantAlpha BYTE
	AlphaFormat         BYTE
} /* wingdi.h:3148:11 */

type BLENDFUNCTION = _BLENDFUNCTION /* wingdi.h:3153:5 */
type PBLENDFUNCTION = uintptr       /* wingdi.h:3153:19 */

type MFENUMPROC = uintptr /* wingdi.h:3181:15 */

type ENHMFENUMPROC = uintptr /* wingdi.h:3185:15 */

type tagDIBSECTION = struct {
	dsBm        BITMAP
	dsBmih      BITMAPINFOHEADER
	dsBitfields [3]DWORD
	dshSection  HANDLE
	dsOffset    DWORD
} /* wingdi.h:3217:11 */

type DIBSECTION = tagDIBSECTION /* wingdi.h:3223:5 */
type LPDIBSECTION = uintptr     /* wingdi.h:3223:16 */
type PDIBSECTION = uintptr      /* wingdi.h:3223:30 */

type tagCOLORADJUSTMENT = struct {
	caSize            WORD
	caFlags           WORD
	caIlluminantIndex WORD
	caRedGamma        WORD
	caGreenGamma      WORD
	caBlueGamma       WORD
	caReferenceBlack  WORD
	caReferenceWhite  WORD
	caContrast        SHORT
	caBrightness      SHORT
	caColorfulness    SHORT
	caRedGreenTint    SHORT
} /* wingdi.h:3265:11 */

type COLORADJUSTMENT = tagCOLORADJUSTMENT /* wingdi.h:3278:5 */
type PCOLORADJUSTMENT = uintptr           /* wingdi.h:3278:21 */
type LPCOLORADJUSTMENT = uintptr          /* wingdi.h:3278:39 */

type ABORTPROC = uintptr /* wingdi.h:3284:19 */

type _DOCINFOA = struct {
	cbSize       int32
	lpszDocName  LPCSTR
	lpszOutput   LPCSTR
	lpszDatatype LPCSTR
	fwType       DWORD
} /* wingdi.h:3286:11 */

type DOCINFOA = _DOCINFOA /* wingdi.h:3292:5 */
type LPDOCINFOA = uintptr /* wingdi.h:3292:14 */

type _DOCINFOW = struct {
	cbSize       int32
	lpszDocName  LPCWSTR
	lpszOutput   LPCWSTR
	lpszDatatype LPCWSTR
	fwType       DWORD
} /* wingdi.h:3294:11 */

type DOCINFOW = _DOCINFOW /* wingdi.h:3300:5 */
type LPDOCINFOW = uintptr /* wingdi.h:3300:14 */

type DOCINFO = DOCINFOA     /* wingdi.h:3302:3 */
type LPDOCINFO = LPDOCINFOA /* wingdi.h:3303:3 */

type tagKERNINGPAIR = struct {
	wFirst      WORD
	wSecond     WORD
	iKernAmount int32
} /* wingdi.h:3373:11 */

type KERNINGPAIR = tagKERNINGPAIR /* wingdi.h:3377:5 */
type LPKERNINGPAIR = uintptr      /* wingdi.h:3377:17 */

type ICMENUMPROCA = uintptr /* wingdi.h:3395:15 */
type ICMENUMPROCW = uintptr /* wingdi.h:3396:15 */

type tagEMR = struct {
	iType DWORD
	nSize DWORD
} /* wingdi.h:3561:11 */

type EMR = tagEMR   /* wingdi.h:3564:5 */
type PEMR = uintptr /* wingdi.h:3564:9 */

type tagEMRTEXT = struct {
	ptlReference POINTL
	nChars       DWORD
	offString    DWORD
	fOptions     DWORD
	rcl          RECTL
	offDx        DWORD
} /* wingdi.h:3566:11 */

type EMRTEXT = tagEMRTEXT /* wingdi.h:3573:5 */
type PEMRTEXT = uintptr   /* wingdi.h:3573:13 */

type tagABORTPATH = struct{ emr EMR } /* wingdi.h:3575:11 */

type EMRABORTPATH = tagABORTPATH      /* wingdi.h:3577:5 */
type PEMRABORTPATH = uintptr          /* wingdi.h:3577:18 */
type EMRBEGINPATH = tagABORTPATH      /* wingdi.h:3577:33 */
type PEMRBEGINPATH = uintptr          /* wingdi.h:3577:46 */
type EMRENDPATH = tagABORTPATH        /* wingdi.h:3577:61 */
type PEMRENDPATH = uintptr            /* wingdi.h:3577:72 */
type EMRCLOSEFIGURE = tagABORTPATH    /* wingdi.h:3577:85 */
type PEMRCLOSEFIGURE = uintptr        /* wingdi.h:3577:100 */
type EMRFLATTENPATH = tagABORTPATH    /* wingdi.h:3577:117 */
type PEMRFLATTENPATH = uintptr        /* wingdi.h:3577:132 */
type EMRWIDENPATH = tagABORTPATH      /* wingdi.h:3577:149 */
type PEMRWIDENPATH = uintptr          /* wingdi.h:3577:162 */
type EMRSETMETARGN = tagABORTPATH     /* wingdi.h:3577:177 */
type PEMRSETMETARGN = uintptr         /* wingdi.h:3577:191 */
type EMRSAVEDC = tagABORTPATH         /* wingdi.h:3577:207 */
type PEMRSAVEDC = uintptr             /* wingdi.h:3577:217 */
type EMRREALIZEPALETTE = tagABORTPATH /* wingdi.h:3577:229 */
type PEMRREALIZEPALETTE = uintptr     /* wingdi.h:3577:247 */

type tagEMRSELECTCLIPPATH = struct {
	emr   EMR
	iMode DWORD
} /* wingdi.h:3579:11 */

type EMRSELECTCLIPPATH = tagEMRSELECTCLIPPATH    /* wingdi.h:3582:5 */
type PEMRSELECTCLIPPATH = uintptr                /* wingdi.h:3582:23 */
type EMRSETBKMODE = tagEMRSELECTCLIPPATH         /* wingdi.h:3582:43 */
type PEMRSETBKMODE = uintptr                     /* wingdi.h:3582:56 */
type EMRSETMAPMODE = tagEMRSELECTCLIPPATH        /* wingdi.h:3582:71 */
type PEMRSETMAPMODE = uintptr                    /* wingdi.h:3582:85 */
type EMRSETLAYOUT = tagEMRSELECTCLIPPATH         /* wingdi.h:3582:101 */
type PEMRSETLAYOUT = uintptr                     /* wingdi.h:3582:114 */
type EMRSETPOLYFILLMODE = tagEMRSELECTCLIPPATH   /* wingdi.h:3583:5 */
type PEMRSETPOLYFILLMODE = uintptr               /* wingdi.h:3583:24 */
type EMRSETROP2 = tagEMRSELECTCLIPPATH           /* wingdi.h:3583:45 */
type PEMRSETROP2 = uintptr                       /* wingdi.h:3583:56 */
type EMRSETSTRETCHBLTMODE = tagEMRSELECTCLIPPATH /* wingdi.h:3583:69 */
type PEMRSETSTRETCHBLTMODE = uintptr             /* wingdi.h:3583:90 */
type EMRSETICMMODE = tagEMRSELECTCLIPPATH        /* wingdi.h:3583:113 */
type PEMRSETICMMODE = uintptr                    /* wingdi.h:3584:5 */
type EMRSETTEXTALIGN = tagEMRSELECTCLIPPATH      /* wingdi.h:3584:21 */
type PEMRSETTEXTALIGN = uintptr                  /* wingdi.h:3584:37 */

type tagEMRSETMITERLIMIT = struct {
	emr         EMR
	eMiterLimit FLOAT
} /* wingdi.h:3586:11 */

type EMRSETMITERLIMIT = tagEMRSETMITERLIMIT /* wingdi.h:3589:5 */
type PEMRSETMITERLIMIT = uintptr            /* wingdi.h:3589:22 */

type tagEMRRESTOREDC = struct {
	emr       EMR
	iRelative LONG
} /* wingdi.h:3591:11 */

type EMRRESTOREDC = tagEMRRESTOREDC /* wingdi.h:3594:5 */
type PEMRRESTOREDC = uintptr        /* wingdi.h:3594:18 */

type tagEMRSETARCDIRECTION = struct {
	emr           EMR
	iArcDirection DWORD
} /* wingdi.h:3596:11 */

type EMRSETARCDIRECTION = tagEMRSETARCDIRECTION /* wingdi.h:3600:5 */
type PEMRSETARCDIRECTION = uintptr              /* wingdi.h:3600:24 */

type tagEMRSETMAPPERFLAGS = struct {
	emr     EMR
	dwFlags DWORD
} /* wingdi.h:3602:11 */

type EMRSETMAPPERFLAGS = tagEMRSETMAPPERFLAGS /* wingdi.h:3605:5 */
type PEMRSETMAPPERFLAGS = uintptr             /* wingdi.h:3605:23 */

type tagEMRSETTEXTCOLOR = struct {
	emr     EMR
	crColor COLORREF
} /* wingdi.h:3607:11 */

type EMRSETBKCOLOR = tagEMRSETTEXTCOLOR   /* wingdi.h:3610:5 */
type PEMRSETBKCOLOR = uintptr             /* wingdi.h:3610:19 */
type EMRSETTEXTCOLOR = tagEMRSETTEXTCOLOR /* wingdi.h:3610:35 */
type PEMRSETTEXTCOLOR = uintptr           /* wingdi.h:3610:51 */

type tagEMRSELECTOBJECT = struct {
	emr      EMR
	ihObject DWORD
} /* wingdi.h:3612:11 */

type EMRSELECTOBJECT = tagEMRSELECTOBJECT /* wingdi.h:3615:5 */
type PEMRSELECTOBJECT = uintptr           /* wingdi.h:3615:21 */
type EMRDELETEOBJECT = tagEMRSELECTOBJECT /* wingdi.h:3615:39 */
type PEMRDELETEOBJECT = uintptr           /* wingdi.h:3615:55 */

type tagEMRSELECTPALETTE = struct {
	emr   EMR
	ihPal DWORD
} /* wingdi.h:3617:11 */

type EMRSELECTPALETTE = tagEMRSELECTPALETTE /* wingdi.h:3620:5 */
type PEMRSELECTPALETTE = uintptr            /* wingdi.h:3620:22 */

type tagEMRRESIZEPALETTE = struct {
	emr      EMR
	ihPal    DWORD
	cEntries DWORD
} /* wingdi.h:3622:11 */

type EMRRESIZEPALETTE = tagEMRRESIZEPALETTE /* wingdi.h:3626:5 */
type PEMRRESIZEPALETTE = uintptr            /* wingdi.h:3626:22 */

type tagEMRSETPALETTEENTRIES = struct {
	emr         EMR
	ihPal       DWORD
	iStart      DWORD
	cEntries    DWORD
	aPalEntries [1]PALETTEENTRY
} /* wingdi.h:3628:11 */

type EMRSETPALETTEENTRIES = tagEMRSETPALETTEENTRIES /* wingdi.h:3634:5 */
type PEMRSETPALETTEENTRIES = uintptr                /* wingdi.h:3634:26 */

type tagEMRSETCOLORADJUSTMENT = struct {
	emr             EMR
	ColorAdjustment COLORADJUSTMENT
} /* wingdi.h:3636:11 */

type EMRSETCOLORADJUSTMENT = tagEMRSETCOLORADJUSTMENT /* wingdi.h:3639:5 */
type PEMRSETCOLORADJUSTMENT = uintptr                 /* wingdi.h:3639:27 */

type tagEMRGDICOMMENT = struct {
	emr    EMR
	cbData DWORD
	Data   [1]BYTE
	_      [3]byte
} /* wingdi.h:3641:11 */

type EMRGDICOMMENT = tagEMRGDICOMMENT /* wingdi.h:3645:5 */
type PEMRGDICOMMENT = uintptr         /* wingdi.h:3645:19 */

type tagEMREOF = struct {
	emr           EMR
	nPalEntries   DWORD
	offPalEntries DWORD
	nSizeLast     DWORD
} /* wingdi.h:3647:11 */

type EMREOF = tagEMREOF /* wingdi.h:3652:5 */
type PEMREOF = uintptr  /* wingdi.h:3652:12 */

type tagEMRLINETO = struct {
	emr EMR
	ptl POINTL
} /* wingdi.h:3654:11 */

type EMRLINETO = tagEMRLINETO   /* wingdi.h:3657:5 */
type PEMRLINETO = uintptr       /* wingdi.h:3657:15 */
type EMRMOVETOEX = tagEMRLINETO /* wingdi.h:3657:27 */
type PEMRMOVETOEX = uintptr     /* wingdi.h:3657:39 */

type tagEMROFFSETCLIPRGN = struct {
	emr       EMR
	ptlOffset POINTL
} /* wingdi.h:3659:11 */

type EMROFFSETCLIPRGN = tagEMROFFSETCLIPRGN /* wingdi.h:3662:5 */
type PEMROFFSETCLIPRGN = uintptr            /* wingdi.h:3662:22 */

type tagEMRFILLPATH = struct {
	emr       EMR
	rclBounds RECTL
} /* wingdi.h:3664:11 */

type EMRFILLPATH = tagEMRFILLPATH          /* wingdi.h:3667:5 */
type PEMRFILLPATH = uintptr                /* wingdi.h:3667:17 */
type EMRSTROKEANDFILLPATH = tagEMRFILLPATH /* wingdi.h:3667:31 */
type PEMRSTROKEANDFILLPATH = uintptr       /* wingdi.h:3667:52 */
type EMRSTROKEPATH = tagEMRFILLPATH        /* wingdi.h:3667:75 */
type PEMRSTROKEPATH = uintptr              /* wingdi.h:3667:89 */

type tagEMREXCLUDECLIPRECT = struct {
	emr     EMR
	rclClip RECTL
} /* wingdi.h:3669:11 */

type EMREXCLUDECLIPRECT = tagEMREXCLUDECLIPRECT   /* wingdi.h:3672:5 */
type PEMREXCLUDECLIPRECT = uintptr                /* wingdi.h:3672:24 */
type EMRINTERSECTCLIPRECT = tagEMREXCLUDECLIPRECT /* wingdi.h:3672:45 */
type PEMRINTERSECTCLIPRECT = uintptr              /* wingdi.h:3672:66 */

type tagEMRSETVIEWPORTORGEX = struct {
	emr       EMR
	ptlOrigin POINTL
} /* wingdi.h:3674:11 */

type EMRSETVIEWPORTORGEX = tagEMRSETVIEWPORTORGEX /* wingdi.h:3677:5 */
type PEMRSETVIEWPORTORGEX = uintptr               /* wingdi.h:3677:25 */
type EMRSETWINDOWORGEX = tagEMRSETVIEWPORTORGEX   /* wingdi.h:3677:47 */
type PEMRSETWINDOWORGEX = uintptr                 /* wingdi.h:3677:65 */
type EMRSETBRUSHORGEX = tagEMRSETVIEWPORTORGEX    /* wingdi.h:3677:85 */
type PEMRSETBRUSHORGEX = uintptr                  /* wingdi.h:3677:102 */

type tagEMRSETVIEWPORTEXTEX = struct {
	emr       EMR
	szlExtent SIZEL
} /* wingdi.h:3679:11 */

type EMRSETVIEWPORTEXTEX = tagEMRSETVIEWPORTEXTEX /* wingdi.h:3682:5 */
type PEMRSETVIEWPORTEXTEX = uintptr               /* wingdi.h:3682:25 */
type EMRSETWINDOWEXTEX = tagEMRSETVIEWPORTEXTEX   /* wingdi.h:3682:47 */
type PEMRSETWINDOWEXTEX = uintptr                 /* wingdi.h:3682:65 */

type tagEMRSCALEVIEWPORTEXTEX = struct {
	emr    EMR
	xNum   LONG
	xDenom LONG
	yNum   LONG
	yDenom LONG
} /* wingdi.h:3684:11 */

type EMRSCALEVIEWPORTEXTEX = tagEMRSCALEVIEWPORTEXTEX /* wingdi.h:3690:5 */
type PEMRSCALEVIEWPORTEXTEX = uintptr                 /* wingdi.h:3690:27 */
type EMRSCALEWINDOWEXTEX = tagEMRSCALEVIEWPORTEXTEX   /* wingdi.h:3690:51 */
type PEMRSCALEWINDOWEXTEX = uintptr                   /* wingdi.h:3690:71 */

type tagEMRSETWORLDTRANSFORM = struct {
	emr   EMR
	xform XFORM
} /* wingdi.h:3692:11 */

type EMRSETWORLDTRANSFORM = tagEMRSETWORLDTRANSFORM /* wingdi.h:3695:5 */
type PEMRSETWORLDTRANSFORM = uintptr                /* wingdi.h:3695:26 */

type tagEMRMODIFYWORLDTRANSFORM = struct {
	emr   EMR
	xform XFORM
	iMode DWORD
} /* wingdi.h:3697:11 */

type EMRMODIFYWORLDTRANSFORM = tagEMRMODIFYWORLDTRANSFORM /* wingdi.h:3701:5 */
type PEMRMODIFYWORLDTRANSFORM = uintptr                   /* wingdi.h:3701:29 */

type tagEMRSETPIXELV = struct {
	emr      EMR
	ptlPixel POINTL
	crColor  COLORREF
} /* wingdi.h:3703:11 */

type EMRSETPIXELV = tagEMRSETPIXELV /* wingdi.h:3707:5 */
type PEMRSETPIXELV = uintptr        /* wingdi.h:3707:18 */

type tagEMREXTFLOODFILL = struct {
	emr      EMR
	ptlStart POINTL
	crColor  COLORREF
	iMode    DWORD
} /* wingdi.h:3709:11 */

type EMREXTFLOODFILL = tagEMREXTFLOODFILL /* wingdi.h:3714:5 */
type PEMREXTFLOODFILL = uintptr           /* wingdi.h:3714:21 */

type tagEMRELLIPSE = struct {
	emr    EMR
	rclBox RECTL
} /* wingdi.h:3716:11 */

type EMRELLIPSE = tagEMRELLIPSE   /* wingdi.h:3719:5 */
type PEMRELLIPSE = uintptr        /* wingdi.h:3719:16 */
type EMRRECTANGLE = tagEMRELLIPSE /* wingdi.h:3719:29 */
type PEMRRECTANGLE = uintptr      /* wingdi.h:3719:42 */

type tagEMRROUNDRECT = struct {
	emr       EMR
	rclBox    RECTL
	szlCorner SIZEL
} /* wingdi.h:3721:11 */

type EMRROUNDRECT = tagEMRROUNDRECT /* wingdi.h:3725:5 */
type PEMRROUNDRECT = uintptr        /* wingdi.h:3725:18 */

type tagEMRARC = struct {
	emr      EMR
	rclBox   RECTL
	ptlStart POINTL
	ptlEnd   POINTL
} /* wingdi.h:3727:11 */

type EMRARC = tagEMRARC   /* wingdi.h:3732:5 */
type PEMRARC = uintptr    /* wingdi.h:3732:12 */
type EMRARCTO = tagEMRARC /* wingdi.h:3732:21 */
type PEMRARCTO = uintptr  /* wingdi.h:3732:30 */
type EMRCHORD = tagEMRARC /* wingdi.h:3732:41 */
type PEMRCHORD = uintptr  /* wingdi.h:3732:50 */
type EMRPIE = tagEMRARC   /* wingdi.h:3732:61 */
type PEMRPIE = uintptr    /* wingdi.h:3732:68 */

type tagEMRANGLEARC = struct {
	emr         EMR
	ptlCenter   POINTL
	nRadius     DWORD
	eStartAngle FLOAT
	eSweepAngle FLOAT
} /* wingdi.h:3734:11 */

type EMRANGLEARC = tagEMRANGLEARC /* wingdi.h:3740:5 */
type PEMRANGLEARC = uintptr       /* wingdi.h:3740:17 */

type tagEMRPOLYLINE = struct {
	emr       EMR
	rclBounds RECTL
	cptl      DWORD
	aptl      [1]POINTL
} /* wingdi.h:3742:11 */

type EMRPOLYLINE = tagEMRPOLYLINE     /* wingdi.h:3747:5 */
type PEMRPOLYLINE = uintptr           /* wingdi.h:3747:17 */
type EMRPOLYBEZIER = tagEMRPOLYLINE   /* wingdi.h:3747:31 */
type PEMRPOLYBEZIER = uintptr         /* wingdi.h:3747:45 */
type EMRPOLYGON = tagEMRPOLYLINE      /* wingdi.h:3747:61 */
type PEMRPOLYGON = uintptr            /* wingdi.h:3747:72 */
type EMRPOLYBEZIERTO = tagEMRPOLYLINE /* wingdi.h:3747:85 */
type PEMRPOLYBEZIERTO = uintptr       /* wingdi.h:3747:101 */
type EMRPOLYLINETO = tagEMRPOLYLINE   /* wingdi.h:3747:119 */
type PEMRPOLYLINETO = uintptr         /* wingdi.h:3747:133 */

type tagEMRPOLYLINE16 = struct {
	emr       EMR
	rclBounds RECTL
	cpts      DWORD
	apts      [1]POINTS
} /* wingdi.h:3749:11 */

type EMRPOLYLINE16 = tagEMRPOLYLINE16     /* wingdi.h:3754:5 */
type PEMRPOLYLINE16 = uintptr             /* wingdi.h:3754:19 */
type EMRPOLYBEZIER16 = tagEMRPOLYLINE16   /* wingdi.h:3754:35 */
type PEMRPOLYBEZIER16 = uintptr           /* wingdi.h:3754:51 */
type EMRPOLYGON16 = tagEMRPOLYLINE16      /* wingdi.h:3754:69 */
type PEMRPOLYGON16 = uintptr              /* wingdi.h:3754:82 */
type EMRPOLYBEZIERTO16 = tagEMRPOLYLINE16 /* wingdi.h:3754:97 */
type PEMRPOLYBEZIERTO16 = uintptr         /* wingdi.h:3754:115 */
type EMRPOLYLINETO16 = tagEMRPOLYLINE16   /* wingdi.h:3754:135 */
type PEMRPOLYLINETO16 = uintptr           /* wingdi.h:3754:151 */

type tagEMRPOLYDRAW = struct {
	emr       EMR
	rclBounds RECTL
	cptl      DWORD
	aptl      [1]POINTL
	abTypes   [1]BYTE
	_         [3]byte
} /* wingdi.h:3756:11 */

type EMRPOLYDRAW = tagEMRPOLYDRAW /* wingdi.h:3762:5 */
type PEMRPOLYDRAW = uintptr       /* wingdi.h:3762:17 */

type tagEMRPOLYDRAW16 = struct {
	emr       EMR
	rclBounds RECTL
	cpts      DWORD
	apts      [1]POINTS
	abTypes   [1]BYTE
	_         [3]byte
} /* wingdi.h:3764:11 */

type EMRPOLYDRAW16 = tagEMRPOLYDRAW16 /* wingdi.h:3770:5 */
type PEMRPOLYDRAW16 = uintptr         /* wingdi.h:3770:19 */

type tagEMRPOLYPOLYLINE = struct {
	emr         EMR
	rclBounds   RECTL
	nPolys      DWORD
	cptl        DWORD
	aPolyCounts [1]DWORD
	aptl        [1]POINTL
} /* wingdi.h:3772:11 */

type EMRPOLYPOLYLINE = tagEMRPOLYPOLYLINE /* wingdi.h:3779:5 */
type PEMRPOLYPOLYLINE = uintptr           /* wingdi.h:3779:21 */
type EMRPOLYPOLYGON = tagEMRPOLYPOLYLINE  /* wingdi.h:3779:39 */
type PEMRPOLYPOLYGON = uintptr            /* wingdi.h:3779:54 */

type tagEMRPOLYPOLYLINE16 = struct {
	emr         EMR
	rclBounds   RECTL
	nPolys      DWORD
	cpts        DWORD
	aPolyCounts [1]DWORD
	apts        [1]POINTS
} /* wingdi.h:3781:11 */

type EMRPOLYPOLYLINE16 = tagEMRPOLYPOLYLINE16 /* wingdi.h:3788:5 */
type PEMRPOLYPOLYLINE16 = uintptr             /* wingdi.h:3788:23 */
type EMRPOLYPOLYGON16 = tagEMRPOLYPOLYLINE16  /* wingdi.h:3788:43 */
type PEMRPOLYPOLYGON16 = uintptr              /* wingdi.h:3788:60 */

type tagEMRINVERTRGN = struct {
	emr       EMR
	rclBounds RECTL
	cbRgnData DWORD
	RgnData   [1]BYTE
	_         [3]byte
} /* wingdi.h:3790:11 */

type EMRINVERTRGN = tagEMRINVERTRGN /* wingdi.h:3795:5 */
type PEMRINVERTRGN = uintptr        /* wingdi.h:3795:18 */
type EMRPAINTRGN = tagEMRINVERTRGN  /* wingdi.h:3795:33 */
type PEMRPAINTRGN = uintptr         /* wingdi.h:3795:45 */

type tagEMRFILLRGN = struct {
	emr       EMR
	rclBounds RECTL
	cbRgnData DWORD
	ihBrush   DWORD
	RgnData   [1]BYTE
	_         [3]byte
} /* wingdi.h:3797:11 */

type EMRFILLRGN = tagEMRFILLRGN /* wingdi.h:3803:5 */
type PEMRFILLRGN = uintptr      /* wingdi.h:3803:16 */

type tagEMRFRAMERGN = struct {
	emr       EMR
	rclBounds RECTL
	cbRgnData DWORD
	ihBrush   DWORD
	szlStroke SIZEL
	RgnData   [1]BYTE
	_         [3]byte
} /* wingdi.h:3805:11 */

type EMRFRAMERGN = tagEMRFRAMERGN /* wingdi.h:3812:5 */
type PEMRFRAMERGN = uintptr       /* wingdi.h:3812:17 */

type tagEMREXTSELECTCLIPRGN = struct {
	emr       EMR
	cbRgnData DWORD
	iMode     DWORD
	RgnData   [1]BYTE
	_         [3]byte
} /* wingdi.h:3814:11 */

type EMREXTSELECTCLIPRGN = tagEMREXTSELECTCLIPRGN /* wingdi.h:3819:5 */
type PEMREXTSELECTCLIPRGN = uintptr               /* wingdi.h:3819:25 */

type tagEMREXTTEXTOUTA = struct {
	emr           EMR
	rclBounds     RECTL
	iGraphicsMode DWORD
	exScale       FLOAT
	eyScale       FLOAT
	emrtext       EMRTEXT
} /* wingdi.h:3821:11 */

type EMREXTTEXTOUTA = tagEMREXTTEXTOUTA /* wingdi.h:3828:5 */
type PEMREXTTEXTOUTA = uintptr          /* wingdi.h:3828:20 */
type EMREXTTEXTOUTW = tagEMREXTTEXTOUTA /* wingdi.h:3828:37 */
type PEMREXTTEXTOUTW = uintptr          /* wingdi.h:3828:52 */

type tagEMRPOLYTEXTOUTA = struct {
	emr           EMR
	rclBounds     RECTL
	iGraphicsMode DWORD
	exScale       FLOAT
	eyScale       FLOAT
	cStrings      LONG
	aemrtext      [1]EMRTEXT
} /* wingdi.h:3830:11 */

type EMRPOLYTEXTOUTA = tagEMRPOLYTEXTOUTA /* wingdi.h:3838:5 */
type PEMRPOLYTEXTOUTA = uintptr           /* wingdi.h:3838:21 */
type EMRPOLYTEXTOUTW = tagEMRPOLYTEXTOUTA /* wingdi.h:3838:39 */
type PEMRPOLYTEXTOUTW = uintptr           /* wingdi.h:3838:55 */

type tagEMRBITBLT = struct {
	emr          EMR
	rclBounds    RECTL
	xDest        LONG
	yDest        LONG
	cxDest       LONG
	cyDest       LONG
	dwRop        DWORD
	xSrc         LONG
	ySrc         LONG
	xformSrc     XFORM
	crBkColorSrc COLORREF
	iUsageSrc    DWORD
	offBmiSrc    DWORD
	cbBmiSrc     DWORD
	offBitsSrc   DWORD
	cbBitsSrc    DWORD
} /* wingdi.h:3840:11 */

type EMRBITBLT = tagEMRBITBLT /* wingdi.h:3857:5 */
type PEMRBITBLT = uintptr     /* wingdi.h:3857:15 */

type tagEMRSTRETCHBLT = struct {
	emr          EMR
	rclBounds    RECTL
	xDest        LONG
	yDest        LONG
	cxDest       LONG
	cyDest       LONG
	dwRop        DWORD
	xSrc         LONG
	ySrc         LONG
	xformSrc     XFORM
	crBkColorSrc COLORREF
	iUsageSrc    DWORD
	offBmiSrc    DWORD
	cbBmiSrc     DWORD
	offBitsSrc   DWORD
	cbBitsSrc    DWORD
	cxSrc        LONG
	cySrc        LONG
} /* wingdi.h:3859:11 */

type EMRSTRETCHBLT = tagEMRSTRETCHBLT /* wingdi.h:3878:5 */
type PEMRSTRETCHBLT = uintptr         /* wingdi.h:3878:19 */

type tagEMRMASKBLT = struct {
	emr          EMR
	rclBounds    RECTL
	xDest        LONG
	yDest        LONG
	cxDest       LONG
	cyDest       LONG
	dwRop        DWORD
	xSrc         LONG
	ySrc         LONG
	xformSrc     XFORM
	crBkColorSrc COLORREF
	iUsageSrc    DWORD
	offBmiSrc    DWORD
	cbBmiSrc     DWORD
	offBitsSrc   DWORD
	cbBitsSrc    DWORD
	xMask        LONG
	yMask        LONG
	iUsageMask   DWORD
	offBmiMask   DWORD
	cbBmiMask    DWORD
	offBitsMask  DWORD
	cbBitsMask   DWORD
} /* wingdi.h:3880:11 */

type EMRMASKBLT = tagEMRMASKBLT /* wingdi.h:3904:5 */
type PEMRMASKBLT = uintptr      /* wingdi.h:3904:16 */

type tagEMRPLGBLT = struct {
	emr          EMR
	rclBounds    RECTL
	aptlDest     [3]POINTL
	xSrc         LONG
	ySrc         LONG
	cxSrc        LONG
	cySrc        LONG
	xformSrc     XFORM
	crBkColorSrc COLORREF
	iUsageSrc    DWORD
	offBmiSrc    DWORD
	cbBmiSrc     DWORD
	offBitsSrc   DWORD
	cbBitsSrc    DWORD
	xMask        LONG
	yMask        LONG
	iUsageMask   DWORD
	offBmiMask   DWORD
	cbBmiMask    DWORD
	offBitsMask  DWORD
	cbBitsMask   DWORD
} /* wingdi.h:3906:11 */

type EMRPLGBLT = tagEMRPLGBLT /* wingdi.h:3928:5 */
type PEMRPLGBLT = uintptr     /* wingdi.h:3928:15 */

type tagEMRSETDIBITSTODEVICE = struct {
	emr        EMR
	rclBounds  RECTL
	xDest      LONG
	yDest      LONG
	xSrc       LONG
	ySrc       LONG
	cxSrc      LONG
	cySrc      LONG
	offBmiSrc  DWORD
	cbBmiSrc   DWORD
	offBitsSrc DWORD
	cbBitsSrc  DWORD
	iUsageSrc  DWORD
	iStartScan DWORD
	cScans     DWORD
} /* wingdi.h:3930:11 */

type EMRSETDIBITSTODEVICE = tagEMRSETDIBITSTODEVICE /* wingdi.h:3946:5 */
type PEMRSETDIBITSTODEVICE = uintptr                /* wingdi.h:3946:26 */

type tagEMRSTRETCHDIBITS = struct {
	emr        EMR
	rclBounds  RECTL
	xDest      LONG
	yDest      LONG
	xSrc       LONG
	ySrc       LONG
	cxSrc      LONG
	cySrc      LONG
	offBmiSrc  DWORD
	cbBmiSrc   DWORD
	offBitsSrc DWORD
	cbBitsSrc  DWORD
	iUsageSrc  DWORD
	dwRop      DWORD
	cxDest     LONG
	cyDest     LONG
} /* wingdi.h:3948:11 */

type EMRSTRETCHDIBITS = tagEMRSTRETCHDIBITS /* wingdi.h:3965:5 */
type PEMRSTRETCHDIBITS = uintptr            /* wingdi.h:3965:22 */

type tagEMREXTCREATEFONTINDIRECTW = struct {
	emr    EMR
	ihFont DWORD
	elfw   EXTLOGFONTW
} /* wingdi.h:3967:11 */

type EMREXTCREATEFONTINDIRECTW = tagEMREXTCREATEFONTINDIRECTW /* wingdi.h:3971:5 */
type PEMREXTCREATEFONTINDIRECTW = uintptr                     /* wingdi.h:3971:31 */

type tagEMRCREATEPALETTE = struct {
	emr   EMR
	ihPal DWORD
	lgpl  LOGPALETTE
} /* wingdi.h:3973:11 */

type EMRCREATEPALETTE = tagEMRCREATEPALETTE /* wingdi.h:3977:5 */
type PEMRCREATEPALETTE = uintptr            /* wingdi.h:3977:22 */

type tagEMRCREATEPEN = struct {
	emr   EMR
	ihPen DWORD
	lopn  LOGPEN
} /* wingdi.h:3979:11 */

type EMRCREATEPEN = tagEMRCREATEPEN /* wingdi.h:3983:5 */
type PEMRCREATEPEN = uintptr        /* wingdi.h:3983:18 */

type tagEMREXTCREATEPEN = struct {
	emr     EMR
	ihPen   DWORD
	offBmi  DWORD
	cbBmi   DWORD
	offBits DWORD
	cbBits  DWORD
	elp     EXTLOGPEN
} /* wingdi.h:3985:11 */

type EMREXTCREATEPEN = tagEMREXTCREATEPEN /* wingdi.h:3993:5 */
type PEMREXTCREATEPEN = uintptr           /* wingdi.h:3993:21 */

type tagEMRCREATEBRUSHINDIRECT = struct {
	emr     EMR
	ihBrush DWORD
	lb      LOGBRUSH32
} /* wingdi.h:3995:11 */

type EMRCREATEBRUSHINDIRECT = tagEMRCREATEBRUSHINDIRECT /* wingdi.h:3999:5 */
type PEMRCREATEBRUSHINDIRECT = uintptr                  /* wingdi.h:3999:28 */

type tagEMRCREATEMONOBRUSH = struct {
	emr     EMR
	ihBrush DWORD
	iUsage  DWORD
	offBmi  DWORD
	cbBmi   DWORD
	offBits DWORD
	cbBits  DWORD
} /* wingdi.h:4001:11 */

type EMRCREATEMONOBRUSH = tagEMRCREATEMONOBRUSH /* wingdi.h:4009:5 */
type PEMRCREATEMONOBRUSH = uintptr              /* wingdi.h:4009:24 */

type tagEMRCREATEDIBPATTERNBRUSHPT = struct {
	emr     EMR
	ihBrush DWORD
	iUsage  DWORD
	offBmi  DWORD
	cbBmi   DWORD
	offBits DWORD
	cbBits  DWORD
} /* wingdi.h:4011:11 */

type EMRCREATEDIBPATTERNBRUSHPT = tagEMRCREATEDIBPATTERNBRUSHPT /* wingdi.h:4019:5 */
type PEMRCREATEDIBPATTERNBRUSHPT = uintptr                      /* wingdi.h:4019:32 */

type tagEMRFORMAT = struct {
	dSignature DWORD
	nVersion   DWORD
	cbData     DWORD
	offData    DWORD
} /* wingdi.h:4021:11 */

type EMRFORMAT = tagEMRFORMAT /* wingdi.h:4026:5 */
type PEMRFORMAT = uintptr     /* wingdi.h:4026:15 */

type tagEMRGLSRECORD = struct {
	emr    EMR
	cbData DWORD
	Data   [1]BYTE
	_      [3]byte
} /* wingdi.h:4028:11 */

type EMRGLSRECORD = tagEMRGLSRECORD /* wingdi.h:4032:5 */
type PEMRGLSRECORD = uintptr        /* wingdi.h:4032:18 */

type tagEMRGLSBOUNDEDRECORD = struct {
	emr       EMR
	rclBounds RECTL
	cbData    DWORD
	Data      [1]BYTE
	_         [3]byte
} /* wingdi.h:4034:11 */

type EMRGLSBOUNDEDRECORD = tagEMRGLSBOUNDEDRECORD /* wingdi.h:4039:5 */
type PEMRGLSBOUNDEDRECORD = uintptr               /* wingdi.h:4039:25 */

type tagEMRPIXELFORMAT = struct {
	emr EMR
	pfd PIXELFORMATDESCRIPTOR
} /* wingdi.h:4041:11 */

type EMRPIXELFORMAT = tagEMRPIXELFORMAT /* wingdi.h:4044:5 */
type PEMRPIXELFORMAT = uintptr          /* wingdi.h:4044:20 */

type tagEMRCREATECOLORSPACE = struct {
	emr  EMR
	ihCS DWORD
	lcs  LOGCOLORSPACEA
} /* wingdi.h:4046:11 */

type EMRCREATECOLORSPACE = tagEMRCREATECOLORSPACE /* wingdi.h:4050:5 */
type PEMRCREATECOLORSPACE = uintptr               /* wingdi.h:4050:25 */

type tagEMRSETCOLORSPACE = struct {
	emr  EMR
	ihCS DWORD
} /* wingdi.h:4052:11 */

type EMRSETCOLORSPACE = tagEMRSETCOLORSPACE    /* wingdi.h:4055:5 */
type PEMRSETCOLORSPACE = uintptr               /* wingdi.h:4055:22 */
type EMRSELECTCOLORSPACE = tagEMRSETCOLORSPACE /* wingdi.h:4055:41 */
type PEMRSELECTCOLORSPACE = uintptr            /* wingdi.h:4055:61 */
type EMRDELETECOLORSPACE = tagEMRSETCOLORSPACE /* wingdi.h:4055:83 */
type PEMRDELETECOLORSPACE = uintptr            /* wingdi.h:4055:103 */

type tagEMREXTESCAPE = struct {
	emr       EMR
	iEscape   INT
	cbEscData INT
	EscData   [1]BYTE
	_         [3]byte
} /* wingdi.h:4057:11 */

type EMREXTESCAPE = tagEMREXTESCAPE  /* wingdi.h:4062:5 */
type PEMREXTESCAPE = uintptr         /* wingdi.h:4062:18 */
type EMRDRAWESCAPE = tagEMREXTESCAPE /* wingdi.h:4062:33 */
type PEMRDRAWESCAPE = uintptr        /* wingdi.h:4062:47 */

type tagEMRNAMEDESCAPE = struct {
	emr       EMR
	iEscape   INT
	cbDriver  INT
	cbEscData INT
	EscData   [1]BYTE
	_         [3]byte
} /* wingdi.h:4064:11 */

type EMRNAMEDESCAPE = tagEMRNAMEDESCAPE /* wingdi.h:4070:5 */
type PEMRNAMEDESCAPE = uintptr          /* wingdi.h:4070:20 */

type tagEMRSETICMPROFILE = struct {
	emr     EMR
	dwFlags DWORD
	cbName  DWORD
	cbData  DWORD
	Data    [1]BYTE
	_       [3]byte
} /* wingdi.h:4074:11 */

type EMRSETICMPROFILE = tagEMRSETICMPROFILE  /* wingdi.h:4080:5 */
type PEMRSETICMPROFILE = uintptr             /* wingdi.h:4080:22 */
type EMRSETICMPROFILEA = tagEMRSETICMPROFILE /* wingdi.h:4080:41 */
type PEMRSETICMPROFILEA = uintptr            /* wingdi.h:4080:59 */
type EMRSETICMPROFILEW = tagEMRSETICMPROFILE /* wingdi.h:4080:79 */
type PEMRSETICMPROFILEW = uintptr            /* wingdi.h:4080:97 */

type tagEMRCREATECOLORSPACEW = struct {
	emr     EMR
	ihCS    DWORD
	lcs     LOGCOLORSPACEW
	dwFlags DWORD
	cbData  DWORD
	Data    [1]BYTE
	_       [3]byte
} /* wingdi.h:4084:11 */

type EMRCREATECOLORSPACEW = tagEMRCREATECOLORSPACEW /* wingdi.h:4091:5 */
type PEMRCREATECOLORSPACEW = uintptr                /* wingdi.h:4091:26 */

type tagCOLORMATCHTOTARGET = struct {
	emr      EMR
	dwAction DWORD
	dwFlags  DWORD
	cbName   DWORD
	cbData   DWORD
	Data     [1]BYTE
	_        [3]byte
} /* wingdi.h:4095:11 */

type EMRCOLORMATCHTOTARGET = tagCOLORMATCHTOTARGET /* wingdi.h:4102:5 */
type PEMRCOLORMATCHTOTARGET = uintptr              /* wingdi.h:4102:27 */

type tagCOLORCORRECTPALETTE = struct {
	emr         EMR
	ihPalette   DWORD
	nFirstEntry DWORD
	nPalEntries DWORD
	nReserved   DWORD
} /* wingdi.h:4104:11 */

type EMRCOLORCORRECTPALETTE = tagCOLORCORRECTPALETTE /* wingdi.h:4110:5 */
type PEMRCOLORCORRECTPALETTE = uintptr               /* wingdi.h:4110:28 */

type tagEMRALPHABLEND = struct {
	emr          EMR
	rclBounds    RECTL
	xDest        LONG
	yDest        LONG
	cxDest       LONG
	cyDest       LONG
	dwRop        DWORD
	xSrc         LONG
	ySrc         LONG
	xformSrc     XFORM
	crBkColorSrc COLORREF
	iUsageSrc    DWORD
	offBmiSrc    DWORD
	cbBmiSrc     DWORD
	offBitsSrc   DWORD
	cbBitsSrc    DWORD
	cxSrc        LONG
	cySrc        LONG
} /* wingdi.h:4112:11 */

type EMRALPHABLEND = tagEMRALPHABLEND /* wingdi.h:4131:5 */
type PEMRALPHABLEND = uintptr         /* wingdi.h:4131:19 */

type tagEMRGRADIENTFILL = struct {
	emr       EMR
	rclBounds RECTL
	nVer      DWORD
	nTri      DWORD
	ulMode    ULONG
	Ver       [1]TRIVERTEX
} /* wingdi.h:4133:11 */

type EMRGRADIENTFILL = tagEMRGRADIENTFILL /* wingdi.h:4140:5 */
type PEMRGRADIENTFILL = uintptr           /* wingdi.h:4140:21 */

type tagEMRTRANSPARENTBLT = struct {
	emr          EMR
	rclBounds    RECTL
	xDest        LONG
	yDest        LONG
	cxDest       LONG
	cyDest       LONG
	dwRop        DWORD
	xSrc         LONG
	ySrc         LONG
	xformSrc     XFORM
	crBkColorSrc COLORREF
	iUsageSrc    DWORD
	offBmiSrc    DWORD
	cbBmiSrc     DWORD
	offBitsSrc   DWORD
	cbBitsSrc    DWORD
	cxSrc        LONG
	cySrc        LONG
} /* wingdi.h:4142:11 */

type EMRTRANSPARENTBLT = tagEMRTRANSPARENTBLT /* wingdi.h:4161:5 */
type PEMRTRANSPARENTBLT = uintptr             /* wingdi.h:4161:23 */

type _POINTFLOAT = struct {
	x FLOAT
	y FLOAT
} /* wingdi.h:4188:11 */

type POINTFLOAT = _POINTFLOAT /* wingdi.h:4191:5 */
type PPOINTFLOAT = uintptr    /* wingdi.h:4191:16 */

type _GLYPHMETRICSFLOAT = struct {
	gmfBlackBoxX     FLOAT
	gmfBlackBoxY     FLOAT
	gmfptGlyphOrigin POINTFLOAT
	gmfCellIncX      FLOAT
	gmfCellIncY      FLOAT
} /* wingdi.h:4193:11 */

type GLYPHMETRICSFLOAT = _GLYPHMETRICSFLOAT /* wingdi.h:4199:5 */
type PGLYPHMETRICSFLOAT = uintptr           /* wingdi.h:4199:23 */
type LPGLYPHMETRICSFLOAT = uintptr          /* wingdi.h:4199:43 */

type tagLAYERPLANEDESCRIPTOR = struct {
	nSize           WORD
	nVersion        WORD
	dwFlags         DWORD
	iPixelType      BYTE
	cColorBits      BYTE
	cRedBits        BYTE
	cRedShift       BYTE
	cGreenBits      BYTE
	cGreenShift     BYTE
	cBlueBits       BYTE
	cBlueShift      BYTE
	cAlphaBits      BYTE
	cAlphaShift     BYTE
	cAccumBits      BYTE
	cAccumRedBits   BYTE
	cAccumGreenBits BYTE
	cAccumBlueBits  BYTE
	cAccumAlphaBits BYTE
	cDepthBits      BYTE
	cStencilBits    BYTE
	cAuxBuffers     BYTE
	iLayerPlane     BYTE
	bReserved       BYTE
	crTransparent   COLORREF
} /* wingdi.h:4209:11 */

type LAYERPLANEDESCRIPTOR = tagLAYERPLANEDESCRIPTOR /* wingdi.h:4234:5 */
type PLAYERPLANEDESCRIPTOR = uintptr                /* wingdi.h:4234:26 */
type LPLAYERPLANEDESCRIPTOR = uintptr               /* wingdi.h:4234:49 */

type _WGLSWAP = struct {
	hdc     HDC
	uiFlags UINT
} /* wingdi.h:4288:11 */

type WGLSWAP = _WGLSWAP  /* wingdi.h:4291:5 */
type PWGLSWAP = uintptr  /* wingdi.h:4291:13 */
type LPWGLSWAP = uintptr /* wingdi.h:4291:23 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Copyright (C) 1989, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with GCC; see the file COPYING.  If not, write to
// the Free Software Foundation, 51 Franklin Street, Fifth Floor,
// Boston, MA 02110-1301, USA.

// As a special exception, if you include this header file into source
//    files compiled by GCC, this header file does not by itself cause
//    the resulting executable to be covered by the GNU General Public
//    License.  This exception does not however invalidate any other
//    reasons why the executable file might be covered by the GNU General
//    Public License.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// include mingw stuff
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Copyright (C) 1989-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// GCC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// ISO C Standard:  7.15  Variable arguments  <stdarg.h>

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// __declspec(selectany) must be applied to initialized objects on GCC 5 hence must not be used here.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type HDWP = HANDLE                    /* winuser.h:32:18 */
type LPMENUTEMPLATEA = PVOID          /* winuser.h:35:17 */
type LPMENUTEMPLATEW = PVOID          /* winuser.h:36:17 */
type LPMENUTEMPLATE = LPMENUTEMPLATEA /* winuser.h:39:3 */

type WNDPROC = uintptr /* winuser.h:41:19 */

type DLGPROC = uintptr /* winuser.h:46:19 */

type TIMERPROC = uintptr      /* winuser.h:50:16 */
type GRAYSTRINGPROC = uintptr /* winuser.h:51:19 */
type WNDENUMPROC = uintptr    /* winuser.h:52:19 */
type HOOKPROC = uintptr       /* winuser.h:53:19 */
type SENDASYNCPROC = uintptr  /* winuser.h:54:16 */

type PROPENUMPROCA = uintptr /* winuser.h:56:19 */
type PROPENUMPROCW = uintptr /* winuser.h:57:19 */

type PROPENUMPROCEXA = uintptr /* winuser.h:59:19 */
type PROPENUMPROCEXW = uintptr /* winuser.h:60:19 */

type EDITWORDBREAKPROCA = uintptr /* winuser.h:62:15 */
type EDITWORDBREAKPROCW = uintptr /* winuser.h:63:15 */

type DRAWSTATEPROC = uintptr /* winuser.h:65:19 */

type PROPENUMPROC = PROPENUMPROCA           /* winuser.h:93:3 */
type PROPENUMPROCEX = PROPENUMPROCEXA       /* winuser.h:94:3 */
type EDITWORDBREAKPROC = EDITWORDBREAKPROCA /* winuser.h:95:3 */

type NAMEENUMPROCA = uintptr          /* winuser.h:98:19 */
type NAMEENUMPROCW = uintptr          /* winuser.h:99:19 */
type WINSTAENUMPROCA = NAMEENUMPROCA  /* winuser.h:100:25 */
type WINSTAENUMPROCW = NAMEENUMPROCW  /* winuser.h:101:25 */
type DESKTOPENUMPROCA = NAMEENUMPROCA /* winuser.h:102:25 */
type DESKTOPENUMPROCW = NAMEENUMPROCW /* winuser.h:103:25 */

type WINSTAENUMPROC = WINSTAENUMPROCA   /* winuser.h:113:3 */
type DESKTOPENUMPROC = DESKTOPENUMPROCA /* winuser.h:114:3 */

type tagCBT_CREATEWNDA = struct {
	lpcs            uintptr
	hwndInsertAfter HWND
} /* winuser.h:456:11 */

type tagCREATESTRUCTA = struct {
	lpCreateParams LPVOID
	hInstance      HINSTANCE
	hMenu          HMENU
	hwndParent     HWND
	cy             int32
	cx             int32
	y              int32
	x              int32
	style          LONG
	lpszName       LPCSTR
	lpszClass      LPCSTR
	dwExStyle      DWORD
} /* winuser.h:456:11 */

type CBT_CREATEWNDA = tagCBT_CREATEWNDA /* winuser.h:459:5 */
type LPCBT_CREATEWNDA = uintptr         /* winuser.h:459:20 */

type tagCBT_CREATEWNDW = struct {
	lpcs            uintptr
	hwndInsertAfter HWND
} /* winuser.h:461:11 */

type tagCREATESTRUCTW = struct {
	lpCreateParams LPVOID
	hInstance      HINSTANCE
	hMenu          HMENU
	hwndParent     HWND
	cy             int32
	cx             int32
	y              int32
	x              int32
	style          LONG
	lpszName       LPCWSTR
	lpszClass      LPCWSTR
	dwExStyle      DWORD
} /* winuser.h:461:11 */

type CBT_CREATEWNDW = tagCBT_CREATEWNDW /* winuser.h:464:5 */
type LPCBT_CREATEWNDW = uintptr         /* winuser.h:464:20 */

type CBT_CREATEWND = CBT_CREATEWNDA     /* winuser.h:466:3 */
type LPCBT_CREATEWND = LPCBT_CREATEWNDA /* winuser.h:467:3 */

type tagCBTACTIVATESTRUCT = struct {
	fMouse     WINBOOL
	hWndActive HWND
} /* winuser.h:469:11 */

type CBTACTIVATESTRUCT = tagCBTACTIVATESTRUCT /* winuser.h:472:5 */
type LPCBTACTIVATESTRUCT = uintptr            /* winuser.h:472:23 */

type tagWTSSESSION_NOTIFICATION = struct {
	cbSize      DWORD
	dwSessionId DWORD
} /* winuser.h:476:11 */

type WTSSESSION_NOTIFICATION = tagWTSSESSION_NOTIFICATION /* winuser.h:479:5 */
type PWTSSESSION_NOTIFICATION = uintptr                   /* winuser.h:479:29 */

type SHELLHOOKINFO = struct {
	hwnd HWND
	rc   RECT
}                              /* winuser.h:600:5 */
type LPSHELLHOOKINFO = uintptr /* winuser.h:600:19 */

type tagEVENTMSG = struct {
	message UINT
	paramL  UINT
	paramH  UINT
	time    DWORD
	hwnd    HWND
} /* winuser.h:602:11 */

type EVENTMSG = tagEVENTMSG  /* winuser.h:608:5 */
type PEVENTMSGMSG = uintptr  /* winuser.h:608:14 */
type NPEVENTMSGMSG = uintptr /* winuser.h:608:28 */
type LPEVENTMSGMSG = uintptr /* winuser.h:608:43 */

type PEVENTMSG = uintptr  /* winuser.h:610:30 */
type NPEVENTMSG = uintptr /* winuser.h:610:41 */
type LPEVENTMSG = uintptr /* winuser.h:610:53 */

type tagCWPSTRUCT = struct {
	lParam  LPARAM
	wParam  WPARAM
	message UINT
	hwnd    HWND
} /* winuser.h:612:11 */

type CWPSTRUCT = tagCWPSTRUCT /* winuser.h:617:5 */
type PCWPSTRUCT = uintptr     /* winuser.h:617:15 */
type NPCWPSTRUCT = uintptr    /* winuser.h:617:27 */
type LPCWPSTRUCT = uintptr    /* winuser.h:617:40 */

type tagCWPRETSTRUCT = struct {
	lResult LRESULT
	lParam  LPARAM
	wParam  WPARAM
	message UINT
	hwnd    HWND
} /* winuser.h:619:11 */

type CWPRETSTRUCT = tagCWPRETSTRUCT /* winuser.h:625:5 */
type PCWPRETSTRUCT = uintptr        /* winuser.h:625:18 */
type NPCWPRETSTRUCT = uintptr       /* winuser.h:625:33 */
type LPCWPRETSTRUCT = uintptr       /* winuser.h:625:49 */

type tagKBDLLHOOKSTRUCT = struct {
	vkCode      DWORD
	scanCode    DWORD
	flags       DWORD
	time        DWORD
	dwExtraInfo ULONG_PTR
} /* winuser.h:636:11 */

type KBDLLHOOKSTRUCT = tagKBDLLHOOKSTRUCT /* winuser.h:642:5 */
type LPKBDLLHOOKSTRUCT = uintptr          /* winuser.h:642:21 */
type PKBDLLHOOKSTRUCT = uintptr           /* winuser.h:642:40 */

type tagMSLLHOOKSTRUCT = struct {
	pt          POINT
	mouseData   DWORD
	flags       DWORD
	time        DWORD
	dwExtraInfo ULONG_PTR
} /* winuser.h:644:11 */

type MSLLHOOKSTRUCT = tagMSLLHOOKSTRUCT /* winuser.h:650:5 */
type LPMSLLHOOKSTRUCT = uintptr         /* winuser.h:650:20 */
type PMSLLHOOKSTRUCT = uintptr          /* winuser.h:650:38 */

type tagDEBUGHOOKINFO = struct {
	idThread          DWORD
	idThreadInstaller DWORD
	lParam            LPARAM
	wParam            WPARAM
	code              int32
} /* winuser.h:652:11 */

type DEBUGHOOKINFO = tagDEBUGHOOKINFO /* winuser.h:658:5 */
type PDEBUGHOOKINFO = uintptr         /* winuser.h:658:19 */
type NPDEBUGHOOKINFO = uintptr        /* winuser.h:658:35 */
type LPDEBUGHOOKINFO = uintptr        /* winuser.h:658:52 */

type tagMOUSEHOOKSTRUCT = struct {
	pt           POINT
	hwnd         HWND
	wHitTestCode UINT
	dwExtraInfo  ULONG_PTR
} /* winuser.h:660:11 */

type MOUSEHOOKSTRUCT = tagMOUSEHOOKSTRUCT /* winuser.h:665:5 */
type LPMOUSEHOOKSTRUCT = uintptr          /* winuser.h:665:21 */
type PMOUSEHOOKSTRUCT = uintptr           /* winuser.h:665:40 */

type tagMOUSEHOOKSTRUCTEX = struct {
	__unnamed MOUSEHOOKSTRUCT
	mouseData DWORD
} /* winuser.h:672:11 */

type MOUSEHOOKSTRUCTEX = tagMOUSEHOOKSTRUCTEX /* winuser.h:675:5 */
type LPMOUSEHOOKSTRUCTEX = uintptr            /* winuser.h:675:23 */
type PMOUSEHOOKSTRUCTEX = uintptr             /* winuser.h:675:44 */

type tagHARDWAREHOOKSTRUCT = struct {
	hwnd    HWND
	message UINT
	wParam  WPARAM
	lParam  LPARAM
} /* winuser.h:678:11 */

type HARDWAREHOOKSTRUCT = tagHARDWAREHOOKSTRUCT /* winuser.h:683:5 */
type LPHARDWAREHOOKSTRUCT = uintptr             /* winuser.h:683:24 */
type PHARDWAREHOOKSTRUCT = uintptr              /* winuser.h:683:46 */

type tagMOUSEMOVEPOINT = struct {
	x           int32
	y           int32
	time        DWORD
	dwExtraInfo ULONG_PTR
} /* winuser.h:719:11 */

type MOUSEMOVEPOINT = tagMOUSEMOVEPOINT /* winuser.h:724:5 */
type PMOUSEMOVEPOINT = uintptr          /* winuser.h:724:20 */
type LPMOUSEMOVEPOINT = uintptr         /* winuser.h:724:37 */

type tagUSEROBJECTFLAGS = struct {
	fInherit  WINBOOL
	fReserved WINBOOL
	dwFlags   DWORD
} /* winuser.h:825:11 */

type USEROBJECTFLAGS = tagUSEROBJECTFLAGS /* winuser.h:829:5 */
type PUSEROBJECTFLAGS = uintptr           /* winuser.h:829:21 */

type tagWNDCLASSEXA = struct {
	cbSize        UINT
	style         UINT
	lpfnWndProc   WNDPROC
	cbClsExtra    int32
	cbWndExtra    int32
	hInstance     HINSTANCE
	hIcon         HICON
	hCursor       HCURSOR
	hbrBackground HBRUSH
	lpszMenuName  LPCSTR
	lpszClassName LPCSTR
	hIconSm       HICON
} /* winuser.h:842:11 */

type WNDCLASSEXA = tagWNDCLASSEXA /* winuser.h:855:5 */
type PWNDCLASSEXA = uintptr       /* winuser.h:855:17 */
type NPWNDCLASSEXA = uintptr      /* winuser.h:855:31 */
type LPWNDCLASSEXA = uintptr      /* winuser.h:855:46 */

type tagWNDCLASSEXW = struct {
	cbSize        UINT
	style         UINT
	lpfnWndProc   WNDPROC
	cbClsExtra    int32
	cbWndExtra    int32
	hInstance     HINSTANCE
	hIcon         HICON
	hCursor       HCURSOR
	hbrBackground HBRUSH
	lpszMenuName  LPCWSTR
	lpszClassName LPCWSTR
	hIconSm       HICON
} /* winuser.h:857:11 */

type WNDCLASSEXW = tagWNDCLASSEXW /* winuser.h:870:5 */
type PWNDCLASSEXW = uintptr       /* winuser.h:870:17 */
type NPWNDCLASSEXW = uintptr      /* winuser.h:870:31 */
type LPWNDCLASSEXW = uintptr      /* winuser.h:870:46 */

type WNDCLASSEX = WNDCLASSEXA     /* winuser.h:872:3 */
type PWNDCLASSEX = PWNDCLASSEXA   /* winuser.h:873:3 */
type NPWNDCLASSEX = NPWNDCLASSEXA /* winuser.h:874:3 */
type LPWNDCLASSEX = LPWNDCLASSEXA /* winuser.h:875:3 */

type tagWNDCLASSA = struct {
	style         UINT
	lpfnWndProc   WNDPROC
	cbClsExtra    int32
	cbWndExtra    int32
	hInstance     HINSTANCE
	hIcon         HICON
	hCursor       HCURSOR
	hbrBackground HBRUSH
	lpszMenuName  LPCSTR
	lpszClassName LPCSTR
} /* winuser.h:877:11 */

type WNDCLASSA = tagWNDCLASSA /* winuser.h:888:5 */
type PWNDCLASSA = uintptr     /* winuser.h:888:15 */
type NPWNDCLASSA = uintptr    /* winuser.h:888:27 */
type LPWNDCLASSA = uintptr    /* winuser.h:888:40 */

type tagWNDCLASSW = struct {
	style         UINT
	lpfnWndProc   WNDPROC
	cbClsExtra    int32
	cbWndExtra    int32
	hInstance     HINSTANCE
	hIcon         HICON
	hCursor       HCURSOR
	hbrBackground HBRUSH
	lpszMenuName  LPCWSTR
	lpszClassName LPCWSTR
} /* winuser.h:890:11 */

type WNDCLASSW = tagWNDCLASSW /* winuser.h:901:5 */
type PWNDCLASSW = uintptr     /* winuser.h:901:15 */
type NPWNDCLASSW = uintptr    /* winuser.h:901:27 */
type LPWNDCLASSW = uintptr    /* winuser.h:901:40 */

type WNDCLASS = WNDCLASSA     /* winuser.h:903:3 */
type PWNDCLASS = PWNDCLASSA   /* winuser.h:904:3 */
type NPWNDCLASS = NPWNDCLASSA /* winuser.h:905:3 */
type LPWNDCLASS = LPWNDCLASSA /* winuser.h:906:3 */

type tagMSG = struct {
	hwnd    HWND
	message UINT
	wParam  WPARAM
	lParam  LPARAM
	time    DWORD
	pt      POINT
} /* winuser.h:914:11 */

type MSG = tagMSG    /* winuser.h:921:5 */
type PMSG = uintptr  /* winuser.h:921:9 */
type NPMSG = uintptr /* winuser.h:921:15 */
type LPMSG = uintptr /* winuser.h:921:22 */

type tagMINMAXINFO = struct {
	ptReserved     POINT
	ptMaxSize      POINT
	ptMaxPosition  POINT
	ptMinTrackSize POINT
	ptMaxTrackSize POINT
} /* winuser.h:1031:11 */

type MINMAXINFO = tagMINMAXINFO /* winuser.h:1037:5 */
type PMINMAXINFO = uintptr      /* winuser.h:1037:16 */
type LPMINMAXINFO = uintptr     /* winuser.h:1037:29 */

type tagCOPYDATASTRUCT = struct {
	dwData ULONG_PTR
	cbData DWORD
	lpData PVOID
} /* winuser.h:1074:11 */

type COPYDATASTRUCT = tagCOPYDATASTRUCT /* winuser.h:1078:5 */
type PCOPYDATASTRUCT = uintptr          /* winuser.h:1078:20 */

type tagMDINEXTMENU = struct {
	hmenuIn   HMENU
	hmenuNext HMENU
	hwndNext  HWND
} /* winuser.h:1080:11 */

type MDINEXTMENU = tagMDINEXTMENU /* winuser.h:1084:5 */
type PMDINEXTMENU = uintptr       /* winuser.h:1084:17 */
type LPMDINEXTMENU = uintptr      /* winuser.h:1084:31 */

type POWERBROADCAST_SETTING = struct {
	PowerSetting GUID
	DataLength   DWORD
	Data         [1]UCHAR
	_            [3]byte
}                                      /* winuser.h:1268:5 */
type PPOWERBROADCAST_SETTING = uintptr /* winuser.h:1268:28 */

type tagWINDOWPOS = struct {
	hwnd            HWND
	hwndInsertAfter HWND
	x               int32
	y               int32
	cx              int32
	cy              int32
	flags           UINT
} /* winuser.h:1462:11 */

type WINDOWPOS = tagWINDOWPOS /* winuser.h:1470:5 */
type LPWINDOWPOS = uintptr    /* winuser.h:1470:15 */
type PWINDOWPOS = uintptr     /* winuser.h:1470:28 */

type tagNCCALCSIZE_PARAMS = struct {
	rgrc  [3]RECT
	lppos PWINDOWPOS
} /* winuser.h:1472:11 */

type NCCALCSIZE_PARAMS = tagNCCALCSIZE_PARAMS /* winuser.h:1475:5 */
type LPNCCALCSIZE_PARAMS = uintptr            /* winuser.h:1475:23 */

type tagTRACKMOUSEEVENT = struct {
	cbSize      DWORD
	dwFlags     DWORD
	hwndTrack   HWND
	dwHoverTime DWORD
} /* winuser.h:1509:11 */

type TRACKMOUSEEVENT = tagTRACKMOUSEEVENT /* winuser.h:1514:5 */
type LPTRACKMOUSEEVENT = uintptr          /* winuser.h:1514:21 */

type tagACCEL = struct {
	fVirt BYTE
	_     [1]byte
	key   WORD
	cmd   WORD
} /* winuser.h:1753:11 */

type ACCEL = tagACCEL  /* winuser.h:1757:5 */
type LPACCEL = uintptr /* winuser.h:1757:11 */

type tagPAINTSTRUCT = struct {
	hdc         HDC
	fErase      WINBOOL
	rcPaint     RECT
	fRestore    WINBOOL
	fIncUpdate  WINBOOL
	rgbReserved [32]BYTE
} /* winuser.h:1759:11 */

type PAINTSTRUCT = tagPAINTSTRUCT /* winuser.h:1766:5 */
type PPAINTSTRUCT = uintptr       /* winuser.h:1766:17 */
type NPPAINTSTRUCT = uintptr      /* winuser.h:1766:31 */
type LPPAINTSTRUCT = uintptr      /* winuser.h:1766:46 */

type CREATESTRUCTA = tagCREATESTRUCTA /* winuser.h:1781:5 */
type LPCREATESTRUCTA = uintptr        /* winuser.h:1781:19 */

type CREATESTRUCTW = tagCREATESTRUCTW /* winuser.h:1796:5 */
type LPCREATESTRUCTW = uintptr        /* winuser.h:1796:19 */

type CREATESTRUCT = CREATESTRUCTA     /* winuser.h:1798:3 */
type LPCREATESTRUCT = LPCREATESTRUCTA /* winuser.h:1799:3 */

type tagWINDOWPLACEMENT = struct {
	length           UINT
	flags            UINT
	showCmd          UINT
	ptMinPosition    POINT
	ptMaxPosition    POINT
	rcNormalPosition RECT
} /* winuser.h:1801:11 */

type WINDOWPLACEMENT = tagWINDOWPLACEMENT /* winuser.h:1808:5 */
type PWINDOWPLACEMENT = uintptr           /* winuser.h:1809:27 */
type LPWINDOWPLACEMENT = uintptr          /* winuser.h:1809:45 */

type tagNMHDR = struct {
	hwndFrom HWND
	idFrom   UINT_PTR
	code     UINT
} /* winuser.h:1817:11 */

type NMHDR = tagNMHDR /* winuser.h:1821:5 */

type LPNMHDR = uintptr /* winuser.h:1825:17 */

type tagSTYLESTRUCT = struct {
	styleOld DWORD
	styleNew DWORD
} /* winuser.h:1827:11 */

type STYLESTRUCT = tagSTYLESTRUCT /* winuser.h:1830:5 */
type LPSTYLESTRUCT = uintptr      /* winuser.h:1830:17 */

type tagMEASUREITEMSTRUCT = struct {
	CtlType    UINT
	CtlID      UINT
	itemID     UINT
	itemWidth  UINT
	itemHeight UINT
	itemData   ULONG_PTR
} /* winuser.h:1856:11 */

type MEASUREITEMSTRUCT = tagMEASUREITEMSTRUCT /* winuser.h:1863:5 */
type PMEASUREITEMSTRUCT = uintptr             /* winuser.h:1863:23 */
type LPMEASUREITEMSTRUCT = uintptr            /* winuser.h:1863:43 */

type tagDRAWITEMSTRUCT = struct {
	CtlType    UINT
	CtlID      UINT
	itemID     UINT
	itemAction UINT
	itemState  UINT
	hwndItem   HWND
	hDC        HDC
	rcItem     RECT
	itemData   ULONG_PTR
} /* winuser.h:1865:11 */

type DRAWITEMSTRUCT = tagDRAWITEMSTRUCT /* winuser.h:1875:5 */
type PDRAWITEMSTRUCT = uintptr          /* winuser.h:1875:20 */
type LPDRAWITEMSTRUCT = uintptr         /* winuser.h:1875:37 */

type tagDELETEITEMSTRUCT = struct {
	CtlType  UINT
	CtlID    UINT
	itemID   UINT
	hwndItem HWND
	itemData ULONG_PTR
} /* winuser.h:1877:11 */

type DELETEITEMSTRUCT = tagDELETEITEMSTRUCT /* winuser.h:1883:5 */
type PDELETEITEMSTRUCT = uintptr            /* winuser.h:1883:22 */
type LPDELETEITEMSTRUCT = uintptr           /* winuser.h:1883:41 */

type tagCOMPAREITEMSTRUCT = struct {
	CtlType    UINT
	CtlID      UINT
	hwndItem   HWND
	itemID1    UINT
	itemData1  ULONG_PTR
	itemID2    UINT
	itemData2  ULONG_PTR
	dwLocaleId DWORD
} /* winuser.h:1885:11 */

type COMPAREITEMSTRUCT = tagCOMPAREITEMSTRUCT /* winuser.h:1894:5 */
type PCOMPAREITEMSTRUCT = uintptr             /* winuser.h:1894:23 */
type LPCOMPAREITEMSTRUCT = uintptr            /* winuser.h:1894:43 */

type BSMINFO = struct {
	cbSize UINT
	hdesk  HDESK
	hwnd   HWND
	luid   LUID
}                       /* winuser.h:1997:5 */
type PBSMINFO = uintptr /* winuser.h:1997:13 */

type HDEVNOTIFY = PVOID    /* winuser.h:2030:17 */
type PHDEVNOTIFY = uintptr /* winuser.h:2031:22 */

type HPOWERNOTIFY = HANDLE   /* winuser.h:2054:18 */
type PHPOWERNOTIFY = uintptr /* winuser.h:2055:24 */

type PREGISTERCLASSNAMEW = uintptr /* winuser.h:2132:19 */

type tagUPDATELAYEREDWINDOWINFO = struct {
	cbSize   DWORD
	hdcDst   HDC
	pptDst   uintptr
	psize    uintptr
	hdcSrc   HDC
	pptSrc   uintptr
	crKey    COLORREF
	pblend   uintptr
	dwFlags  DWORD
	prcDirty uintptr
} /* winuser.h:2155:11 */

type UPDATELAYEREDWINDOWINFO = tagUPDATELAYEREDWINDOWINFO /* winuser.h:2166:5 */
type PUPDATELAYEREDWINDOWINFO = uintptr                   /* winuser.h:2166:29 */

type FLASHWINFO = struct {
	cbSize    UINT
	hwnd      HWND
	dwFlags   DWORD
	uCount    UINT
	dwTimeout DWORD
}                          /* winuser.h:2206:5 */
type PFLASHWINFO = uintptr /* winuser.h:2206:16 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type DLGTEMPLATE = struct {
	style           DWORD
	dwExtendedStyle DWORD
	cdit            WORD
	x               int16
	y               int16
	cx              int16
	cy              int16
	_               [2]byte
} /* winuser.h:2279:5 */

type LPDLGTEMPLATEA = uintptr /* winuser.h:2283:23 */
type LPDLGTEMPLATEW = uintptr /* winuser.h:2284:23 */

type LPDLGTEMPLATE = LPDLGTEMPLATEA /* winuser.h:2286:3 */

type LPCDLGTEMPLATEA = uintptr /* winuser.h:2290:29 */
type LPCDLGTEMPLATEW = uintptr /* winuser.h:2291:29 */

type LPCDLGTEMPLATE = LPCDLGTEMPLATEA /* winuser.h:2293:3 */

type DLGITEMTEMPLATE = struct {
	style           DWORD
	dwExtendedStyle DWORD
	x               int16
	y               int16
	cx              int16
	cy              int16
	id              WORD
	_               [2]byte
} /* winuser.h:2305:5 */

type PDLGITEMTEMPLATEA = uintptr /* winuser.h:2307:27 */
type PDLGITEMTEMPLATEW = uintptr /* winuser.h:2308:27 */

type PDLGITEMTEMPLATE = PDLGITEMTEMPLATEA /* winuser.h:2310:3 */

type LPDLGITEMTEMPLATEA = uintptr /* winuser.h:2312:27 */
type LPDLGITEMTEMPLATEW = uintptr /* winuser.h:2313:27 */

type LPDLGITEMTEMPLATE = LPDLGITEMTEMPLATEA /* winuser.h:2315:3 */

type tagMOUSEINPUT = struct {
	dx          LONG
	dy          LONG
	mouseData   DWORD
	dwFlags     DWORD
	time        DWORD
	dwExtraInfo ULONG_PTR
} /* winuser.h:2646:11 */

type MOUSEINPUT = tagMOUSEINPUT /* winuser.h:2653:5 */
type PMOUSEINPUT = uintptr      /* winuser.h:2653:16 */
type LPMOUSEINPUT = uintptr     /* winuser.h:2653:29 */

type tagKEYBDINPUT = struct {
	wVk         WORD
	wScan       WORD
	dwFlags     DWORD
	time        DWORD
	dwExtraInfo ULONG_PTR
} /* winuser.h:2655:11 */

type KEYBDINPUT = tagKEYBDINPUT /* winuser.h:2661:5 */
type PKEYBDINPUT = uintptr      /* winuser.h:2661:16 */
type LPKEYBDINPUT = uintptr     /* winuser.h:2661:29 */

type tagHARDWAREINPUT = struct {
	uMsg    DWORD
	wParamL WORD
	wParamH WORD
} /* winuser.h:2663:11 */

type HARDWAREINPUT = tagHARDWAREINPUT /* winuser.h:2667:5 */
type PHARDWAREINPUT = uintptr         /* winuser.h:2667:19 */
type LPHARDWAREINPUT = uintptr        /* winuser.h:2667:35 */

type tagINPUT = struct {
	__type DWORD
	u      struct{ mi MOUSEINPUT }
} /* winuser.h:2669:11 */

type INPUT = tagINPUT  /* winuser.h:2676:5 */
type PINPUT = uintptr  /* winuser.h:2676:11 */
type LPINPUT = uintptr /* winuser.h:2676:19 */

type tagLASTINPUTINFO = struct {
	cbSize UINT
	dwTime DWORD
} /* winuser.h:2830:11 */

type LASTINPUTINFO = tagLASTINPUTINFO /* winuser.h:2833:5 */
type PLASTINPUTINFO = uintptr         /* winuser.h:2833:19 */

type tagTPMPARAMS = struct {
	cbSize    UINT
	rcExclude RECT
} /* winuser.h:3152:11 */

type TPMPARAMS = tagTPMPARAMS /* winuser.h:3155:5 */

type tagMENUINFO = struct {
	cbSize          DWORD
	fMask           DWORD
	dwStyle         DWORD
	cyMax           UINT
	hbrBack         HBRUSH
	dwContextHelpID DWORD
	dwMenuData      ULONG_PTR
} /* winuser.h:3157:11 */

type MENUINFO = tagMENUINFO /* winuser.h:3165:5 */
type LPMENUINFO = uintptr   /* winuser.h:3165:14 */

type LPTPMPARAMS = uintptr /* winuser.h:3167:21 */
type LPCMENUINFO = uintptr /* winuser.h:3168:26 */

type tagMENUGETOBJECTINFO = struct {
	dwFlags DWORD
	uPos    UINT
	hmenu   HMENU
	riid    PVOID
	pvObj   PVOID
} /* winuser.h:3178:11 */

type MENUGETOBJECTINFO = tagMENUGETOBJECTINFO /* winuser.h:3184:5 */
type PMENUGETOBJECTINFO = uintptr             /* winuser.h:3184:23 */

type tagMENUITEMINFOA = struct {
	cbSize        UINT
	fMask         UINT
	fType         UINT
	fState        UINT
	wID           UINT
	hSubMenu      HMENU
	hbmpChecked   HBITMAP
	hbmpUnchecked HBITMAP
	dwItemData    ULONG_PTR
	dwTypeData    LPSTR
	cch           UINT
	hbmpItem      HBITMAP
} /* winuser.h:3186:11 */

type MENUITEMINFOA = tagMENUITEMINFOA /* winuser.h:3199:5 */
type LPMENUITEMINFOA = uintptr        /* winuser.h:3199:19 */

type tagMENUITEMINFOW = struct {
	cbSize        UINT
	fMask         UINT
	fType         UINT
	fState        UINT
	wID           UINT
	hSubMenu      HMENU
	hbmpChecked   HBITMAP
	hbmpUnchecked HBITMAP
	dwItemData    ULONG_PTR
	dwTypeData    LPWSTR
	cch           UINT
	hbmpItem      HBITMAP
} /* winuser.h:3201:11 */

type MENUITEMINFOW = tagMENUITEMINFOW /* winuser.h:3214:5 */
type LPMENUITEMINFOW = uintptr        /* winuser.h:3214:19 */

type MENUITEMINFO = MENUITEMINFOA     /* winuser.h:3216:3 */
type LPMENUITEMINFO = LPMENUITEMINFOA /* winuser.h:3217:3 */

type LPCMENUITEMINFOA = uintptr /* winuser.h:3219:31 */
type LPCMENUITEMINFOW = uintptr /* winuser.h:3220:31 */

type LPCMENUITEMINFO = LPCMENUITEMINFOA /* winuser.h:3222:3 */

type tagDROPSTRUCT = struct {
	hwndSource    HWND
	hwndSink      HWND
	wFmt          DWORD
	dwData        ULONG_PTR
	ptDrop        POINT
	dwControlData DWORD
} /* winuser.h:3270:11 */

type DROPSTRUCT = tagDROPSTRUCT /* winuser.h:3277:5 */
type PDROPSTRUCT = uintptr      /* winuser.h:3277:16 */
type LPDROPSTRUCT = uintptr     /* winuser.h:3277:29 */

type tagDRAWTEXTPARAMS = struct {
	cbSize        UINT
	iTabLength    int32
	iLeftMargin   int32
	iRightMargin  int32
	uiLengthDrawn UINT
} /* winuser.h:3324:11 */

type DRAWTEXTPARAMS = tagDRAWTEXTPARAMS /* winuser.h:3330:5 */
type LPDRAWTEXTPARAMS = uintptr         /* winuser.h:3330:20 */

type tagHELPINFO = struct {
	cbSize       UINT
	iContextType int32
	iCtrlId      int32
	hItemHandle  HANDLE
	dwContextId  DWORD_PTR
	MousePos     POINT
} /* winuser.h:3507:11 */

type HELPINFO = tagHELPINFO /* winuser.h:3514:5 */
type LPHELPINFO = uintptr   /* winuser.h:3514:14 */

type MSGBOXCALLBACK = uintptr /* winuser.h:3571:16 */

type tagMSGBOXPARAMSA = struct {
	cbSize             UINT
	hwndOwner          HWND
	hInstance          HINSTANCE
	lpszText           LPCSTR
	lpszCaption        LPCSTR
	dwStyle            DWORD
	lpszIcon           LPCSTR
	dwContextHelpId    DWORD_PTR
	lpfnMsgBoxCallback MSGBOXCALLBACK
	dwLanguageId       DWORD
} /* winuser.h:3573:11 */

type MSGBOXPARAMSA = tagMSGBOXPARAMSA /* winuser.h:3584:5 */
type PMSGBOXPARAMSA = uintptr         /* winuser.h:3584:19 */
type LPMSGBOXPARAMSA = uintptr        /* winuser.h:3584:35 */

type tagMSGBOXPARAMSW = struct {
	cbSize             UINT
	hwndOwner          HWND
	hInstance          HINSTANCE
	lpszText           LPCWSTR
	lpszCaption        LPCWSTR
	dwStyle            DWORD
	lpszIcon           LPCWSTR
	dwContextHelpId    DWORD_PTR
	lpfnMsgBoxCallback MSGBOXCALLBACK
	dwLanguageId       DWORD
} /* winuser.h:3586:11 */

type MSGBOXPARAMSW = tagMSGBOXPARAMSW /* winuser.h:3597:5 */
type PMSGBOXPARAMSW = uintptr         /* winuser.h:3597:19 */
type LPMSGBOXPARAMSW = uintptr        /* winuser.h:3597:35 */

type MSGBOXPARAMS = MSGBOXPARAMSA     /* winuser.h:3599:3 */
type PMSGBOXPARAMS = PMSGBOXPARAMSA   /* winuser.h:3600:3 */
type LPMSGBOXPARAMS = LPMSGBOXPARAMSA /* winuser.h:3601:3 */

type MENUITEMTEMPLATEHEADER = struct {
	versionNumber WORD
	offset        WORD
}                                      /* winuser.h:3910:5 */
type PMENUITEMTEMPLATEHEADER = uintptr /* winuser.h:3910:28 */

type MENUITEMTEMPLATE = struct {
	mtOption WORD
	mtID     WORD
	mtString [1]WCHAR
}                                /* winuser.h:3916:5 */
type PMENUITEMTEMPLATE = uintptr /* winuser.h:3916:22 */

type _ICONINFO = struct {
	fIcon    WINBOOL
	xHotspot DWORD
	yHotspot DWORD
	hbmMask  HBITMAP
	hbmColor HBITMAP
} /* winuser.h:3989:11 */

type ICONINFO = _ICONINFO /* winuser.h:3995:5 */
type PICONINFO = uintptr  /* winuser.h:3996:20 */

type tagCURSORSHAPE = struct {
	xHotSpot  int32
	yHotSpot  int32
	cx        int32
	cy        int32
	cbWidth   int32
	Planes    BYTE
	BitsPixel BYTE
	_         [2]byte
} /* winuser.h:4013:11 */

type CURSORSHAPE = tagCURSORSHAPE /* winuser.h:4021:5 */
type LPCURSORSHAPE = uintptr      /* winuser.h:4021:17 */

type tagSCROLLINFO = struct {
	cbSize    UINT
	fMask     UINT
	nMin      int32
	nMax      int32
	nPage     UINT
	nPos      int32
	nTrackPos int32
} /* winuser.h:4701:11 */

type SCROLLINFO = tagSCROLLINFO /* winuser.h:4709:5 */
type LPSCROLLINFO = uintptr     /* winuser.h:4709:16 */
type LPCSCROLLINFO = uintptr    /* winuser.h:4710:28 */

type tagMDICREATESTRUCTA = struct {
	szClass LPCSTR
	szTitle LPCSTR
	hOwner  HANDLE
	x       int32
	y       int32
	cx      int32
	cy      int32
	style   DWORD
	lParam  LPARAM
} /* winuser.h:4728:11 */

type MDICREATESTRUCTA = tagMDICREATESTRUCTA /* winuser.h:4738:5 */
type LPMDICREATESTRUCTA = uintptr           /* winuser.h:4738:22 */

type tagMDICREATESTRUCTW = struct {
	szClass LPCWSTR
	szTitle LPCWSTR
	hOwner  HANDLE
	x       int32
	y       int32
	cx      int32
	cy      int32
	style   DWORD
	lParam  LPARAM
} /* winuser.h:4740:11 */

type MDICREATESTRUCTW = tagMDICREATESTRUCTW /* winuser.h:4750:5 */
type LPMDICREATESTRUCTW = uintptr           /* winuser.h:4750:22 */

type MDICREATESTRUCT = MDICREATESTRUCTA     /* winuser.h:4752:3 */
type LPMDICREATESTRUCT = LPMDICREATESTRUCTA /* winuser.h:4753:3 */

type tagCLIENTCREATESTRUCT = struct {
	hWindowMenu  HANDLE
	idFirstChild UINT
} /* winuser.h:4755:11 */

type CLIENTCREATESTRUCT = tagCLIENTCREATESTRUCT /* winuser.h:4758:5 */
type LPCLIENTCREATESTRUCT = uintptr             /* winuser.h:4758:24 */

type HELPPOLY = DWORD /* winuser.h:4784:17 */

type tagMULTIKEYHELPA = struct {
	mkSize      DWORD
	mkKeylist   CHAR
	szKeyphrase [1]CHAR
	_           [2]byte
} /* winuser.h:4786:11 */

type MULTIKEYHELPA = tagMULTIKEYHELPA /* winuser.h:4790:5 */
type PMULTIKEYHELPA = uintptr         /* winuser.h:4790:19 */
type LPMULTIKEYHELPA = uintptr        /* winuser.h:4790:35 */

type tagMULTIKEYHELPW = struct {
	mkSize      DWORD
	mkKeylist   WCHAR
	szKeyphrase [1]WCHAR
} /* winuser.h:4792:11 */

type MULTIKEYHELPW = tagMULTIKEYHELPW /* winuser.h:4796:5 */
type PMULTIKEYHELPW = uintptr         /* winuser.h:4796:19 */
type LPMULTIKEYHELPW = uintptr        /* winuser.h:4796:35 */

type MULTIKEYHELP = MULTIKEYHELPA     /* winuser.h:4798:3 */
type PMULTIKEYHELP = PMULTIKEYHELPA   /* winuser.h:4799:3 */
type LPMULTIKEYHELP = LPMULTIKEYHELPA /* winuser.h:4800:3 */

type tagHELPWININFOA = struct {
	wStructSize int32
	x           int32
	y           int32
	dx          int32
	dy          int32
	wMax        int32
	rgchMember  [2]CHAR
	_           [2]byte
} /* winuser.h:4802:11 */

type HELPWININFOA = tagHELPWININFOA /* winuser.h:4810:5 */
type PHELPWININFOA = uintptr        /* winuser.h:4810:18 */
type LPHELPWININFOA = uintptr       /* winuser.h:4810:33 */

type tagHELPWININFOW = struct {
	wStructSize int32
	x           int32
	y           int32
	dx          int32
	dy          int32
	wMax        int32
	rgchMember  [2]WCHAR
} /* winuser.h:4812:11 */

type HELPWININFOW = tagHELPWININFOW /* winuser.h:4820:5 */
type PHELPWININFOW = uintptr        /* winuser.h:4820:18 */
type LPHELPWININFOW = uintptr       /* winuser.h:4820:33 */

type HELPWININFO = HELPWININFOA     /* winuser.h:4822:3 */
type PHELPWININFO = PHELPWININFOA   /* winuser.h:4823:3 */
type LPHELPWININFO = LPHELPWININFOA /* winuser.h:4824:3 */

type tagNONCLIENTMETRICSA = struct {
	cbSize           UINT
	iBorderWidth     int32
	iScrollWidth     int32
	iScrollHeight    int32
	iCaptionWidth    int32
	iCaptionHeight   int32
	lfCaptionFont    LOGFONTA
	iSmCaptionWidth  int32
	iSmCaptionHeight int32
	lfSmCaptionFont  LOGFONTA
	iMenuWidth       int32
	iMenuHeight      int32
	lfMenuFont       LOGFONTA
	lfStatusFont     LOGFONTA
	lfMessageFont    LOGFONTA
} /* winuser.h:5183:11 */

type NONCLIENTMETRICSA = tagNONCLIENTMETRICSA /* winuser.h:5202:5 */
type PNONCLIENTMETRICSA = uintptr             /* winuser.h:5202:23 */
type LPNONCLIENTMETRICSA = uintptr            /* winuser.h:5202:43 */

type tagNONCLIENTMETRICSW = struct {
	cbSize           UINT
	iBorderWidth     int32
	iScrollWidth     int32
	iScrollHeight    int32
	iCaptionWidth    int32
	iCaptionHeight   int32
	lfCaptionFont    LOGFONTW
	iSmCaptionWidth  int32
	iSmCaptionHeight int32
	lfSmCaptionFont  LOGFONTW
	iMenuWidth       int32
	iMenuHeight      int32
	lfMenuFont       LOGFONTW
	lfStatusFont     LOGFONTW
	lfMessageFont    LOGFONTW
} /* winuser.h:5204:11 */

type NONCLIENTMETRICSW = tagNONCLIENTMETRICSW /* winuser.h:5223:5 */
type PNONCLIENTMETRICSW = uintptr             /* winuser.h:5223:23 */
type LPNONCLIENTMETRICSW = uintptr            /* winuser.h:5223:43 */

type NONCLIENTMETRICS = NONCLIENTMETRICSA     /* winuser.h:5225:3 */
type PNONCLIENTMETRICS = PNONCLIENTMETRICSA   /* winuser.h:5226:3 */
type LPNONCLIENTMETRICS = LPNONCLIENTMETRICSA /* winuser.h:5227:3 */

type tagMINIMIZEDMETRICS = struct {
	cbSize   UINT
	iWidth   int32
	iHorzGap int32
	iVertGap int32
	iArrange int32
} /* winuser.h:5247:11 */

type MINIMIZEDMETRICS = tagMINIMIZEDMETRICS /* winuser.h:5253:5 */
type PMINIMIZEDMETRICS = uintptr            /* winuser.h:5253:22 */
type LPMINIMIZEDMETRICS = uintptr           /* winuser.h:5253:41 */

type tagICONMETRICSA = struct {
	cbSize       UINT
	iHorzSpacing int32
	iVertSpacing int32
	iTitleWrap   int32
	lfFont       LOGFONTA
} /* winuser.h:5257:11 */

type ICONMETRICSA = tagICONMETRICSA /* winuser.h:5263:5 */
type PICONMETRICSA = uintptr        /* winuser.h:5263:18 */
type LPICONMETRICSA = uintptr       /* winuser.h:5263:33 */

type tagICONMETRICSW = struct {
	cbSize       UINT
	iHorzSpacing int32
	iVertSpacing int32
	iTitleWrap   int32
	lfFont       LOGFONTW
} /* winuser.h:5265:11 */

type ICONMETRICSW = tagICONMETRICSW /* winuser.h:5271:5 */
type PICONMETRICSW = uintptr        /* winuser.h:5271:18 */
type LPICONMETRICSW = uintptr       /* winuser.h:5271:33 */

type ICONMETRICS = ICONMETRICSA     /* winuser.h:5273:3 */
type PICONMETRICS = PICONMETRICSA   /* winuser.h:5274:3 */
type LPICONMETRICS = LPICONMETRICSA /* winuser.h:5275:3 */

type tagANIMATIONINFO = struct {
	cbSize      UINT
	iMinAnimate int32
} /* winuser.h:5279:11 */

type ANIMATIONINFO = tagANIMATIONINFO /* winuser.h:5282:5 */
type LPANIMATIONINFO = uintptr        /* winuser.h:5282:19 */

type tagSERIALKEYSA = struct {
	cbSize         UINT
	dwFlags        DWORD
	lpszActivePort LPSTR
	lpszPort       LPSTR
	iBaudRate      UINT
	iPortState     UINT
	iActive        UINT
} /* winuser.h:5284:11 */

type SERIALKEYSA = tagSERIALKEYSA /* winuser.h:5292:5 */
type LPSERIALKEYSA = uintptr      /* winuser.h:5292:17 */

type tagSERIALKEYSW = struct {
	cbSize         UINT
	dwFlags        DWORD
	lpszActivePort LPWSTR
	lpszPort       LPWSTR
	iBaudRate      UINT
	iPortState     UINT
	iActive        UINT
} /* winuser.h:5294:11 */

type SERIALKEYSW = tagSERIALKEYSW /* winuser.h:5302:5 */
type LPSERIALKEYSW = uintptr      /* winuser.h:5302:17 */

type SERIALKEYS = SERIALKEYSA     /* winuser.h:5304:3 */
type LPSERIALKEYS = LPSERIALKEYSA /* winuser.h:5305:3 */

type tagHIGHCONTRASTA = struct {
	cbSize            UINT
	dwFlags           DWORD
	lpszDefaultScheme LPSTR
} /* winuser.h:5307:11 */

type HIGHCONTRASTA = tagHIGHCONTRASTA /* winuser.h:5311:5 */
type LPHIGHCONTRASTA = uintptr        /* winuser.h:5311:19 */

type tagHIGHCONTRASTW = struct {
	cbSize            UINT
	dwFlags           DWORD
	lpszDefaultScheme LPWSTR
} /* winuser.h:5313:11 */

type HIGHCONTRASTW = tagHIGHCONTRASTW /* winuser.h:5317:5 */
type LPHIGHCONTRASTW = uintptr        /* winuser.h:5317:19 */

type HIGHCONTRAST = HIGHCONTRASTA     /* winuser.h:5319:3 */
type LPHIGHCONTRAST = LPHIGHCONTRASTA /* winuser.h:5320:3 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// __declspec(selectany) must be applied to initialized objects on GCC 5 hence must not be used here.

type _VIDEOPARAMETERS = struct {
	Guid                  GUID
	dwOffset              ULONG
	dwCommand             ULONG
	dwFlags               ULONG
	dwMode                ULONG
	dwTVStandard          ULONG
	dwAvailableModes      ULONG
	dwAvailableTVStandard ULONG
	dwFlickerFilter       ULONG
	dwOverScanX           ULONG
	dwOverScanY           ULONG
	dwMaxUnscaledX        ULONG
	dwMaxUnscaledY        ULONG
	dwPositionX           ULONG
	dwPositionY           ULONG
	dwBrightness          ULONG
	dwContrast            ULONG
	dwCPType              ULONG
	dwCPCommand           ULONG
	dwCPStandard          ULONG
	dwCPKey               ULONG
	bCP_APSTriggerBits    ULONG
	bOEMCopyProtection    [256]UCHAR
} /* tvout.h:11:9 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// __declspec(selectany) must be applied to initialized objects on GCC 5 hence must not be used here.

type VIDEOPARAMETERS = _VIDEOPARAMETERS /* tvout.h:35:3 */
type PVIDEOPARAMETERS = uintptr         /* tvout.h:35:19 */
type LPVIDEOPARAMETERS = uintptr        /* tvout.h:35:37 */

type tagFILTERKEYS = struct {
	cbSize      UINT
	dwFlags     DWORD
	iWaitMSec   DWORD
	iDelayMSec  DWORD
	iRepeatMSec DWORD
	iBounceMSec DWORD
} /* winuser.h:5409:11 */

type FILTERKEYS = tagFILTERKEYS /* winuser.h:5416:5 */
type LPFILTERKEYS = uintptr     /* winuser.h:5416:16 */

type tagSTICKYKEYS = struct {
	cbSize  UINT
	dwFlags DWORD
} /* winuser.h:5428:11 */

type STICKYKEYS = tagSTICKYKEYS /* winuser.h:5431:5 */
type LPSTICKYKEYS = uintptr     /* winuser.h:5431:16 */

type tagMOUSEKEYS = struct {
	cbSize          UINT
	dwFlags         DWORD
	iMaxSpeed       DWORD
	iTimeToMaxSpeed DWORD
	iCtrlSpeed      DWORD
	dwReserved1     DWORD
	dwReserved2     DWORD
} /* winuser.h:5461:11 */

type MOUSEKEYS = tagMOUSEKEYS /* winuser.h:5469:5 */
type LPMOUSEKEYS = uintptr    /* winuser.h:5469:15 */

type tagACCESSTIMEOUT = struct {
	cbSize       UINT
	dwFlags      DWORD
	iTimeOutMSec DWORD
} /* winuser.h:5487:11 */

type ACCESSTIMEOUT = tagACCESSTIMEOUT /* winuser.h:5491:5 */
type LPACCESSTIMEOUT = uintptr        /* winuser.h:5491:19 */

type tagSOUNDSENTRYA = struct {
	cbSize                 UINT
	dwFlags                DWORD
	iFSTextEffect          DWORD
	iFSTextEffectMSec      DWORD
	iFSTextEffectColorBits DWORD
	iFSGrafEffect          DWORD
	iFSGrafEffectMSec      DWORD
	iFSGrafEffectColor     DWORD
	iWindowsEffect         DWORD
	iWindowsEffectMSec     DWORD
	lpszWindowsEffectDLL   LPSTR
	iWindowsEffectOrdinal  DWORD
} /* winuser.h:5512:11 */

type SOUNDSENTRYA = tagSOUNDSENTRYA /* winuser.h:5525:5 */
type LPSOUNDSENTRYA = uintptr       /* winuser.h:5525:18 */

type tagSOUNDSENTRYW = struct {
	cbSize                 UINT
	dwFlags                DWORD
	iFSTextEffect          DWORD
	iFSTextEffectMSec      DWORD
	iFSTextEffectColorBits DWORD
	iFSGrafEffect          DWORD
	iFSGrafEffectMSec      DWORD
	iFSGrafEffectColor     DWORD
	iWindowsEffect         DWORD
	iWindowsEffectMSec     DWORD
	lpszWindowsEffectDLL   LPWSTR
	iWindowsEffectOrdinal  DWORD
} /* winuser.h:5527:11 */

type SOUNDSENTRYW = tagSOUNDSENTRYW /* winuser.h:5540:5 */
type LPSOUNDSENTRYW = uintptr       /* winuser.h:5540:18 */

type SOUNDSENTRY = SOUNDSENTRYA     /* winuser.h:5542:3 */
type LPSOUNDSENTRY = LPSOUNDSENTRYA /* winuser.h:5543:3 */

type tagTOGGLEKEYS = struct {
	cbSize  UINT
	dwFlags DWORD
} /* winuser.h:5555:11 */

type TOGGLEKEYS = tagTOGGLEKEYS /* winuser.h:5558:5 */
type LPTOGGLEKEYS = uintptr     /* winuser.h:5558:16 */

type tagMONITORINFO = struct {
	cbSize    DWORD
	rcMonitor RECT
	rcWork    RECT
	dwFlags   DWORD
} /* winuser.h:5560:11 */

type MONITORINFO = tagMONITORINFO /* winuser.h:5565:5 */
type LPMONITORINFO = uintptr      /* winuser.h:5565:17 */

type tagMONITORINFOEXA = struct {
	__0 struct {
		cbSize    DWORD
		rcMonitor RECT
		rcWork    RECT
		dwFlags   DWORD
	}
	szDevice [32]CHAR
} /* winuser.h:5587:11 */

type MONITORINFOEXA = tagMONITORINFOEXA /* winuser.h:5595:5 */
type LPMONITORINFOEXA = uintptr         /* winuser.h:5595:20 */

type tagMONITORINFOEXW = struct {
	__0 struct {
		cbSize    DWORD
		rcMonitor RECT
		rcWork    RECT
		dwFlags   DWORD
	}
	szDevice [32]WCHAR
} /* winuser.h:5597:11 */

type MONITORINFOEXW = tagMONITORINFOEXW /* winuser.h:5605:5 */
type LPMONITORINFOEXW = uintptr         /* winuser.h:5605:20 */

type MONITORINFOEX = MONITORINFOEXA     /* winuser.h:5607:3 */
type LPMONITORINFOEX = LPMONITORINFOEXA /* winuser.h:5608:3 */

type MONITORENUMPROC = uintptr /* winuser.h:5611:19 */

type WINEVENTPROC = uintptr /* winuser.h:5653:16 */

type tagGUITHREADINFO = struct {
	cbSize        DWORD
	flags         DWORD
	hwndActive    HWND
	hwndFocus     HWND
	hwndCapture   HWND
	hwndMenuOwner HWND
	hwndMoveSize  HWND
	hwndCaret     HWND
	rcCaret       RECT
} /* winuser.h:5830:11 */

type GUITHREADINFO = tagGUITHREADINFO /* winuser.h:5840:5 */
type PGUITHREADINFO = uintptr         /* winuser.h:5840:19 */
type LPGUITHREADINFO = uintptr        /* winuser.h:5840:35 */

type tagCURSORINFO = struct {
	cbSize      DWORD
	flags       DWORD
	hCursor     HCURSOR
	ptScreenPos POINT
} /* winuser.h:5908:11 */

type CURSORINFO = tagCURSORINFO /* winuser.h:5913:5 */
type PCURSORINFO = uintptr      /* winuser.h:5913:16 */
type LPCURSORINFO = uintptr     /* winuser.h:5913:29 */

type tagWINDOWINFO = struct {
	cbSize          DWORD
	rcWindow        RECT
	rcClient        RECT
	dwStyle         DWORD
	dwExStyle       DWORD
	dwWindowStatus  DWORD
	cxWindowBorders UINT
	cyWindowBorders UINT
	atomWindowType  ATOM
	wCreatorVersion WORD
} /* winuser.h:5922:11 */

type WINDOWINFO = tagWINDOWINFO /* winuser.h:5933:5 */
type PWINDOWINFO = uintptr      /* winuser.h:5933:16 */
type LPWINDOWINFO = uintptr     /* winuser.h:5933:29 */

type tagTITLEBARINFO = struct {
	cbSize     DWORD
	rcTitleBar RECT
	rgstate    [6]DWORD
} /* winuser.h:5939:11 */

type TITLEBARINFO = tagTITLEBARINFO /* winuser.h:5943:5 */
type PTITLEBARINFO = uintptr        /* winuser.h:5943:18 */
type LPTITLEBARINFO = uintptr       /* winuser.h:5943:33 */

type tagMENUBARINFO = struct {
	cbSize      DWORD
	rcBar       RECT
	hMenu       HMENU
	hwndMenu    HWND
	fBarFocused uint8 /* WINBOOL fBarFocused: 1, WINBOOL fFocused: 1 */
	_           [3]byte
} /* winuser.h:5956:11 */

type MENUBARINFO = tagMENUBARINFO /* winuser.h:5963:5 */
type PMENUBARINFO = uintptr       /* winuser.h:5963:17 */
type LPMENUBARINFO = uintptr      /* winuser.h:5963:31 */

type tagSCROLLBARINFO = struct {
	cbSize        DWORD
	rcScrollBar   RECT
	dxyLineButton int32
	xyThumbTop    int32
	xyThumbBottom int32
	reserved      int32
	rgstate       [6]DWORD
} /* winuser.h:5967:11 */

type SCROLLBARINFO = tagSCROLLBARINFO /* winuser.h:5975:5 */
type PSCROLLBARINFO = uintptr         /* winuser.h:5975:19 */
type LPSCROLLBARINFO = uintptr        /* winuser.h:5975:35 */

type tagCOMBOBOXINFO = struct {
	cbSize      DWORD
	rcItem      RECT
	rcButton    RECT
	stateButton DWORD
	hwndCombo   HWND
	hwndItem    HWND
	hwndList    HWND
} /* winuser.h:5979:11 */

type COMBOBOXINFO = tagCOMBOBOXINFO /* winuser.h:5987:5 */
type PCOMBOBOXINFO = uintptr        /* winuser.h:5987:18 */
type LPCOMBOBOXINFO = uintptr       /* winuser.h:5987:33 */

type tagALTTABINFO = struct {
	cbSize    DWORD
	cItems    int32
	cColumns  int32
	cRows     int32
	iColFocus int32
	iRowFocus int32
	cxItem    int32
	cyItem    int32
	ptStart   POINT
} /* winuser.h:6004:11 */

type ALTTABINFO = tagALTTABINFO /* winuser.h:6014:5 */
type PALTTABINFO = uintptr      /* winuser.h:6014:16 */
type LPALTTABINFO = uintptr     /* winuser.h:6014:29 */

type HRAWINPUT__ = struct{ unused int32 } /* winuser.h:6028:3 */

type HRAWINPUT = uintptr /* winuser.h:6028:3 */

type tagRAWINPUTHEADER = struct {
	dwType  DWORD
	dwSize  DWORD
	hDevice HANDLE
	wParam  WPARAM
} /* winuser.h:6037:11 */

type RAWINPUTHEADER = tagRAWINPUTHEADER /* winuser.h:6042:5 */
type PRAWINPUTHEADER = uintptr          /* winuser.h:6042:20 */
type LPRAWINPUTHEADER = uintptr         /* winuser.h:6042:37 */

type tagRAWMOUSE = struct {
	usFlags            USHORT
	_                  [2]byte
	__4                struct{ ulButtons ULONG }
	ulRawButtons       ULONG
	lLastX             LONG
	lLastY             LONG
	ulExtraInformation ULONG
} /* winuser.h:6050:11 */

type RAWMOUSE = tagRAWMOUSE /* winuser.h:6063:5 */
type PRAWMOUSE = uintptr    /* winuser.h:6063:14 */
type LPRAWMOUSE = uintptr   /* winuser.h:6063:25 */

type tagRAWKEYBOARD = struct {
	MakeCode         USHORT
	Flags            USHORT
	Reserved         USHORT
	VKey             USHORT
	Message          UINT
	ExtraInformation ULONG
} /* winuser.h:6094:11 */

type RAWKEYBOARD = tagRAWKEYBOARD /* winuser.h:6101:5 */
type PRAWKEYBOARD = uintptr       /* winuser.h:6101:17 */
type LPRAWKEYBOARD = uintptr      /* winuser.h:6101:31 */

type tagRAWHID = struct {
	dwSizeHid DWORD
	dwCount   DWORD
	bRawData  [1]BYTE
	_         [3]byte
} /* winuser.h:6114:11 */

type RAWHID = tagRAWHID /* winuser.h:6118:5 */
type PRAWHID = uintptr  /* winuser.h:6118:12 */
type LPRAWHID = uintptr /* winuser.h:6118:21 */

type tagRAWINPUT = struct {
	header RAWINPUTHEADER
	data   struct{ mouse RAWMOUSE }
} /* winuser.h:6120:11 */

type RAWINPUT = tagRAWINPUT /* winuser.h:6127:5 */
type PRAWINPUT = uintptr    /* winuser.h:6127:14 */
type LPRAWINPUT = uintptr   /* winuser.h:6127:25 */

type tagRID_DEVICE_INFO_MOUSE = struct {
	dwId                DWORD
	dwNumberOfButtons   DWORD
	dwSampleRate        DWORD
	fHasHorizontalWheel WINBOOL
} /* winuser.h:6150:11 */

type RID_DEVICE_INFO_MOUSE = tagRID_DEVICE_INFO_MOUSE /* winuser.h:6155:5 */
type PRID_DEVICE_INFO_MOUSE = uintptr                 /* winuser.h:6155:27 */

type tagRID_DEVICE_INFO_KEYBOARD = struct {
	dwType                 DWORD
	dwSubType              DWORD
	dwKeyboardMode         DWORD
	dwNumberOfFunctionKeys DWORD
	dwNumberOfIndicators   DWORD
	dwNumberOfKeysTotal    DWORD
} /* winuser.h:6157:11 */

type RID_DEVICE_INFO_KEYBOARD = tagRID_DEVICE_INFO_KEYBOARD /* winuser.h:6164:5 */
type PRID_DEVICE_INFO_KEYBOARD = uintptr                    /* winuser.h:6164:30 */

type tagRID_DEVICE_INFO_HID = struct {
	dwVendorId      DWORD
	dwProductId     DWORD
	dwVersionNumber DWORD
	usUsagePage     USHORT
	usUsage         USHORT
} /* winuser.h:6166:11 */

type RID_DEVICE_INFO_HID = tagRID_DEVICE_INFO_HID /* winuser.h:6172:5 */
type PRID_DEVICE_INFO_HID = uintptr               /* winuser.h:6172:25 */

type tagRID_DEVICE_INFO = struct {
	cbSize DWORD
	dwType DWORD
	u      struct {
		mouse RID_DEVICE_INFO_MOUSE
		_     [8]byte
	}
} /* winuser.h:6174:11 */

type RID_DEVICE_INFO = tagRID_DEVICE_INFO /* winuser.h:6182:5 */
type PRID_DEVICE_INFO = uintptr           /* winuser.h:6182:21 */
type LPRID_DEVICE_INFO = uintptr          /* winuser.h:6182:39 */

type tagRAWINPUTDEVICE = struct {
	usUsagePage USHORT
	usUsage     USHORT
	dwFlags     DWORD
	hwndTarget  HWND
} /* winuser.h:6190:11 */

type RAWINPUTDEVICE = tagRAWINPUTDEVICE /* winuser.h:6195:5 */
type PRAWINPUTDEVICE = uintptr          /* winuser.h:6195:20 */
type LPRAWINPUTDEVICE = uintptr         /* winuser.h:6195:37 */

type PCRAWINPUTDEVICE = uintptr /* winuser.h:6197:32 */

type tagRAWINPUTDEVICELIST = struct {
	hDevice HANDLE
	dwType  DWORD
} /* winuser.h:6224:11 */

type RAWINPUTDEVICELIST = tagRAWINPUTDEVICELIST /* winuser.h:6227:5 */
type PRAWINPUTDEVICELIST = uintptr              /* winuser.h:6227:24 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type LGRPID = DWORD  /* winnls.h:644:17 */
type LCTYPE = DWORD  /* winnls.h:645:17 */
type CALTYPE = DWORD /* winnls.h:646:17 */
type CALID = DWORD   /* winnls.h:647:17 */

type _cpinfo = struct {
	MaxCharSize UINT
	DefaultChar [2]BYTE
	LeadByte    [12]BYTE
	_           [2]byte
} /* winnls.h:649:11 */

type CPINFO = _cpinfo   /* winnls.h:653:5 */
type LPCPINFO = uintptr /* winnls.h:653:12 */
type _cpinfoexA = struct {
	MaxCharSize        UINT
	DefaultChar        [2]BYTE
	LeadByte           [12]BYTE
	UnicodeDefaultChar WCHAR
	CodePage           UINT
	CodePageName       [260]CHAR
} /* winnls.h:654:11 */

type CPINFOEXA = _cpinfoexA /* winnls.h:661:5 */
type LPCPINFOEXA = uintptr  /* winnls.h:661:15 */

type _cpinfoexW = struct {
	MaxCharSize        UINT
	DefaultChar        [2]BYTE
	LeadByte           [12]BYTE
	UnicodeDefaultChar WCHAR
	CodePage           UINT
	CodePageName       [260]WCHAR
} /* winnls.h:663:11 */

type CPINFOEXW = _cpinfoexW /* winnls.h:670:5 */
type LPCPINFOEXW = uintptr  /* winnls.h:670:15 */

type CPINFOEX = CPINFOEXA     /* winnls.h:672:3 */
type LPCPINFOEX = LPCPINFOEXA /* winnls.h:673:3 */

type _numberfmtA = struct {
	NumDigits     UINT
	LeadingZero   UINT
	Grouping      UINT
	lpDecimalSep  LPSTR
	lpThousandSep LPSTR
	NegativeOrder UINT
} /* winnls.h:675:11 */

type NUMBERFMTA = _numberfmtA /* winnls.h:682:5 */
type LPNUMBERFMTA = uintptr   /* winnls.h:682:16 */
type _numberfmtW = struct {
	NumDigits     UINT
	LeadingZero   UINT
	Grouping      UINT
	lpDecimalSep  LPWSTR
	lpThousandSep LPWSTR
	NegativeOrder UINT
} /* winnls.h:683:11 */

type NUMBERFMTW = _numberfmtW /* winnls.h:690:5 */
type LPNUMBERFMTW = uintptr   /* winnls.h:690:16 */

type NUMBERFMT = NUMBERFMTA     /* winnls.h:692:3 */
type LPNUMBERFMT = LPNUMBERFMTA /* winnls.h:693:3 */

type _currencyfmtA = struct {
	NumDigits        UINT
	LeadingZero      UINT
	Grouping         UINT
	lpDecimalSep     LPSTR
	lpThousandSep    LPSTR
	NegativeOrder    UINT
	PositiveOrder    UINT
	lpCurrencySymbol LPSTR
} /* winnls.h:695:11 */

type CURRENCYFMTA = _currencyfmtA /* winnls.h:704:5 */
type LPCURRENCYFMTA = uintptr     /* winnls.h:704:18 */

type _currencyfmtW = struct {
	NumDigits        UINT
	LeadingZero      UINT
	Grouping         UINT
	lpDecimalSep     LPWSTR
	lpThousandSep    LPWSTR
	NegativeOrder    UINT
	PositiveOrder    UINT
	lpCurrencySymbol LPWSTR
} /* winnls.h:706:11 */

type CURRENCYFMTW = _currencyfmtW /* winnls.h:715:5 */
type LPCURRENCYFMTW = uintptr     /* winnls.h:715:18 */

type CURRENCYFMT = CURRENCYFMTA     /* winnls.h:717:3 */
type LPCURRENCYFMT = LPCURRENCYFMTA /* winnls.h:718:3 */

type NLS_FUNCTION = DWORD /* winnls.h:724:17 */

type _nlsversioninfo = struct {
	dwNLSVersionInfoSize DWORD
	dwNLSVersion         DWORD
	dwDefinedVersion     DWORD
} /* winnls.h:735:11 */

type NLSVERSIONINFO = _nlsversioninfo /* winnls.h:739:5 */
type LPNLSVERSIONINFO = uintptr       /* winnls.h:739:20 */

type _nlsversioninfoex = struct {
	dwNLSVersionInfoSize DWORD
	dwNLSVersion         DWORD
	dwDefinedVersion     DWORD
	dwEffectiveId        DWORD
	guidCustomVersion    GUID
} /* winnls.h:742:11 */

type NLSVERSIONINFOEX = _nlsversioninfoex /* winnls.h:748:5 */
type LPNLSVERSIONINFOEX = uintptr         /* winnls.h:748:22 */

type GEOID = LONG     /* winnls.h:750:16 */
type GEOTYPE = DWORD  /* winnls.h:751:17 */
type GEOCLASS = DWORD /* winnls.h:752:17 */

type LANGUAGEGROUP_ENUMPROCA = uintptr   /* winnls.h:798:19 */
type LANGGROUPLOCALE_ENUMPROCA = uintptr /* winnls.h:799:19 */
type UILANGUAGE_ENUMPROCA = uintptr      /* winnls.h:800:19 */
type CODEPAGE_ENUMPROCA = uintptr        /* winnls.h:801:19 */
type DATEFMT_ENUMPROCA = uintptr         /* winnls.h:802:19 */
type DATEFMT_ENUMPROCEXA = uintptr       /* winnls.h:803:19 */
type TIMEFMT_ENUMPROCA = uintptr         /* winnls.h:804:19 */
type CALINFO_ENUMPROCA = uintptr         /* winnls.h:805:19 */
type CALINFO_ENUMPROCEXA = uintptr       /* winnls.h:806:19 */
type LOCALE_ENUMPROCA = uintptr          /* winnls.h:807:19 */
type LOCALE_ENUMPROCW = uintptr          /* winnls.h:808:19 */
type LANGUAGEGROUP_ENUMPROCW = uintptr   /* winnls.h:809:19 */
type LANGGROUPLOCALE_ENUMPROCW = uintptr /* winnls.h:810:19 */
type UILANGUAGE_ENUMPROCW = uintptr      /* winnls.h:811:19 */
type CODEPAGE_ENUMPROCW = uintptr        /* winnls.h:812:19 */
type DATEFMT_ENUMPROCW = uintptr         /* winnls.h:813:19 */
type DATEFMT_ENUMPROCEXW = uintptr       /* winnls.h:814:19 */
type TIMEFMT_ENUMPROCW = uintptr         /* winnls.h:815:19 */
type CALINFO_ENUMPROCW = uintptr         /* winnls.h:816:19 */
type CALINFO_ENUMPROCEXW = uintptr       /* winnls.h:817:19 */
type GEO_ENUMPROC = uintptr              /* winnls.h:818:19 */

type _FILEMUIINFO = struct {
	dwSize               DWORD
	dwVersion            DWORD
	dwFileType           DWORD
	pChecksum            [16]BYTE
	pServiceChecksum     [16]BYTE
	dwLanguageNameOffset DWORD
	dwTypeIDMainSize     DWORD
	dwTypeIDMainOffset   DWORD
	dwTypeNameMainOffset DWORD
	dwTypeIDMUISize      DWORD
	dwTypeIDMUIOffset    DWORD
	dwTypeNameMUIOffset  DWORD
	abBuffer             [8]BYTE
} /* winnls.h:869:11 */

type FILEMUIINFO = _FILEMUIINFO /* winnls.h:883:5 */
type PFILEMUIINFO = uintptr     /* winnls.h:883:17 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type _COORD = struct {
	X SHORT
	Y SHORT
} /* wincon.h:17:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type COORD = _COORD   /* wincon.h:20:5 */
type PCOORD = uintptr /* wincon.h:20:11 */

type _SMALL_RECT = struct {
	Left   SHORT
	Top    SHORT
	Right  SHORT
	Bottom SHORT
} /* wincon.h:22:11 */

type SMALL_RECT = _SMALL_RECT /* wincon.h:27:5 */
type PSMALL_RECT = uintptr    /* wincon.h:27:16 */

type _KEY_EVENT_RECORD = struct {
	bKeyDown          WINBOOL
	wRepeatCount      WORD
	wVirtualKeyCode   WORD
	wVirtualScanCode  WORD
	uChar             struct{ UnicodeChar WCHAR }
	dwControlKeyState DWORD
} /* wincon.h:29:11 */

type KEY_EVENT_RECORD = _KEY_EVENT_RECORD /* wincon.h:39:5 */
type PKEY_EVENT_RECORD = uintptr          /* wincon.h:39:22 */

type _MOUSE_EVENT_RECORD = struct {
	dwMousePosition   COORD
	dwButtonState     DWORD
	dwControlKeyState DWORD
	dwEventFlags      DWORD
} /* wincon.h:58:11 */

type MOUSE_EVENT_RECORD = _MOUSE_EVENT_RECORD /* wincon.h:63:5 */
type PMOUSE_EVENT_RECORD = uintptr            /* wincon.h:63:24 */

type _WINDOW_BUFFER_SIZE_RECORD = struct{ dwSize COORD } /* wincon.h:78:11 */

type WINDOW_BUFFER_SIZE_RECORD = _WINDOW_BUFFER_SIZE_RECORD /* wincon.h:80:5 */
type PWINDOW_BUFFER_SIZE_RECORD = uintptr                   /* wincon.h:80:31 */

type _MENU_EVENT_RECORD = struct{ dwCommandId UINT } /* wincon.h:82:11 */

type MENU_EVENT_RECORD = _MENU_EVENT_RECORD /* wincon.h:84:5 */
type PMENU_EVENT_RECORD = uintptr           /* wincon.h:84:23 */

type _FOCUS_EVENT_RECORD = struct{ bSetFocus WINBOOL } /* wincon.h:86:11 */

type FOCUS_EVENT_RECORD = _FOCUS_EVENT_RECORD /* wincon.h:88:5 */
type PFOCUS_EVENT_RECORD = uintptr            /* wincon.h:88:24 */

type _INPUT_RECORD = struct {
	EventType WORD
	_         [2]byte
	Event     struct{ KeyEvent KEY_EVENT_RECORD }
} /* wincon.h:90:11 */

type INPUT_RECORD = _INPUT_RECORD /* wincon.h:99:5 */
type PINPUT_RECORD = uintptr      /* wincon.h:99:18 */

type _CHAR_INFO = struct {
	Char       struct{ UnicodeChar WCHAR }
	Attributes WORD
} /* wincon.h:107:11 */

type CHAR_INFO = _CHAR_INFO /* wincon.h:113:5 */
type PCHAR_INFO = uintptr   /* wincon.h:113:15 */

type _CONSOLE_SCREEN_BUFFER_INFO = struct {
	dwSize              COORD
	dwCursorPosition    COORD
	wAttributes         WORD
	srWindow            SMALL_RECT
	dwMaximumWindowSize COORD
} /* wincon.h:133:11 */

type CONSOLE_SCREEN_BUFFER_INFO = _CONSOLE_SCREEN_BUFFER_INFO /* wincon.h:139:5 */
type PCONSOLE_SCREEN_BUFFER_INFO = uintptr                    /* wincon.h:139:32 */

type _CONSOLE_CURSOR_INFO = struct {
	dwSize   DWORD
	bVisible WINBOOL
} /* wincon.h:141:11 */

type CONSOLE_CURSOR_INFO = _CONSOLE_CURSOR_INFO /* wincon.h:144:5 */
type PCONSOLE_CURSOR_INFO = uintptr             /* wincon.h:144:25 */

type _CONSOLE_FONT_INFO = struct {
	nFont      DWORD
	dwFontSize COORD
} /* wincon.h:146:11 */

type CONSOLE_FONT_INFO = _CONSOLE_FONT_INFO /* wincon.h:149:5 */
type PCONSOLE_FONT_INFO = uintptr           /* wincon.h:149:23 */

type _CONSOLE_SELECTION_INFO = struct {
	dwFlags           DWORD
	dwSelectionAnchor COORD
	srSelection       SMALL_RECT
} /* wincon.h:151:11 */

type CONSOLE_SELECTION_INFO = _CONSOLE_SELECTION_INFO /* wincon.h:155:5 */
type PCONSOLE_SELECTION_INFO = uintptr                /* wincon.h:155:28 */

type PHANDLER_ROUTINE = uintptr /* wincon.h:163:19 */

type _CONSOLE_FONT_INFOEX = struct {
	cbSize     ULONG
	nFont      DWORD
	dwFontSize COORD
	FontFamily UINT
	FontWeight UINT
	FaceName   [32]WCHAR
} /* wincon.h:297:9 */

type CONSOLE_FONT_INFOEX = _CONSOLE_FONT_INFOEX /* wincon.h:304:3 */
type PCONSOLE_FONT_INFOEX = uintptr             /* wincon.h:304:24 */

type _CONSOLE_HISTORY_INFO = struct {
	cbSize                 UINT
	HistoryBufferSize      UINT
	NumberOfHistoryBuffers UINT
	dwFlags                DWORD
} /* wincon.h:306:9 */

type CONSOLE_HISTORY_INFO = _CONSOLE_HISTORY_INFO /* wincon.h:311:3 */
type PCONSOLE_HISTORY_INFO = uintptr              /* wincon.h:311:25 */

type _CONSOLE_READCONSOLE_CONTROL = struct {
	nLength           ULONG
	nInitialChars     ULONG
	dwCtrlWakeupMask  ULONG
	dwControlKeyState ULONG
} /* wincon.h:313:9 */

type CONSOLE_READCONSOLE_CONTROL = _CONSOLE_READCONSOLE_CONTROL /* wincon.h:318:3 */
type PCONSOLE_READCONSOLE_CONTROL = uintptr                     /* wincon.h:318:32 */

type _CONSOLE_SCREEN_BUFFER_INFOEX = struct {
	cbSize               ULONG
	dwSize               COORD
	dwCursorPosition     COORD
	wAttributes          WORD
	srWindow             SMALL_RECT
	dwMaximumWindowSize  COORD
	wPopupAttributes     WORD
	bFullscreenSupported WINBOOL
	ColorTable           [16]COLORREF
} /* wincon.h:320:9 */

type CONSOLE_SCREEN_BUFFER_INFOEX = _CONSOLE_SCREEN_BUFFER_INFOEX /* wincon.h:330:3 */
type PCONSOLE_SCREEN_BUFFER_INFOEX = uintptr                      /* wincon.h:330:33 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type tagVS_FIXEDFILEINFO = struct {
	dwSignature        DWORD
	dwStrucVersion     DWORD
	dwFileVersionMS    DWORD
	dwFileVersionLS    DWORD
	dwProductVersionMS DWORD
	dwProductVersionLS DWORD
	dwFileFlagsMask    DWORD
	dwFileFlags        DWORD
	dwFileOS           DWORD
	dwFileType         DWORD
	dwFileSubtype      DWORD
	dwFileDateMS       DWORD
	dwFileDateLS       DWORD
} /* winver.h:113:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type VS_FIXEDFILEINFO = tagVS_FIXEDFILEINFO /* winver.h:128:5 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type REGSAM = ACCESS_MASK /* winreg.h:35:23 */
type LSTATUS = LONG       /* winreg.h:36:16 */

type val_context = struct {
	valuelen      int32
	value_context LPVOID
	val_buff_ptr  LPVOID
} /* winreg.h:54:3 */

type PVALCONTEXT = uintptr /* winreg.h:60:30 */

type pvalueA = struct {
	pv_valuename     LPSTR
	pv_valuelen      int32
	pv_value_context LPVOID
	pv_type          DWORD
} /* winreg.h:62:11 */

type PVALUEA = pvalueA  /* winreg.h:67:4 */
type PPVALUEA = uintptr /* winreg.h:67:12 */

type pvalueW = struct {
	pv_valuename     LPWSTR
	pv_valuelen      int32
	pv_value_context LPVOID
	pv_type          DWORD
} /* winreg.h:69:11 */

type PVALUEW = pvalueW  /* winreg.h:74:4 */
type PPVALUEW = uintptr /* winreg.h:74:12 */

type PVALUE = PVALUEA   /* winreg.h:76:3 */
type PPVALUE = PPVALUEA /* winreg.h:77:3 */

type PQUERYHANDLER = uintptr /* winreg.h:81:24 */

type provider_info = struct {
	pi_R0_1val     PQUERYHANDLER
	pi_R0_allvals  PQUERYHANDLER
	pi_R3_1val     PQUERYHANDLER
	pi_R3_allvals  PQUERYHANDLER
	pi_flags       DWORD
	pi_key_context LPVOID
} /* winreg.h:83:11 */

type REG_PROVIDER = provider_info /* winreg.h:90:5 */

type PPROVIDER = uintptr /* winreg.h:92:32 */

type value_entA = struct {
	ve_valuename LPSTR
	ve_valuelen  DWORD
	ve_valueptr  DWORD_PTR
	ve_type      DWORD
} /* winreg.h:94:11 */

type VALENTA = value_entA /* winreg.h:99:5 */
type PVALENTA = uintptr   /* winreg.h:99:13 */

type value_entW = struct {
	ve_valuename LPWSTR
	ve_valuelen  DWORD
	ve_valueptr  DWORD_PTR
	ve_type      DWORD
} /* winreg.h:101:11 */

type VALENTW = value_entW /* winreg.h:106:5 */
type PVALENTW = uintptr   /* winreg.h:106:13 */

type VALENT = VALENTA   /* winreg.h:108:3 */
type PVALENT = PVALENTA /* winreg.h:109:3 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type _NETRESOURCEA = struct {
	dwScope       DWORD
	dwType        DWORD
	dwDisplayType DWORD
	dwUsage       DWORD
	lpLocalName   LPSTR
	lpRemoteName  LPSTR
	lpComment     LPSTR
	lpProvider    LPSTR
} /* winnetwk.h:53:11 */

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type NETRESOURCEA = _NETRESOURCEA /* winnetwk.h:62:5 */
type LPNETRESOURCEA = uintptr     /* winnetwk.h:62:18 */
type _NETRESOURCEW = struct {
	dwScope       DWORD
	dwType        DWORD
	dwDisplayType DWORD
	dwUsage       DWORD
	lpLocalName   LPWSTR
	lpRemoteName  LPWSTR
	lpComment     LPWSTR
	lpProvider    LPWSTR
} /* winnetwk.h:63:11 */

type NETRESOURCEW = _NETRESOURCEW /* winnetwk.h:72:5 */
type LPNETRESOURCEW = uintptr     /* winnetwk.h:72:18 */

type NETRESOURCE = NETRESOURCEA     /* winnetwk.h:74:3 */
type LPNETRESOURCE = LPNETRESOURCEA /* winnetwk.h:75:3 */

type _CONNECTDLGSTRUCTA = struct {
	cbStructure DWORD
	hwndOwner   HWND
	lpConnRes   LPNETRESOURCEA
	dwFlags     DWORD
	dwDevNum    DWORD
} /* winnetwk.h:129:11 */

type CONNECTDLGSTRUCTA = _CONNECTDLGSTRUCTA /* winnetwk.h:135:5 */
type LPCONNECTDLGSTRUCTA = uintptr          /* winnetwk.h:135:23 */

type _CONNECTDLGSTRUCTW = struct {
	cbStructure DWORD
	hwndOwner   HWND
	lpConnRes   LPNETRESOURCEW
	dwFlags     DWORD
	dwDevNum    DWORD
} /* winnetwk.h:137:11 */

type CONNECTDLGSTRUCTW = _CONNECTDLGSTRUCTW /* winnetwk.h:143:5 */
type LPCONNECTDLGSTRUCTW = uintptr          /* winnetwk.h:143:23 */

type CONNECTDLGSTRUCT = CONNECTDLGSTRUCTA     /* winnetwk.h:145:3 */
type LPCONNECTDLGSTRUCT = LPCONNECTDLGSTRUCTA /* winnetwk.h:146:3 */

type _DISCDLGSTRUCTA = struct {
	cbStructure  DWORD
	hwndOwner    HWND
	lpLocalName  LPSTR
	lpRemoteName LPSTR
	dwFlags      DWORD
} /* winnetwk.h:161:11 */

type DISCDLGSTRUCTA = _DISCDLGSTRUCTA /* winnetwk.h:167:5 */
type LPDISCDLGSTRUCTA = uintptr       /* winnetwk.h:167:20 */

type _DISCDLGSTRUCTW = struct {
	cbStructure  DWORD
	hwndOwner    HWND
	lpLocalName  LPWSTR
	lpRemoteName LPWSTR
	dwFlags      DWORD
} /* winnetwk.h:169:11 */

type DISCDLGSTRUCTW = _DISCDLGSTRUCTW /* winnetwk.h:175:5 */
type LPDISCDLGSTRUCTW = uintptr       /* winnetwk.h:175:20 */

type DISCDLGSTRUCT = DISCDLGSTRUCTA     /* winnetwk.h:177:3 */
type LPDISCDLGSTRUCT = LPDISCDLGSTRUCTA /* winnetwk.h:178:3 */

type _UNIVERSAL_NAME_INFOA = struct{ lpUniversalName LPSTR } /* winnetwk.h:204:11 */

type UNIVERSAL_NAME_INFOA = _UNIVERSAL_NAME_INFOA /* winnetwk.h:206:5 */
type LPUNIVERSAL_NAME_INFOA = uintptr             /* winnetwk.h:206:26 */

type _UNIVERSAL_NAME_INFOW = struct{ lpUniversalName LPWSTR } /* winnetwk.h:208:11 */

type UNIVERSAL_NAME_INFOW = _UNIVERSAL_NAME_INFOW /* winnetwk.h:210:5 */
type LPUNIVERSAL_NAME_INFOW = uintptr             /* winnetwk.h:210:26 */

type UNIVERSAL_NAME_INFO = UNIVERSAL_NAME_INFOA     /* winnetwk.h:212:3 */
type LPUNIVERSAL_NAME_INFO = LPUNIVERSAL_NAME_INFOA /* winnetwk.h:213:3 */

type _REMOTE_NAME_INFOA = struct {
	lpUniversalName  LPSTR
	lpConnectionName LPSTR
	lpRemainingPath  LPSTR
} /* winnetwk.h:215:11 */

type REMOTE_NAME_INFOA = _REMOTE_NAME_INFOA /* winnetwk.h:219:5 */
type LPREMOTE_NAME_INFOA = uintptr          /* winnetwk.h:219:23 */

type _REMOTE_NAME_INFOW = struct {
	lpUniversalName  LPWSTR
	lpConnectionName LPWSTR
	lpRemainingPath  LPWSTR
} /* winnetwk.h:221:11 */

type REMOTE_NAME_INFOW = _REMOTE_NAME_INFOW /* winnetwk.h:225:5 */
type LPREMOTE_NAME_INFOW = uintptr          /* winnetwk.h:225:23 */

type REMOTE_NAME_INFO = REMOTE_NAME_INFOA     /* winnetwk.h:227:3 */
type LPREMOTE_NAME_INFO = LPREMOTE_NAME_INFOA /* winnetwk.h:228:3 */

type _NETINFOSTRUCT = struct {
	cbStructure       DWORD
	dwProviderVersion DWORD
	dwStatus          DWORD
	dwCharacteristics DWORD
	dwHandle          ULONG_PTR
	wNetType          WORD
	_                 [2]byte
	dwPrinters        DWORD
	dwDrives          DWORD
} /* winnetwk.h:247:11 */

type NETINFOSTRUCT = _NETINFOSTRUCT /* winnetwk.h:256:5 */
type LPNETINFOSTRUCT = uintptr      /* winnetwk.h:256:19 */

type PFNGETPROFILEPATHA = uintptr /* winnetwk.h:267:16 */
type PFNGETPROFILEPATHW = uintptr /* winnetwk.h:268:16 */

type PFNRECONCILEPROFILEA = uintptr /* winnetwk.h:272:16 */
type PFNRECONCILEPROFILEW = uintptr /* winnetwk.h:273:16 */

type PFNPROCESSPOLICIESA = uintptr /* winnetwk.h:280:19 */
type PFNPROCESSPOLICIESW = uintptr /* winnetwk.h:281:19 */

type _NETCONNECTINFOSTRUCT = struct {
	cbStructure   DWORD
	dwFlags       DWORD
	dwSpeed       DWORD
	dwDelay       DWORD
	dwOptDataSize DWORD
} /* winnetwk.h:335:11 */

type NETCONNECTINFOSTRUCT = _NETCONNECTINFOSTRUCT /* winnetwk.h:341:5 */
type LPNETCONNECTINFOSTRUCT = uintptr             /* winnetwk.h:341:26 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type _SERVICE_DESCRIPTIONA = struct{ lpDescription LPSTR } /* winsvc.h:95:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER within this package.

type SERVICE_DESCRIPTIONA = _SERVICE_DESCRIPTIONA /* winsvc.h:97:5 */
type LPSERVICE_DESCRIPTIONA = uintptr             /* winsvc.h:97:26 */

type _SERVICE_DESCRIPTIONW = struct{ lpDescription LPWSTR } /* winsvc.h:99:11 */

type SERVICE_DESCRIPTIONW = _SERVICE_DESCRIPTIONW /* winsvc.h:101:5 */
type LPSERVICE_DESCRIPTIONW = uintptr             /* winsvc.h:101:26 */

type SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONA     /* winsvc.h:103:3 */
type LPSERVICE_DESCRIPTION = LPSERVICE_DESCRIPTIONA /* winsvc.h:104:3 */

type SC_ACTION_TYPE = uint32 /* winsvc.h:108:5 */

type _SC_ACTION = struct {
	Type  SC_ACTION_TYPE
	Delay DWORD
} /* winsvc.h:110:11 */

type SC_ACTION = _SC_ACTION /* winsvc.h:113:5 */
type LPSC_ACTION = uintptr  /* winsvc.h:113:15 */

type _SERVICE_FAILURE_ACTIONSA = struct {
	dwResetPeriod DWORD
	lpRebootMsg   LPSTR
	lpCommand     LPSTR
	cActions      DWORD
	lpsaActions   uintptr
} /* winsvc.h:115:11 */

type SERVICE_FAILURE_ACTIONSA = _SERVICE_FAILURE_ACTIONSA /* winsvc.h:121:5 */
type LPSERVICE_FAILURE_ACTIONSA = uintptr                 /* winsvc.h:121:30 */

type _SERVICE_FAILURE_ACTIONSW = struct {
	dwResetPeriod DWORD
	lpRebootMsg   LPWSTR
	lpCommand     LPWSTR
	cActions      DWORD
	lpsaActions   uintptr
} /* winsvc.h:123:11 */

type SERVICE_FAILURE_ACTIONSW = _SERVICE_FAILURE_ACTIONSW /* winsvc.h:129:5 */
type LPSERVICE_FAILURE_ACTIONSW = uintptr                 /* winsvc.h:129:30 */

type SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSA     /* winsvc.h:131:3 */
type LPSERVICE_FAILURE_ACTIONS = LPSERVICE_FAILURE_ACTIONSA /* winsvc.h:132:3 */

type SC_HANDLE__ = struct{ unused int32 } /* winsvc.h:134:3 */

type SC_HANDLE = uintptr   /* winsvc.h:134:3 */
type LPSC_HANDLE = uintptr /* winsvc.h:135:21 */

type SERVICE_STATUS_HANDLE__ = struct{ unused int32 } /* winsvc.h:137:3 */

type SERVICE_STATUS_HANDLE = uintptr /* winsvc.h:137:3 */

type SC_STATUS_TYPE = uint32 /* winsvc.h:141:5 */

type SC_ENUM_TYPE = uint32 /* winsvc.h:145:5 */

type _SERVICE_STATUS = struct {
	dwServiceType             DWORD
	dwCurrentState            DWORD
	dwControlsAccepted        DWORD
	dwWin32ExitCode           DWORD
	dwServiceSpecificExitCode DWORD
	dwCheckPoint              DWORD
	dwWaitHint                DWORD
} /* winsvc.h:147:11 */

type SERVICE_STATUS = _SERVICE_STATUS /* winsvc.h:155:5 */
type LPSERVICE_STATUS = uintptr       /* winsvc.h:155:20 */

type _SERVICE_STATUS_PROCESS = struct {
	dwServiceType             DWORD
	dwCurrentState            DWORD
	dwControlsAccepted        DWORD
	dwWin32ExitCode           DWORD
	dwServiceSpecificExitCode DWORD
	dwCheckPoint              DWORD
	dwWaitHint                DWORD
	dwProcessId               DWORD
	dwServiceFlags            DWORD
} /* winsvc.h:157:11 */

type SERVICE_STATUS_PROCESS = _SERVICE_STATUS_PROCESS /* winsvc.h:167:5 */
type LPSERVICE_STATUS_PROCESS = uintptr               /* winsvc.h:167:28 */

type _ENUM_SERVICE_STATUSA = struct {
	lpServiceName LPSTR
	lpDisplayName LPSTR
	ServiceStatus SERVICE_STATUS
} /* winsvc.h:169:11 */

type ENUM_SERVICE_STATUSA = _ENUM_SERVICE_STATUSA /* winsvc.h:173:5 */
type LPENUM_SERVICE_STATUSA = uintptr             /* winsvc.h:173:26 */

type _ENUM_SERVICE_STATUSW = struct {
	lpServiceName LPWSTR
	lpDisplayName LPWSTR
	ServiceStatus SERVICE_STATUS
} /* winsvc.h:175:11 */

type ENUM_SERVICE_STATUSW = _ENUM_SERVICE_STATUSW /* winsvc.h:179:5 */
type LPENUM_SERVICE_STATUSW = uintptr             /* winsvc.h:179:26 */

type ENUM_SERVICE_STATUS = ENUM_SERVICE_STATUSA     /* winsvc.h:181:3 */
type LPENUM_SERVICE_STATUS = LPENUM_SERVICE_STATUSA /* winsvc.h:182:3 */

type _ENUM_SERVICE_STATUS_PROCESSA = struct {
	lpServiceName        LPSTR
	lpDisplayName        LPSTR
	ServiceStatusProcess SERVICE_STATUS_PROCESS
} /* winsvc.h:184:11 */

type ENUM_SERVICE_STATUS_PROCESSA = _ENUM_SERVICE_STATUS_PROCESSA /* winsvc.h:188:5 */
type LPENUM_SERVICE_STATUS_PROCESSA = uintptr                     /* winsvc.h:188:34 */

type _ENUM_SERVICE_STATUS_PROCESSW = struct {
	lpServiceName        LPWSTR
	lpDisplayName        LPWSTR
	ServiceStatusProcess SERVICE_STATUS_PROCESS
} /* winsvc.h:190:11 */

type ENUM_SERVICE_STATUS_PROCESSW = _ENUM_SERVICE_STATUS_PROCESSW /* winsvc.h:194:5 */
type LPENUM_SERVICE_STATUS_PROCESSW = uintptr                     /* winsvc.h:194:34 */

type ENUM_SERVICE_STATUS_PROCESS = ENUM_SERVICE_STATUS_PROCESSA     /* winsvc.h:196:3 */
type LPENUM_SERVICE_STATUS_PROCESS = LPENUM_SERVICE_STATUS_PROCESSA /* winsvc.h:197:3 */

type SC_LOCK = LPVOID /* winsvc.h:199:18 */

type _QUERY_SERVICE_LOCK_STATUSA = struct {
	fIsLocked      DWORD
	lpLockOwner    LPSTR
	dwLockDuration DWORD
} /* winsvc.h:201:11 */

type QUERY_SERVICE_LOCK_STATUSA = _QUERY_SERVICE_LOCK_STATUSA /* winsvc.h:205:5 */
type LPQUERY_SERVICE_LOCK_STATUSA = uintptr                   /* winsvc.h:205:32 */

type _QUERY_SERVICE_LOCK_STATUSW = struct {
	fIsLocked      DWORD
	lpLockOwner    LPWSTR
	dwLockDuration DWORD
} /* winsvc.h:207:11 */

type QUERY_SERVICE_LOCK_STATUSW = _QUERY_SERVICE_LOCK_STATUSW /* winsvc.h:211:5 */
type LPQUERY_SERVICE_LOCK_STATUSW = uintptr                   /* winsvc.h:211:32 */

type QUERY_SERVICE_LOCK_STATUS = QUERY_SERVICE_LOCK_STATUSA     /* winsvc.h:213:3 */
type LPQUERY_SERVICE_LOCK_STATUS = LPQUERY_SERVICE_LOCK_STATUSA /* winsvc.h:214:3 */

type _QUERY_SERVICE_CONFIGA = struct {
	dwServiceType      DWORD
	dwStartType        DWORD
	dwErrorControl     DWORD
	lpBinaryPathName   LPSTR
	lpLoadOrderGroup   LPSTR
	dwTagId            DWORD
	lpDependencies     LPSTR
	lpServiceStartName LPSTR
	lpDisplayName      LPSTR
} /* winsvc.h:216:11 */

type QUERY_SERVICE_CONFIGA = _QUERY_SERVICE_CONFIGA /* winsvc.h:226:5 */
type LPQUERY_SERVICE_CONFIGA = uintptr              /* winsvc.h:226:27 */

type _QUERY_SERVICE_CONFIGW = struct {
	dwServiceType      DWORD
	dwStartType        DWORD
	dwErrorControl     DWORD
	lpBinaryPathName   LPWSTR
	lpLoadOrderGroup   LPWSTR
	dwTagId            DWORD
	lpDependencies     LPWSTR
	lpServiceStartName LPWSTR
	lpDisplayName      LPWSTR
} /* winsvc.h:228:11 */

type QUERY_SERVICE_CONFIGW = _QUERY_SERVICE_CONFIGW /* winsvc.h:238:5 */
type LPQUERY_SERVICE_CONFIGW = uintptr              /* winsvc.h:238:27 */

type QUERY_SERVICE_CONFIG = QUERY_SERVICE_CONFIGA     /* winsvc.h:240:3 */
type LPQUERY_SERVICE_CONFIG = LPQUERY_SERVICE_CONFIGA /* winsvc.h:241:3 */

type LPSERVICE_MAIN_FUNCTIONW = uintptr /* winsvc.h:243:16 */
type LPSERVICE_MAIN_FUNCTIONA = uintptr /* winsvc.h:244:16 */

type _SERVICE_TABLE_ENTRYA = struct {
	lpServiceName LPSTR
	lpServiceProc LPSERVICE_MAIN_FUNCTIONA
} /* winsvc.h:248:11 */

type SERVICE_TABLE_ENTRYA = _SERVICE_TABLE_ENTRYA /* winsvc.h:251:5 */
type LPSERVICE_TABLE_ENTRYA = uintptr             /* winsvc.h:251:26 */

type _SERVICE_TABLE_ENTRYW = struct {
	lpServiceName LPWSTR
	lpServiceProc LPSERVICE_MAIN_FUNCTIONW
} /* winsvc.h:253:11 */

type SERVICE_TABLE_ENTRYW = _SERVICE_TABLE_ENTRYW /* winsvc.h:256:5 */
type LPSERVICE_TABLE_ENTRYW = uintptr             /* winsvc.h:256:26 */

type SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYA     /* winsvc.h:258:3 */
type LPSERVICE_TABLE_ENTRY = LPSERVICE_TABLE_ENTRYA /* winsvc.h:259:3 */

type LPHANDLER_FUNCTION = uintptr    /* winsvc.h:261:16 */
type LPHANDLER_FUNCTION_EX = uintptr /* winsvc.h:262:17 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type _MODEMDEVCAPS = struct {
	dwActualSize              DWORD
	dwRequiredSize            DWORD
	dwDevSpecificOffset       DWORD
	dwDevSpecificSize         DWORD
	dwModemProviderVersion    DWORD
	dwModemManufacturerOffset DWORD
	dwModemManufacturerSize   DWORD
	dwModemModelOffset        DWORD
	dwModemModelSize          DWORD
	dwModemVersionOffset      DWORD
	dwModemVersionSize        DWORD
	dwDialOptions             DWORD
	dwCallSetupFailTimer      DWORD
	dwInactivityTimeout       DWORD
	dwSpeakerVolume           DWORD
	dwSpeakerMode             DWORD
	dwModemOptions            DWORD
	dwMaxDTERate              DWORD
	dwMaxDCERate              DWORD
	abVariablePortion         [1]BYTE
	_                         [3]byte
} /* mcx.h:9:9 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type MODEMDEVCAPS = _MODEMDEVCAPS /* mcx.h:30:3 */
type PMODEMDEVCAPS = uintptr      /* mcx.h:30:16 */
type LPMODEMDEVCAPS = uintptr     /* mcx.h:30:31 */

type _MODEMSETTINGS = struct {
	dwActualSize             DWORD
	dwRequiredSize           DWORD
	dwDevSpecificOffset      DWORD
	dwDevSpecificSize        DWORD
	dwCallSetupFailTimer     DWORD
	dwInactivityTimeout      DWORD
	dwSpeakerVolume          DWORD
	dwSpeakerMode            DWORD
	dwPreferredModemOptions  DWORD
	dwNegotiatedModemOptions DWORD
	dwNegotiatedDCERate      DWORD
	abVariablePortion        [1]BYTE
	_                        [3]byte
} /* mcx.h:32:9 */

type MODEMSETTINGS = _MODEMSETTINGS /* mcx.h:45:3 */
type PMODEMSETTINGS = uintptr       /* mcx.h:45:17 */
type LPMODEMSETTINGS = uintptr      /* mcx.h:45:33 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

type HIMC__ = struct{ unused int32 } /* imm.h:18:3 */

type HIMC = uintptr                   /* imm.h:18:3 */
type HIMCC__ = struct{ unused int32 } /* imm.h:19:3 */

type HIMCC = uintptr /* imm.h:19:3 */

type LPHKL = uintptr  /* imm.h:21:15 */
type LPUINT = uintptr /* imm.h:24:16 */

type tagCOMPOSITIONFORM = struct {
	dwStyle      DWORD
	ptCurrentPos POINT
	rcArea       RECT
} /* imm.h:27:11 */

type COMPOSITIONFORM = tagCOMPOSITIONFORM /* imm.h:31:5 */
type PCOMPOSITIONFORM = uintptr           /* imm.h:31:21 */
type NPCOMPOSITIONFORM = uintptr          /* imm.h:31:39 */
type LPCOMPOSITIONFORM = uintptr          /* imm.h:31:58 */

type tagCANDIDATEFORM = struct {
	dwIndex      DWORD
	dwStyle      DWORD
	ptCurrentPos POINT
	rcArea       RECT
} /* imm.h:33:11 */

type CANDIDATEFORM = tagCANDIDATEFORM /* imm.h:38:5 */
type PCANDIDATEFORM = uintptr         /* imm.h:38:19 */
type NPCANDIDATEFORM = uintptr        /* imm.h:38:35 */
type LPCANDIDATEFORM = uintptr        /* imm.h:38:52 */

type tagCANDIDATELIST = struct {
	dwSize      DWORD
	dwStyle     DWORD
	dwCount     DWORD
	dwSelection DWORD
	dwPageStart DWORD
	dwPageSize  DWORD
	dwOffset    [1]DWORD
} /* imm.h:40:11 */

type CANDIDATELIST = tagCANDIDATELIST /* imm.h:48:5 */
type PCANDIDATELIST = uintptr         /* imm.h:48:19 */
type NPCANDIDATELIST = uintptr        /* imm.h:48:35 */
type LPCANDIDATELIST = uintptr        /* imm.h:48:52 */

type tagREGISTERWORDA = struct {
	lpReading LPSTR
	lpWord    LPSTR
} /* imm.h:50:11 */

type REGISTERWORDA = tagREGISTERWORDA /* imm.h:53:5 */
type PREGISTERWORDA = uintptr         /* imm.h:53:19 */
type NPREGISTERWORDA = uintptr        /* imm.h:53:35 */
type LPREGISTERWORDA = uintptr        /* imm.h:53:52 */

type tagREGISTERWORDW = struct {
	lpReading LPWSTR
	lpWord    LPWSTR
} /* imm.h:55:11 */

type REGISTERWORDW = tagREGISTERWORDW /* imm.h:58:5 */
type PREGISTERWORDW = uintptr         /* imm.h:58:19 */
type NPREGISTERWORDW = uintptr        /* imm.h:58:35 */
type LPREGISTERWORDW = uintptr        /* imm.h:58:52 */

type REGISTERWORD = REGISTERWORDA     /* imm.h:60:3 */
type PREGISTERWORD = PREGISTERWORDA   /* imm.h:61:3 */
type NPREGISTERWORD = NPREGISTERWORDA /* imm.h:62:3 */
type LPREGISTERWORD = LPREGISTERWORDA /* imm.h:63:3 */

type tagRECONVERTSTRING = struct {
	dwSize            DWORD
	dwVersion         DWORD
	dwStrLen          DWORD
	dwStrOffset       DWORD
	dwCompStrLen      DWORD
	dwCompStrOffset   DWORD
	dwTargetStrLen    DWORD
	dwTargetStrOffset DWORD
} /* imm.h:65:11 */

type RECONVERTSTRING = tagRECONVERTSTRING /* imm.h:74:5 */
type PRECONVERTSTRING = uintptr           /* imm.h:74:21 */
type NPRECONVERTSTRING = uintptr          /* imm.h:74:39 */
type LPRECONVERTSTRING = uintptr          /* imm.h:74:58 */

type tagSTYLEBUFA = struct {
	dwStyle       DWORD
	szDescription [32]CHAR
} /* imm.h:78:11 */

type STYLEBUFA = tagSTYLEBUFA /* imm.h:81:5 */
type PSTYLEBUFA = uintptr     /* imm.h:81:15 */
type NPSTYLEBUFA = uintptr    /* imm.h:81:27 */
type LPSTYLEBUFA = uintptr    /* imm.h:81:40 */

type tagSTYLEBUFW = struct {
	dwStyle       DWORD
	szDescription [32]WCHAR
} /* imm.h:83:11 */

type STYLEBUFW = tagSTYLEBUFW /* imm.h:86:5 */
type PSTYLEBUFW = uintptr     /* imm.h:86:15 */
type NPSTYLEBUFW = uintptr    /* imm.h:86:27 */
type LPSTYLEBUFW = uintptr    /* imm.h:86:40 */

type STYLEBUF = STYLEBUFA     /* imm.h:88:3 */
type PSTYLEBUF = PSTYLEBUFA   /* imm.h:89:3 */
type NPSTYLEBUF = NPSTYLEBUFA /* imm.h:90:3 */
type LPSTYLEBUF = LPSTYLEBUFA /* imm.h:91:3 */

type tagIMEMENUITEMINFOA = struct {
	cbSize        UINT
	fType         UINT
	fState        UINT
	wID           UINT
	hbmpChecked   HBITMAP
	hbmpUnchecked HBITMAP
	dwItemData    DWORD
	szString      [80]CHAR
	hbmpItem      HBITMAP
} /* imm.h:95:11 */

type IMEMENUITEMINFOA = tagIMEMENUITEMINFOA /* imm.h:105:5 */
type PIMEMENUITEMINFOA = uintptr            /* imm.h:105:22 */
type NPIMEMENUITEMINFOA = uintptr           /* imm.h:105:41 */
type LPIMEMENUITEMINFOA = uintptr           /* imm.h:105:61 */

type tagIMEMENUITEMINFOW = struct {
	cbSize        UINT
	fType         UINT
	fState        UINT
	wID           UINT
	hbmpChecked   HBITMAP
	hbmpUnchecked HBITMAP
	dwItemData    DWORD
	szString      [80]WCHAR
	hbmpItem      HBITMAP
} /* imm.h:107:11 */

type IMEMENUITEMINFOW = tagIMEMENUITEMINFOW /* imm.h:117:5 */
type PIMEMENUITEMINFOW = uintptr            /* imm.h:117:22 */
type NPIMEMENUITEMINFOW = uintptr           /* imm.h:117:41 */
type LPIMEMENUITEMINFOW = uintptr           /* imm.h:117:61 */

type IMEMENUITEMINFO = IMEMENUITEMINFOA     /* imm.h:119:3 */
type PIMEMENUITEMINFO = PIMEMENUITEMINFOA   /* imm.h:120:3 */
type NPIMEMENUITEMINFO = NPIMEMENUITEMINFOA /* imm.h:121:3 */
type LPIMEMENUITEMINFO = LPIMEMENUITEMINFOA /* imm.h:122:3 */

type tagIMECHARPOSITION = struct {
	dwSize      DWORD
	dwCharPos   DWORD
	pt          POINT
	cLineHeight UINT
	rcDocument  RECT
} /* imm.h:124:11 */

type IMECHARPOSITION = tagIMECHARPOSITION /* imm.h:130:5 */
type PIMECHARPOSITION = uintptr           /* imm.h:130:21 */
type NPIMECHARPOSITION = uintptr          /* imm.h:130:39 */
type LPIMECHARPOSITION = uintptr          /* imm.h:130:58 */

type IMCENUMPROC = uintptr /* imm.h:132:19 */

type REGISTERWORDENUMPROCA = uintptr /* imm.h:185:15 */
type REGISTERWORDENUMPROCW = uintptr /* imm.h:186:15 */

// Posix thread extensions.

// Extension defined as by report VC 10+ defines error-numbers.

// Defined as WSAETIMEDOUT.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Copyright (C) 1992-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// This administrivia gets added to the beginning of limits.h
//    if the system has its own version of limits.h.

// We use _GCC_LIMITS_H_ because we want this not to match
//    any macros that the system's limits.h uses for its own purposes.

// Use "..." so that we find syslimits.h only in this same directory.
// syslimits.h stands for the system's own limits.h file.
//    If we can use it ok unmodified, then we install this text.
//    If fixincludes fixes it, then the fixed version is installed
//    instead of this text.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.
// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// File system limits
//
// NOTE: Apparently the actual size of PATH_MAX is 260, but a space is
//       required for the NUL. TODO: Test?
// NOTE: PATH_MAX is the POSIX equivalent for Microsoft's MAX_PATH; the two
//       are semantically identical, with a limit of 259 characters for the
//       path name, plus one for a terminating NUL, for a total of 260.

// Copyright (C) 1991-2018 Free Software Foundation, Inc.
//
// This file is part of GCC.
//
// GCC is free software; you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free
// Software Foundation; either version 3, or (at your option) any later
// version.
//
// GCC is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
//
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

// Number of bits in a `char'.

// Maximum length of a multibyte character.

// Minimum and maximum values a `signed char' can hold.

// Maximum value an `unsigned char' can hold.  (Minimum is 0).

// Minimum and maximum values a `char' can hold.

// Minimum and maximum values a `signed short int' can hold.

// Maximum value an `unsigned short int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed int' can hold.

// Maximum value an `unsigned int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long int' can hold.
//    (Same as `int').

// Maximum value an `unsigned long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// Minimum and maximum values a `signed long long int' can hold.

// Maximum value an `unsigned long long int' can hold.  (Minimum is 0).

// This administrivia gets added to the end of limits.h
//    if the system has its own version of limits.h.

type _onexit_t = uintptr /* stdlib.h:49:15 */

type _div_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:59:11 */

type div_t = _div_t /* stdlib.h:62:5 */

type _ldiv_t = struct {
	quot int32
	rem  int32
} /* stdlib.h:64:11 */

type ldiv_t = _ldiv_t /* stdlib.h:67:5 */

type _LDOUBLE = struct{ ld [10]uint8 } /* stdlib.h:76:5 */

type _CRT_DOUBLE = struct{ x float64 } /* stdlib.h:83:5 */

type _CRT_FLOAT = struct{ f float32 } /* stdlib.h:87:5 */

type _LONGDOUBLE = struct{ x float64 } /* stdlib.h:94:5 */

type _LDBL12 = struct{ ld12 [12]uint8 } /* stdlib.h:101:5 */

type _purecall_handler = uintptr /* stdlib.h:142:16 */

type _invalid_parameter_handler = uintptr /* stdlib.h:147:16 */

type lldiv_t = struct {
	quot int64
	rem  int64
} /* stdlib.h:699:61 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Return codes for _heapwalk()

// Values for _heapinfo.useflag

// The structure used to walk through the heap with _heapwalk.
type _heapinfo = struct {
	_pentry  uintptr
	_size    size_t
	_useflag int32
} /* malloc.h:46:11 */

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// Return codes for _heapwalk()

// Values for _heapinfo.useflag

// The structure used to walk through the heap with _heapwalk.
type _HEAPINFO = _heapinfo /* malloc.h:50:5 */

// Static assertion.  Requires support in the compiler.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// The suffix to append to the child command lines, if any

// The directory separator character(s)

// Mark a parameter as unused to suppress compiler warnings

// Global data
type Global = struct {
	argv0            uintptr
	zVfs             uintptr
	zDbFile          uintptr
	db               uintptr
	zErrLog          uintptr
	pErrLog          uintptr
	zLog             uintptr
	pLog             uintptr
	zName            [32]int8
	taskId           int32
	iTrace           int32
	bSqlTrace        int32
	bIgnoreSqlErrors int32
	nError           int32
	nTest            int32
	iTimeout         int32
	bSync            int32
} /* mptest.c:72:8 */

// Static assertion.  Requires support in the compiler.

// *
// This file has no copyright assigned and is placed in the Public Domain.
// This file is part of the mingw-w64 runtime package.
// No warranty is given; refer to the file DISCLAIMER.PD within this package.

// The suffix to append to the child command lines, if any

// The directory separator character(s)

// Mark a parameter as unused to suppress compiler warnings

// Global data
var g Global /* mptest.c:90:3: */

// Default timeout

// Print a message adding zPrefix[] to the beginning of every line.
func printWithPrefix(tls *libc.TLS, pOut uintptr, zPrefix uintptr, zMsg uintptr) { /* mptest.c:98:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	for (zMsg != 0) && (*(*int8)(unsafe.Pointer(zMsg + uintptr(0))) != 0) {
		var i int32
		for i = 0; ((*(*int8)(unsafe.Pointer(zMsg + uintptr(i))) != 0) && (int32(*(*int8)(unsafe.Pointer(zMsg + uintptr(i)))) != '\n')) && (int32(*(*int8)(unsafe.Pointer(zMsg + uintptr(i)))) != '\r'); i++ {
		}
		libc.Xfprintf(tls, pOut, ts /* "%s%.*s\n" */, libc.VaList(bp, zPrefix, i, zMsg))
		zMsg += uintptr(i)
		for (int32(*(*int8)(unsafe.Pointer(zMsg + uintptr(0)))) == '\n') || (int32(*(*int8)(unsafe.Pointer(zMsg + uintptr(0)))) == '\r') {
			zMsg++
		}
	}
}

// Compare two pointers to strings, where the pointers might be NULL.
func safe_strcmp(tls *libc.TLS, a uintptr, b uintptr) int32 { /* mptest.c:111:12: */
	if a == b {
		return 0
	}
	if a == uintptr(0) {
		return -1
	}
	if b == uintptr(0) {
		return 1
	}
	return libc.Xstrcmp(tls, a, b)
}

// Return TRUE if string z[] matches glob pattern zGlob[].
// Return FALSE if the pattern does not match.
//
// Globbing rules:
//
//      '*'       Matches any sequence of zero or more characters.
//
//      '?'       Matches exactly one character.
//
//     [...]      Matches one character from the enclosed list of
//                characters.
//
//     [^...]     Matches one character not in the enclosed list.
//
//      '#'       Matches any sequence of one or more digits with an
//                optional + or - sign in front
func strglob(tls *libc.TLS, zGlob uintptr, z uintptr) int32 { /* mptest.c:136:5: */
	var c int32
	var c2 int32
	var invert int32
	var seen int32

	for (libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1)))))) != 0 {
		if c == '*' {
			for ((libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1)))))) == '*') || (c == '?') {
				if (c == '?') && ((int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) == 0) {
					return 0
				}
			}
			if c == 0 {
				return 1
			} else if c == '[' {
				for (*(*int8)(unsafe.Pointer(z)) != 0) && (strglob(tls, (zGlob-uintptr(1)), z) != 0) {
					z++
				}
				return (libc.Bool32((int32(*(*int8)(unsafe.Pointer(z)))) != 0))
			}
			for (libc.AssignInt32(&c2, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))))) != 0 {
				for c2 != c {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
					if c2 == 0 {
						return 0
					}
				}
				if strglob(tls, zGlob, z) != 0 {
					return 1
				}
			}
			return 0
		} else if c == '?' {
			if (int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) == 0 {
				return 0
			}
		} else if c == '[' {
			var prior_c int32 = 0
			seen = 0
			invert = 0
			c = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
			if c == 0 {
				return 0
			}
			c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			if c2 == '^' {
				invert = 1
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == ']' {
				if c == ']' {
					seen = 1
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			for (c2 != 0) && (c2 != ']') {
				if (((c2 == '-') && (int32(*(*int8)(unsafe.Pointer(zGlob + uintptr(0)))) != ']')) && (int32(*(*int8)(unsafe.Pointer(zGlob + uintptr(0)))) != 0)) && (prior_c > 0) {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
					if (c >= prior_c) && (c <= c2) {
						seen = 1
					}
					prior_c = 0
				} else {
					if c == c2 {
						seen = 1
					}
					prior_c = c2
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if (c2 == 0) || ((seen ^ invert) == 0) {
				return 0
			}
		} else if c == '#' {
			if ((int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '-') || (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '+')) && (libc.Xisdigit(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(1)))))) != 0) {
				z++
			}
			if !(libc.Xisdigit(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(0)))))) != 0) {
				return 0
			}
			z++
			for libc.Xisdigit(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(0)))))) != 0 {
				z++
			}
		} else {
			if c != (int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) {
				return 0
			}
		}
	}
	return (libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) == 0))
}

// Close output stream pOut if it is not stdout or stderr
func maybeClose(tls *libc.TLS, pOut uintptr) { /* mptest.c:208:13: */
	if (pOut != (libc.X__acrt_iob_func(tls, uint32(1)))) && (pOut != (libc.X__acrt_iob_func(tls, uint32(2)))) {
		libc.Xfclose(tls, pOut)
	}
}

// Print an error message
func errorMessage(tls *libc.TLS, zFormat uintptr, va uintptr) { /* mptest.c:215:13: */
	bp := tls.Alloc(46)
	defer tls.Free(46)

	var ap va_list
	_ = ap
	var zMsg uintptr
	// var zPrefix [30]int8 at bp+16, 30

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+16 /* &zPrefix[0] */, ts+8 /* "%s:ERROR: " */, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+32 /* &.zName */))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+16 /* &zPrefix[0] */, zMsg)
		libc.Xfflush(tls, g.pLog)
	}
	if (g.pErrLog != 0) && (safe_strcmp(tls, g.zErrLog, g.zLog) != 0) {
		printWithPrefix(tls, g.pErrLog, bp+16 /* &zPrefix[0] */, zMsg)
		libc.Xfflush(tls, g.pErrLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
	g.nError++
}

// Print an error message and then quit.
func fatalError(tls *libc.TLS, zFormat uintptr, va uintptr) { /* mptest.c:241:13: */
	bp := tls.Alloc(46)
	defer tls.Free(46)

	var ap va_list
	_ = ap
	var zMsg uintptr
	// var zPrefix [30]int8 at bp+16, 30

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+16 /* &zPrefix[0] */, ts+19 /* "%s:FATAL: " */, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+32 /* &.zName */))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+16 /* &zPrefix[0] */, zMsg)
		libc.Xfflush(tls, g.pLog)
		maybeClose(tls, g.pLog)
	}
	if (g.pErrLog != 0) && (safe_strcmp(tls, g.zErrLog, g.zLog) != 0) {
		printWithPrefix(tls, g.pErrLog, bp+16 /* &zPrefix[0] */, zMsg)
		libc.Xfflush(tls, g.pErrLog)
		maybeClose(tls, g.pErrLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
	if g.db != 0 {
		var nTry int32 = 0
		g.iTimeout = 0
		for (trySql(tls, ts+30 /* "UPDATE client SE..." */, 0) == 5) &&
			((libc.PostIncInt32(&nTry, 1)) < 100) {
			sqlite3.Xsqlite3_sleep(tls, 10)
		}
	}
	sqlite3.Xsqlite3_close(tls, g.db)
	libc.Xexit(tls, 1)
}

// Print a log message
func logMessage(tls *libc.TLS, zFormat uintptr, va uintptr) { /* mptest.c:276:13: */
	bp := tls.Alloc(46)
	defer tls.Free(46)

	var ap va_list
	_ = ap
	var zMsg uintptr
	// var zPrefix [30]int8 at bp+16, 30

	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+16 /* &zPrefix[0] */, ts+60 /* "%s: " */, libc.VaList(bp, uintptr(unsafe.Pointer(&g))+32 /* &.zName */))
	if g.pLog != 0 {
		printWithPrefix(tls, g.pLog, bp+16 /* &zPrefix[0] */, zMsg)
		libc.Xfflush(tls, g.pLog)
	}
	sqlite3.Xsqlite3_free(tls, zMsg)
}

// Return the length of a string omitting trailing whitespace
func clipLength(tls *libc.TLS, z uintptr) int32 { /* mptest.c:294:12: */
	var n int32 = int32(libc.Xstrlen(tls, z))
	for (n > 0) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr((n - 1))))))) != 0) {
		n--
	}
	return n
}

// Auxiliary SQL function to return the name of the VFS
func vfsNameFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* mptest.c:303:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	*(*uintptr)(unsafe.Pointer(bp /* zVfs */)) = uintptr(0)
	_ = argc
	_ = argv
	sqlite3.Xsqlite3_file_control(tls, db, ts+65 /* "main" */, 12, bp /* &zVfs */)
	if *(*uintptr)(unsafe.Pointer(bp /* zVfs */)) != 0 {
		sqlite3.Xsqlite3_result_text(tls, context, *(*uintptr)(unsafe.Pointer(bp /* zVfs */)), -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// Busy handler with a g.iTimeout-millisecond timeout
func busyHandler(tls *libc.TLS, pCD uintptr, count int32) int32 { /* mptest.c:321:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	_ = pCD
	if (count * 10) > g.iTimeout {
		if g.iTimeout > 0 {
			errorMessage(tls, ts+70 /* "timeout after %d..." */, libc.VaList(bp, g.iTimeout))
		}
		return 0
	}
	sqlite3.Xsqlite3_sleep(tls, 10)
	return 1
}

// SQL Trace callback
func sqlTraceCallback(tls *libc.TLS, NotUsed1 uintptr, zSql uintptr) { /* mptest.c:334:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = NotUsed1
	logMessage(tls, ts+89 /* "[%.*s]" */, libc.VaList(bp, clipLength(tls, zSql), zSql))
}

// SQL error log callback
func sqlErrorCallback(tls *libc.TLS, pArg uintptr, iErrCode int32, zMsg uintptr) { /* mptest.c:342:13: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	_ = pArg
	if (iErrCode == 1) && (g.bIgnoreSqlErrors != 0) {
		return
	}
	if ((iErrCode & 0xff) == 17) && (g.iTrace < 3) {
		return
	}
	if ((g.iTimeout == 0) && ((iErrCode & 0xff) == 5)) && (g.iTrace < 3) {
		return
	}
	if (iErrCode & 0xff) == 27 {
		logMessage(tls, ts+96 /* "(info) %s" */, libc.VaList(bp, zMsg))
	} else {
		errorMessage(tls, ts+106 /* "(errcode=%d) %s" */, libc.VaList(bp+16, iErrCode, zMsg))
	}
}

// Prepare an SQL statement.  Issue a fatal error if unable.
func prepareSql(tls *libc.TLS, zFormat uintptr, va uintptr) uintptr { /* mptest.c:357:21: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt */)) = uintptr(0)
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_prepare_v2(tls, g.db, zSql, -1, bp+24 /* &pStmt */, uintptr(0))
	if rc != 0 {
		sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt */)))
		fatalError(tls, ts+122 /* "%s\n%s\n" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db), zSql))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	return *(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt */))
}

// Run arbitrary SQL.  Issue a fatal error on failure.
func runSql(tls *libc.TLS, zFormat uintptr, va uintptr) { /* mptest.c:377:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, uintptr(0), uintptr(0), uintptr(0))
	if rc != 0 {
		fatalError(tls, ts+122 /* "%s\n%s\n" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db), zSql))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
}

// Try to run arbitrary SQL.  Return success code.
func trySql(tls *libc.TLS, zFormat uintptr, va uintptr) int32 { /* mptest.c:394:12: */
	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	return rc
}

// Structure for holding an arbitrary length string
type String1 = struct {
	z      uintptr
	n      int32
	nAlloc int32
} /* mptest.c:408:9 */

// Structure for holding an arbitrary length string
type String = String1 /* mptest.c:408:23 */

// Free a string
func stringFree(tls *libc.TLS, p uintptr) { /* mptest.c:416:13: */
	if (*String)(unsafe.Pointer(p)).z != 0 {
		sqlite3.Xsqlite3_free(tls, (*String)(unsafe.Pointer(p)).z)
	}
	libc.Xmemset(tls, p, 0, uint32(unsafe.Sizeof(String{})))
}

// Append n bytes of text to a string.  If n<0 append the entire string.
func stringAppend(tls *libc.TLS, p uintptr, z uintptr, n int32) { /* mptest.c:422:13: */
	if n < 0 {
		n = int32(libc.Xstrlen(tls, z))
	}
	if ((*String)(unsafe.Pointer(p)).n + n) >= (*String)(unsafe.Pointer(p)).nAlloc {
		var nAlloc int32 = ((((*String)(unsafe.Pointer(p)).nAlloc * 2) + n) + 100)
		var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*String)(unsafe.Pointer(p)).z, nAlloc)
		if zNew == uintptr(0) {
			fatalError(tls, ts+129 /* "out of memory" */, 0)
		}
		(*String)(unsafe.Pointer(p)).z = zNew
		(*String)(unsafe.Pointer(p)).nAlloc = nAlloc
	}
	libc.Xmemcpy(tls, ((*String)(unsafe.Pointer(p)).z + uintptr((*String)(unsafe.Pointer(p)).n)), z, uint32(n))
	*(*int32)(unsafe.Pointer(p + 4 /* &.n */)) += (n)
	*(*int8)(unsafe.Pointer((*String)(unsafe.Pointer(p)).z + uintptr((*String)(unsafe.Pointer(p)).n))) = int8(0)
}

// Reset a string to an empty string
func stringReset(tls *libc.TLS, p uintptr) { /* mptest.c:437:13: */
	if (*String)(unsafe.Pointer(p)).z == uintptr(0) {
		stringAppend(tls, p, ts+143 /* " " */, 1)
	}
	(*String)(unsafe.Pointer(p)).n = 0
	*(*int8)(unsafe.Pointer((*String)(unsafe.Pointer(p)).z + uintptr(0))) = int8(0)
}

// Append a new token onto the end of the string
func stringAppendTerm(tls *libc.TLS, p uintptr, z uintptr) { /* mptest.c:444:13: */
	var i int32
	if (*String)(unsafe.Pointer(p)).n != 0 {
		stringAppend(tls, p, ts+143 /* " " */, 1)
	}
	if z == uintptr(0) {
		stringAppend(tls, p, ts+145 /* "nil" */, 3)
		return
	}
	for i = 0; (*(*int8)(unsafe.Pointer(z + uintptr(i))) != 0) && !(libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))))) != 0); i++ {
	}
	if (i > 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == 0) {
		stringAppend(tls, p, z, i)
		return
	}
	stringAppend(tls, p, ts+149 /* "'" */, 1)
	for *(*int8)(unsafe.Pointer(z + uintptr(0))) != 0 {
		for i = 0; (*(*int8)(unsafe.Pointer(z + uintptr(i))) != 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '\''); i++ {
		}
		if *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0 {
			stringAppend(tls, p, z, (i + 1))
			stringAppend(tls, p, ts+149 /* "'" */, 1)
			z += (uintptr(i + 1))
		} else {
			stringAppend(tls, p, z, i)
			break
		}
	}
	stringAppend(tls, p, ts+149 /* "'" */, 1)
}

// Callback function for evalSql()
func evalCallback(tls *libc.TLS, pCData uintptr, argc int32, argv uintptr, azCol uintptr) int32 { /* mptest.c:474:12: */
	var p uintptr = pCData
	var i int32
	_ = azCol
	for i = 0; i < argc; i++ {
		stringAppendTerm(tls, p, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4)))
	}
	return 0
}

// Run arbitrary SQL and record the results in an output string
// given by the first parameter.
func evalSql(tls *libc.TLS, p uintptr, zFormat uintptr, va uintptr) int32 { /* mptest.c:486:12: */
	bp := tls.Alloc(50)
	defer tls.Free(50)

	var ap va_list
	_ = ap
	var zSql uintptr
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 16 /* zErrMsg */)) = uintptr(0)
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap

	rc = sqlite3.Xsqlite3_exec(tls, g.db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{evalCallback})), p, bp+16 /* &zErrMsg */)
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		// var zErr [30]int8 at bp+20, 30

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+20 /* &zErr[0] */, ts+151 /* "error(%d)" */, libc.VaList(bp, rc))
		stringAppendTerm(tls, p, bp+20 /* &zErr[0] */)
		if *(*uintptr)(unsafe.Pointer(bp + 16 /* zErrMsg */)) != 0 {
			stringAppendTerm(tls, p, *(*uintptr)(unsafe.Pointer(bp + 16 /* zErrMsg */)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* zErrMsg */)))
		}
	}
	return rc
}

// Auxiliary SQL function to recursively evaluate SQL.
func evalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* mptest.c:512:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var zSql uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4)))
	// var res String at bp, 12

	*(*uintptr)(unsafe.Pointer(bp + 12 /* zErrMsg */)) = uintptr(0)
	var rc int32
	_ = argc
	libc.Xmemset(tls, bp /* &res */, 0, uint32(unsafe.Sizeof(String{})))
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{evalCallback})), bp /* &res */, bp+12 /* &zErrMsg */)
	if *(*uintptr)(unsafe.Pointer(bp + 12 /* zErrMsg */)) != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, *(*uintptr)(unsafe.Pointer(bp + 12 /* zErrMsg */)), -1)
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 12 /* zErrMsg */)))
	} else if rc != 0 {
		sqlite3.Xsqlite3_result_error_code(tls, context, rc)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, (*String)(unsafe.Pointer(bp /* &res */)).z, -1, libc.UintptrFromInt32(-1))
	}
	stringFree(tls, bp /* &res */)
}

// Look up the next task for client iClient in the database.
// Return the task script and the task number and mark that
// task as being under way.
func startScript(tls *libc.TLS, iClient int32, pzScript uintptr, pTaskId uintptr, pzTaskName uintptr) int32 { /* mptest.c:541:12: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var pStmt uintptr = uintptr(0)
	var taskId int32
	var rc int32
	var totalTime int32 = 0

	*(*uintptr)(unsafe.Pointer(pzScript)) = uintptr(0)
	g.iTimeout = 0
	for 1 != 0 {
		rc = trySql(tls, ts+161 /* "BEGIN IMMEDIATE" */, 0)
		if rc == 5 {
			sqlite3.Xsqlite3_sleep(tls, 10)
			totalTime = totalTime + (10)
			continue
		}
		if rc != 0 {
			fatalError(tls, ts+177 /* "in startScript: ..." */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, g.db)))
		}
		if (g.nError != 0) || (g.nTest != 0) {
			runSql(tls, ts+196, /* "UPDATE counters ..." */
				libc.VaList(bp+16, g.nError, g.nTest))
			g.nError = 0
			g.nTest = 0
		}
		pStmt = prepareSql(tls, ts+249 /* "SELECT 1 FROM cl..." */, libc.VaList(bp+40, iClient))
		rc = sqlite3.Xsqlite3_step(tls, pStmt)
		sqlite3.Xsqlite3_finalize(tls, pStmt)
		if rc == 100 {
			runSql(tls, ts+295 /* "DELETE FROM clie..." */, libc.VaList(bp+56, iClient))
			g.iTimeout = 10000
			runSql(tls, ts+326 /* "COMMIT TRANSACTI..." */, 0)
			return 101
		}
		pStmt = prepareSql(tls,

			ts+346 /* "SELECT script, i..." */, libc.VaList(bp+72, iClient))
		rc = sqlite3.Xsqlite3_step(tls, pStmt)
		if rc == 100 {
			var n int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 0)
			*(*uintptr)(unsafe.Pointer(pzScript)) = sqlite3.Xsqlite3_malloc(tls, (n + 1))
			libc.Xstrcpy(tls, *(*uintptr)(unsafe.Pointer(pzScript)), sqlite3.Xsqlite3_column_text(tls, pStmt, 0))
			*(*int32)(unsafe.Pointer(pTaskId)) = libc.AssignInt32(&taskId, sqlite3.Xsqlite3_column_int(tls, pStmt, 1))
			*(*uintptr)(unsafe.Pointer(pzTaskName)) = sqlite3.Xsqlite3_mprintf(tls, ts+438 /* "%s" */, libc.VaList(bp+88, sqlite3.Xsqlite3_column_text(tls, pStmt, 2)))
			sqlite3.Xsqlite3_finalize(tls, pStmt)
			runSql(tls,

				ts+441 /* "UPDATE task   SE..." */, libc.VaList(bp+104, taskId))
			g.iTimeout = 10000
			runSql(tls, ts+326 /* "COMMIT TRANSACTI..." */, 0)
			return 0
		}
		sqlite3.Xsqlite3_finalize(tls, pStmt)
		if rc == 101 {
			if totalTime > 30000 {
				errorMessage(tls, ts+524 /* "Waited over 30 s..." */, 0)
				runSql(tls, ts+573 /* "DELETE FROM clie..." */, libc.VaList(bp+120, iClient))
				sqlite3.Xsqlite3_close(tls, g.db)
				libc.Xexit(tls, 1)
			}
			for trySql(tls, ts+613 /* "COMMIT" */, 0) == 5 {
				sqlite3.Xsqlite3_sleep(tls, 10)
				totalTime = totalTime + (10)
			}
			sqlite3.Xsqlite3_sleep(tls, 100)
			totalTime = totalTime + (100)
			continue
		}
		fatalError(tls, ts+438 /* "%s" */, libc.VaList(bp+136, sqlite3.Xsqlite3_errmsg(tls, g.db)))
	}
	g.iTimeout = 10000
	return int32(0)
}

// Mark a script as having finished.   Remove the CLIENT table entry
// if bShutdown is true.
func finishScript(tls *libc.TLS, iClient int32, taskId int32, bShutdown int32) int32 { /* mptest.c:623:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	runSql(tls,

		ts+620 /* "UPDATE task   SE..." */, libc.VaList(bp, taskId))
	if bShutdown != 0 {
		runSql(tls, ts+295 /* "DELETE FROM clie..." */, libc.VaList(bp+16, iClient))
	}
	return 0
}

// Start up a client process for iClient, if it is not already
// running.  If the client is already running, then this routine
// is a no-op.
func startClient(tls *libc.TLS, iClient int32) { /* mptest.c:638:13: */
	bp := tls.Alloc(228)
	defer tls.Free(228)

	runSql(tls, ts+701 /* "INSERT OR IGNORE..." */, libc.VaList(bp, iClient))
	if sqlite3.Xsqlite3_changes(tls, g.db) != 0 {
		var zSys uintptr
		var rc int32
		zSys = sqlite3.Xsqlite3_mprintf(tls, ts+743, /* "%s \"%s\" --client..." */
			libc.VaList(bp+16, g.argv0, g.zDbFile, iClient, g.iTrace))
		if g.bSqlTrace != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+774 /* "%z --sqltrace" */, libc.VaList(bp+56, zSys))
		}
		if g.bSync != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+788 /* "%z --sync" */, libc.VaList(bp+72, zSys))
		}
		if g.zVfs != 0 {
			zSys = sqlite3.Xsqlite3_mprintf(tls, ts+798 /* "%z --vfs \"%s\"" */, libc.VaList(bp+88, zSys, g.zVfs))
		}
		if g.iTrace >= 2 {
			logMessage(tls, ts+812 /* "system('%q')" */, libc.VaList(bp+112, zSys))
		}
		{
			// var startupInfo STARTUPINFOA at bp+144, 68

			// var processInfo PROCESS_INFORMATION at bp+212, 16

			libc.Xmemset(tls, bp+144 /* &startupInfo */, 0, uint32(unsafe.Sizeof(STARTUPINFOA{})))
			(*STARTUPINFOA)(unsafe.Pointer(bp + 144 /* &startupInfo */)).cb = DWORD(unsafe.Sizeof(STARTUPINFOA{}))
			libc.Xmemset(tls, bp+212 /* &processInfo */, 0, uint32(unsafe.Sizeof(PROCESS_INFORMATION{})))
			rc = libc.XCreateProcessA(tls, uintptr(0), zSys, uintptr(0), uintptr(0), 0, uint32(0), uintptr(0), uintptr(0),
				bp+144 /* &startupInfo */, bp+212 /* &processInfo */)
			if rc != 0 {
				libc.XCloseHandle(tls, (*PROCESS_INFORMATION)(unsafe.Pointer(bp+212 /* &processInfo */)).hThread)
				libc.XCloseHandle(tls, (*PROCESS_INFORMATION)(unsafe.Pointer(bp+212 /* &processInfo */)).hProcess)
			} else {
				errorMessage(tls, ts+825, /* "CreateProcessA()..." */
					libc.VaList(bp+128, libc.XGetLastError(tls)))
			}

		}
		sqlite3.Xsqlite3_free(tls, zSys)
	}
}

// Read the entire content of a file into memory
func readFile(tls *libc.TLS, zFilename uintptr) uintptr { /* mptest.c:684:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var in uintptr = libc.Xfopen(tls, zFilename, ts+868 /* "rb" */)
	var sz int32
	var z uintptr
	if in == uintptr(0) {
		fatalError(tls, ts+871 /* "cannot open \"%s\"..." */, libc.VaList(bp, zFilename))
	}
	libc.Xfseek(tls, in, 0, 2)
	sz = libc.Xftell(tls, in)
	libc.Xrewind(tls, in)
	z = sqlite3.Xsqlite3_malloc(tls, (int32(sz + 1)))
	sz = int32(libc.Xfread(tls, z, uint32(1), uint32(sz), in))
	*(*int8)(unsafe.Pointer(z + uintptr(sz))) = int8(0)
	libc.Xfclose(tls, in)
	return z
}

// Return the length of the next token.
func tokenLength(tls *libc.TLS, z uintptr, pnLine uintptr) int32 { /* mptest.c:704:12: */
	var n int32 = 0
	if (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(0)))))) != 0) || ((int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '/') && (int32(*(*int8)(unsafe.Pointer(z + uintptr(1)))) == '*')) {
		var inC int32 = 0
		var c int32
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '/' {
			inC = 1
			n = 2
		}
		for (libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&n, 1))))))) != 0 {
			if c == '\n' {
				(*(*int32)(unsafe.Pointer(pnLine)))++
			}
			if libc.Xisspace(tls, int32(uint8(c))) != 0 {
				continue
			}
			if ((inC != 0) && (c == '*')) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == '/') {
				n++
				inC = 0
			} else if (!(inC != 0) && (c == '/')) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == '*') {
				n++
				inC = 1
			} else if !(inC != 0) {
				break
			}
		}
		n--
	} else if (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '-') && (int32(*(*int8)(unsafe.Pointer(z + uintptr(1)))) == '-') {
		for n = 2; (*(*int8)(unsafe.Pointer(z + uintptr(n))) != 0) && (int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) != '\n'); n++ {
		}
		if *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 {
			(*(*int32)(unsafe.Pointer(pnLine)))++
			n++
		}
	} else if (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '"') || (int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '\'') {
		var delim int32 = int32(*(*int8)(unsafe.Pointer(z + uintptr(0))))
		for n = 1; *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0; n++ {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == '\n' {
				(*(*int32)(unsafe.Pointer(pnLine)))++
			}
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))) == delim {
				n++
				if int32(*(*int8)(unsafe.Pointer(z + uintptr((n + 1))))) != delim {
					break
				}
			}
		}
	} else {
		var c int32
		for n = 1; (((((libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(z + uintptr(n)))))) != 0) && !(libc.Xisspace(tls, int32(uint8(c))) != 0)) && (c != '"')) && (c != '\'')) && (c != ';'); n++ {
		}
	}
	return n
}

// Copy a single token into a string buffer.
func extractToken(tls *libc.TLS, zIn uintptr, nIn int32, zOut uintptr, nOut int32) int32 { /* mptest.c:749:12: */
	var i int32
	if nIn <= 0 {
		*(*int8)(unsafe.Pointer(zOut + uintptr(0))) = int8(0)
		return 0
	}
	for i = 0; ((i < nIn) && (i < (nOut - 1))) && !(libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))))) != 0); i++ {
		*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = *(*int8)(unsafe.Pointer(zIn + uintptr(i)))
	}
	*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = int8(0)
	return i
}

// Find the number of characters up to the start of the next "--end" token.
func findEnd(tls *libc.TLS, z uintptr, pnLine uintptr) int32 { /* mptest.c:763:12: */
	var n int32 = 0
	for (*(*int8)(unsafe.Pointer(z + uintptr(n))) != 0) && ((libc.Xstrncmp(tls, (z+uintptr(n)), ts+900 /* "--end" */, uint32(5)) != 0) || !(libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr((n + 5))))))) != 0)) {
		n = n + (tokenLength(tls, (z + uintptr(n)), pnLine))
	}
	return n
}

// Find the number of characters up to the first character past the
// of the next "--endif"  or "--else" token. Nested --if commands are
// also skipped.
func findEndif(tls *libc.TLS, z uintptr, stopAtElse int32, pnLine uintptr) int32 { /* mptest.c:776:12: */
	var n int32 = 0
	for *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 {
		var len int32 = tokenLength(tls, (z + uintptr(n)), pnLine)
		if ((libc.Xstrncmp(tls, (z+uintptr(n)), ts+906 /* "--endif" */, uint32(7)) == 0) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr((n + 7))))))) != 0)) ||
			(((stopAtElse != 0) && (libc.Xstrncmp(tls, (z+uintptr(n)), ts+914 /* "--else" */, uint32(6)) == 0)) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr((n + 6))))))) != 0)) {
			return (n + len)
		}
		if (libc.Xstrncmp(tls, (z+uintptr(n)), ts+921 /* "--if" */, uint32(4)) == 0) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr((n + 4))))))) != 0) {
			var skip int32 = findEndif(tls, ((z + uintptr(n)) + uintptr(len)), 0, pnLine)
			n = n + (skip + len)
		} else {
			n = n + (len)
		}
	}
	return n
}

// Wait for a client process to complete all its tasks
func waitForClient(tls *libc.TLS, iClient int32, iTimeout int32, zErrPrefix uintptr) { /* mptest.c:798:13: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var pStmt uintptr
	var rc int32
	if iClient > 0 {
		pStmt = prepareSql(tls,

			ts+926, /* "SELECT 1 FROM ta..." */
			libc.VaList(bp, iClient))
	} else {
		pStmt = prepareSql(tls,

			ts+1022 /* "SELECT 1 FROM ta..." */, 0)
	}
	g.iTimeout = 0
	for (((libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt))) == 5) || (rc == 100)) &&
		(iTimeout > 0) {
		sqlite3.Xsqlite3_reset(tls, pStmt)
		sqlite3.Xsqlite3_sleep(tls, 50)
		iTimeout = iTimeout - (50)
	}
	sqlite3.Xsqlite3_finalize(tls, pStmt)
	g.iTimeout = 10000
	if rc != 101 {
		if zErrPrefix == uintptr(0) {
			zErrPrefix = ts + 1103 /* "" */
		}
		if iClient > 0 {
			errorMessage(tls, ts+1104 /* "%stimeout waitin..." */, libc.VaList(bp+16, zErrPrefix, iClient))
		} else {
			errorMessage(tls, ts+1136 /* "%stimeout waitin..." */, libc.VaList(bp+40, zErrPrefix))
		}
	}
}

// Return a pointer to the tail of a filename
func filenameTail(tls *libc.TLS, z uintptr) uintptr { /* mptest.c:836:13: */
	var i int32
	var j int32
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		if ((int32(*(*int8)(unsafe.Pointer(z + uintptr(i))))) == '/') || ((int32(*(*int8)(unsafe.Pointer(z + uintptr(i))))) == '\\') {
			j = (i + 1)
		}
	}
	return (z + uintptr(j))
}

// Interpret zArg as a boolean value.  Return either 0 or 1.
func booleanValue(tls *libc.TLS, zArg uintptr) int32 { /* mptest.c:845:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	if zArg == uintptr(0) {
		return 0
	}
	for i = 0; (int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i)))) >= '0') && (int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i)))) <= '9'); i++ {
	}
	if (i > 0) && (int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i)))) == 0) {
		return libc.Xatoi(tls, zArg)
	}
	if (sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1170 /* "on" */) == 0) || (sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1173 /* "yes" */) == 0) {
		return 1
	}
	if (sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1177 /* "off" */) == 0) || (sqlite3.Xsqlite3_stricmp(tls, zArg, ts+1181 /* "no" */) == 0) {
		return 0
	}
	errorMessage(tls, ts+1184 /* "unknown boolean:..." */, libc.VaList(bp, zArg))
	return 0
}

// This routine exists as a convenient place to set a debugger
// breakpoint.
func test_breakpoint(tls *libc.TLS) { /* mptest.c:864:13: */
	atomic.AddInt32(&cnt, 1)
}

var cnt int32 = 0 /* mptest.c:864:56 */

// Maximum number of arguments to a --command

// Run a script.
func runScript(tls *libc.TLS, iClient int32, taskId int32, zScript uintptr, zFilename uintptr) { /* mptest.c:872:13: */
	bp := tls.Alloc(1766)
	defer tls.Free(1766)

	*(*int32)(unsafe.Pointer(bp + 532 /* lineno */)) = 1
	var prevLine int32 = 1
	var ii int32 = 0
	var iBegin int32 = 0
	var n int32
	var c int32
	var j int32
	var len int32
	var nArg int32
	// var sResult String at bp+520, 12

	// var zCmd [30]int8 at bp+536, 30

	// var zError [1000]int8 at bp+766, 1000

	// var azArg [2][100]int8 at bp+566, 200

	libc.Xmemset(tls, bp+520 /* &sResult */, 0, uint32(unsafe.Sizeof(String{})))
	stringReset(tls, bp+520 /* &sResult */)
	for (libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(zScript + uintptr(ii)))))) != 0 {
		prevLine = *(*int32)(unsafe.Pointer(bp + 532 /* lineno */))
		len = tokenLength(tls, (zScript + uintptr(ii)), bp+532 /* &lineno */)
		if (libc.Xisspace(tls, int32(uint8(c))) != 0) || ((c == '/') && (int32(*(*int8)(unsafe.Pointer(zScript + uintptr((ii + 1))))) == '*')) {
			ii = ii + (len)
			continue
		}
		if ((c != '-') || (int32(*(*int8)(unsafe.Pointer(zScript + uintptr((ii + 1))))) != '-')) || !(libc.Xisalpha(tls, int32(*(*int8)(unsafe.Pointer(zScript + uintptr((ii + 2)))))) != 0) {
			ii = ii + (len)
			continue
		}

		// Run any prior SQL before processing the new --command
		if ii > iBegin {
			var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+1206 /* "%.*s" */, libc.VaList(bp, (ii-iBegin), (zScript+uintptr(iBegin))))
			evalSql(tls, bp+520 /* &sResult */, zSql, 0)
			sqlite3.Xsqlite3_free(tls, zSql)
			iBegin = (ii + len)
		}

		// Parse the --command
		if g.iTrace >= 2 {
			logMessage(tls, ts+1206 /* "%.*s" */, libc.VaList(bp+24, len, (zScript+uintptr(ii))))
		}
		n = extractToken(tls, ((zScript + uintptr(ii)) + uintptr(2)), (len - 2), bp+536 /* &zCmd[0] */, int32(unsafe.Sizeof([30]int8{})))
		for nArg = 0; (n < (len - 2)) && (nArg < 2); nArg++ {
			for (n < (len - 2)) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zScript + uintptr(((ii + 2) + n))))))) != 0) {
				n++
			}
			if n >= (len - 2) {
				break
			}
			n = n + (extractToken(tls, (((zScript + uintptr(ii)) + uintptr(2)) + uintptr(n)), ((len - 2) - n),
				(bp + 566 /* &azArg[0] */ + uintptr(nArg)*100), int32(unsafe.Sizeof([100]int8{}))))
		}
		for j = nArg; j < 2; j++ {
			*(*int8)(unsafe.Pointer((bp + 566 /* &azArg[0] */ + uintptr(libc.PostIncInt32(&j, 1))*100) + uintptr(0))) = int8(0)
		}

		//  --sleep N
		//
		// Pause for N milliseconds
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1211 /* "sleep" */) == 0 {
			sqlite3.Xsqlite3_sleep(tls, libc.Xatoi(tls, (bp+566 /* &azArg[0] */ +uintptr(0)*100)))
		} else

		//   --exit N
		//
		// Exit this process.  If N>0 then exit without shutting down
		// SQLite.  (In other words, simulate a crash.)
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1217 /* "exit" */) == 0 {
			var rc int32 = libc.Xatoi(tls, (bp + 566 /* &azArg[0] */ + uintptr(0)*100))
			finishScript(tls, iClient, taskId, 1)
			if rc == 0 {
				sqlite3.Xsqlite3_close(tls, g.db)
			}
			libc.Xexit(tls, rc)
		} else

		//   --testcase NAME
		//
		// Begin a new test case.  Announce in the log that the test case
		// has begun.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1222 /* "testcase" */) == 0 {
			if g.iTrace == 1 {
				logMessage(tls, ts+1206 /* "%.*s" */, libc.VaList(bp+48, (len-1), (zScript+uintptr(ii))))
			}
			stringReset(tls, bp+520 /* &sResult */)
		} else

		//   --finish
		//
		// Mark the current task as having finished, even if it is not.
		// This can be used in conjunction with --exit to simulate a crash.
		if (libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1231 /* "finish" */) == 0) && (iClient > 0) {
			finishScript(tls, iClient, taskId, 1)
		} else

		//  --reset
		//
		// Reset accumulated results back to an empty string
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1238 /* "reset" */) == 0 {
			stringReset(tls, bp+520 /* &sResult */)
		} else

		//  --match ANSWER...
		//
		// Check to see if output matches ANSWER.  Report an error if not.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1244 /* "match" */) == 0 {
			var jj int32
			var zAns uintptr = (zScript + uintptr(ii))
			for jj = 7; (jj < (len - 1)) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zAns + uintptr(jj)))))) != 0); jj++ {
			}
			zAns += uintptr(jj)
			if (((len - jj) - 1) != (*String)(unsafe.Pointer(bp+520 /* &sResult */)).n) || (libc.Xstrncmp(tls, (*String)(unsafe.Pointer(bp+520 /* &sResult */)).z, zAns, (uint32((len-jj)-1))) != 0) {
				errorMessage(tls, ts+1250, /* "line %d of %s:\nE..." */
					libc.VaList(bp+72, prevLine, zFilename, ((len-jj)-1), zAns, (*String)(unsafe.Pointer(bp+520 /* &sResult */)).z))
			}
			g.nTest++
			stringReset(tls, bp+520 /* &sResult */)
		} else

		//  --glob ANSWER...
		//  --notglob ANSWER....
		//
		// Check to see if output does or does not match the glob pattern
		// ANSWER.
		if (libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1295 /* "glob" */) == 0) || (libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1300 /* "notglob" */) == 0) {
			var jj int32
			var zAns uintptr = (zScript + uintptr(ii))
			var zCopy uintptr
			var isGlob int32 = (libc.Bool32(int32(*(*int8)(unsafe.Pointer(bp + 536 /* &zCmd[0] */ + uintptr(0)))) == 'g'))
			for jj = (9 - (3 * isGlob)); (jj < (len - 1)) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zAns + uintptr(jj)))))) != 0); jj++ {
			}
			zAns += uintptr(jj)
			zCopy = sqlite3.Xsqlite3_mprintf(tls, ts+1206 /* "%.*s" */, libc.VaList(bp+120, ((len-jj)-1), zAns))
			if ((libc.Bool32(sqlite3.Xsqlite3_strglob(tls, zCopy, (*String)(unsafe.Pointer(bp+520 /* &sResult */)).z) == 0)) ^ isGlob) != 0 {
				errorMessage(tls, ts+1308, /* "line %d of %s:\nE..." */
					libc.VaList(bp+144, prevLine, zFilename, zCopy, (*String)(unsafe.Pointer(bp+520 /* &sResult */)).z))
			}
			sqlite3.Xsqlite3_free(tls, zCopy)
			g.nTest++
			stringReset(tls, bp+520 /* &sResult */)
		} else

		//  --output
		//
		// Output the result of the previous SQL.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1351 /* "output" */) == 0 {
			logMessage(tls, ts+438 /* "%s" */, libc.VaList(bp+184, (*String)(unsafe.Pointer(bp+520 /* &sResult */)).z))
		} else

		//  --source FILENAME
		//
		// Run a subscript from a separate file.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1358 /* "source" */) == 0 {
			var zNewFile uintptr
			var zNewScript uintptr
			var zToDel uintptr = uintptr(0)
			zNewFile = (bp + 566 /* &azArg[0] */ + uintptr(0)*100)
			if !(((int32(*(*int8)(unsafe.Pointer(zNewFile + uintptr(0))))) == '/') || ((int32(*(*int8)(unsafe.Pointer(zNewFile + uintptr(0))))) == '\\')) {
				var k int32
				for k = (int32(libc.Xstrlen(tls, zFilename)) - 1); (k >= 0) && !(((int32(*(*int8)(unsafe.Pointer(zFilename + uintptr(k))))) == '/') || ((int32(*(*int8)(unsafe.Pointer(zFilename + uintptr(k))))) == '\\')); k-- {
				}
				if k > 0 {
					zNewFile = libc.AssignUintptr(&zToDel, sqlite3.Xsqlite3_mprintf(tls, ts+1365 /* "%.*s/%s" */, libc.VaList(bp+200, k, zFilename, zNewFile)))
				}
			}
			zNewScript = readFile(tls, zNewFile)
			if g.iTrace != 0 {
				logMessage(tls, ts+1373 /* "begin script [%s..." */, libc.VaList(bp+232, zNewFile))
			}
			runScript(tls, 0, 0, zNewScript, zNewFile)
			sqlite3.Xsqlite3_free(tls, zNewScript)
			if g.iTrace != 0 {
				logMessage(tls, ts+1392 /* "end script [%s]\n" */, libc.VaList(bp+248, zNewFile))
			}
			sqlite3.Xsqlite3_free(tls, zToDel)
		} else

		//  --print MESSAGE....
		//
		// Output the remainder of the line to the log file
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1409 /* "print" */) == 0 {
			var jj int32
			for jj = 7; (jj < len) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zScript + uintptr((ii + jj))))))) != 0); jj++ {
			}
			logMessage(tls, ts+1206 /* "%.*s" */, libc.VaList(bp+264, (len-jj), ((zScript+uintptr(ii))+uintptr(jj))))
		} else

		//  --if EXPR
		//
		// Skip forward to the next matching --endif or --else if EXPR is false.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1415 /* "if" */) == 0 {
			var jj int32
			var rc int32
			var pStmt uintptr
			for jj = 4; (jj < len) && (libc.Xisspace(tls, int32(uint8(*(*int8)(unsafe.Pointer(zScript + uintptr((ii + jj))))))) != 0); jj++ {
			}
			pStmt = prepareSql(tls, ts+1418 /* "SELECT %.*s" */, libc.VaList(bp+288, (len-jj), ((zScript+uintptr(ii))+uintptr(jj))))
			rc = sqlite3.Xsqlite3_step(tls, pStmt)
			if (rc != 100) || (sqlite3.Xsqlite3_column_int(tls, pStmt, 0) == 0) {
				ii = ii + (findEndif(tls, ((zScript + uintptr(ii)) + uintptr(len)), 1, bp+532 /* &lineno */))
			}
			sqlite3.Xsqlite3_finalize(tls, pStmt)
		} else

		//  --else
		//
		// This command can only be encountered if currently inside an --if that
		// is true.  Skip forward to the next matching --endif.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1430 /* "else" */) == 0 {
			ii = ii + (findEndif(tls, ((zScript + uintptr(ii)) + uintptr(len)), 0, bp+532 /* &lineno */))
		} else

		//  --endif
		//
		// This command can only be encountered if currently inside an --if that
		// is true or an --else of a false if.  This is a no-op.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1435 /* "endif" */) == 0 {
			// no-op
		} else

		//  --start CLIENT
		//
		// Start up the given client.
		if (libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1441 /* "start" */) == 0) && (iClient == 0) {
			var iNewClient int32 = libc.Xatoi(tls, (bp + 566 /* &azArg[0] */ + uintptr(0)*100))
			if iNewClient > 0 {
				startClient(tls, iNewClient)
			}
		} else

		//  --wait CLIENT TIMEOUT
		//
		// Wait until all tasks complete for the given client.  If CLIENT is
		// "all" then wait for all clients to complete.  Wait no longer than
		// TIMEOUT milliseconds (default 10,000)
		if (libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1447 /* "wait" */) == 0) && (iClient == 0) {
			var iTimeout int32
			if nArg >= 2 {
				iTimeout = libc.Xatoi(tls, (bp + 566 /* &azArg[0] */ + uintptr(1)*100))
			} else {
				iTimeout = 10000
			}
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+766 /* &zError[0] */, ts+1452, /* "line %d of %s\n" */
				libc.VaList(bp+312, prevLine, zFilename))
			waitForClient(tls, libc.Xatoi(tls, (bp+566 /* &azArg[0] */ +uintptr(0)*100)), iTimeout, bp+766 /* &zError[0] */)
		} else

		//  --task CLIENT
		//     <task-content-here>
		//  --end
		//
		// Assign work to a client.  Start the client if it is not running
		// already.
		if (libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1467 /* "task" */) == 0) && (iClient == 0) {
			var iTarget int32 = libc.Xatoi(tls, (bp + 566 /* &azArg[0] */ + uintptr(0)*100))
			var iEnd int32
			var zTask uintptr
			var zTName uintptr
			iEnd = findEnd(tls, ((zScript + uintptr(ii)) + uintptr(len)), bp+532 /* &lineno */)
			if iTarget < 0 {
				errorMessage(tls, ts+1472, /* "line %d of %s: b..." */
					libc.VaList(bp+336, prevLine, zFilename, iTarget))
			} else {
				zTask = sqlite3.Xsqlite3_mprintf(tls, ts+1206 /* "%.*s" */, libc.VaList(bp+368, iEnd, ((zScript+uintptr(ii))+uintptr(len))))
				if nArg > 1 {
					zTName = sqlite3.Xsqlite3_mprintf(tls, ts+438 /* "%s" */, libc.VaList(bp+392, (bp+566 /* &azArg[0] */ +uintptr(1)*100)))
				} else {
					zTName = sqlite3.Xsqlite3_mprintf(tls, ts+1509 /* "%s:%d" */, libc.VaList(bp+408, filenameTail(tls, zFilename), prevLine))
				}
				startClient(tls, iTarget)
				runSql(tls,
					ts+1515 /* "INSERT INTO task..." */, libc.VaList(bp+432, iTarget, zTask, zTName))
				sqlite3.Xsqlite3_free(tls, zTask)
				sqlite3.Xsqlite3_free(tls, zTName)
			}
			iEnd = iEnd + (tokenLength(tls, (((zScript + uintptr(ii)) + uintptr(len)) + uintptr(iEnd)), bp+532 /* &lineno */))
			len = len + (iEnd)
			iBegin = (ii + len)
		} else

		//  --breakpoint
		//
		// This command calls "test_breakpoint()" which is a routine provided
		// as a convenient place to set a debugger breakpoint.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1571 /* "breakpoint" */) == 0 {
			test_breakpoint(tls)
		} else

		//  --show-sql-errors BOOLEAN
		//
		// Turn display of SQL errors on and off.
		if libc.Xstrcmp(tls, bp+536 /* &zCmd[0] */, ts+1582 /* "show-sql-errors" */) == 0 {
			g.bIgnoreSqlErrors = func() int32 {
				if nArg >= 1 {
					return libc.BoolInt32(!(booleanValue(tls, (bp+566 /* &azArg[0] */ +uintptr(0)*100)) != 0))
				}
				return 1
			}()
		} else {
			errorMessage(tls, ts+1598, /* "line %d of %s: u..." */
				libc.VaList(bp+464, prevLine, zFilename, bp+536 /* &zCmd[0] */))
		}
		ii = ii + (len)
	}
	if iBegin < ii {
		var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+1206 /* "%.*s" */, libc.VaList(bp+496, (ii-iBegin), (zScript+uintptr(iBegin))))
		runSql(tls, zSql, 0)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	stringFree(tls, bp+520 /* &sResult */)
}

// Look for a command-line option.  If present, return a pointer.
// Return NULL if missing.
//
// hasArg==0 means the option is a flag.  It is either present or not.
// hasArg==1 means the option has an argument.  Return a pointer to the
// argument.
func findOption(tls *libc.TLS, azArg uintptr, pnArg uintptr, zOption uintptr, hasArg int32) uintptr { /* mptest.c:1201:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	var j int32
	var zReturn uintptr = uintptr(0)
	var nArg int32 = *(*int32)(unsafe.Pointer(pnArg))

	for i = 0; i < nArg; i++ {
		var z uintptr
		if (i + hasArg) >= nArg {
			break
		}
		z = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) != '-' {
			continue
		}
		z++
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(0)))) == '-' {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(1)))) == 0 {
				break
			}
			z++
		}
		if libc.Xstrcmp(tls, z, zOption) == 0 {
			if (hasArg != 0) && (i == (nArg - 1)) {
				fatalError(tls, ts+1634 /* "command-line opt..." */, libc.VaList(bp, z))
			}
			if hasArg != 0 {
				zReturn = *(*uintptr)(unsafe.Pointer(azArg + uintptr((i+1))*4))
			} else {
				zReturn = *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))
			}
			j = ((i + 1) + (libc.Bool32(hasArg != 0)))
			for j < nArg {
				*(*uintptr)(unsafe.Pointer(azArg + uintptr(libc.PostIncInt32(&i, 1))*4)) = *(*uintptr)(unsafe.Pointer(azArg + uintptr(libc.PostIncInt32(&j, 1))*4))
			}
			*(*int32)(unsafe.Pointer(pnArg)) = i
			return zReturn
		}
	}
	return zReturn
}

// Print a usage message for the program and exit
func usage(tls *libc.TLS, argv0 uintptr) { /* mptest.c:1241:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	var zTail uintptr = argv0
	for i = 0; *(*int8)(unsafe.Pointer(argv0 + uintptr(i))) != 0; i++ {
		if ((int32(*(*int8)(unsafe.Pointer(argv0 + uintptr(i))))) == '/') || ((int32(*(*int8)(unsafe.Pointer(argv0 + uintptr(i))))) == '\\') {
			zTail = ((argv0 + uintptr(i)) + uintptr(1))
		}
	}
	libc.Xfprintf(tls, libc.X__acrt_iob_func(tls, uint32(2)), ts+1682 /* "Usage: %s DATABA..." */, libc.VaList(bp, zTail))
	libc.Xfprintf(tls, libc.X__acrt_iob_func(tls, uint32(2)),

		ts+1721 /* "Options:\n   --er..." */, 0)
	libc.Xexit(tls, 1)
}

// Report on unrecognized arguments
func unrecognizedArguments(tls *libc.TLS, argv0 uintptr, nArg int32, azArg uintptr) { /* mptest.c:1265:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var i int32
	libc.Xfprintf(tls, libc.X__acrt_iob_func(tls, uint32(2)), ts+2293 /* "%s: unrecognized..." */, libc.VaList(bp, argv0))
	for i = 0; i < nArg; i++ {
		libc.Xfprintf(tls, libc.X__acrt_iob_func(tls, uint32(2)), ts+2321 /* " %s" */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*4))))
	}
	libc.Xfprintf(tls, libc.X__acrt_iob_func(tls, uint32(2)), ts+2325 /* "\n" */, 0)
	libc.Xexit(tls, 1)
}

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 { /* mptest.c:1279:18: */
	bp := tls.Alloc(416)
	defer tls.Free(416)

	var zClient uintptr
	var iClient int32
	// var n int32 at bp+400, 4

	var i int32
	var openFlags int32 = 0x00000002
	var rc int32
	// var zScript uintptr at bp+404, 4

	// var taskId int32 at bp+408, 4

	var zTrace uintptr
	var zCOption uintptr
	var zJMode uintptr
	var zNRep uintptr
	var nRep int32 = 1
	var iRep int32
	var iTmout int32 = 0 // Default: no timeout
	var zTmout uintptr

	g.argv0 = *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4))
	g.iTrace = 1
	if argc < 2 {
		usage(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4)))
	}
	g.zDbFile = *(*uintptr)(unsafe.Pointer(argv + uintptr(1)*4))
	if strglob(tls, ts+2327 /* "*.test" */, g.zDbFile) != 0 {
		usage(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4)))
	}
	if libc.Xstrcmp(tls, sqlite3.Xsqlite3_sourceid(tls), ts+2334 /* "2020-08-14 13:23..." */) != 0 {
		libc.Xfprintf(tls, libc.X__acrt_iob_func(tls, uint32(2)),

			ts+2419, /* "SQLite library a..." */
			libc.VaList(bp, sqlite3.Xsqlite3_sourceid(tls), ts+2334 /* "2020-08-14 13:23..." */))
		libc.Xexit(tls, 1)
	}
	*(*int32)(unsafe.Pointer(bp + 400 /* n */)) = (argc - 2)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), uintptr(unsafe.Pointer(&g))+32 /* &.zName */, ts+2479 /* "%05d.mptest" */, libc.VaList(bp+24, int32(libc.XGetCurrentProcessId(tls))))
	zJMode = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2491 /* "journalmode" */, 1)
	zNRep = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2503 /* "repeat" */, 1)
	if zNRep != 0 {
		nRep = libc.Xatoi(tls, zNRep)
	}
	if nRep < 1 {
		nRep = 1
	}
	g.zVfs = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2510 /* "vfs" */, 1)
	zClient = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2514 /* "client" */, 1)
	g.zErrLog = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2521 /* "errlog" */, 1)
	g.zLog = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2528 /* "log" */, 1)
	zTrace = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2532 /* "trace" */, 1)
	if zTrace != 0 {
		g.iTrace = libc.Xatoi(tls, zTrace)
	}
	if findOption(tls, (argv+uintptr(2)*4), bp+400 /* &n */, ts+2538 /* "quiet" */, 0) != uintptr(0) {
		g.iTrace = 0
	}
	zTmout = findOption(tls, (argv + uintptr(2)*4), bp+400 /* &n */, ts+2544 /* "timeout" */, 1)
	if zTmout != 0 {
		iTmout = libc.Xatoi(tls, zTmout)
	}
	g.bSqlTrace = (libc.Bool32(findOption(tls, (argv+uintptr(2)*4), bp+400 /* &n */, ts+2552 /* "sqltrace" */, 0) != uintptr(0)))
	g.bSync = (libc.Bool32(findOption(tls, (argv+uintptr(2)*4), bp+400 /* &n */, ts+2561 /* "sync" */, 0) != uintptr(0)))
	if g.zErrLog != 0 {
		g.pErrLog = libc.Xfopen(tls, g.zErrLog, ts+2566 /* "a" */)
	} else {
		g.pErrLog = libc.X__acrt_iob_func(tls, uint32(2))
	}
	if g.zLog != 0 {
		g.pLog = libc.Xfopen(tls, g.zLog, ts+2566 /* "a" */)
	} else {
		g.pLog = libc.X__acrt_iob_func(tls, uint32(1))
	}

	sqlite3.Xsqlite3_config(tls, 16, libc.VaList(bp+40, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{sqlErrorCallback})), 0))
	if zClient != 0 {
		iClient = libc.Xatoi(tls, zClient)
		if iClient < 1 {
			fatalError(tls, ts+2568 /* "illegal client n..." */, libc.VaList(bp+64, iClient))
		}
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), uintptr(unsafe.Pointer(&g))+32 /* &.zName */, ts+2595, /* "%05d.client%02d" */
			libc.VaList(bp+80, int32(libc.XGetCurrentProcessId(tls)), iClient))
	} else {
		var nTry int32 = 0
		if g.iTrace > 0 {
			libc.Xprintf(tls, ts+2611 /* "BEGIN: %s" */, libc.VaList(bp+104, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4))))
			for i = 1; i < argc; i++ {
				libc.Xprintf(tls, ts+2321 /* " %s" */, libc.VaList(bp+120, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
			}
			libc.Xprintf(tls, ts+2325 /* "\n" */, 0)
			libc.Xprintf(tls, ts+2621 /* "With SQLite 3.33..." */, 0)
			for i = 0; (libc.AssignUintptr(&zCOption, sqlite3.Xsqlite3_compileoption_get(tls, i))) != uintptr(0); i++ {
				libc.Xprintf(tls, ts+2726 /* "-DSQLITE_%s\n" */, libc.VaList(bp+136, zCOption))
			}
			libc.Xfflush(tls, libc.X__acrt_iob_func(tls, uint32(1)))
		}
		iClient = 0
		for ok := true; ok; ok = (((rc != 0) && ((libc.PreIncInt32(&nTry, 1)) < 60)) && (sqlite3.Xsqlite3_sleep(tls, 1000) > 0)) {
			if (nTry % 5) == 4 {
				libc.Xprintf(tls, ts+2739, /* "... %strying to ..." */
					libc.VaList(bp+152, func() uintptr {
						if nTry > 5 {
							return ts + 2768 /* "still " */
						}
						return ts + 1103 /* "" */
					}(), g.zDbFile))
			}
			rc = libc.Xunlink(tls, g.zDbFile)
			if (rc != 0) && ((*(*int32)(unsafe.Pointer(libc.X_errno(tls)))) == 2) {
				rc = 0
			}
		}
		if rc != 0 {
			fatalError(tls, ts+2775, /* "unable to unlink..." */
				libc.VaList(bp+176, g.zDbFile, nTry))
		}
		openFlags = openFlags | (0x00000004)
	}
	rc = sqlite3.Xsqlite3_open_v2(tls, g.zDbFile, (uintptr(unsafe.Pointer(&g)) + 12 /* &.db */), openFlags, g.zVfs)
	if rc != 0 {
		fatalError(tls, ts+2816 /* "cannot open [%s]" */, libc.VaList(bp+200, g.zDbFile))
	}
	if iTmout > 0 {
		sqlite3.Xsqlite3_busy_timeout(tls, g.db, iTmout)
	}

	if zJMode != 0 {
		if (sqlite3.Xsqlite3_stricmp(tls, zJMode, ts+2833 /* "persist" */) == 0) ||
			(sqlite3.Xsqlite3_stricmp(tls, zJMode, ts+2841 /* "truncate" */) == 0) {
			libc.Xprintf(tls, ts+2850 /* "Changing journal..." */, libc.VaList(bp+216, zJMode))
			zJMode = ts + 2890 /* "DELETE" */
		}
		runSql(tls, ts+2897 /* "PRAGMA journal_m..." */, libc.VaList(bp+232, zJMode))
	}
	if !(g.bSync != 0) {
		trySql(tls, ts+2921 /* "PRAGMA synchrono..." */, 0)
	}
	sqlite3.Xsqlite3_enable_load_extension(tls, g.db, 1)
	sqlite3.Xsqlite3_busy_handler(tls, g.db, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{busyHandler})), uintptr(0))
	sqlite3.Xsqlite3_create_function(tls, g.db, ts+2944 /* "vfsname" */, 0, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{vfsNameFunc})), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_create_function(tls, g.db, ts+2952 /* "eval" */, 1, 1, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{evalFunc})), uintptr(0), uintptr(0))
	g.iTimeout = 10000
	if g.bSqlTrace != 0 {
		sqlite3.Xsqlite3_trace(tls, g.db, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{sqlTraceCallback})), uintptr(0))
	}
	if iClient > 0 {
		if *(*int32)(unsafe.Pointer(bp + 400 /* n */)) > 0 {
			unrecognizedArguments(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4)), *(*int32)(unsafe.Pointer(bp + 400 /* n */)), (argv + uintptr(2)*4))
		}
		if g.iTrace != 0 {
			logMessage(tls, ts+2957 /* "start-client" */, 0)
		}
		for 1 != 0 {
			*(*uintptr)(unsafe.Pointer(bp + 412 /* zTaskName */)) = uintptr(0)
			rc = startScript(tls, iClient, bp+404 /* &zScript */, bp+408 /* &taskId */, bp+412 /* &zTaskName */)
			if rc == 101 {
				break
			}
			if g.iTrace != 0 {
				logMessage(tls, ts+2970 /* "begin %s (%d)" */, libc.VaList(bp+248, *(*uintptr)(unsafe.Pointer(bp + 412 /* zTaskName */)), *(*int32)(unsafe.Pointer(bp + 408 /* taskId */))))
			}
			runScript(tls, iClient, *(*int32)(unsafe.Pointer(bp + 408 /* taskId */)), *(*uintptr)(unsafe.Pointer(bp + 404 /* zScript */)), *(*uintptr)(unsafe.Pointer(bp + 412 /* zTaskName */)))
			if g.iTrace != 0 {
				logMessage(tls, ts+2984 /* "end %s (%d)" */, libc.VaList(bp+272, *(*uintptr)(unsafe.Pointer(bp + 412 /* zTaskName */)), *(*int32)(unsafe.Pointer(bp + 408 /* taskId */))))
			}
			finishScript(tls, iClient, *(*int32)(unsafe.Pointer(bp + 408 /* taskId */)), 0)
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 412 /* zTaskName */)))
			sqlite3.Xsqlite3_sleep(tls, 10)
		}
		if g.iTrace != 0 {
			logMessage(tls, ts+2996 /* "end-client" */, 0)
		}
	} else {
		var pStmt uintptr
		var iTimeout int32
		if *(*int32)(unsafe.Pointer(bp + 400 /* n */)) == 0 {
			fatalError(tls, ts+3007 /* "missing script f..." */, 0)
		}
		if *(*int32)(unsafe.Pointer(bp + 400 /* n */)) > 1 {
			unrecognizedArguments(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4)), *(*int32)(unsafe.Pointer(bp + 400 /* n */)), (argv + uintptr(2)*4))
		}
		runSql(tls,

			ts+3031 /* "DROP TABLE IF EX..." */, 0)
		*(*uintptr)(unsafe.Pointer(bp + 404 /* zScript */)) = readFile(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*4)))
		for iRep = 1; iRep <= nRep; iRep++ {
			if g.iTrace != 0 {
				logMessage(tls, ts+3467 /* "begin script [%s..." */, libc.VaList(bp+296, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*4)), iRep))
			}
			runScript(tls, 0, 0, *(*uintptr)(unsafe.Pointer(bp + 404 /* zScript */)), *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*4)))
			if g.iTrace != 0 {
				logMessage(tls, ts+3495 /* "end script [%s] ..." */, libc.VaList(bp+320, *(*uintptr)(unsafe.Pointer(argv + uintptr(2)*4)), iRep))
			}
		}
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 404 /* zScript */)))
		waitForClient(tls, 0, 2000, ts+3521 /* "during shutdown...." */)
		trySql(tls, ts+3541 /* "UPDATE client SE..." */, 0)
		sqlite3.Xsqlite3_sleep(tls, 10)
		g.iTimeout = 0
		iTimeout = 1000
		for (((libc.AssignInt32(&rc, trySql(tls, ts+3570 /* "SELECT 1 FROM cl..." */, 0))) == 5) ||
			(rc == 100)) && (iTimeout > 0) {
			sqlite3.Xsqlite3_sleep(tls, 10)
			iTimeout = iTimeout - (10)
		}
		sqlite3.Xsqlite3_sleep(tls, 100)
		pStmt = prepareSql(tls, ts+3591 /* "SELECT nError, n..." */, 0)
		iTimeout = 1000
		for ((libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt))) == 5) && (iTimeout > 0) {
			sqlite3.Xsqlite3_sleep(tls, 10)
			iTimeout = iTimeout - (10)
		}
		if rc == 100 {
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 80 /* &.nError */)) += (sqlite3.Xsqlite3_column_int(tls, pStmt, 0))
			*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g)) + 84 /* &.nTest */)) += (sqlite3.Xsqlite3_column_int(tls, pStmt, 1))
		}
		sqlite3.Xsqlite3_finalize(tls, pStmt)
	}
	sqlite3.Xsqlite3_close(tls, g.db)
	maybeClose(tls, g.pLog)
	maybeClose(tls, g.pErrLog)
	if iClient == 0 {
		libc.Xprintf(tls, ts+3626 /* "Summary: %d erro..." */, libc.VaList(bp+344, g.nError, g.nTest))
		libc.Xprintf(tls, ts+3662 /* "END: %s" */, libc.VaList(bp+368, *(*uintptr)(unsafe.Pointer(argv + uintptr(0)*4))))
		for i = 1; i < argc; i++ {
			libc.Xprintf(tls, ts+2321 /* " %s" */, libc.VaList(bp+384, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*4))))
		}
		libc.Xprintf(tls, ts+2325 /* "\n" */, 0)
	}
	return (libc.Bool32(g.nError > 0))
}

var ts1 = "%s%.*s\n\x00%s:ERROR: \x00%s:FATAL: \x00UPDATE client SET wantHalt=1;\x00%s: \x00main\x00timeout after %dms\x00[%.*s]\x00(info) %s\x00(errcode=%d) %s\x00%s\n%s\n\x00out of memory\x00 \x00nil\x00'\x00error(%d)\x00BEGIN IMMEDIATE\x00in startScript: %s\x00UPDATE counters SET nError=nError+%d, nTest=nTest+%d\x00SELECT 1 FROM client WHERE id=%d AND wantHalt\x00DELETE FROM client WHERE id=%d\x00COMMIT TRANSACTION;\x00SELECT script, id, name FROM task WHERE client=%d AND starttime IS NULL ORDER BY id LIMIT 1\x00%s\x00UPDATE task   SET starttime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00Waited over 30 seconds with no work.  Giving up.\x00DELETE FROM client WHERE id=%d; COMMIT;\x00COMMIT\x00UPDATE task   SET endtime=strftime('%%Y-%%m-%%d %%H:%%M:%%f','now') WHERE id=%d;\x00INSERT OR IGNORE INTO client VALUES(%d,0)\x00%s \"%s\" --client %d --trace %d\x00%z --sqltrace\x00%z --sync\x00%z --vfs \"%s\"\x00system('%q')\x00CreateProcessA() fails with error code %lu\x00rb\x00cannot open \"%s\" for reading\x00--end\x00--endif\x00--else\x00--if\x00SELECT 1 FROM task WHERE client=%d   AND client IN (SELECT id FROM client)  AND endtime IS NULL\x00SELECT 1 FROM task WHERE client IN (SELECT id FROM client)   AND endtime IS NULL\x00\x00%stimeout waiting for client %d\x00%stimeout waiting for all clients\x00on\x00yes\x00off\x00no\x00unknown boolean: [%s]\x00%.*s\x00sleep\x00exit\x00testcase\x00finish\x00reset\x00match\x00line %d of %s:\nExpected [%.*s]\n     Got [%s]\x00glob\x00notglob\x00line %d of %s:\nExpected [%s]\n     Got [%s]\x00output\x00source\x00%.*s/%s\x00begin script [%s]\n\x00end script [%s]\n\x00print\x00if\x00SELECT %.*s\x00else\x00endif\x00start\x00wait\x00line %d of %s\n\x00task\x00line %d of %s: bad client number: %d\x00%s:%d\x00INSERT INTO task(client,script,name) VALUES(%d,'%q',%Q)\x00breakpoint\x00show-sql-errors\x00line %d of %s: unknown command --%s\x00command-line option \"--%s\" requires an argument\x00Usage: %s DATABASE ?OPTIONS? ?SCRIPT?\n\x00Options:\n   --errlog FILENAME           Write errors to FILENAME\n   --journalmode MODE          Use MODE as the journal_mode\n   --log FILENAME              Log messages to FILENAME\n   --quiet                     Suppress unnecessary output\n   --vfs NAME                  Use NAME as the VFS\n   --repeat N                  Repeat the test N times\n   --sqltrace                  Enable SQL tracing\n   --sync                      Enable synchronous disk writes\n   --timeout MILLISEC          Busy timeout is MILLISEC\n   --trace BOOLEAN             Enable or disable tracing\n\x00%s: unrecognized arguments:\x00 %s\x00\n\x00*.test\x002020-08-14 13:23:32 fca8dc8b578f215a969cd899336378966156154710873e68b3d9ac5881b0ff3f\x00SQLite library and header mismatch\nLibrary: %s\nHeader:  %s\n\x00%05d.mptest\x00journalmode\x00repeat\x00vfs\x00client\x00errlog\x00log\x00trace\x00quiet\x00timeout\x00sqltrace\x00sync\x00a\x00illegal client number: %d\n\x00%05d.client%02d\x00BEGIN: %s\x00With SQLite 3.33.0 2020-08-14 13:23:32 fca8dc8b578f215a969cd899336378966156154710873e68b3d9ac5881b0ff3f\n\x00-DSQLITE_%s\n\x00... %strying to unlink '%s'\n\x00still \x00unable to unlink '%s' after %d attempts\n\x00cannot open [%s]\x00persist\x00truncate\x00Changing journal mode to DELETE from %s\x00DELETE\x00PRAGMA journal_mode=%Q;\x00PRAGMA synchronous=OFF\x00vfsname\x00eval\x00start-client\x00begin %s (%d)\x00end %s (%d)\x00end-client\x00missing script filename\x00DROP TABLE IF EXISTS task;\nDROP TABLE IF EXISTS counters;\nDROP TABLE IF EXISTS client;\nCREATE TABLE task(\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  client INTEGER,\n  starttime DATE,\n  endtime DATE,\n  script TEXT\n);CREATE INDEX task_i1 ON task(client, starttime);\nCREATE INDEX task_i2 ON task(client, endtime);\nCREATE TABLE counters(nError,nTest);\nINSERT INTO counters VALUES(0,0);\nCREATE TABLE client(id INTEGER PRIMARY KEY, wantHalt);\n\x00begin script [%s] cycle %d\n\x00end script [%s] cycle %d\n\x00during shutdown...\n\x00UPDATE client SET wantHalt=1\x00SELECT 1 FROM client\x00SELECT nError, nTest FROM counters\x00Summary: %d errors out of %d tests\n\x00END: %s\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
