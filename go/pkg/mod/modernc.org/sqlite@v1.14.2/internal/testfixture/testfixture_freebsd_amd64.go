// Code generated by 'ccgo -DSQLITE_OMIT_LOAD_EXTENSION -DSQLITE_SERIES_CONSTRAINT_VERIFY=1 -DSQLITE_SERVER=1 -DTCLSH_INIT_PROC=sqlite3TestInit -D_HAVE_SQLITE_CONFIG_H -I/usr/local/include/tcl8.6 -export-defines "" -export-fields F -trace-translation-units -volatile=sqlite3_io_error_pending,sqlite3_open_file_count,sqlite3_pager_readdb_count,sqlite3_pager_writedb_count,sqlite3_pager_writej_count,sqlite3_search_count,sqlite3_sort_count,saved_cnt -lmodernc.org/sqlite/libtest -lmodernc.org/tcl/lib -lmodernc.org/z/lib -o internal/testfixture/testfixture_freebsd_amd64.go -Itestdata/sqlite-src-3370000/ext/async -Itestdata/sqlite-src-3370000/ext/fts3 -Itestdata/sqlite-src-3370000/ext/icu -Itestdata/sqlite-src-3370000/ext/rtree -Itestdata/sqlite-src-3370000/ext/session -Itestdata/sqlite-src-3370000/ext/userauth -Itestdata/sqlite-src-3370000/src -Itestdata/sqlite-amalgamation-3370000 -Itestdata/sqlite-src-3370000 testdata/sqlite-src-3370000/ext/expert/sqlite3expert.c testdata/sqlite-src-3370000/ext/expert/test_expert.c testdata/sqlite-src-3370000/ext/fts3/fts3_term.c testdata/sqlite-src-3370000/ext/fts3/fts3_test.c testdata/sqlite-src-3370000/ext/fts5/fts5_tcl.c testdata/sqlite-src-3370000/ext/fts5/fts5_test_mi.c testdata/sqlite-src-3370000/ext/fts5/fts5_test_tok.c testdata/sqlite-src-3370000/ext/misc/appendvfs.c testdata/sqlite-src-3370000/ext/misc/amatch.c testdata/sqlite-src-3370000/ext/misc/carray.c testdata/sqlite-src-3370000/ext/misc/cksumvfs.c testdata/sqlite-src-3370000/ext/misc/closure.c testdata/sqlite-src-3370000/ext/misc/csv.c testdata/sqlite-src-3370000/ext/misc/decimal.c testdata/sqlite-src-3370000/ext/misc/eval.c testdata/sqlite-src-3370000/ext/misc/explain.c testdata/sqlite-src-3370000/ext/misc/fileio.c testdata/sqlite-src-3370000/ext/misc/fuzzer.c testdata/sqlite-src-3370000/ext/misc/ieee754.c testdata/sqlite-src-3370000/ext/misc/mmapwarm.c testdata/sqlite-src-3370000/ext/misc/nextchar.c testdata/sqlite-src-3370000/ext/misc/normalize.c testdata/sqlite-src-3370000/ext/misc/percentile.c testdata/sqlite-src-3370000/ext/misc/prefixes.c testdata/sqlite-src-3370000/ext/misc/regexp.c testdata/sqlite-src-3370000/ext/misc/remember.c testdata/sqlite-src-3370000/ext/misc/series.c testdata/sqlite-src-3370000/ext/misc/spellfix.c testdata/sqlite-src-3370000/ext/misc/totype.c testdata/sqlite-src-3370000/ext/misc/unionvtab.c testdata/sqlite-src-3370000/ext/misc/wholenumber.c testdata/sqlite-src-3370000/ext/misc/zipfile.c testdata/sqlite-src-3370000/ext/rbu/test_rbu.c testdata/sqlite-src-3370000/ext/rtree/test_rtreedoc.c testdata/sqlite-src-3370000/ext/session/test_session.c testdata/sqlite-src-3370000/ext/userauth/userauth.c testdata/sqlite-src-3370000/src/tclsqlite.c testdata/sqlite-src-3370000/src/test1.c testdata/sqlite-src-3370000/src/test2.c testdata/sqlite-src-3370000/src/test3.c testdata/sqlite-src-3370000/src/test4.c testdata/sqlite-src-3370000/src/test5.c testdata/sqlite-src-3370000/src/test6.c testdata/sqlite-src-3370000/src/test7.c testdata/sqlite-src-3370000/src/test8.c testdata/sqlite-src-3370000/src/test9.c testdata/sqlite-src-3370000/src/test_async.c testdata/sqlite-src-3370000/src/test_autoext.c testdata/sqlite-src-3370000/src/test_backup.c testdata/sqlite-src-3370000/src/test_bestindex.c testdata/sqlite-src-3370000/src/test_blob.c testdata/sqlite-src-3370000/src/test_btree.c testdata/sqlite-src-3370000/src/test_config.c testdata/sqlite-src-3370000/src/test_delete.c testdata/sqlite-src-3370000/src/test_demovfs.c testdata/sqlite-src-3370000/src/test_devsym.c testdata/sqlite-src-3370000/src/test_fs.c testdata/sqlite-src-3370000/src/test_func.c testdata/sqlite-src-3370000/src/test_hexio.c testdata/sqlite-src-3370000/src/test_init.c testdata/sqlite-src-3370000/src/test_intarray.c testdata/sqlite-src-3370000/src/test_journal.c testdata/sqlite-src-3370000/src/test_malloc.c testdata/sqlite-src-3370000/src/test_md5.c testdata/sqlite-src-3370000/src/test_multiplex.c testdata/sqlite-src-3370000/src/test_mutex.c testdata/sqlite-src-3370000/src/test_onefile.c testdata/sqlite-src-3370000/src/test_osinst.c testdata/sqlite-src-3370000/src/test_pcache.c testdata/sqlite-src-3370000/src/test_quota.c testdata/sqlite-src-3370000/src/test_rtree.c testdata/sqlite-src-3370000/src/test_schema.c testdata/sqlite-src-3370000/src/test_server.c testdata/sqlite-src-3370000/src/test_superlock.c testdata/sqlite-src-3370000/src/test_syscall.c testdata/sqlite-src-3370000/src/test_tclsh.c testdata/sqlite-src-3370000/src/test_tclvar.c testdata/sqlite-src-3370000/src/test_thread.c testdata/sqlite-src-3370000/src/test_vdbecov.c testdata/sqlite-src-3370000/src/test_vfs.c testdata/sqlite-src-3370000/src/test_windirent.c testdata/sqlite-src-3370000/src/test_window.c testdata/sqlite-src-3370000/src/test_wsd.c -DNDEBUG -DHAVE_USLEEP -DLONGDOUBLE_TYPE=double -DSQLITE_CKSUMVFS_STATIC -DSQLITE_CORE -DSQLITE_DEFAULT_MEMSTATUS=0 -DSQLITE_DEFAULT_PAGE_SIZE=1024 -DSQLITE_ENABLE_BYTECODE_VTAB -DSQLITE_ENABLE_COLUMN_METADATA -DSQLITE_ENABLE_DBPAGE_VTAB -DSQLITE_ENABLE_DBSTAT_VTAB -DSQLITE_ENABLE_DESERIALIZE -DSQLITE_ENABLE_EXPLAIN_COMMENTS -DSQLITE_ENABLE_FTS5 -DSQLITE_ENABLE_GEOPOLY -DSQLITE_ENABLE_JSON1 -DSQLITE_ENABLE_MEMORY_MANAGEMENT -DSQLITE_ENABLE_OFFSET_SQL_FUNC -DSQLITE_ENABLE_PREUPDATE_HOOK -DSQLITE_ENABLE_RBU -DSQLITE_ENABLE_RTREE -DSQLITE_ENABLE_SESSION -DSQLITE_ENABLE_SNAPSHOT -DSQLITE_ENABLE_STAT4 -DSQLITE_ENABLE_STMTVTAB -DSQLITE_ENABLE_UNLOCK_NOTIFY -DSQLITE_HAVE_ZLIB=1 -DSQLITE_LIKE_DOESNT_MATCH_BLOBS -DSQLITE_MUTEX_APPDEF=1 -DSQLITE_MUTEX_NOOP -DSQLITE_SOUNDEX -DSQLITE_TEMP_STORE=1 -DSQLITE_TEST -DSQLITE_THREADSAFE=1', DO NOT EDIT.

package main

import (
	"math"
	"reflect"
	"sync/atomic"
	"unsafe"

	"modernc.org/libc"
	"modernc.org/libc/sys/types"
	"modernc.org/sqlite/libtest"
	"modernc.org/tcl/lib"
	"modernc.org/z/lib"
)

var _ = math.Pi
var _ reflect.Kind
var _ atomic.Value
var _ unsafe.Pointer
var _ *libc.TLS
var _ types.Size_t

func main() { libc.Start(main1) }

const (
	BUFSIZ                                = 1024
	EOF                                   = -1
	EXPERT_CONFIG_SAMPLE                  = 1
	EXPERT_REPORT_CANDIDATES              = 4
	EXPERT_REPORT_INDEXES                 = 2
	EXPERT_REPORT_PLAN                    = 3
	EXPERT_REPORT_SQL                     = 1
	FILENAME_MAX                          = 1024
	FOPEN_MAX                             = 20
	FTS5_TOKENIZE_AUX                     = 0x0008
	FTS5_TOKENIZE_DOCUMENT                = 0x0004
	FTS5_TOKENIZE_PREFIX                  = 0x0002
	FTS5_TOKENIZE_QUERY                   = 0x0001
	FTS5_TOKEN_COLOCATED                  = 0x0001
	FULLY_WITHIN                          = 2
	HAVE_USLEEP                           = 1
	IDX_HASH_SIZE                         = 1023
	L_ctermid                             = 1024
	L_cuserid                             = 17
	L_tmpnam                              = 1024
	NDEBUG                                = 1
	NOT_WITHIN                            = 0
	PARTLY_WITHIN                         = 1
	P_tmpdir                              = "/tmp/"
	SEEK_CUR                              = 1
	SEEK_END                              = 2
	SEEK_SET                              = 0
	SQLITE3_H                             = 0
	SQLITE3_TEXT                          = 3
	SQLITEEXPERT_H                        = 1
	SQLITE_ABORT                          = 4
	SQLITE_ABORT_ROLLBACK                 = 516
	SQLITE_ACCESS_EXISTS                  = 0
	SQLITE_ACCESS_READ                    = 2
	SQLITE_ACCESS_READWRITE               = 1
	SQLITE_ALTER_TABLE                    = 26
	SQLITE_ANALYZE                        = 28
	SQLITE_ANY                            = 5
	SQLITE_API                            = 0
	SQLITE_APICALL                        = 0
	SQLITE_ATTACH                         = 24
	SQLITE_AUTH                           = 23
	SQLITE_AUTH_USER                      = 279
	SQLITE_BLOB                           = 4
	SQLITE_BUSY                           = 5
	SQLITE_BUSY_RECOVERY                  = 261
	SQLITE_BUSY_SNAPSHOT                  = 517
	SQLITE_BUSY_TIMEOUT                   = 773
	SQLITE_CALLBACK                       = 0
	SQLITE_CANTOPEN                       = 14
	SQLITE_CANTOPEN_CONVPATH              = 1038
	SQLITE_CANTOPEN_DIRTYWAL              = 1294
	SQLITE_CANTOPEN_FULLPATH              = 782
	SQLITE_CANTOPEN_ISDIR                 = 526
	SQLITE_CANTOPEN_NOTEMPDIR             = 270
	SQLITE_CANTOPEN_SYMLINK               = 1550
	SQLITE_CDECL                          = 0
	SQLITE_CHANGESETAPPLY_INVERT          = 0x0002
	SQLITE_CHANGESETAPPLY_NOSAVEPOINT     = 0x0001
	SQLITE_CHANGESETSTART_INVERT          = 0x0002
	SQLITE_CHANGESET_ABORT                = 2
	SQLITE_CHANGESET_CONFLICT             = 3
	SQLITE_CHANGESET_CONSTRAINT           = 4
	SQLITE_CHANGESET_DATA                 = 1
	SQLITE_CHANGESET_FOREIGN_KEY          = 5
	SQLITE_CHANGESET_NOTFOUND             = 2
	SQLITE_CHANGESET_OMIT                 = 0
	SQLITE_CHANGESET_REPLACE              = 1
	SQLITE_CHECKPOINT_FULL                = 1
	SQLITE_CHECKPOINT_PASSIVE             = 0
	SQLITE_CHECKPOINT_RESTART             = 2
	SQLITE_CHECKPOINT_TRUNCATE            = 3
	SQLITE_CKSUMVFS_STATIC                = 1
	SQLITE_CONFIG_COVERING_INDEX_SCAN     = 20
	SQLITE_CONFIG_GETMALLOC               = 5
	SQLITE_CONFIG_GETMUTEX                = 11
	SQLITE_CONFIG_GETPCACHE               = 15
	SQLITE_CONFIG_GETPCACHE2              = 19
	SQLITE_CONFIG_HEAP                    = 8
	SQLITE_CONFIG_LOG                     = 16
	SQLITE_CONFIG_LOOKASIDE               = 13
	SQLITE_CONFIG_MALLOC                  = 4
	SQLITE_CONFIG_MEMDB_MAXSIZE           = 29
	SQLITE_CONFIG_MEMSTATUS               = 9
	SQLITE_CONFIG_MMAP_SIZE               = 22
	SQLITE_CONFIG_MULTITHREAD             = 2
	SQLITE_CONFIG_MUTEX                   = 10
	SQLITE_CONFIG_PAGECACHE               = 7
	SQLITE_CONFIG_PCACHE                  = 14
	SQLITE_CONFIG_PCACHE2                 = 18
	SQLITE_CONFIG_PCACHE_HDRSZ            = 24
	SQLITE_CONFIG_PMASZ                   = 25
	SQLITE_CONFIG_SCRATCH                 = 6
	SQLITE_CONFIG_SERIALIZED              = 3
	SQLITE_CONFIG_SINGLETHREAD            = 1
	SQLITE_CONFIG_SMALL_MALLOC            = 27
	SQLITE_CONFIG_SORTERREF_SIZE          = 28
	SQLITE_CONFIG_SQLLOG                  = 21
	SQLITE_CONFIG_STMTJRNL_SPILL          = 26
	SQLITE_CONFIG_URI                     = 17
	SQLITE_CONFIG_WIN32_HEAPSIZE          = 23
	SQLITE_CONSTRAINT                     = 19
	SQLITE_CONSTRAINT_CHECK               = 275
	SQLITE_CONSTRAINT_COMMITHOOK          = 531
	SQLITE_CONSTRAINT_DATATYPE            = 3091
	SQLITE_CONSTRAINT_FOREIGNKEY          = 787
	SQLITE_CONSTRAINT_FUNCTION            = 1043
	SQLITE_CONSTRAINT_NOTNULL             = 1299
	SQLITE_CONSTRAINT_PINNED              = 2835
	SQLITE_CONSTRAINT_PRIMARYKEY          = 1555
	SQLITE_CONSTRAINT_ROWID               = 2579
	SQLITE_CONSTRAINT_TRIGGER             = 1811
	SQLITE_CONSTRAINT_UNIQUE              = 2067
	SQLITE_CONSTRAINT_VTAB                = 2323
	SQLITE_COPY                           = 0
	SQLITE_CORE                           = 1
	SQLITE_CORRUPT                        = 11
	SQLITE_CORRUPT_INDEX                  = 779
	SQLITE_CORRUPT_SEQUENCE               = 523
	SQLITE_CORRUPT_VTAB                   = 267
	SQLITE_CREATE_INDEX                   = 1
	SQLITE_CREATE_TABLE                   = 2
	SQLITE_CREATE_TEMP_INDEX              = 3
	SQLITE_CREATE_TEMP_TABLE              = 4
	SQLITE_CREATE_TEMP_TRIGGER            = 5
	SQLITE_CREATE_TEMP_VIEW               = 6
	SQLITE_CREATE_TRIGGER                 = 7
	SQLITE_CREATE_VIEW                    = 8
	SQLITE_CREATE_VTABLE                  = 29
	SQLITE_DBCONFIG_DEFENSIVE             = 1010
	SQLITE_DBCONFIG_DQS_DDL               = 1014
	SQLITE_DBCONFIG_DQS_DML               = 1013
	SQLITE_DBCONFIG_ENABLE_FKEY           = 1002
	SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER = 1004
	SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION = 1005
	SQLITE_DBCONFIG_ENABLE_QPSG           = 1007
	SQLITE_DBCONFIG_ENABLE_TRIGGER        = 1003
	SQLITE_DBCONFIG_ENABLE_VIEW           = 1015
	SQLITE_DBCONFIG_LEGACY_ALTER_TABLE    = 1012
	SQLITE_DBCONFIG_LEGACY_FILE_FORMAT    = 1016
	SQLITE_DBCONFIG_LOOKASIDE             = 1001
	SQLITE_DBCONFIG_MAINDBNAME            = 1000
	SQLITE_DBCONFIG_MAX                   = 1017
	SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      = 1006
	SQLITE_DBCONFIG_RESET_DATABASE        = 1009
	SQLITE_DBCONFIG_TRIGGER_EQP           = 1008
	SQLITE_DBCONFIG_TRUSTED_SCHEMA        = 1017
	SQLITE_DBCONFIG_WRITABLE_SCHEMA       = 1011
	SQLITE_DBSTATUS_CACHE_HIT             = 7
	SQLITE_DBSTATUS_CACHE_MISS            = 8
	SQLITE_DBSTATUS_CACHE_SPILL           = 12
	SQLITE_DBSTATUS_CACHE_USED            = 1
	SQLITE_DBSTATUS_CACHE_USED_SHARED     = 11
	SQLITE_DBSTATUS_CACHE_WRITE           = 9
	SQLITE_DBSTATUS_DEFERRED_FKS          = 10
	SQLITE_DBSTATUS_LOOKASIDE_HIT         = 4
	SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL   = 6
	SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE   = 5
	SQLITE_DBSTATUS_LOOKASIDE_USED        = 0
	SQLITE_DBSTATUS_MAX                   = 12
	SQLITE_DBSTATUS_SCHEMA_USED           = 2
	SQLITE_DBSTATUS_STMT_USED             = 3
	SQLITE_DEFAULT_MEMSTATUS              = 0
	SQLITE_DEFAULT_PAGE_SIZE              = 1024
	SQLITE_DELETE                         = 9
	SQLITE_DENY                           = 1
	SQLITE_DEPRECATED                     = 0
	SQLITE_DESERIALIZE_FREEONCLOSE        = 1
	SQLITE_DESERIALIZE_READONLY           = 4
	SQLITE_DESERIALIZE_RESIZEABLE         = 2
	SQLITE_DETACH                         = 25
	SQLITE_DETERMINISTIC                  = 0x000000800
	SQLITE_DIRECTONLY                     = 0x000080000
	SQLITE_DONE                           = 101
	SQLITE_DROP_INDEX                     = 10
	SQLITE_DROP_TABLE                     = 11
	SQLITE_DROP_TEMP_INDEX                = 12
	SQLITE_DROP_TEMP_TABLE                = 13
	SQLITE_DROP_TEMP_TRIGGER              = 14
	SQLITE_DROP_TEMP_VIEW                 = 15
	SQLITE_DROP_TRIGGER                   = 16
	SQLITE_DROP_VIEW                      = 17
	SQLITE_DROP_VTABLE                    = 30
	SQLITE_EMPTY                          = 16
	SQLITE_ENABLE_BYTECODE_VTAB           = 1
	SQLITE_ENABLE_COLUMN_METADATA         = 1
	SQLITE_ENABLE_DBPAGE_VTAB             = 1
	SQLITE_ENABLE_DBSTAT_VTAB             = 1
	SQLITE_ENABLE_DESERIALIZE             = 1
	SQLITE_ENABLE_EXPLAIN_COMMENTS        = 1
	SQLITE_ENABLE_FTS5                    = 1
	SQLITE_ENABLE_GEOPOLY                 = 1
	SQLITE_ENABLE_JSON1                   = 1
	SQLITE_ENABLE_MEMORY_MANAGEMENT       = 1
	SQLITE_ENABLE_OFFSET_SQL_FUNC         = 1
	SQLITE_ENABLE_PREUPDATE_HOOK          = 1
	SQLITE_ENABLE_RBU                     = 1
	SQLITE_ENABLE_RTREE                   = 1
	SQLITE_ENABLE_SESSION                 = 1
	SQLITE_ENABLE_SNAPSHOT                = 1
	SQLITE_ENABLE_STAT4                   = 1
	SQLITE_ENABLE_STMTVTAB                = 1
	SQLITE_ENABLE_UNLOCK_NOTIFY           = 1
	SQLITE_ERROR                          = 1
	SQLITE_ERROR_MISSING_COLLSEQ          = 257
	SQLITE_ERROR_RETRY                    = 513
	SQLITE_ERROR_SNAPSHOT                 = 769
	SQLITE_EXPERIMENTAL                   = 0
	SQLITE_FAIL                           = 3
	SQLITE_FCNTL_BEGIN_ATOMIC_WRITE       = 31
	SQLITE_FCNTL_BUSYHANDLER              = 15
	SQLITE_FCNTL_CHUNK_SIZE               = 6
	SQLITE_FCNTL_CKPT_DONE                = 37
	SQLITE_FCNTL_CKPT_START               = 39
	SQLITE_FCNTL_CKSM_FILE                = 41
	SQLITE_FCNTL_COMMIT_ATOMIC_WRITE      = 32
	SQLITE_FCNTL_COMMIT_PHASETWO          = 22
	SQLITE_FCNTL_DATA_VERSION             = 35
	SQLITE_FCNTL_EXTERNAL_READER          = 40
	SQLITE_FCNTL_FILE_POINTER             = 7
	SQLITE_FCNTL_GET_LOCKPROXYFILE        = 2
	SQLITE_FCNTL_HAS_MOVED                = 20
	SQLITE_FCNTL_JOURNAL_POINTER          = 28
	SQLITE_FCNTL_LAST_ERRNO               = 4
	SQLITE_FCNTL_LOCKSTATE                = 1
	SQLITE_FCNTL_LOCK_TIMEOUT             = 34
	SQLITE_FCNTL_MMAP_SIZE                = 18
	SQLITE_FCNTL_OVERWRITE                = 11
	SQLITE_FCNTL_PDB                      = 30
	SQLITE_FCNTL_PERSIST_WAL              = 10
	SQLITE_FCNTL_POWERSAFE_OVERWRITE      = 13
	SQLITE_FCNTL_PRAGMA                   = 14
	SQLITE_FCNTL_RBU                      = 26
	SQLITE_FCNTL_RESERVE_BYTES            = 38
	SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE    = 33
	SQLITE_FCNTL_SET_LOCKPROXYFILE        = 3
	SQLITE_FCNTL_SIZE_HINT                = 5
	SQLITE_FCNTL_SIZE_LIMIT               = 36
	SQLITE_FCNTL_SYNC                     = 21
	SQLITE_FCNTL_SYNC_OMITTED             = 8
	SQLITE_FCNTL_TEMPFILENAME             = 16
	SQLITE_FCNTL_TRACE                    = 19
	SQLITE_FCNTL_VFSNAME                  = 12
	SQLITE_FCNTL_VFS_POINTER              = 27
	SQLITE_FCNTL_WAL_BLOCK                = 24
	SQLITE_FCNTL_WIN32_AV_RETRY           = 9
	SQLITE_FCNTL_WIN32_GET_HANDLE         = 29
	SQLITE_FCNTL_WIN32_SET_HANDLE         = 23
	SQLITE_FCNTL_ZIPVFS                   = 25
	SQLITE_FLOAT                          = 2
	SQLITE_FORMAT                         = 24
	SQLITE_FULL                           = 13
	SQLITE_FUNCTION                       = 31
	SQLITE_GET_LOCKPROXYFILE              = 2
	SQLITE_HAVE_ZLIB                      = 1
	SQLITE_IGNORE                         = 2
	SQLITE_INDEX_CONSTRAINT_EQ            = 2
	SQLITE_INDEX_CONSTRAINT_FUNCTION      = 150
	SQLITE_INDEX_CONSTRAINT_GE            = 32
	SQLITE_INDEX_CONSTRAINT_GLOB          = 66
	SQLITE_INDEX_CONSTRAINT_GT            = 4
	SQLITE_INDEX_CONSTRAINT_IS            = 72
	SQLITE_INDEX_CONSTRAINT_ISNOT         = 69
	SQLITE_INDEX_CONSTRAINT_ISNOTNULL     = 70
	SQLITE_INDEX_CONSTRAINT_ISNULL        = 71
	SQLITE_INDEX_CONSTRAINT_LE            = 8
	SQLITE_INDEX_CONSTRAINT_LIKE          = 65
	SQLITE_INDEX_CONSTRAINT_LT            = 16
	SQLITE_INDEX_CONSTRAINT_MATCH         = 64
	SQLITE_INDEX_CONSTRAINT_NE            = 68
	SQLITE_INDEX_CONSTRAINT_REGEXP        = 67
	SQLITE_INDEX_SCAN_UNIQUE              = 1
	SQLITE_INNOCUOUS                      = 0x000200000
	SQLITE_INSERT                         = 18
	SQLITE_INTEGER                        = 1
	SQLITE_INTERNAL                       = 2
	SQLITE_INTERRUPT                      = 9
	SQLITE_IOCAP_ATOMIC                   = 0x00000001
	SQLITE_IOCAP_ATOMIC16K                = 0x00000040
	SQLITE_IOCAP_ATOMIC1K                 = 0x00000004
	SQLITE_IOCAP_ATOMIC2K                 = 0x00000008
	SQLITE_IOCAP_ATOMIC32K                = 0x00000080
	SQLITE_IOCAP_ATOMIC4K                 = 0x00000010
	SQLITE_IOCAP_ATOMIC512                = 0x00000002
	SQLITE_IOCAP_ATOMIC64K                = 0x00000100
	SQLITE_IOCAP_ATOMIC8K                 = 0x00000020
	SQLITE_IOCAP_BATCH_ATOMIC             = 0x00004000
	SQLITE_IOCAP_IMMUTABLE                = 0x00002000
	SQLITE_IOCAP_POWERSAFE_OVERWRITE      = 0x00001000
	SQLITE_IOCAP_SAFE_APPEND              = 0x00000200
	SQLITE_IOCAP_SEQUENTIAL               = 0x00000400
	SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN    = 0x00000800
	SQLITE_IOERR                          = 10
	SQLITE_IOERR_ACCESS                   = 3338
	SQLITE_IOERR_AUTH                     = 7178
	SQLITE_IOERR_BEGIN_ATOMIC             = 7434
	SQLITE_IOERR_BLOCKED                  = 2826
	SQLITE_IOERR_CHECKRESERVEDLOCK        = 3594
	SQLITE_IOERR_CLOSE                    = 4106
	SQLITE_IOERR_COMMIT_ATOMIC            = 7690
	SQLITE_IOERR_CONVPATH                 = 6666
	SQLITE_IOERR_CORRUPTFS                = 8458
	SQLITE_IOERR_DATA                     = 8202
	SQLITE_IOERR_DELETE                   = 2570
	SQLITE_IOERR_DELETE_NOENT             = 5898
	SQLITE_IOERR_DIR_CLOSE                = 4362
	SQLITE_IOERR_DIR_FSYNC                = 1290
	SQLITE_IOERR_FSTAT                    = 1802
	SQLITE_IOERR_FSYNC                    = 1034
	SQLITE_IOERR_GETTEMPPATH              = 6410
	SQLITE_IOERR_LOCK                     = 3850
	SQLITE_IOERR_MMAP                     = 6154
	SQLITE_IOERR_NOMEM                    = 3082
	SQLITE_IOERR_RDLOCK                   = 2314
	SQLITE_IOERR_READ                     = 266
	SQLITE_IOERR_ROLLBACK_ATOMIC          = 7946
	SQLITE_IOERR_SEEK                     = 5642
	SQLITE_IOERR_SHMLOCK                  = 5130
	SQLITE_IOERR_SHMMAP                   = 5386
	SQLITE_IOERR_SHMOPEN                  = 4618
	SQLITE_IOERR_SHMSIZE                  = 4874
	SQLITE_IOERR_SHORT_READ               = 522
	SQLITE_IOERR_TRUNCATE                 = 1546
	SQLITE_IOERR_UNLOCK                   = 2058
	SQLITE_IOERR_VNODE                    = 6922
	SQLITE_IOERR_WRITE                    = 778
	SQLITE_LAST_ERRNO                     = 4
	SQLITE_LIKE_DOESNT_MATCH_BLOBS        = 1
	SQLITE_LIMIT_ATTACHED                 = 7
	SQLITE_LIMIT_COLUMN                   = 2
	SQLITE_LIMIT_COMPOUND_SELECT          = 4
	SQLITE_LIMIT_EXPR_DEPTH               = 3
	SQLITE_LIMIT_FUNCTION_ARG             = 6
	SQLITE_LIMIT_LENGTH                   = 0
	SQLITE_LIMIT_LIKE_PATTERN_LENGTH      = 8
	SQLITE_LIMIT_SQL_LENGTH               = 1
	SQLITE_LIMIT_TRIGGER_DEPTH            = 10
	SQLITE_LIMIT_VARIABLE_NUMBER          = 9
	SQLITE_LIMIT_VDBE_OP                  = 5
	SQLITE_LIMIT_WORKER_THREADS           = 11
	SQLITE_LOCKED                         = 6
	SQLITE_LOCKED_SHAREDCACHE             = 262
	SQLITE_LOCKED_VTAB                    = 518
	SQLITE_LOCK_EXCLUSIVE                 = 4
	SQLITE_LOCK_NONE                      = 0
	SQLITE_LOCK_PENDING                   = 3
	SQLITE_LOCK_RESERVED                  = 2
	SQLITE_LOCK_SHARED                    = 1
	SQLITE_MISMATCH                       = 20
	SQLITE_MISUSE                         = 21
	SQLITE_MUTEX_APPDEF                   = 1
	SQLITE_MUTEX_FAST                     = 0
	SQLITE_MUTEX_NOOP                     = 1
	SQLITE_MUTEX_RECURSIVE                = 1
	SQLITE_MUTEX_STATIC_APP1              = 8
	SQLITE_MUTEX_STATIC_APP2              = 9
	SQLITE_MUTEX_STATIC_APP3              = 10
	SQLITE_MUTEX_STATIC_LRU               = 6
	SQLITE_MUTEX_STATIC_LRU2              = 7
	SQLITE_MUTEX_STATIC_MAIN              = 2
	SQLITE_MUTEX_STATIC_MASTER            = 2
	SQLITE_MUTEX_STATIC_MEM               = 3
	SQLITE_MUTEX_STATIC_MEM2              = 4
	SQLITE_MUTEX_STATIC_OPEN              = 4
	SQLITE_MUTEX_STATIC_PMEM              = 7
	SQLITE_MUTEX_STATIC_PRNG              = 5
	SQLITE_MUTEX_STATIC_VFS1              = 11
	SQLITE_MUTEX_STATIC_VFS2              = 12
	SQLITE_MUTEX_STATIC_VFS3              = 13
	SQLITE_NOLFS                          = 22
	SQLITE_NOMEM                          = 7
	SQLITE_NOTADB                         = 26
	SQLITE_NOTFOUND                       = 12
	SQLITE_NOTICE                         = 27
	SQLITE_NOTICE_RECOVER_ROLLBACK        = 539
	SQLITE_NOTICE_RECOVER_WAL             = 283
	SQLITE_NULL                           = 5
	SQLITE_OK                             = 0
	SQLITE_OK_LOAD_PERMANENTLY            = 256
	SQLITE_OK_SYMLINK                     = 512
	SQLITE_OMIT_LOAD_EXTENSION            = 1
	SQLITE_OPEN_AUTOPROXY                 = 0x00000020
	SQLITE_OPEN_CREATE                    = 0x00000004
	SQLITE_OPEN_DELETEONCLOSE             = 0x00000008
	SQLITE_OPEN_EXCLUSIVE                 = 0x00000010
	SQLITE_OPEN_EXRESCODE                 = 0x02000000
	SQLITE_OPEN_FULLMUTEX                 = 0x00010000
	SQLITE_OPEN_MAIN_DB                   = 0x00000100
	SQLITE_OPEN_MAIN_JOURNAL              = 0x00000800
	SQLITE_OPEN_MASTER_JOURNAL            = 0x00004000
	SQLITE_OPEN_MEMORY                    = 0x00000080
	SQLITE_OPEN_NOFOLLOW                  = 0x01000000
	SQLITE_OPEN_NOMUTEX                   = 0x00008000
	SQLITE_OPEN_PRIVATECACHE              = 0x00040000
	SQLITE_OPEN_READONLY                  = 0x00000001
	SQLITE_OPEN_READWRITE                 = 0x00000002
	SQLITE_OPEN_SHAREDCACHE               = 0x00020000
	SQLITE_OPEN_SUBJOURNAL                = 0x00002000
	SQLITE_OPEN_SUPER_JOURNAL             = 0x00004000
	SQLITE_OPEN_TEMP_DB                   = 0x00000200
	SQLITE_OPEN_TEMP_JOURNAL              = 0x00001000
	SQLITE_OPEN_TRANSIENT_DB              = 0x00000400
	SQLITE_OPEN_URI                       = 0x00000040
	SQLITE_OPEN_WAL                       = 0x00080000
	SQLITE_PERM                           = 3
	SQLITE_PRAGMA                         = 19
	SQLITE_PREPARE_NORMALIZE              = 0x02
	SQLITE_PREPARE_NO_VTAB                = 0x04
	SQLITE_PREPARE_PERSISTENT             = 0x01
	SQLITE_PROTOCOL                       = 15
	SQLITE_RANGE                          = 25
	SQLITE_READ                           = 20
	SQLITE_READONLY                       = 8
	SQLITE_READONLY_CANTINIT              = 1288
	SQLITE_READONLY_CANTLOCK              = 520
	SQLITE_READONLY_DBMOVED               = 1032
	SQLITE_READONLY_DIRECTORY             = 1544
	SQLITE_READONLY_RECOVERY              = 264
	SQLITE_READONLY_ROLLBACK              = 776
	SQLITE_RECURSIVE                      = 33
	SQLITE_REINDEX                        = 27
	SQLITE_REPLACE                        = 5
	SQLITE_ROLLBACK                       = 1
	SQLITE_ROW                            = 100
	SQLITE_SAVEPOINT                      = 32
	SQLITE_SCANSTAT_EST                   = 2
	SQLITE_SCANSTAT_EXPLAIN               = 4
	SQLITE_SCANSTAT_NAME                  = 3
	SQLITE_SCANSTAT_NLOOP                 = 0
	SQLITE_SCANSTAT_NVISIT                = 1
	SQLITE_SCANSTAT_SELECTID              = 5
	SQLITE_SCHEMA                         = 17
	SQLITE_SELECT                         = 21
	SQLITE_SERIALIZE_NOCOPY               = 0x001
	SQLITE_SERIES_CONSTRAINT_VERIFY       = 1
	SQLITE_SERVER                         = 1
	SQLITE_SESSION_CONFIG_STRMSIZE        = 1
	SQLITE_SESSION_OBJCONFIG_SIZE         = 1
	SQLITE_SET_LOCKPROXYFILE              = 3
	SQLITE_SHM_EXCLUSIVE                  = 8
	SQLITE_SHM_LOCK                       = 2
	SQLITE_SHM_NLOCK                      = 8
	SQLITE_SHM_SHARED                     = 4
	SQLITE_SHM_UNLOCK                     = 1
	SQLITE_SOUNDEX                        = 1
	SQLITE_SOURCE_ID                      = "2021-11-27 14:13:22 bd41822c7424d393a30e92ff6cb254d25c26769889c1499a18a0b9339f5d6c8a"
	SQLITE_STATUS_MALLOC_COUNT            = 9
	SQLITE_STATUS_MALLOC_SIZE             = 5
	SQLITE_STATUS_MEMORY_USED             = 0
	SQLITE_STATUS_PAGECACHE_OVERFLOW      = 2
	SQLITE_STATUS_PAGECACHE_SIZE          = 7
	SQLITE_STATUS_PAGECACHE_USED          = 1
	SQLITE_STATUS_PARSER_STACK            = 6
	SQLITE_STATUS_SCRATCH_OVERFLOW        = 4
	SQLITE_STATUS_SCRATCH_SIZE            = 8
	SQLITE_STATUS_SCRATCH_USED            = 3
	SQLITE_STDCALL                        = 0
	SQLITE_STMTSTATUS_AUTOINDEX           = 3
	SQLITE_STMTSTATUS_FULLSCAN_STEP       = 1
	SQLITE_STMTSTATUS_MEMUSED             = 99
	SQLITE_STMTSTATUS_REPREPARE           = 5
	SQLITE_STMTSTATUS_RUN                 = 6
	SQLITE_STMTSTATUS_SORT                = 2
	SQLITE_STMTSTATUS_VM_STEP             = 4
	SQLITE_SUBTYPE                        = 0x000100000
	SQLITE_SYNC_DATAONLY                  = 0x00010
	SQLITE_SYNC_FULL                      = 0x00003
	SQLITE_SYNC_NORMAL                    = 0x00002
	SQLITE_SYSAPI                         = 0
	SQLITE_TEMP_STORE                     = 1
	SQLITE_TEST                           = 1
	SQLITE_TESTCTRL_ALWAYS                = 13
	SQLITE_TESTCTRL_ASSERT                = 12
	SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS   = 10
	SQLITE_TESTCTRL_BITVEC_TEST           = 8
	SQLITE_TESTCTRL_BYTEORDER             = 22
	SQLITE_TESTCTRL_EXPLAIN_STMT          = 19
	SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS   = 29
	SQLITE_TESTCTRL_FAULT_INSTALL         = 9
	SQLITE_TESTCTRL_FIRST                 = 5
	SQLITE_TESTCTRL_IMPOSTER              = 25
	SQLITE_TESTCTRL_INTERNAL_FUNCTIONS    = 17
	SQLITE_TESTCTRL_ISINIT                = 23
	SQLITE_TESTCTRL_ISKEYWORD             = 16
	SQLITE_TESTCTRL_LAST                  = 32
	SQLITE_TESTCTRL_LOCALTIME_FAULT       = 18
	SQLITE_TESTCTRL_NEVER_CORRUPT         = 20
	SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD  = 19
	SQLITE_TESTCTRL_OPTIMIZATIONS         = 15
	SQLITE_TESTCTRL_PARSER_COVERAGE       = 26
	SQLITE_TESTCTRL_PENDING_BYTE          = 11
	SQLITE_TESTCTRL_PRNG_RESET            = 7
	SQLITE_TESTCTRL_PRNG_RESTORE          = 6
	SQLITE_TESTCTRL_PRNG_SAVE             = 5
	SQLITE_TESTCTRL_PRNG_SEED             = 28
	SQLITE_TESTCTRL_RESERVE               = 14
	SQLITE_TESTCTRL_RESULT_INTREAL        = 27
	SQLITE_TESTCTRL_SCRATCHMALLOC         = 17
	SQLITE_TESTCTRL_SEEK_COUNT            = 30
	SQLITE_TESTCTRL_SORTER_MMAP           = 24
	SQLITE_TESTCTRL_TRACEFLAGS            = 31
	SQLITE_TESTCTRL_TUNE                  = 32
	SQLITE_TESTCTRL_VDBE_COVERAGE         = 21
	SQLITE_TEXT                           = 3
	SQLITE_THREADSAFE                     = 1
	SQLITE_TOOBIG                         = 18
	SQLITE_TRACE_CLOSE                    = 0x08
	SQLITE_TRACE_PROFILE                  = 0x02
	SQLITE_TRACE_ROW                      = 0x04
	SQLITE_TRACE_STMT                     = 0x01
	SQLITE_TRANSACTION                    = 22
	SQLITE_TXN_NONE                       = 0
	SQLITE_TXN_READ                       = 1
	SQLITE_TXN_WRITE                      = 2
	SQLITE_UPDATE                         = 23
	SQLITE_UTF16                          = 4
	SQLITE_UTF16BE                        = 3
	SQLITE_UTF16LE                        = 2
	SQLITE_UTF16_ALIGNED                  = 8
	SQLITE_UTF8                           = 1
	SQLITE_VERSION                        = "3.37.0"
	SQLITE_VERSION_NUMBER                 = 3037000
	SQLITE_VTAB_CONSTRAINT_SUPPORT        = 1
	SQLITE_VTAB_DIRECTONLY                = 3
	SQLITE_VTAB_INNOCUOUS                 = 2
	SQLITE_WARNING                        = 28
	SQLITE_WARNING_AUTOINDEX              = 284
	SQLITE_WIN32_DATA_DIRECTORY_TYPE      = 1
	SQLITE_WIN32_TEMP_DIRECTORY_TYPE      = 2
	TMP_MAX                               = 308915776
	UNIQUE_TABLE_NAME                     = "t592690916721053953805701627921227776"
	X_ASSERT_H_                           = 0
	X_ERRNO_T_DEFINED                     = 0
	X_FILE_OFFSET_BITS                    = 64
	X_FSTDIO                              = 0
	X_FTRUNCATE_DECLARED                  = 0
	X_FTS5_H                              = 0
	X_HAVE_SQLITE_CONFIG_H                = 1
	X_IOFBF                               = 0
	X_IOLBF                               = 1
	X_IONBF                               = 2
	X_LOCALE_T_DEFINED                    = 0
	X_LP64                                = 1
	X_LSEEK_DECLARED                      = 0
	X_MACHINE_STDARG_H_                   = 0
	X_MACHINE__LIMITS_H_                  = 0
	X_MACHINE__TYPES_H_                   = 0
	X_MMAP_DECLARED                       = 0
	X_Nonnull                             = 0
	X_Null_unspecified                    = 0
	X_Nullable                            = 0
	X_OFF64_T_DECLARED                    = 0
	X_OFF_T_DECLARED                      = 0
	X_RSIZE_T_DEFINED                     = 0
	X_SIZE_T_DECLARED                     = 0
	X_SQLITE3RTREE_H_                     = 0
	X_SSIZE_T_DECLARED                    = 0
	X_STDFILE_DECLARED                    = 0
	X_STDIO_H_                            = 0
	X_STDSTREAM_DECLARED                  = 0
	X_STRINGS_H_                          = 0
	X_STRING_H_                           = 0
	X_SWAB_DECLARED                       = 0
	X_SYS_CDEFS_H_                        = 0
	X_SYS__STDARG_H_                      = 0
	X_SYS__TYPES_H_                       = 0
	X_TRUNCATE_DECLARED                   = 0
	X_VA_LIST_DECLARED                    = 0
	X_XLOCALE_STRING1_H                   = 0
	X_XLOCALE_STRINGS1_H                  = 0
	Unix                                  = 1
	CRTIMPORT                             = 0
	DLLIMPORT                             = 0
	INLINE                                = 0
	MP_DIGIT_DECLARED                     = 0
	MP_INT_DECLARED                       = 0
	NUM_STATIC_TOKENS                     = 20
	SQLITE_TCLAPI                         = 0
	TCL_ALLOW_INLINE_COMPILATION          = 0x20000
	TCL_ALL_EVENTS                        = -3
	TCL_ALPHA_RELEASE                     = 0
	TCL_APPEND_VALUE                      = 4
	TCL_ARGV_CONSTANT                     = 15
	TCL_ARGV_END                          = 23
	TCL_ARGV_FLOAT                        = 19
	TCL_ARGV_FUNC                         = 20
	TCL_ARGV_GENFUNC                      = 21
	TCL_ARGV_HELP                         = 22
	TCL_ARGV_INT                          = 16
	TCL_ARGV_REST                         = 18
	TCL_ARGV_STRING                       = 17
	TCL_BETA_RELEASE                      = 1
	TCL_BREAK                             = 3
	TCL_CANCEL_UNWIND                     = 0x100000
	TCL_CHANNEL_THREAD_INSERT             = 0
	TCL_CHANNEL_THREAD_REMOVE             = 1
	TCL_CLOSE_READ                        = 2
	TCL_CLOSE_WRITE                       = 4
	TCL_CONTINUE                          = 4
	TCL_CONVERT_MULTIBYTE                 = -1
	TCL_CONVERT_NOSPACE                   = -4
	TCL_CONVERT_SYNTAX                    = -2
	TCL_CONVERT_UNKNOWN                   = -3
	TCL_CREATE_HARD_LINK                  = 0x02
	TCL_CREATE_SYMBOLIC_LINK              = 0x01
	TCL_CUSTOM_PTR_KEYS                   = -1
	TCL_CUSTOM_TYPE_KEYS                  = -2
	TCL_DONT_QUOTE_HASH                   = 8
	TCL_DONT_USE_BRACES                   = 1
	TCL_DONT_WAIT                         = 2
	TCL_DOUBLE_SPACE                      = 27
	TCL_DSTRING_STATIC_SIZE               = 200
	TCL_ENCODING_CHAR_LIMIT               = 0x10
	TCL_ENCODING_END                      = 0x02
	TCL_ENCODING_NO_TERMINATE             = 0x08
	TCL_ENCODING_START                    = 0x01
	TCL_ENCODING_STOPONERROR              = 0x04
	TCL_ENFORCE_MODE                      = 16
	TCL_ENSEMBLE_PREFIX                   = 0x02
	TCL_ERROR                             = 1
	TCL_EVAL_DIRECT                       = 0x040000
	TCL_EVAL_GLOBAL                       = 0x020000
	TCL_EVAL_INVOKE                       = 0x080000
	TCL_EVAL_NOERR                        = 0x200000
	TCL_EXACT                             = 1
	TCL_EXCEPTION                         = 8
	TCL_FILE_EVENTS                       = 8
	TCL_FINAL_RELEASE                     = 2
	TCL_GLOBAL_ONLY                       = 1
	TCL_GLOB_PERM_HIDDEN                  = 2
	TCL_GLOB_PERM_R                       = 4
	TCL_GLOB_PERM_RONLY                   = 1
	TCL_GLOB_PERM_W                       = 8
	TCL_GLOB_PERM_X                       = 16
	TCL_GLOB_TYPE_BLOCK                   = 1
	TCL_GLOB_TYPE_CHAR                    = 2
	TCL_GLOB_TYPE_DIR                     = 4
	TCL_GLOB_TYPE_FILE                    = 16
	TCL_GLOB_TYPE_LINK                    = 32
	TCL_GLOB_TYPE_MOUNT                   = 128
	TCL_GLOB_TYPE_PIPE                    = 8
	TCL_GLOB_TYPE_SOCK                    = 64
	TCL_HASH_KEY_RANDOMIZE_HASH           = 0x1
	TCL_HASH_KEY_STORE_HASH               = 1
	TCL_HASH_KEY_SYSTEM_HASH              = 0x2
	TCL_HASH_KEY_TYPE_VERSION             = 1
	TCL_IDLE_EVENTS                       = 32
	TCL_INTEGER_SPACE                     = 24
	TCL_INTERP_DESTROYED                  = 0x100
	TCL_LEAVE_ERR_MSG                     = 0x200
	TCL_LIMIT_COMMANDS                    = 0x01
	TCL_LIMIT_TIME                        = 0x02
	TCL_LINK_BOOLEAN                      = 3
	TCL_LINK_CHAR                         = 6
	TCL_LINK_DOUBLE                       = 2
	TCL_LINK_FLOAT                        = 13
	TCL_LINK_INT                          = 1
	TCL_LINK_LONG                         = 11
	TCL_LINK_READ_ONLY                    = 0x80
	TCL_LINK_SHORT                        = 8
	TCL_LINK_STRING                       = 4
	TCL_LINK_UCHAR                        = 7
	TCL_LINK_UINT                         = 10
	TCL_LINK_ULONG                        = 12
	TCL_LINK_USHORT                       = 9
	TCL_LINK_WIDE_INT                     = 5
	TCL_LINK_WIDE_UINT                    = 14
	TCL_LIST_ELEMENT                      = 8
	TCL_LL_MODIFIER                       = "ll"
	TCL_LOAD_GLOBAL                       = 1
	TCL_LOAD_LAZY                         = 2
	TCL_MAJOR_VERSION                     = 8
	TCL_MATCH_NOCASE                      = 1
	TCL_MAX_PREC                          = 17
	TCL_MINOR_VERSION                     = 6
	TCL_MODE_BLOCKING                     = 0
	TCL_MODE_NONBLOCKING                  = 1
	TCL_NAMESPACE_ONLY                    = 2
	TCL_NORETURN1                         = 0
	TCL_NO_EVAL                           = 0x010000
	TCL_OK                                = 0
	TCL_ONE_WORD_KEYS                     = 1
	TCL_PARSE_BAD_NUMBER                  = 9
	TCL_PARSE_BRACE_EXTRA                 = 2
	TCL_PARSE_MISSING_BRACE               = 3
	TCL_PARSE_MISSING_BRACKET             = 4
	TCL_PARSE_MISSING_PAREN               = 5
	TCL_PARSE_MISSING_QUOTE               = 6
	TCL_PARSE_MISSING_VAR_BRACE           = 7
	TCL_PARSE_PART1                       = 0x400
	TCL_PARSE_QUOTE_EXTRA                 = 1
	TCL_PARSE_SUCCESS                     = 0
	TCL_PARSE_SYNTAX                      = 8
	TCL_PATCH_LEVEL                       = "8.6.11"
	TCL_READABLE                          = 2
	TCL_REG_ADVANCED                      = 000003
	TCL_REG_ADVF                          = 000002
	TCL_REG_BASIC                         = 000000
	TCL_REG_CANMATCH                      = 001000
	TCL_REG_EXPANDED                      = 000040
	TCL_REG_EXTENDED                      = 000001
	TCL_REG_NEWLINE                       = 000300
	TCL_REG_NLANCH                        = 000200
	TCL_REG_NLSTOP                        = 000100
	TCL_REG_NOCASE                        = 000010
	TCL_REG_NOSUB                         = 000020
	TCL_REG_NOTBOL                        = 0001
	TCL_REG_NOTEOL                        = 0002
	TCL_REG_QUOTE                         = 000004
	TCL_RELEASE_LEVEL                     = 2
	TCL_RELEASE_SERIAL                    = 11
	TCL_RESULT_SIZE                       = 200
	TCL_RETURN                            = 2
	TCL_SERVICE_ALL                       = 1
	TCL_SERVICE_NONE                      = 0
	TCL_SMALL_HASH_TABLE                  = 4
	TCL_STDERR                            = 8
	TCL_STDIN                             = 2
	TCL_STDOUT                            = 4
	TCL_STORAGE_CLASS                     = 0
	TCL_STRING_KEYS                       = 0
	TCL_SUBST_ALL                         = 007
	TCL_SUBST_BACKSLASHES                 = 004
	TCL_SUBST_COMMANDS                    = 001
	TCL_SUBST_VARIABLES                   = 002
	TCL_THREAD_CREATE_RETURN              = 0
	TCL_THREAD_JOINABLE                   = 1
	TCL_THREAD_NOFLAGS                    = 0
	TCL_THREAD_STACK_DEFAULT              = 0
	TCL_TIMER_EVENTS                      = 16
	TCL_TOKEN_BS                          = 8
	TCL_TOKEN_COMMAND                     = 16
	TCL_TOKEN_EXPAND_WORD                 = 256
	TCL_TOKEN_OPERATOR                    = 128
	TCL_TOKEN_SIMPLE_WORD                 = 2
	TCL_TOKEN_SUB_EXPR                    = 64
	TCL_TOKEN_TEXT                        = 4
	TCL_TOKEN_VARIABLE                    = 32
	TCL_TOKEN_WORD                        = 1
	TCL_TRACE_ARRAY                       = 0x800
	TCL_TRACE_DELETE                      = 0x4000
	TCL_TRACE_DESTROYED                   = 0x80
	TCL_TRACE_OLD_STYLE                   = 0x1000
	TCL_TRACE_READS                       = 0x10
	TCL_TRACE_RENAME                      = 0x2000
	TCL_TRACE_RESULT_DYNAMIC              = 0x8000
	TCL_TRACE_RESULT_OBJECT               = 0x10000
	TCL_TRACE_UNSETS                      = 0x40
	TCL_TRACE_WRITES                      = 0x20
	TCL_UNLOAD_DETACH_FROM_INTERPRETER    = 1
	TCL_UNLOAD_DETACH_FROM_PROCESS        = 2
	TCL_UTF_MAX                           = 3
	TCL_VERSION                           = "8.6"
	TCL_WINDOW_EVENTS                     = 4
	TCL_WRITABLE                          = 4
	TCL_ZLIB_COMPRESS_BEST                = 9
	TCL_ZLIB_COMPRESS_DEFAULT             = -1
	TCL_ZLIB_COMPRESS_FAST                = 1
	TCL_ZLIB_COMPRESS_NONE                = 0
	TCL_ZLIB_FINALIZE                     = 4
	TCL_ZLIB_FLUSH                        = 2
	TCL_ZLIB_FORMAT_AUTO                  = 8
	TCL_ZLIB_FORMAT_GZIP                  = 4
	TCL_ZLIB_FORMAT_RAW                   = 1
	TCL_ZLIB_FORMAT_ZLIB                  = 2
	TCL_ZLIB_FULLFLUSH                    = 3
	TCL_ZLIB_NO_FLUSH                     = 0
	TCL_ZLIB_STREAM_DEFLATE               = 16
	TCL_ZLIB_STREAM_INFLATE               = 32
	X_CLIENTDATA                          = 0
	X_TCL                                 = 0
	X_TCLDECLS                            = 0
	X_TCLPLATDECLS                        = 0
	X_FTSINT_H                            = 0
	FTS3_TOK_SCHEMA                       = "CREATE TABLE x(input HIDDEN, token, start, end, position)"
	APND_MARK_FOS_SZ                      = 8
	APND_MARK_PREFIX                      = "Start-Of-SQLite3-"
	APND_MARK_PREFIX_SZ                   = 17
	APND_MARK_SIZE                        = 25
	APND_MAX_SIZE                         = 1073741824
	APND_ROUNDUP                          = 4096
	SQLITE3EXT_H                          = 0
	SQLITE_EXTENSION_INIT1                = 0
	SQLITE_EXTENSION_INIT3                = 0
	AMATCH_COL_COMMAND                    = 3
	AMATCH_COL_DISTANCE                   = 1
	AMATCH_COL_LANGUAGE                   = 2
	AMATCH_COL_NWORD                      = 4
	AMATCH_COL_WORD                       = 0
	AMATCH_MX_COST                        = 1000
	AMATCH_MX_LANGID                      = 2147483647
	AMATCH_MX_LENGTH                      = 50
	EXIT_FAILURE                          = 1
	EXIT_SUCCESS                          = 0
	RAND_MAX                              = 0x7fffffff
	X_CACHED_RUNES                        = 256
	X_CRMASK                              = -256
	X_CTYPE_A                             = 0x00000100
	X_CTYPE_B                             = 0x00020000
	X_CTYPE_C                             = 0x00000200
	X_CTYPE_D                             = 0x00000400
	X_CTYPE_G                             = 0x00000800
	X_CTYPE_H_                            = 0
	X_CTYPE_I                             = 0x00080000
	X_CTYPE_L                             = 0x00001000
	X_CTYPE_N                             = 0x00400000
	X_CTYPE_P                             = 0x00002000
	X_CTYPE_Q                             = 0x00200000
	X_CTYPE_R                             = 0x00040000
	X_CTYPE_S                             = 0x00004000
	X_CTYPE_SW0                           = 0x20000000
	X_CTYPE_SW1                           = 0x40000000
	X_CTYPE_SW2                           = 0x80000000
	X_CTYPE_SW3                           = 0xc0000000
	X_CTYPE_SWM                           = 0xe0000000
	X_CTYPE_SWS                           = 30
	X_CTYPE_T                             = 0x00100000
	X_CTYPE_U                             = 0x00008000
	X_CTYPE_X                             = 0x00010000
	X_MKDTEMP_DECLARED                    = 0
	X_MKSTEMP_DECLARED                    = 0
	X_MKTEMP_DECLARED                     = 0
	X_RUNETYPE_H_                         = 0
	X_RUNE_MAGIC_1                        = "RuneMagi"
	X_RUNE_T_DECLARED                     = 0
	X_STDLIB_H_                           = 0
	X_WCHAR_T_DECLARED                    = 0
	X_XLOCALE_CTYPE_H                     = 0
	X_XLOCALE_RUN_FUNCTIONS_DEFINED       = 1
	CARRAY_COLUMN_COUNT                   = 2
	CARRAY_COLUMN_CTYPE                   = 3
	CARRAY_COLUMN_POINTER                 = 1
	CARRAY_COLUMN_VALUE                   = 0
	CARRAY_DOUBLE                         = 2
	CARRAY_INT32                          = 0
	CARRAY_INT64                          = 1
	CARRAY_TEXT                           = 3
	CLOSURE_COL_DEPTH                     = 1
	CLOSURE_COL_ID                        = 0
	CLOSURE_COL_IDCOLUMN                  = 4
	CLOSURE_COL_PARENTCOLUMN              = 5
	CLOSURE_COL_ROOT                      = 2
	CLOSURE_COL_TABLENAME                 = 3
	CSVTEST_FIDX                          = 0x0001
	CSV_INBUFSZ                           = 1024
	CSV_MXERR                             = 200
	EXPLN_COLUMN_ADDR                     = 0
	EXPLN_COLUMN_COMMENT                  = 7
	EXPLN_COLUMN_OPCODE                   = 1
	EXPLN_COLUMN_P1                       = 2
	EXPLN_COLUMN_P2                       = 3
	EXPLN_COLUMN_P3                       = 4
	EXPLN_COLUMN_P4                       = 5
	EXPLN_COLUMN_P5                       = 6
	EXPLN_COLUMN_SQL                      = 8
	ACCESSPERMS                           = 511
	ALLPERMS                              = 4095
	AT_EACCESS                            = 0x0100
	AT_FDCWD                              = -100
	AT_REMOVEDIR                          = 0x0800
	AT_RESOLVE_BENEATH                    = 0x2000
	AT_SYMLINK_FOLLOW                     = 0x0400
	AT_SYMLINK_NOFOLLOW                   = 0x0200
	BIG_ENDIAN                            = 4321
	BYTE_ORDER                            = 1234
	CLK_TCK                               = 128
	CLOCKS_PER_SEC                        = 128
	CLOCK_MONOTONIC                       = 4
	CLOCK_MONOTONIC_FAST                  = 12
	CLOCK_MONOTONIC_PRECISE               = 11
	CLOCK_PROCESS_CPUTIME_ID              = 15
	CLOCK_PROF                            = 2
	CLOCK_REALTIME                        = 0
	CLOCK_REALTIME_FAST                   = 10
	CLOCK_REALTIME_PRECISE                = 9
	CLOCK_SECOND                          = 13
	CLOCK_THREAD_CPUTIME_ID               = 14
	CLOCK_UPTIME                          = 5
	CLOCK_UPTIME_FAST                     = 8
	CLOCK_UPTIME_PRECISE                  = 7
	CLOCK_VIRTUAL                         = 1
	CPUCLOCK_WHICH_PID                    = 0
	CPUCLOCK_WHICH_TID                    = 1
	DEFFILEMODE                           = 438
	DIRBLKSIZ                             = 1024
	DST_AUST                              = 2
	DST_CAN                               = 6
	DST_EET                               = 5
	DST_MET                               = 4
	DST_NONE                              = 0
	DST_USA                               = 1
	DST_WET                               = 3
	DTF_HIDEW                             = 0x0001
	DTF_NODUP                             = 0x0002
	DTF_REWIND                            = 0x0004
	DT_BLK                                = 6
	DT_CHR                                = 2
	DT_DIR                                = 4
	DT_FIFO                               = 1
	DT_LNK                                = 10
	DT_REG                                = 8
	DT_SOCK                               = 12
	DT_UNKNOWN                            = 0
	DT_WHT                                = 14
	E2BIG                                 = 7
	EACCES                                = 13
	EADDRINUSE                            = 48
	EADDRNOTAVAIL                         = 49
	EAFNOSUPPORT                          = 47
	EAGAIN                                = 35
	EALREADY                              = 37
	EAUTH                                 = 80
	EBADF                                 = 9
	EBADMSG                               = 89
	EBADRPC                               = 72
	EBUSY                                 = 16
	ECANCELED                             = 85
	ECAPMODE                              = 94
	ECHILD                                = 10
	ECONNABORTED                          = 53
	ECONNREFUSED                          = 61
	ECONNRESET                            = 54
	EDEADLK                               = 11
	EDESTADDRREQ                          = 39
	EDOM                                  = 33
	EDOOFUS                               = 88
	EDQUOT                                = 69
	EEXIST                                = 17
	EFAULT                                = 14
	EFBIG                                 = 27
	EFTYPE                                = 79
	EHOSTDOWN                             = 64
	EHOSTUNREACH                          = 65
	EIDRM                                 = 82
	EILSEQ                                = 86
	EINPROGRESS                           = 36
	EINTEGRITY                            = 97
	EINTR                                 = 4
	EINVAL                                = 22
	EIO                                   = 5
	EISCONN                               = 56
	EISDIR                                = 21
	ELAST                                 = 97
	ELOOP                                 = 62
	EMFILE                                = 24
	EMLINK                                = 31
	EMSGSIZE                              = 40
	EMULTIHOP                             = 90
	ENAMETOOLONG                          = 63
	ENEEDAUTH                             = 81
	ENETDOWN                              = 50
	ENETRESET                             = 52
	ENETUNREACH                           = 51
	ENFILE                                = 23
	ENOATTR                               = 87
	ENOBUFS                               = 55
	ENODEV                                = 19
	ENOENT                                = 2
	ENOEXEC                               = 8
	ENOLCK                                = 77
	ENOLINK                               = 91
	ENOMEM                                = 12
	ENOMSG                                = 83
	ENOPROTOOPT                           = 42
	ENOSPC                                = 28
	ENOSYS                                = 78
	ENOTBLK                               = 15
	ENOTCAPABLE                           = 93
	ENOTCONN                              = 57
	ENOTDIR                               = 20
	ENOTEMPTY                             = 66
	ENOTRECOVERABLE                       = 95
	ENOTSOCK                              = 38
	ENOTSUP                               = 45
	ENOTTY                                = 25
	ENXIO                                 = 6
	EOPNOTSUPP                            = 45
	EOVERFLOW                             = 84
	EOWNERDEAD                            = 96
	EPERM                                 = 1
	EPFNOSUPPORT                          = 46
	EPIPE                                 = 32
	EPROCLIM                              = 67
	EPROCUNAVAIL                          = 76
	EPROGMISMATCH                         = 75
	EPROGUNAVAIL                          = 74
	EPROTO                                = 92
	EPROTONOSUPPORT                       = 43
	EPROTOTYPE                            = 41
	ERANGE                                = 34
	EREMOTE                               = 71
	EROFS                                 = 30
	ERPCMISMATCH                          = 73
	ESHUTDOWN                             = 58
	ESOCKTNOSUPPORT                       = 44
	ESPIPE                                = 29
	ESRCH                                 = 3
	ESTALE                                = 70
	ETIMEDOUT                             = 60
	ETOOMANYREFS                          = 59
	ETXTBSY                               = 26
	EUSERS                                = 68
	EWOULDBLOCK                           = 35
	EXDEV                                 = 18
	FAPPEND                               = 8
	FASYNC                                = 64
	FDSYNC                                = 16777216
	FD_CLOEXEC                            = 1
	FD_NONE                               = -200
	FD_SETSIZE                            = 1024
	FFSYNC                                = 128
	FNDELAY                               = 4
	FNONBLOCK                             = 4
	FRDAHEAD                              = 512
	FREAD                                 = 0x0001
	FSDIR_COLUMN_DATA                     = 3
	FSDIR_COLUMN_DIR                      = 5
	FSDIR_COLUMN_MODE                     = 1
	FSDIR_COLUMN_MTIME                    = 2
	FSDIR_COLUMN_NAME                     = 0
	FSDIR_COLUMN_PATH                     = 4
	FSDIR_SCHEMA                          = "(name,mode,mtime,data,path HIDDEN,dir HIDDEN)"
	FWRITE                                = 0x0002
	F_ADD_SEALS                           = 19
	F_CANCEL                              = 5
	F_DUP2FD                              = 10
	F_DUP2FD_CLOEXEC                      = 18
	F_DUPFD                               = 0
	F_DUPFD_CLOEXEC                       = 17
	F_GETFD                               = 1
	F_GETFL                               = 3
	F_GETLK                               = 11
	F_GETOWN                              = 5
	F_GET_SEALS                           = 20
	F_ISUNIONSTACK                        = 21
	F_LOCK                                = 1
	F_OGETLK                              = 7
	F_OK                                  = 0
	F_OSETLK                              = 8
	F_OSETLKW                             = 9
	F_RDAHEAD                             = 16
	F_RDLCK                               = 1
	F_READAHEAD                           = 15
	F_SEAL_GROW                           = 0x0004
	F_SEAL_SEAL                           = 0x0001
	F_SEAL_SHRINK                         = 0x0002
	F_SEAL_WRITE                          = 0x0008
	F_SETFD                               = 2
	F_SETFL                               = 4
	F_SETLK                               = 12
	F_SETLKW                              = 13
	F_SETLK_REMOTE                        = 14
	F_SETOWN                              = 6
	F_TEST                                = 3
	F_TLOCK                               = 2
	F_ULOCK                               = 0
	F_UNLCK                               = 2
	F_UNLCKSYS                            = 4
	F_WRLCK                               = 3
	ITIMER_PROF                           = 2
	ITIMER_REAL                           = 0
	ITIMER_VIRTUAL                        = 1
	LITTLE_ENDIAN                         = 1234
	LOCK_EX                               = 0x02
	LOCK_NB                               = 0x04
	LOCK_SH                               = 0x01
	LOCK_UN                               = 0x08
	L_INCR                                = 1
	L_SET                                 = 0
	L_XTND                                = 2
	MAXNAMLEN                             = 255
	O_ACCMODE                             = 0x0003
	O_APPEND                              = 0x0008
	O_ASYNC                               = 0x0040
	O_CLOEXEC                             = 0x00100000
	O_CREAT                               = 0x0200
	O_DIRECT                              = 0x00010000
	O_DIRECTORY                           = 0x00020000
	O_DSYNC                               = 0x01000000
	O_EXCL                                = 0x0800
	O_EXEC                                = 0x00040000
	O_EXLOCK                              = 0x0020
	O_FSYNC                               = 0x0080
	O_NDELAY                              = 4
	O_NOCTTY                              = 0x8000
	O_NOFOLLOW                            = 0x0100
	O_NONBLOCK                            = 0x0004
	O_RDONLY                              = 0x0000
	O_RDWR                                = 0x0002
	O_RESOLVE_BENEATH                     = 0x00800000
	O_SEARCH                              = 262144
	O_SHLOCK                              = 0x0010
	O_SYNC                                = 0x0080
	O_TRUNC                               = 0x0400
	O_TTY_INIT                            = 0x00080000
	O_VERIFY                              = 0x00200000
	O_WRONLY                              = 0x0001
	PDP_ENDIAN                            = 3412
	POSIX_FADV_DONTNEED                   = 4
	POSIX_FADV_NOREUSE                    = 5
	POSIX_FADV_NORMAL                     = 0
	POSIX_FADV_RANDOM                     = 1
	POSIX_FADV_SEQUENTIAL                 = 2
	POSIX_FADV_WILLNEED                   = 3
	RFCENVG                               = 2048
	RFCFDG                                = 4096
	RFCNAMEG                              = 1024
	RFENVG                                = 2
	RFFDG                                 = 4
	RFFLAGS                               = 2416930932
	RFHIGHPID                             = 262144
	RFKERNELONLY                          = 268828672
	RFLINUXTHPN                           = 65536
	RFMEM                                 = 32
	RFNAMEG                               = 1
	RFNOTEG                               = 8
	RFNOWAIT                              = 64
	RFPPWAIT                              = 2147483648
	RFPROC                                = 16
	RFPROCDESC                            = 268435456
	RFSIGSHARE                            = 16384
	RFSPAWN                               = 2147483648
	RFSTOPPED                             = 131072
	RFTHREAD                              = 8192
	RFTSIGMASK                            = 0xFF
	RFTSIGSHIFT                           = 20
	RFTSIGZMB                             = 524288
	R_OK                                  = 0x04
	SBT_MAX                               = 0x7fffffffffffffff
	SEEK_DATA                             = 3
	SEEK_HOLE                             = 4
	SF_APPEND                             = 0x00040000
	SF_ARCHIVED                           = 0x00010000
	SF_IMMUTABLE                          = 0x00020000
	SF_NOUNLINK                           = 0x00100000
	SF_SETTABLE                           = 0xffff0000
	SF_SNAPSHOT                           = 0x00200000
	STDERR_FILENO                         = 2
	STDIN_FILENO                          = 0
	STDOUT_FILENO                         = 1
	S_BLKSIZE                             = 512
	S_IEXEC                               = 64
	S_IFBLK                               = 0060000
	S_IFCHR                               = 0020000
	S_IFDIR                               = 0040000
	S_IFIFO                               = 0010000
	S_IFLNK                               = 0120000
	S_IFMT                                = 0170000
	S_IFREG                               = 0100000
	S_IFSOCK                              = 0140000
	S_IFWHT                               = 0160000
	S_IREAD                               = 256
	S_IRGRP                               = 0000040
	S_IROTH                               = 0000004
	S_IRUSR                               = 0000400
	S_IRWXG                               = 0000070
	S_IRWXO                               = 0000007
	S_IRWXU                               = 0000700
	S_ISGID                               = 0002000
	S_ISTXT                               = 0001000
	S_ISUID                               = 0004000
	S_ISVTX                               = 0001000
	S_IWGRP                               = 0000020
	S_IWOTH                               = 0000002
	S_IWRITE                              = 128
	S_IWUSR                               = 0000200
	S_IXGRP                               = 0000010
	S_IXOTH                               = 0000001
	S_IXUSR                               = 0000100
	TIMER_ABSTIME                         = 0x1
	TIMER_RELTIME                         = 0x0
	TIME_UTC                              = 1
	UF_APPEND                             = 0x00000004
	UF_ARCHIVE                            = 0x00000800
	UF_HIDDEN                             = 0x00008000
	UF_IMMUTABLE                          = 0x00000002
	UF_NODUMP                             = 0x00000001
	UF_NOUNLINK                           = 0x00000010
	UF_OFFLINE                            = 0x00000200
	UF_OPAQUE                             = 0x00000008
	UF_READONLY                           = 0x00001000
	UF_REPARSE                            = 0x00000400
	UF_SETTABLE                           = 0x0000ffff
	UF_SPARSE                             = 0x00000100
	UF_SYSTEM                             = 0x00000080
	UTIME_NOW                             = -1
	UTIME_OMIT                            = -2
	W_OK                                  = 0x02
	X_OK                                  = 0x01
	X_ACCMODE_T_DECLARED                  = 0
	X_BIG_ENDIAN                          = 4321
	X_BLKCNT_T_DECLARED                   = 0
	X_BLKSIZE_T_DECLARED                  = 0
	X_BYTE_ORDER                          = 1234
	X_CAP_IOCTL_T_DECLARED                = 0
	X_CAP_RIGHTS_T_DECLARED               = 0
	X_CLOCKID_T_DECLARED                  = 0
	X_CLOCK_T_DECLARED                    = 0
	X_CS_PATH                             = 1
	X_CS_POSIX_V6_ILP32_OFF32_CFLAGS      = 2
	X_CS_POSIX_V6_ILP32_OFF32_LDFLAGS     = 3
	X_CS_POSIX_V6_ILP32_OFF32_LIBS        = 4
	X_CS_POSIX_V6_ILP32_OFFBIG_CFLAGS     = 5
	X_CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS    = 6
	X_CS_POSIX_V6_ILP32_OFFBIG_LIBS       = 7
	X_CS_POSIX_V6_LP64_OFF64_CFLAGS       = 8
	X_CS_POSIX_V6_LP64_OFF64_LDFLAGS      = 9
	X_CS_POSIX_V6_LP64_OFF64_LIBS         = 10
	X_CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS     = 11
	X_CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS    = 12
	X_CS_POSIX_V6_LPBIG_OFFBIG_LIBS       = 13
	X_CS_POSIX_V6_WIDTH_RESTRICTED_ENVS   = 14
	X_DEV_T_DECLARED                      = 0
	X_DIRENT_H_                           = 0
	X_FFLAGS_T_DECLARED                   = 0
	X_FSBLKCNT_T_DECLARED                 = 0
	X_GETOPT_DECLARED                     = 0
	X_GID_T_DECLARED                      = 0
	X_ID_T_DECLARED                       = 0
	X_INO_T_DECLARED                      = 0
	X_INT16_T_DECLARED                    = 0
	X_INT32_T_DECLARED                    = 0
	X_INT64_T_DECLARED                    = 0
	X_INT8_T_DECLARED                     = 0
	X_INTMAX_T_DECLARED                   = 0
	X_INTPTR_T_DECLARED                   = 0
	X_IN_ADDR_T_DECLARED                  = 0
	X_IN_PORT_T_DECLARED                  = 0
	X_KEY_T_DECLARED                      = 0
	X_LITTLE_ENDIAN                       = 1234
	X_LWPID_T_DECLARED                    = 0
	X_MACHINE_ENDIAN_H_                   = 0
	X_MKNOD_DECLARED                      = 0
	X_MODE_T_DECLARED                     = 0
	X_MQD_T_DECLARED                      = 0
	X_NLINK_T_DECLARED                    = 0
	X_OPTRESET_DECLARED                   = 0
	X_PC_ACL_EXTENDED                     = 59
	X_PC_ACL_NFS4                         = 64
	X_PC_ACL_PATH_MAX                     = 60
	X_PC_ALLOC_SIZE_MIN                   = 10
	X_PC_ASYNC_IO                         = 53
	X_PC_CAP_PRESENT                      = 61
	X_PC_CHOWN_RESTRICTED                 = 7
	X_PC_FILESIZEBITS                     = 12
	X_PC_INF_PRESENT                      = 62
	X_PC_LINK_MAX                         = 1
	X_PC_MAC_PRESENT                      = 63
	X_PC_MAX_CANON                        = 2
	X_PC_MAX_INPUT                        = 3
	X_PC_MIN_HOLE_SIZE                    = 21
	X_PC_NAME_MAX                         = 4
	X_PC_NO_TRUNC                         = 8
	X_PC_PATH_MAX                         = 5
	X_PC_PIPE_BUF                         = 6
	X_PC_PRIO_IO                          = 54
	X_PC_REC_INCR_XFER_SIZE               = 14
	X_PC_REC_MAX_XFER_SIZE                = 15
	X_PC_REC_MIN_XFER_SIZE                = 16
	X_PC_REC_XFER_ALIGN                   = 17
	X_PC_SYMLINK_MAX                      = 18
	X_PC_SYNC_IO                          = 55
	X_PC_VDISABLE                         = 9
	X_PDP_ENDIAN                          = 3412
	X_PID_T_DECLARED                      = 0
	X_POSIX2_CHAR_TERM                    = 1
	X_POSIX2_C_BIND                       = 200112
	X_POSIX2_C_DEV                        = -1
	X_POSIX2_FORT_DEV                     = -1
	X_POSIX2_FORT_RUN                     = 200112
	X_POSIX2_LOCALEDEF                    = -1
	X_POSIX2_PBS                          = -1
	X_POSIX2_PBS_ACCOUNTING               = -1
	X_POSIX2_PBS_CHECKPOINT               = -1
	X_POSIX2_PBS_LOCATE                   = -1
	X_POSIX2_PBS_MESSAGE                  = -1
	X_POSIX2_PBS_TRACK                    = -1
	X_POSIX2_SW_DEV                       = -1
	X_POSIX2_UPE                          = 200112
	X_POSIX2_VERSION                      = 199212
	X_POSIX_ADVISORY_INFO                 = 200112
	X_POSIX_ASYNCHRONOUS_IO               = 200112
	X_POSIX_BARRIERS                      = 200112
	X_POSIX_CHOWN_RESTRICTED              = 1
	X_POSIX_CLOCK_SELECTION               = -1
	X_POSIX_CPUTIME                       = 200112
	X_POSIX_FSYNC                         = 200112
	X_POSIX_IPV6                          = 0
	X_POSIX_JOB_CONTROL                   = 1
	X_POSIX_MAPPED_FILES                  = 200112
	X_POSIX_MEMLOCK                       = -1
	X_POSIX_MEMLOCK_RANGE                 = 200112
	X_POSIX_MEMORY_PROTECTION             = 200112
	X_POSIX_MESSAGE_PASSING               = 200112
	X_POSIX_MONOTONIC_CLOCK               = 200112
	X_POSIX_NO_TRUNC                      = 1
	X_POSIX_PRIORITIZED_IO                = -1
	X_POSIX_PRIORITY_SCHEDULING           = 0
	X_POSIX_RAW_SOCKETS                   = 200112
	X_POSIX_READER_WRITER_LOCKS           = 200112
	X_POSIX_REALTIME_SIGNALS              = 200112
	X_POSIX_REGEXP                        = 1
	X_POSIX_SEMAPHORES                    = 200112
	X_POSIX_SHARED_MEMORY_OBJECTS         = 200112
	X_POSIX_SHELL                         = 1
	X_POSIX_SPAWN                         = 200112
	X_POSIX_SPIN_LOCKS                    = 200112
	X_POSIX_SPORADIC_SERVER               = -1
	X_POSIX_SYNCHRONIZED_IO               = -1
	X_POSIX_THREADS                       = 200112
	X_POSIX_THREAD_ATTR_STACKADDR         = 200112
	X_POSIX_THREAD_ATTR_STACKSIZE         = 200112
	X_POSIX_THREAD_CPUTIME                = 200112
	X_POSIX_THREAD_PRIORITY_SCHEDULING    = 200112
	X_POSIX_THREAD_PRIO_INHERIT           = 200112
	X_POSIX_THREAD_PRIO_PROTECT           = 200112
	X_POSIX_THREAD_PROCESS_SHARED         = 200112
	X_POSIX_THREAD_SAFE_FUNCTIONS         = -1
	X_POSIX_THREAD_SPORADIC_SERVER        = -1
	X_POSIX_TIMEOUTS                      = 200112
	X_POSIX_TIMERS                        = 200112
	X_POSIX_TRACE                         = -1
	X_POSIX_TRACE_EVENT_FILTER            = -1
	X_POSIX_TRACE_INHERIT                 = -1
	X_POSIX_TRACE_LOG                     = -1
	X_POSIX_TYPED_MEMORY_OBJECTS          = -1
	X_POSIX_VDISABLE                      = 0xff
	X_POSIX_VERSION                       = 200112
	X_PTHREAD_T_DECLARED                  = 0
	X_QUAD_HIGHWORD                       = 1
	X_QUAD_LOWWORD                        = 0
	X_RLIM_T_DECLARED                     = 0
	X_SC_2_CHAR_TERM                      = 20
	X_SC_2_C_BIND                         = 18
	X_SC_2_C_DEV                          = 19
	X_SC_2_FORT_DEV                       = 21
	X_SC_2_FORT_RUN                       = 22
	X_SC_2_LOCALEDEF                      = 23
	X_SC_2_PBS                            = 59
	X_SC_2_PBS_ACCOUNTING                 = 60
	X_SC_2_PBS_CHECKPOINT                 = 61
	X_SC_2_PBS_LOCATE                     = 62
	X_SC_2_PBS_MESSAGE                    = 63
	X_SC_2_PBS_TRACK                      = 64
	X_SC_2_SW_DEV                         = 24
	X_SC_2_UPE                            = 25
	X_SC_2_VERSION                        = 17
	X_SC_ADVISORY_INFO                    = 65
	X_SC_AIO_LISTIO_MAX                   = 42
	X_SC_AIO_MAX                          = 43
	X_SC_AIO_PRIO_DELTA_MAX               = 44
	X_SC_ARG_MAX                          = 1
	X_SC_ASYNCHRONOUS_IO                  = 28
	X_SC_ATEXIT_MAX                       = 107
	X_SC_BARRIERS                         = 66
	X_SC_BC_BASE_MAX                      = 9
	X_SC_BC_DIM_MAX                       = 10
	X_SC_BC_SCALE_MAX                     = 11
	X_SC_BC_STRING_MAX                    = 12
	X_SC_CHILD_MAX                        = 2
	X_SC_CLK_TCK                          = 3
	X_SC_CLOCK_SELECTION                  = 67
	X_SC_COLL_WEIGHTS_MAX                 = 13
	X_SC_CPUSET_SIZE                      = 122
	X_SC_CPUTIME                          = 68
	X_SC_DELAYTIMER_MAX                   = 45
	X_SC_EXPR_NEST_MAX                    = 14
	X_SC_FILE_LOCKING                     = 69
	X_SC_FSYNC                            = 38
	X_SC_GETGR_R_SIZE_MAX                 = 70
	X_SC_GETPW_R_SIZE_MAX                 = 71
	X_SC_HOST_NAME_MAX                    = 72
	X_SC_IOV_MAX                          = 56
	X_SC_IPV6                             = 118
	X_SC_JOB_CONTROL                      = 6
	X_SC_LINE_MAX                         = 15
	X_SC_LOGIN_NAME_MAX                   = 73
	X_SC_MAPPED_FILES                     = 29
	X_SC_MEMLOCK                          = 30
	X_SC_MEMLOCK_RANGE                    = 31
	X_SC_MEMORY_PROTECTION                = 32
	X_SC_MESSAGE_PASSING                  = 33
	X_SC_MONOTONIC_CLOCK                  = 74
	X_SC_MQ_OPEN_MAX                      = 46
	X_SC_MQ_PRIO_MAX                      = 75
	X_SC_NGROUPS_MAX                      = 4
	X_SC_NPROCESSORS_CONF                 = 57
	X_SC_NPROCESSORS_ONLN                 = 58
	X_SC_OPEN_MAX                         = 5
	X_SC_PAGESIZE                         = 47
	X_SC_PAGE_SIZE                        = 47
	X_SC_PHYS_PAGES                       = 121
	X_SC_PRIORITIZED_IO                   = 34
	X_SC_PRIORITY_SCHEDULING              = 35
	X_SC_RAW_SOCKETS                      = 119
	X_SC_READER_WRITER_LOCKS              = 76
	X_SC_REALTIME_SIGNALS                 = 36
	X_SC_REGEXP                           = 77
	X_SC_RE_DUP_MAX                       = 16
	X_SC_RTSIG_MAX                        = 48
	X_SC_SAVED_IDS                        = 7
	X_SC_SEMAPHORES                       = 37
	X_SC_SEM_NSEMS_MAX                    = 49
	X_SC_SEM_VALUE_MAX                    = 50
	X_SC_SHARED_MEMORY_OBJECTS            = 39
	X_SC_SHELL                            = 78
	X_SC_SIGQUEUE_MAX                     = 51
	X_SC_SPAWN                            = 79
	X_SC_SPIN_LOCKS                       = 80
	X_SC_SPORADIC_SERVER                  = 81
	X_SC_STREAM_MAX                       = 26
	X_SC_SYMLOOP_MAX                      = 120
	X_SC_SYNCHRONIZED_IO                  = 40
	X_SC_THREADS                          = 96
	X_SC_THREAD_ATTR_STACKADDR            = 82
	X_SC_THREAD_ATTR_STACKSIZE            = 83
	X_SC_THREAD_CPUTIME                   = 84
	X_SC_THREAD_DESTRUCTOR_ITERATIONS     = 85
	X_SC_THREAD_KEYS_MAX                  = 86
	X_SC_THREAD_PRIORITY_SCHEDULING       = 89
	X_SC_THREAD_PRIO_INHERIT              = 87
	X_SC_THREAD_PRIO_PROTECT              = 88
	X_SC_THREAD_PROCESS_SHARED            = 90
	X_SC_THREAD_SAFE_FUNCTIONS            = 91
	X_SC_THREAD_SPORADIC_SERVER           = 92
	X_SC_THREAD_STACK_MIN                 = 93
	X_SC_THREAD_THREADS_MAX               = 94
	X_SC_TIMEOUTS                         = 95
	X_SC_TIMERS                           = 41
	X_SC_TIMER_MAX                        = 52
	X_SC_TRACE                            = 97
	X_SC_TRACE_EVENT_FILTER               = 98
	X_SC_TRACE_INHERIT                    = 99
	X_SC_TRACE_LOG                        = 100
	X_SC_TTY_NAME_MAX                     = 101
	X_SC_TYPED_MEMORY_OBJECTS             = 102
	X_SC_TZNAME_MAX                       = 27
	X_SC_V6_ILP32_OFF32                   = 103
	X_SC_V6_ILP32_OFFBIG                  = 104
	X_SC_V6_LP64_OFF64                    = 105
	X_SC_V6_LPBIG_OFFBIG                  = 106
	X_SC_VERSION                          = 8
	X_SC_XOPEN_CRYPT                      = 108
	X_SC_XOPEN_ENH_I18N                   = 109
	X_SC_XOPEN_LEGACY                     = 110
	X_SC_XOPEN_REALTIME                   = 111
	X_SC_XOPEN_REALTIME_THREADS           = 112
	X_SC_XOPEN_SHM                        = 113
	X_SC_XOPEN_STREAMS                    = 114
	X_SC_XOPEN_UNIX                       = 115
	X_SC_XOPEN_VERSION                    = 116
	X_SC_XOPEN_XCU_VERSION                = 117
	X_SELECT_DECLARED                     = 0
	X_SIGSET_T_DECLARED                   = 0
	X_SIG_MAXSIG                          = 128
	X_SIG_WORDS                           = 4
	X_SUSECONDS_T_DECLARED                = 0
	X_SYS_DIRENT_H_                       = 0
	X_SYS_ERRNO_H_                        = 0
	X_SYS_FCNTL_H_                        = 0
	X_SYS_SELECT_H_                       = 0
	X_SYS_STAT_H_                         = 0
	X_SYS_TIMESPEC_H_                     = 0
	X_SYS_TIME_H_                         = 0
	X_SYS_TYPES_H_                        = 0
	X_SYS_UNISTD_H_                       = 0
	X_SYS__PTHREADTYPES_H_                = 0
	X_SYS__SIGSET_H_                      = 0
	X_SYS__STDINT_H_                      = 0
	X_SYS__TIMESPEC_H_                    = 0
	X_SYS__TIMEVAL_H_                     = 0
	X_TIMER_T_DECLARED                    = 0
	X_TIME_H_                             = 0
	X_TIME_T_DECLARED                     = 0
	X_UID_T_DECLARED                      = 0
	X_UINT16_T_DECLARED                   = 0
	X_UINT32_T_DECLARED                   = 0
	X_UINT64_T_DECLARED                   = 0
	X_UINT8_T_DECLARED                    = 0
	X_UINTMAX_T_DECLARED                  = 0
	X_UINTPTR_T_DECLARED                  = 0
	X_UNISTD_H_                           = 0
	X_USECONDS_T_DECLARED                 = 0
	X_UTIME_H_                            = 0
	X_V6_ILP32_OFF32                      = -1
	X_V6_ILP32_OFFBIG                     = 0
	X_V6_LP64_OFF64                       = 0
	X_V6_LPBIG_OFFBIG                     = -1
	X_XLOCALE_LOCALE1_H                   = 0
	X_XOPEN_CRYPT                         = -1
	X_XOPEN_ENH_I18N                      = -1
	X_XOPEN_LEGACY                        = -1
	X_XOPEN_REALTIME                      = -1
	X_XOPEN_REALTIME_THREADS              = -1
	X_XOPEN_SHM                           = 1
	X_XOPEN_STREAMS                       = -1
	X_XOPEN_UNIX                          = -1
	FUZZER_HASH                           = 4001
	FUZZER_MX_COST                        = 1000
	FUZZER_MX_LENGTH                      = 50
	FUZZER_MX_OUTPUT_LENGTH               = 100
	FUZZER_MX_RULEID                      = 2147483647
	FUZZER_NQUEUE                         = 20
	CC_AND                                = 24
	CC_BANG                               = 15
	CC_COMMA                              = 23
	CC_DIGIT                              = 3
	CC_DOLLAR                             = 4
	CC_DOT                                = 26
	CC_EQ                                 = 14
	CC_GT                                 = 13
	CC_ID                                 = 2
	CC_ILLEGAL                            = 27
	CC_KYWD                               = 1
	CC_LP                                 = 17
	CC_LT                                 = 12
	CC_MINUS                              = 11
	CC_PERCENT                            = 22
	CC_PIPE                               = 10
	CC_PLUS                               = 20
	CC_QUOTE                              = 8
	CC_QUOTE2                             = 9
	CC_RP                                 = 18
	CC_SEMI                               = 19
	CC_SLASH                              = 16
	CC_SPACE                              = 7
	CC_STAR                               = 21
	CC_TILDA                              = 25
	CC_VARALPHA                           = 5
	CC_VARNUM                             = 6
	CC_X                                  = 0
	TK_BITAND                             = 3
	TK_BITNOT                             = 3
	TK_BITOR                              = 3
	TK_BLOB                               = 2
	TK_COMMA                              = 3
	TK_CONCAT                             = 3
	TK_DOT                                = 3
	TK_EQ                                 = 3
	TK_ERROR                              = 4
	TK_FLOAT                              = 2
	TK_GE                                 = 3
	TK_GT                                 = 3
	TK_ID                                 = 1
	TK_ILLEGAL                            = 4
	TK_INTEGER                            = 2
	TK_LE                                 = 3
	TK_LITERAL                            = 2
	TK_LP                                 = 3
	TK_LSHIFT                             = 3
	TK_LT                                 = 3
	TK_MINUS                              = 3
	TK_NAME                               = 1
	TK_NE                                 = 3
	TK_PLUS                               = 3
	TK_PUNCT                              = 3
	TK_REM                                = 3
	TK_RP                                 = 3
	TK_RSHIFT                             = 3
	TK_SEMI                               = 3
	TK_SLASH                              = 3
	TK_SPACE                              = 0
	TK_STAR                               = 3
	TK_STRING                             = 2
	TK_VARIABLE                           = 2
	Deliberate_fall_through               = 0
	RE_EOF                                = 0
	RE_OP_ACCEPT                          = 6
	RE_OP_ANY                             = 2
	RE_OP_ANYSTAR                         = 3
	RE_OP_BOUNDARY                        = 17
	RE_OP_CC_EXC                          = 8
	RE_OP_CC_INC                          = 7
	RE_OP_CC_RANGE                        = 10
	RE_OP_CC_VALUE                        = 9
	RE_OP_DIGIT                           = 13
	RE_OP_FORK                            = 4
	RE_OP_GOTO                            = 5
	RE_OP_MATCH                           = 1
	RE_OP_NOTDIGIT                        = 14
	RE_OP_NOTSPACE                        = 16
	RE_OP_NOTWORD                         = 12
	RE_OP_SPACE                           = 15
	RE_OP_WORD                            = 11
	SERIES_COLUMN_START                   = 1
	SERIES_COLUMN_STEP                    = 3
	SERIES_COLUMN_STOP                    = 2
	SERIES_COLUMN_VALUE                   = 0
	CCLASS_B                              = 2
	CCLASS_C                              = 3
	CCLASS_D                              = 4
	CCLASS_DIGIT                          = 10
	CCLASS_H                              = 5
	CCLASS_L                              = 6
	CCLASS_M                              = 8
	CCLASS_OTHER                          = 12
	CCLASS_R                              = 7
	CCLASS_SILENT                         = 0
	CCLASS_SPACE                          = 11
	CCLASS_VOWEL                          = 1
	CCLASS_Y                              = 9
	FINAL_INS_COST_DIV                    = 4
	SCRIPT_ARABIC                         = 0x0010
	SCRIPT_CYRILLIC                       = 0x0002
	SCRIPT_GREEK                          = 0x0004
	SCRIPT_HEBREW                         = 0x0008
	SCRIPT_LATIN                          = 0x0001
	SPELLFIX_COL_COMMAND                  = 11
	SPELLFIX_COL_DISTANCE                 = 2
	SPELLFIX_COL_LANGID                   = 3
	SPELLFIX_COL_MATCHLEN                 = 5
	SPELLFIX_COL_PHONEHASH                = 6
	SPELLFIX_COL_RANK                     = 1
	SPELLFIX_COL_SCOPE                    = 8
	SPELLFIX_COL_SCORE                    = 4
	SPELLFIX_COL_SOUNDSLIKE               = 10
	SPELLFIX_COL_SRCHCNT                  = 9
	SPELLFIX_COL_TOP                      = 7
	SPELLFIX_COL_WORD                     = 0
	SPELLFIX_IDXNUM_DIST                  = 48
	SPELLFIX_IDXNUM_DISTLE                = 0x20
	SPELLFIX_IDXNUM_DISTLT                = 0x10
	SPELLFIX_IDXNUM_LANGID                = 0x02
	SPELLFIX_IDXNUM_MATCH                 = 0x01
	SPELLFIX_IDXNUM_ROWID                 = 0x40
	SPELLFIX_IDXNUM_SCOPE                 = 0x08
	SPELLFIX_IDXNUM_TOP                   = 0x04
	SPELLFIX_MX_HASH                      = 32
	SPELLFIX_MX_RUN                       = 1
	SQLITE_SPELLFIX_STACKALLOC_SZ         = 1024
	TOTYPE_BIGENDIAN                      = 0
	TOTYPE_LITTLEENDIAN                   = 1
	SWARMVTAB_MAX_OPEN                    = 9
	ARG_MAX                               = 524288
	BC_BASE_MAX                           = 99
	BC_DIM_MAX                            = 2048
	BC_SCALE_MAX                          = 99
	BC_STRING_MAX                         = 1000
	CHARCLASS_NAME_MAX                    = 14
	CHAR_BIT                              = 8
	CHAR_MAX                              = 127
	CHAR_MIN                              = -128
	CHILD_MAX                             = 40
	COLL_WEIGHTS_MAX                      = 10
	EXPR_NEST_MAX                         = 32
	FAR                                   = 0
	GID_MAX                               = 4294967295
	INT_MAX                               = 2147483647
	INT_MIN                               = -2147483648
	IOV_MAX                               = 1024
	LINE_MAX                              = 2048
	LLONG_MAX                             = 9223372036854775807
	LLONG_MIN                             = -9223372036854775808
	LONG_BIT                              = 64
	LONG_MAX                              = 9223372036854775807
	LONG_MIN                              = -9223372036854775808
	MAX_CANON                             = 255
	MAX_INPUT                             = 255
	MAX_MEM_LEVEL                         = 9
	MAX_WBITS                             = 15
	MB_LEN_MAX                            = 6
	MQ_PRIO_MAX                           = 64
	NAME_MAX                              = 255
	NGROUPS_MAX                           = 1023
	NL_ARGMAX                             = 4096
	NL_LANGMAX                            = 31
	NL_MSGMAX                             = 32767
	NL_NMAX                               = 1
	NL_SETMAX                             = 255
	NL_TEXTMAX                            = 2048
	OFF_MAX                               = 9223372036854775807
	OFF_MIN                               = -9223372036854775808
	OPEN_MAX                              = 64
	PASS_MAX                              = 128
	PATH_MAX                              = 1024
	PIPE_BUF                              = 512
	QUAD_MAX                              = 9223372036854775807
	QUAD_MIN                              = -9223372036854775808
	RE_DUP_MAX                            = 255
	SCHAR_MAX                             = 127
	SCHAR_MIN                             = -128
	SHRT_MAX                              = 32767
	SHRT_MIN                              = -32768
	SIZE_T_MAX                            = 18446744073709551615
	SSIZE_MAX                             = 9223372036854775807
	STDC                                  = 0
	STDC99                                = 0
	UCHAR_MAX                             = 255
	UID_MAX                               = 4294967295
	UINT_MAX                              = 4294967295
	ULLONG_MAX                            = 18446744073709551615
	ULONG_MAX                             = 18446744073709551615
	UQUAD_MAX                             = 18446744073709551615
	USHRT_MAX                             = 65535
	WORD_BIT                              = 32
	ZCONF_H                               = 0
	ZEXPORT                               = 0
	ZEXPORTVA                             = 0
	ZIPFILE_BUFFER_SIZE                   = 65536
	ZIPFILE_CDS_FIXED_SZ                  = 46
	ZIPFILE_CDS_NFILE_OFF                 = 28
	ZIPFILE_CDS_SZCOMPRESSED_OFF          = 20
	ZIPFILE_EOCD_FIXED_SZ                 = 22
	ZIPFILE_EXTRA_TIMESTAMP               = 0x5455
	ZIPFILE_F_COLUMN_IDX                  = 7
	ZIPFILE_LFH_FIXED_SZ                  = 30
	ZIPFILE_NEWENTRY_FLAGS                = 0x800
	ZIPFILE_NEWENTRY_MADEBY               = 798
	ZIPFILE_NEWENTRY_REQUIRED             = 20
	ZIPFILE_SIGNATURE_CDS                 = 0x02014b50
	ZIPFILE_SIGNATURE_EOCD                = 0x06054b50
	ZIPFILE_SIGNATURE_LFH                 = 0x04034b50
	ZLIB_H                                = 0
	ZLIB_VERNUM                           = 0x12b0
	ZLIB_VERSION                          = "1.2.11"
	ZLIB_VER_MAJOR                        = 1
	ZLIB_VER_MINOR                        = 2
	ZLIB_VER_REVISION                     = 11
	ZLIB_VER_SUBREVISION                  = 0
	Z_ASCII                               = 1
	Z_BEST_COMPRESSION                    = 9
	Z_BEST_SPEED                          = 1
	Z_BINARY                              = 0
	Z_BLOCK                               = 5
	Z_BUF_ERROR                           = -5
	Z_DATA_ERROR                          = -3
	Z_DEFAULT_COMPRESSION                 = -1
	Z_DEFAULT_STRATEGY                    = 0
	Z_DEFLATED                            = 8
	Z_ERRNO                               = -1
	Z_FILTERED                            = 1
	Z_FINISH                              = 4
	Z_FIXED                               = 4
	Z_FULL_FLUSH                          = 3
	Z_HUFFMAN_ONLY                        = 2
	Z_MEM_ERROR                           = -4
	Z_NEED_DICT                           = 2
	Z_NO_COMPRESSION                      = 0
	Z_NO_FLUSH                            = 0
	Z_NULL                                = 0
	Z_OK                                  = 0
	Z_PARTIAL_FLUSH                       = 1
	Z_RLE                                 = 3
	Z_STREAM_END                          = 1
	Z_STREAM_ERROR                        = -2
	Z_SYNC_FLUSH                          = 2
	Z_TEXT                                = 1
	Z_TREES                               = 6
	Z_UNKNOWN                             = 2
	Z_VERSION_ERROR                       = -6
	X_GCC_MAX_ALIGN_T                     = 0
	X_LIMITS_H_                           = 0
	X_POSIX2_BC_BASE_MAX                  = 99
	X_POSIX2_BC_DIM_MAX                   = 2048
	X_POSIX2_BC_SCALE_MAX                 = 99
	X_POSIX2_BC_STRING_MAX                = 1000
	X_POSIX2_CHARCLASS_NAME_MAX           = 14
	X_POSIX2_COLL_WEIGHTS_MAX             = 2
	X_POSIX2_EQUIV_CLASS_MAX              = 2
	X_POSIX2_EXPR_NEST_MAX                = 32
	X_POSIX2_LINE_MAX                     = 2048
	X_POSIX2_RE_DUP_MAX                   = 255
	X_POSIX_AIO_LISTIO_MAX                = 2
	X_POSIX_AIO_MAX                       = 1
	X_POSIX_ARG_MAX                       = 4096
	X_POSIX_CHILD_MAX                     = 25
	X_POSIX_CLOCKRES_MIN                  = 20000000
	X_POSIX_DELAYTIMER_MAX                = 32
	X_POSIX_HOST_NAME_MAX                 = 255
	X_POSIX_LINK_MAX                      = 8
	X_POSIX_LOGIN_NAME_MAX                = 9
	X_POSIX_MAX_CANON                     = 255
	X_POSIX_MAX_INPUT                     = 255
	X_POSIX_MQ_OPEN_MAX                   = 8
	X_POSIX_MQ_PRIO_MAX                   = 32
	X_POSIX_NAME_MAX                      = 14
	X_POSIX_NGROUPS_MAX                   = 8
	X_POSIX_OPEN_MAX                      = 20
	X_POSIX_PATH_MAX                      = 256
	X_POSIX_PIPE_BUF                      = 512
	X_POSIX_RE_DUP_MAX                    = 255
	X_POSIX_RTSIG_MAX                     = 8
	X_POSIX_SEM_NSEMS_MAX                 = 256
	X_POSIX_SEM_VALUE_MAX                 = 32767
	X_POSIX_SIGQUEUE_MAX                  = 32
	X_POSIX_SSIZE_MAX                     = 32767
	X_POSIX_SS_REPL_MAX                   = 4
	X_POSIX_STREAM_MAX                    = 8
	X_POSIX_SYMLINK_MAX                   = 255
	X_POSIX_SYMLOOP_MAX                   = 8
	X_POSIX_THREAD_DESTRUCTOR_ITERATIONS  = 4
	X_POSIX_THREAD_KEYS_MAX               = 128
	X_POSIX_THREAD_THREADS_MAX            = 64
	X_POSIX_TIMER_MAX                     = 32
	X_POSIX_TRACE_EVENT_NAME_MAX          = 30
	X_POSIX_TRACE_NAME_MAX                = 8
	X_POSIX_TRACE_SYS_MAX                 = 8
	X_POSIX_TRACE_USER_EVENT_MAX          = 32
	X_POSIX_TTY_NAME_MAX                  = 9
	X_POSIX_TZNAME_MAX                    = 6
	X_PTRDIFF_T_DECLARED                  = 0
	X_STDDEF_H_                           = 0
	X_SYS_LIMITS_H_                       = 0
	X_SYS_SYSLIMITS_H_                    = 0
	X_XOPEN_IOV_MAX                       = 16
	X_XOPEN_NAME_MAX                      = 255
	X_XOPEN_PATH_MAX                      = 1024
	Z_const                               = 0
	SQLITE_RBU_STATE_CHECKPOINT           = 3
	SQLITE_RBU_STATE_DONE                 = 4
	SQLITE_RBU_STATE_ERROR                = 5
	SQLITE_RBU_STATE_MOVE                 = 2
	SQLITE_RBU_STATE_OAL                  = 1
	X_SQLITE3RBU_H                        = 0
	BTREE_APPEND                          = 0x08
	BTREE_APPLICATION_ID                  = 8
	BTREE_AUTOVACUUM_FULL                 = 1
	BTREE_AUTOVACUUM_INCR                 = 2
	BTREE_AUTOVACUUM_NONE                 = 0
	BTREE_AUXDELETE                       = 0x04
	BTREE_BLOBKEY                         = 2
	BTREE_BULKLOAD                        = 0x00000001
	BTREE_DATA_VERSION                    = 15
	BTREE_DEFAULT_CACHE_SIZE              = 3
	BTREE_FILE_FORMAT                     = 2
	BTREE_FORDELETE                       = 0x00000008
	BTREE_FREE_PAGE_COUNT                 = 0
	BTREE_HINT_RANGE                      = 0
	BTREE_INCR_VACUUM                     = 7
	BTREE_INTKEY                          = 1
	BTREE_LARGEST_ROOT_PAGE               = 4
	BTREE_MEMORY                          = 2
	BTREE_OMIT_JOURNAL                    = 1
	BTREE_PREFORMAT                       = 0x80
	BTREE_SAVEPOSITION                    = 0x02
	BTREE_SCHEMA_VERSION                  = 1
	BTREE_SEEK_EQ                         = 0x00000002
	BTREE_SINGLE                          = 4
	BTREE_TEXT_ENCODING                   = 5
	BTREE_UNORDERED                       = 8
	BTREE_USER_VERSION                    = 6
	BTREE_WRCSR                           = 0x00000004
	COLFLAG_BUSY                          = 0x0100
	COLFLAG_GENERATED                     = 0x0060
	COLFLAG_HASCOLL                       = 0x0200
	COLFLAG_HASTYPE                       = 0x0004
	COLFLAG_HIDDEN                        = 0x0002
	COLFLAG_NOINSERT                      = 0x0062
	COLFLAG_NOTAVAIL                      = 0x0080
	COLFLAG_PRIMKEY                       = 0x0001
	COLFLAG_SORTERREF                     = 0x0010
	COLFLAG_STORED                        = 0x0040
	COLFLAG_UNIQUE                        = 0x0008
	COLFLAG_VIRTUAL                       = 0x0020
	COLNAME_COLUMN                        = 4
	COLNAME_DATABASE                      = 2
	COLNAME_DECLTYPE                      = 1
	COLNAME_N                             = 5
	COLNAME_NAME                          = 0
	COLNAME_TABLE                         = 3
	COLTYPE_ANY                           = 1
	COLTYPE_BLOB                          = 2
	COLTYPE_CUSTOM                        = 0
	COLTYPE_INT                           = 3
	COLTYPE_INTEGER                       = 4
	COLTYPE_REAL                          = 5
	COLTYPE_TEXT                          = 6
	DBFLAG_EncodingFixed                  = 0x0040
	DBFLAG_InternalFunc                   = 0x0020
	DBFLAG_PreferBuiltin                  = 0x0002
	DBFLAG_SchemaChange                   = 0x0001
	DBFLAG_SchemaKnownOk                  = 0x0010
	DBFLAG_Vacuum                         = 0x0004
	DBFLAG_VacuumInto                     = 0x0008
	DB_ResetWanted                        = 0x0008
	DB_SchemaLoaded                       = 0x0001
	DB_UnresetViews                       = 0x0002
	ENAME_NAME                            = 0
	ENAME_SPAN                            = 1
	ENAME_TAB                             = 2
	EP_Agg                                = 0x000010
	EP_CanBeNull                          = 0x100000
	EP_Collate                            = 0x000100
	EP_Commuted                           = 0x000200
	EP_ConstFunc                          = 0x080000
	EP_DblQuoted                          = 0x000040
	EP_Distinct                           = 0x000002
	EP_FixedCol                           = 0x000008
	EP_FromDDL                            = 0x40000000
	EP_FromJoin                           = 0x000001
	EP_HasFunc                            = 0x000004
	EP_IfNullRow                          = 0x020000
	EP_Immutable                          = 0x02
	EP_InfixFunc                          = 0x000080
	EP_IntValue                           = 0x000400
	EP_IsFalse                            = 0x20000000
	EP_IsTrue                             = 0x10000000
	EP_Leaf                               = 0x800000
	EP_MemToken                           = 0x010000
	EP_NoReduce                           = 0x01
	EP_Propagate                          = 2097412
	EP_Quoted                             = 0x4000000
	EP_Reduced                            = 0x002000
	EP_Skip                               = 0x001000
	EP_Static                             = 0x8000000
	EP_Subquery                           = 0x200000
	EP_Subrtn                             = 0x2000000
	EP_TokenOnly                          = 0x004000
	EP_Unlikely                           = 0x040000
	EP_VarSelect                          = 0x000020
	EP_Win                                = 0x008000
	EP_WinFunc                            = 0x1000000
	EP_xIsSelect                          = 0x000800
	EXCLUSIVE_LOCK                        = 4
	EXPRDUP_REDUCE                        = 0x0001
	GCC_VERSION                           = 4002001
	HAVE_DLFCN_H                          = 1
	HAVE_FCHOWN                           = 1
	HAVE_FDATASYNC                        = 1
	HAVE_GMTIME_R                         = 1
	HAVE_INT16_T                          = 1
	HAVE_INT32_T                          = 1
	HAVE_INT64_T                          = 1
	HAVE_INT8_T                           = 1
	HAVE_INTPTR_T                         = 1
	HAVE_INTTYPES_H                       = 1
	HAVE_ISNAN                            = 1
	HAVE_LOCALTIME_R                      = 1
	HAVE_LSTAT                            = 1
	HAVE_MALLOC_H                         = 1
	HAVE_MALLOC_USABLE_SIZE               = 1
	HAVE_MEMORY_H                         = 1
	HAVE_PREAD                            = 1
	HAVE_PWRITE                           = 1
	HAVE_READLINK                         = 1
	HAVE_STDINT_H                         = 1
	HAVE_STDLIB_H                         = 1
	HAVE_STRCHRNUL                        = 1
	HAVE_STRINGS_H                        = 1
	HAVE_STRING_H                         = 1
	HAVE_SYS_STAT_H                       = 1
	HAVE_SYS_TYPES_H                      = 1
	HAVE_UINT16_T                         = 1
	HAVE_UINT32_T                         = 1
	HAVE_UINT64_T                         = 1
	HAVE_UINT8_T                          = 1
	HAVE_UINTPTR_T                        = 1
	HAVE_UNISTD_H                         = 1
	HAVE_UTIME                            = 1
	INITFLAG_AlterAdd                     = 0x0003
	INITFLAG_AlterDrop                    = 0x0002
	INITFLAG_AlterMask                    = 0x0003
	INITFLAG_AlterRename                  = 0x0001
	INLINEFUNC_affinity                   = 4
	INLINEFUNC_coalesce                   = 0
	INLINEFUNC_expr_compare               = 3
	INLINEFUNC_expr_implies_expr          = 2
	INLINEFUNC_iif                        = 5
	INLINEFUNC_implies_nonnull_row        = 1
	INLINEFUNC_unlikely                   = 99
	INT16_MAX                             = 0x7fff
	INT16_MIN                             = -32768
	INT32_MAX                             = 0x7fffffff
	INT32_MIN                             = -2147483648
	INT64_MAX                             = 0x7fffffffffffffff
	INT64_MIN                             = -9223372036854775808
	INT8_MAX                              = 0x7f
	INT8_MIN                              = -128
	INTMAX_MAX                            = 9223372036854775807
	INTMAX_MIN                            = -9223372036854775808
	INTPTR_MAX                            = 9223372036854775807
	INTPTR_MIN                            = -9223372036854775808
	INT_FAST16_MAX                        = 2147483647
	INT_FAST16_MIN                        = -2147483648
	INT_FAST32_MAX                        = 2147483647
	INT_FAST32_MIN                        = -2147483648
	INT_FAST64_MAX                        = 9223372036854775807
	INT_FAST64_MIN                        = -9223372036854775808
	INT_FAST8_MAX                         = 2147483647
	INT_FAST8_MIN                         = -2147483648
	INT_LEAST16_MAX                       = 32767
	INT_LEAST16_MIN                       = -32768
	INT_LEAST32_MAX                       = 2147483647
	INT_LEAST32_MIN                       = -2147483648
	INT_LEAST64_MAX                       = 9223372036854775807
	INT_LEAST64_MIN                       = -9223372036854775808
	INT_LEAST8_MAX                        = 127
	INT_LEAST8_MIN                        = -128
	IN_INDEX_EPH                          = 2
	IN_INDEX_INDEX_ASC                    = 3
	IN_INDEX_INDEX_DESC                   = 4
	IN_INDEX_LOOP                         = 0x0004
	IN_INDEX_MEMBERSHIP                   = 0x0002
	IN_INDEX_NOOP                         = 5
	IN_INDEX_NOOP_OK                      = 0x0001
	IN_INDEX_ROWID                        = 1
	JT_CROSS                              = 0x0002
	JT_ERROR                              = 0x0040
	JT_INNER                              = 0x0001
	JT_LEFT                               = 0x0008
	JT_NATURAL                            = 0x0004
	JT_OUTER                              = 0x0020
	JT_RIGHT                              = 0x0010
	KEYINFO_ORDER_BIGNULL                 = 0x02
	KEYINFO_ORDER_DESC                    = 0x01
	LEGACY_SCHEMA_TABLE                   = "sqlite_master"
	LEGACY_TEMP_SCHEMA_TABLE              = "sqlite_temp_master"
	LOCATE_NOERR                          = 0x02
	LOCATE_VIEW                           = 0x01
	LOOKASIDE_SMALL                       = 128
	LT_OBJDIR                             = ".libs/"
	M10d_Any                              = 1
	M10d_No                               = 2
	M10d_Yes                              = 0
	MEMTYPE_HEAP                          = 0x01
	MEMTYPE_LOOKASIDE                     = 0x02
	MEMTYPE_PCACHE                        = 0x04
	MSVC_VERSION                          = 0
	NC_AllowAgg                           = 0x000001
	NC_AllowWin                           = 0x004000
	NC_Complex                            = 0x002000
	NC_FromDDL                            = 0x040000
	NC_GenCol                             = 0x000008
	NC_HasAgg                             = 0x000010
	NC_HasWin                             = 0x008000
	NC_IdxExpr                            = 0x000020
	NC_InAggFunc                          = 0x020000
	NC_IsCheck                            = 0x000004
	NC_IsDDL                              = 0x010000
	NC_MinMaxAgg                          = 0x001000
	NC_NoSelect                           = 0x080000
	NC_OrderAgg                           = 0x8000000
	NC_PartIdx                            = 0x000002
	NC_SelfRef                            = 0x00002e
	NC_UAggInfo                           = 0x000100
	NC_UBaseReg                           = 0x000400
	NC_UEList                             = 0x000080
	NC_UUpsert                            = 0x000200
	NC_VarSelect                          = 0x000040
	NO_LOCK                               = 0
	OE_Abort                              = 2
	OE_Cascade                            = 10
	OE_Default                            = 11
	OE_Fail                               = 3
	OE_Ignore                             = 4
	OE_None                               = 0
	OE_Replace                            = 5
	OE_Restrict                           = 7
	OE_Rollback                           = 1
	OE_SetDflt                            = 9
	OE_SetNull                            = 8
	OE_Update                             = 6
	OMIT_TEMPDB                           = 0
	ONEPASS_MULTI                         = 2
	ONEPASS_OFF                           = 0
	ONEPASS_SINGLE                        = 1
	OPFLAG_APPEND                         = 0x08
	OPFLAG_AUXDELETE                      = 0x04
	OPFLAG_BULKCSR                        = 0x01
	OPFLAG_EPHEM                          = 0x01
	OPFLAG_FORDELETE                      = 0x08
	OPFLAG_ISNOOP                         = 0x40
	OPFLAG_ISUPDATE                       = 0x04
	OPFLAG_LASTROWID                      = 0x20
	OPFLAG_LENGTHARG                      = 0x40
	OPFLAG_NCHANGE                        = 0x01
	OPFLAG_NOCHNG                         = 0x01
	OPFLAG_NOCHNG_MAGIC                   = 0x6d
	OPFLAG_P2ISREG                        = 0x10
	OPFLAG_PERMUTE                        = 0x01
	OPFLAG_PREFORMAT                      = 0x80
	OPFLAG_SAVEPOSITION                   = 0x02
	OPFLAG_SEEKEQ                         = 0x02
	OPFLAG_TYPEOFARG                      = 0x80
	OPFLAG_USESEEKRESULT                  = 0x10
	OPFLG_IN1                             = 0x02
	OPFLG_IN2                             = 0x04
	OPFLG_IN3                             = 0x08
	OPFLG_JUMP                            = 0x01
	OPFLG_OUT2                            = 0x10
	OPFLG_OUT3                            = 0x20
	OP_Abortable                          = 181
	OP_Add                                = 106
	OP_AddImm                             = 84
	OP_Affinity                           = 94
	OP_AggFinal                           = 163
	OP_AggInverse                         = 159
	OP_AggStep                            = 160
	OP_AggStep1                           = 161
	OP_AggValue                           = 162
	OP_And                                = 44
	OP_AutoCommit                         = 1
	OP_BitAnd                             = 102
	OP_BitNot                             = 113
	OP_BitOr                              = 103
	OP_Blob                               = 75
	OP_Cast                               = 86
	OP_Checkpoint                         = 6
	OP_ChngCntRow                         = 81
	OP_Clear                              = 143
	OP_Close                              = 120
	OP_CollSeq                            = 83
	OP_Column                             = 92
	OP_ColumnsUsed                        = 121
	OP_Compare                            = 88
	OP_Concat                             = 111
	OP_Copy                               = 78
	OP_Count                              = 96
	OP_CreateBtree                        = 145
	OP_CursorHint                         = 177
	OP_CursorLock                         = 165
	OP_CursorUnlock                       = 166
	OP_DecrJumpZero                       = 60
	OP_DeferredSeek                       = 139
	OP_Delete                             = 128
	OP_Destroy                            = 142
	OP_Divide                             = 109
	OP_DropIndex                          = 150
	OP_DropTable                          = 149
	OP_DropTrigger                        = 151
	OP_ElseEq                             = 58
	OP_EndCoroutine                       = 67
	OP_Eq                                 = 53
	OP_Expire                             = 164
	OP_Explain                            = 180
	OP_FinishSeek                         = 141
	OP_FkCounter                          = 156
	OP_FkIfZero                           = 48
	OP_Found                              = 31
	OP_Function                           = 65
	OP_Ge                                 = 57
	OP_Gosub                              = 12
	OP_Goto                               = 11
	OP_Gt                                 = 54
	OP_Halt                               = 69
	OP_HaltIfNull                         = 68
	OP_IdxDelete                          = 138
	OP_IdxGE                              = 42
	OP_IdxGT                              = 40
	OP_IdxInsert                          = 136
	OP_IdxLE                              = 39
	OP_IdxLT                              = 41
	OP_IdxRowid                           = 140
	OP_If                                 = 18
	OP_IfNoHope                           = 28
	OP_IfNot                              = 20
	OP_IfNotOpen                          = 27
	OP_IfNotZero                          = 59
	OP_IfNullRow                          = 22
	OP_IfPos                              = 49
	OP_IfSmaller                          = 35
	OP_IncrVacuum                         = 61
	OP_Init                               = 63
	OP_InitCoroutine                      = 13
	OP_Insert                             = 126
	OP_Int64                              = 71
	OP_IntCopy                            = 80
	OP_Integer                            = 70
	OP_IntegrityCk                        = 153
	OP_IsNull                             = 50
	OP_IsNullOrType                       = 21
	OP_IsTrue                             = 89
	OP_JournalMode                        = 7
	OP_Jump                               = 16
	OP_Last                               = 34
	OP_Le                                 = 55
	OP_LoadAnalysis                       = 148
	OP_Lt                                 = 56
	OP_MakeRecord                         = 95
	OP_MaxPgcnt                           = 175
	OP_MemMax                             = 157
	OP_Move                               = 77
	OP_Multiply                           = 108
	OP_MustBeInt                          = 15
	OP_Ne                                 = 52
	OP_NewRowid                           = 125
	OP_Next                               = 5
	OP_NoConflict                         = 29
	OP_Noop                               = 179
	OP_Not                                = 19
	OP_NotExists                          = 33
	OP_NotFound                           = 30
	OP_NotNull                            = 51
	OP_Null                               = 73
	OP_NullRow                            = 134
	OP_Offset                             = 91
	OP_OffsetLimit                        = 158
	OP_Once                               = 17
	OP_OpenAutoindex                      = 114
	OP_OpenDup                            = 112
	OP_OpenEphemeral                      = 115
	OP_OpenPseudo                         = 119
	OP_OpenRead                           = 100
	OP_OpenWrite                          = 101
	OP_Or                                 = 43
	OP_Pagecount                          = 174
	OP_Param                              = 155
	OP_ParseSchema                        = 147
	OP_Permutation                        = 87
	OP_Prev                               = 4
	OP_Program                            = 47
	OP_PureFunc                           = 64
	OP_ReadCookie                         = 97
	OP_Real                               = 152
	OP_RealAffinity                       = 85
	OP_ReleaseReg                         = 178
	OP_Remainder                          = 110
	OP_ReopenIdx                          = 99
	OP_ResetCount                         = 129
	OP_ResetSorter                        = 144
	OP_ResultRow                          = 82
	OP_Return                             = 66
	OP_Rewind                             = 38
	OP_RowCell                            = 127
	OP_RowData                            = 132
	OP_RowSetAdd                          = 154
	OP_RowSetRead                         = 45
	OP_RowSetTest                         = 46
	OP_Rowid                              = 133
	OP_SCopy                              = 79
	OP_Savepoint                          = 0
	OP_SeekEnd                            = 135
	OP_SeekGE                             = 25
	OP_SeekGT                             = 26
	OP_SeekHit                            = 123
	OP_SeekLE                             = 24
	OP_SeekLT                             = 23
	OP_SeekRowid                          = 32
	OP_SeekScan                           = 122
	OP_Sequence                           = 124
	OP_SequenceTest                       = 118
	OP_SetCookie                          = 98
	OP_ShiftLeft                          = 104
	OP_ShiftRight                         = 105
	OP_SoftNull                           = 74
	OP_Sort                               = 37
	OP_SorterCompare                      = 130
	OP_SorterData                         = 131
	OP_SorterInsert                       = 137
	OP_SorterNext                         = 3
	OP_SorterOpen                         = 117
	OP_SorterSort                         = 36
	OP_SqlExec                            = 146
	OP_String                             = 72
	OP_String8                            = 116
	OP_Subtract                           = 107
	OP_TableLock                          = 167
	OP_Trace                              = 176
	OP_Transaction                        = 2
	OP_TypeCheck                          = 93
	OP_VBegin                             = 168
	OP_VColumn                            = 172
	OP_VCreate                            = 169
	OP_VDestroy                           = 170
	OP_VFilter                            = 9
	OP_VNext                              = 62
	OP_VOpen                              = 171
	OP_VRename                            = 173
	OP_VUpdate                            = 10
	OP_Vacuum                             = 8
	OP_Variable                           = 76
	OP_Yield                              = 14
	OP_ZeroOrNull                         = 90
	OS_VXWORKS                            = 0
	P4_ADVANCE                            = -5
	P4_COLLSEQ                            = -2
	P4_DYNAMIC                            = -7
	P4_DYNBLOB                            = -17
	P4_EXPR                               = -10
	P4_FREE_IF_LE                         = -7
	P4_FUNCCTX                            = -16
	P4_FUNCDEF                            = -8
	P4_INT32                              = -3
	P4_INT64                              = -14
	P4_INTARRAY                           = -15
	P4_KEYINFO                            = -9
	P4_MEM                                = -11
	P4_NOTUSED                            = 0
	P4_REAL                               = -13
	P4_STATIC                             = -1
	P4_SUBPROGRAM                         = -4
	P4_TABLE                              = -6
	P4_TRANSIENT                          = 0
	P4_VTAB                               = -12
	P5_ConstraintCheck                    = 3
	P5_ConstraintFK                       = 4
	P5_ConstraintNotNull                  = 1
	P5_ConstraintUnique                   = 2
	PACKAGE_BUGREPORT                     = ""
	PACKAGE_NAME                          = "sqlite"
	PACKAGE_STRING                        = "sqlite 3.37.0"
	PACKAGE_TARNAME                       = "sqlite"
	PACKAGE_VERSION                       = "3.37.0"
	PAGER_CACHESPILL                      = 0x20
	PAGER_CKPT_FULLFSYNC                  = 0x10
	PAGER_FLAGS_MASK                      = 0x38
	PAGER_FULLFSYNC                       = 0x08
	PAGER_GET_NOCONTENT                   = 0x01
	PAGER_GET_READONLY                    = 0x02
	PAGER_JOURNALMODE_DELETE              = 0
	PAGER_JOURNALMODE_MEMORY              = 4
	PAGER_JOURNALMODE_OFF                 = 2
	PAGER_JOURNALMODE_PERSIST             = 1
	PAGER_JOURNALMODE_QUERY               = -1
	PAGER_JOURNALMODE_TRUNCATE            = 3
	PAGER_JOURNALMODE_WAL                 = 5
	PAGER_LOCKINGMODE_EXCLUSIVE           = 1
	PAGER_LOCKINGMODE_NORMAL              = 0
	PAGER_LOCKINGMODE_QUERY               = -1
	PAGER_MEMORY                          = 0x0002
	PAGER_OMIT_JOURNAL                    = 0x0001
	PAGER_SYNCHRONOUS_EXTRA               = 0x04
	PAGER_SYNCHRONOUS_FULL                = 0x03
	PAGER_SYNCHRONOUS_MASK                = 0x07
	PAGER_SYNCHRONOUS_NORMAL              = 0x02
	PAGER_SYNCHRONOUS_OFF                 = 0x01
	PARSE_MODE_DECLARE_VTAB               = 1
	PARSE_MODE_NORMAL                     = 0
	PARSE_MODE_RENAME                     = 2
	PARSE_MODE_UNMAP                      = 3
	PENDING_LOCK                          = 3
	PGHDR_CLEAN                           = 0x001
	PGHDR_DIRTY                           = 0x002
	PGHDR_DONT_WRITE                      = 0x010
	PGHDR_MMAP                            = 0x020
	PGHDR_NEED_SYNC                       = 0x008
	PGHDR_WAL_APPEND                      = 0x040
	PGHDR_WRITEABLE                       = 0x004
	PREFERRED_SCHEMA_TABLE                = "sqlite_schema"
	PREFERRED_TEMP_SCHEMA_TABLE           = "sqlite_temp_schema"
	PRIX16                                = "X"
	PRIX32                                = "X"
	PRIX8                                 = "X"
	PRIXFAST16                            = "X"
	PRIXFAST32                            = "X"
	PRIXFAST8                             = "X"
	PRIXLEAST16                           = "X"
	PRIXLEAST32                           = "X"
	PRIXLEAST8                            = "X"
	PRIXMAX                               = "jX"
	PRId16                                = "d"
	PRId32                                = "d"
	PRId8                                 = "d"
	PRIdFAST16                            = "d"
	PRIdFAST32                            = "d"
	PRIdFAST8                             = "d"
	PRIdLEAST16                           = "d"
	PRIdLEAST32                           = "d"
	PRIdLEAST8                            = "d"
	PRIdMAX                               = "jd"
	PRIi16                                = "i"
	PRIi32                                = "i"
	PRIi8                                 = "i"
	PRIiFAST16                            = "i"
	PRIiFAST32                            = "i"
	PRIiFAST8                             = "i"
	PRIiLEAST16                           = "i"
	PRIiLEAST32                           = "i"
	PRIiLEAST8                            = "i"
	PRIiMAX                               = "ji"
	PRIo16                                = "o"
	PRIo32                                = "o"
	PRIo8                                 = "o"
	PRIoFAST16                            = "o"
	PRIoFAST32                            = "o"
	PRIoFAST8                             = "o"
	PRIoLEAST16                           = "o"
	PRIoLEAST32                           = "o"
	PRIoLEAST8                            = "o"
	PRIoMAX                               = "jo"
	PRIu16                                = "u"
	PRIu32                                = "u"
	PRIu8                                 = "u"
	PRIuFAST16                            = "u"
	PRIuFAST32                            = "u"
	PRIuFAST8                             = "u"
	PRIuLEAST16                           = "u"
	PRIuLEAST32                           = "u"
	PRIuLEAST8                            = "u"
	PRIuMAX                               = "ju"
	PRIx16                                = "x"
	PRIx32                                = "x"
	PRIx8                                 = "x"
	PRIxFAST16                            = "x"
	PRIxFAST32                            = "x"
	PRIxFAST8                             = "x"
	PRIxLEAST16                           = "x"
	PRIxLEAST32                           = "x"
	PRIxLEAST8                            = "x"
	PRIxMAX                               = "jx"
	PTRDIFF_MAX                           = 9223372036854775807
	PTRDIFF_MIN                           = -9223372036854775808
	RESERVED_LOCK                         = 2
	RSIZE_MAX                             = 9223372036854775807
	SAVEPOINT_BEGIN                       = 0
	SAVEPOINT_RELEASE                     = 1
	SAVEPOINT_ROLLBACK                    = 2
	SCHEMA_ROOT                           = 1
	SCNd16                                = "hd"
	SCNd32                                = "d"
	SCNd8                                 = "hhd"
	SCNdFAST16                            = "d"
	SCNdFAST32                            = "d"
	SCNdFAST8                             = "d"
	SCNdLEAST16                           = "hd"
	SCNdLEAST32                           = "d"
	SCNdLEAST8                            = "hhd"
	SCNdMAX                               = "jd"
	SCNi16                                = "hi"
	SCNi32                                = "i"
	SCNi8                                 = "hhi"
	SCNiFAST16                            = "i"
	SCNiFAST32                            = "i"
	SCNiFAST8                             = "i"
	SCNiLEAST16                           = "hi"
	SCNiLEAST32                           = "i"
	SCNiLEAST8                            = "hhi"
	SCNiMAX                               = "ji"
	SCNo16                                = "ho"
	SCNo32                                = "o"
	SCNo8                                 = "hho"
	SCNoFAST16                            = "o"
	SCNoFAST32                            = "o"
	SCNoFAST8                             = "o"
	SCNoLEAST16                           = "ho"
	SCNoLEAST32                           = "o"
	SCNoLEAST8                            = "hho"
	SCNoMAX                               = "jo"
	SCNu16                                = "hu"
	SCNu32                                = "u"
	SCNu8                                 = "hhu"
	SCNuFAST16                            = "u"
	SCNuFAST32                            = "u"
	SCNuFAST8                             = "u"
	SCNuLEAST16                           = "hu"
	SCNuLEAST32                           = "u"
	SCNuLEAST8                            = "hhu"
	SCNuMAX                               = "ju"
	SCNx16                                = "hx"
	SCNx32                                = "x"
	SCNx8                                 = "hhx"
	SCNxFAST16                            = "x"
	SCNxFAST32                            = "x"
	SCNxFAST8                             = "x"
	SCNxLEAST16                           = "hx"
	SCNxLEAST32                           = "x"
	SCNxLEAST8                            = "hhx"
	SCNxMAX                               = "jx"
	SELECTTRACE_ENABLED                   = 0
	SF_Aggregate                          = 0x0000008
	SF_All                                = 0x0000002
	SF_ComplexResult                      = 0x0040000
	SF_Compound                           = 0x0000100
	SF_Converted                          = 0x0010000
	SF_CopyCte                            = 0x4000000
	SF_Distinct                           = 0x0000001
	SF_Expanded                           = 0x0000040
	SF_FixedLimit                         = 0x0004000
	SF_HasAgg                             = 0x0000010
	SF_HasTypeInfo                        = 0x0000080
	SF_IncludeHidden                      = 0x0020000
	SF_MaybeConvert                       = 0x0008000
	SF_MinMaxAgg                          = 0x0001000
	SF_MultiPart                          = 0x2000000
	SF_MultiValue                         = 0x0000400
	SF_NestedFrom                         = 0x0000800
	SF_NoopOrderBy                        = 0x0400000
	SF_OrderByReqd                        = 0x8000000
	SF_PushDown                           = 0x1000000
	SF_Recursive                          = 0x0002000
	SF_Resolved                           = 0x0000004
	SF_UFSrcCheck                         = 0x0800000
	SF_UsesEphemeral                      = 0x0000020
	SF_Values                             = 0x0000200
	SF_View                               = 0x0200000
	SF_WhereBegin                         = 0x0080000
	SF_WinRewrite                         = 0x0100000
	SHARED_LOCK                           = 1
	SHARED_SIZE                           = 510
	SIG_ATOMIC_MAX                        = 9223372036854775807
	SIG_ATOMIC_MIN                        = -9223372036854775808
	SIZE_MAX                              = 18446744073709551615
	SQLITECONFIG_H                        = 1
	SQLITEINT_H                           = 0
	SQLITE_AFF_BLOB                       = 0x41
	SQLITE_AFF_INTEGER                    = 0x44
	SQLITE_AFF_MASK                       = 0x47
	SQLITE_AFF_NONE                       = 0x40
	SQLITE_AFF_NUMERIC                    = 0x43
	SQLITE_AFF_REAL                       = 0x45
	SQLITE_AFF_TEXT                       = 0x42
	SQLITE_ASCII                          = 1
	SQLITE_ATOMIC_INTRINSICS              = 0
	SQLITE_AllOpts                        = 0xffffffff
	SQLITE_AutoIndex                      = 0x00008000
	SQLITE_BIGENDIAN                      = 0
	SQLITE_BTREE_H                        = 0
	SQLITE_BYTEORDER                      = 1234
	SQLITE_CacheSpill                     = 0x00000020
	SQLITE_CellSizeCk                     = 0x00200000
	SQLITE_CkptFullFSync                  = 0x00000010
	SQLITE_CountOfView                    = 0x00000200
	SQLITE_CoverIdxScan                   = 0x00000020
	SQLITE_CursorHints                    = 0x00000400
	SQLITE_DEFAULT_AUTOVACUUM             = 0
	SQLITE_DEFAULT_CACHE_SIZE             = -2000
	SQLITE_DEFAULT_FILE_FORMAT            = 4
	SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT     = -1
	SQLITE_DEFAULT_MMAP_SIZE              = 0
	SQLITE_DEFAULT_PCACHE_INITSZ          = 20
	SQLITE_DEFAULT_RECURSIVE_TRIGGERS     = 0
	SQLITE_DEFAULT_SECTOR_SIZE            = 4096
	SQLITE_DEFAULT_SORTERREF_SIZE         = 0x7fffffff
	SQLITE_DEFAULT_SYNCHRONOUS            = 2
	SQLITE_DEFAULT_WAL_AUTOCHECKPOINT     = 1000
	SQLITE_DEFAULT_WAL_SYNCHRONOUS        = 2
	SQLITE_DEFAULT_WORKER_THREADS         = 0
	SQLITE_Defensive                      = 0x10000000
	SQLITE_DeferFKs                       = 0x00080000
	SQLITE_DistinctOpt                    = 0x00000010
	SQLITE_DqsDDL                         = 0x20000000
	SQLITE_DqsDML                         = 0x40000000
	SQLITE_ECEL_DUP                       = 0x01
	SQLITE_ECEL_FACTOR                    = 0x02
	SQLITE_ECEL_OMITREF                   = 0x08
	SQLITE_ECEL_REF                       = 0x04
	SQLITE_EnableQPSG                     = 0x00800000
	SQLITE_EnableTrigger                  = 0x00040000
	SQLITE_EnableView                     = 0x80000000
	SQLITE_FAULTINJECTOR_COUNT            = 1
	SQLITE_FAULTINJECTOR_MALLOC           = 0
	SQLITE_FCNTL_DB_UNCHANGED             = 0xca093fa0
	SQLITE_FUNC_ANYORDER                  = 0x08000000
	SQLITE_FUNC_BUILTIN                   = 0x00800000
	SQLITE_FUNC_CASE                      = 0x0008
	SQLITE_FUNC_CONSTANT                  = 0x0800
	SQLITE_FUNC_COUNT                     = 0x0100
	SQLITE_FUNC_DIRECT                    = 0x00080000
	SQLITE_FUNC_ENCMASK                   = 0x0003
	SQLITE_FUNC_EPHEM                     = 0x0010
	SQLITE_FUNC_HASH_SZ                   = 23
	SQLITE_FUNC_INLINE                    = 0x00400000
	SQLITE_FUNC_INTERNAL                  = 0x00040000
	SQLITE_FUNC_LENGTH                    = 0x0040
	SQLITE_FUNC_LIKE                      = 0x0004
	SQLITE_FUNC_MINMAX                    = 0x1000
	SQLITE_FUNC_NEEDCOLL                  = 0x0020
	SQLITE_FUNC_OFFSET                    = 0x8000
	SQLITE_FUNC_SLOCHNG                   = 0x2000
	SQLITE_FUNC_SUBTYPE                   = 0x00100000
	SQLITE_FUNC_TEST                      = 0x4000
	SQLITE_FUNC_TYPEOF                    = 0x0080
	SQLITE_FUNC_UNLIKELY                  = 0x0400
	SQLITE_FUNC_UNSAFE                    = 0x00200000
	SQLITE_FUNC_WINDOW                    = 0x00010000
	SQLITE_FactorOutConst                 = 0x00000008
	SQLITE_ForeignKeys                    = 0x00004000
	SQLITE_Fts3Tokenizer                  = 0x00400000
	SQLITE_FullColNames                   = 0x00000004
	SQLITE_FullFSync                      = 0x00000008
	SQLITE_GroupByOrder                   = 0x00000004
	SQLITE_HASH_H                         = 0
	SQLITE_HAVE_C99_MATH_FUNCS            = 1
	SQLITE_HAVE_OS_TRACE                  = 0
	SQLITE_IDXTYPE_APPDEF                 = 0
	SQLITE_IDXTYPE_IPK                    = 3
	SQLITE_IDXTYPE_PRIMARYKEY             = 2
	SQLITE_IDXTYPE_UNIQUE                 = 1
	SQLITE_IOERR_NOMEM_BKPT               = 3082
	SQLITE_IgnoreChecks                   = 0x00000200
	SQLITE_JUMPIFNULL                     = 0x10
	SQLITE_LITTLEENDIAN                   = 1
	SQLITE_LegacyAlter                    = 0x04000000
	SQLITE_LegacyFileFmt                  = 0x00000002
	SQLITE_LoadExtFunc                    = 0x00020000
	SQLITE_LoadExtension                  = 0x00010000
	SQLITE_MALLOC_SOFT_LIMIT              = 1024
	SQLITE_MAX_ATTACHED                   = 10
	SQLITE_MAX_COLUMN                     = 2000
	SQLITE_MAX_COMPOUND_SELECT            = 500
	SQLITE_MAX_DB                         = 12
	SQLITE_MAX_DEFAULT_PAGE_SIZE          = 8192
	SQLITE_MAX_EXPR_DEPTH                 = 1000
	SQLITE_MAX_FILE_FORMAT                = 4
	SQLITE_MAX_FUNCTION_ARG               = 127
	SQLITE_MAX_LENGTH                     = 1000000000
	SQLITE_MAX_LIKE_PATTERN_LENGTH        = 50000
	SQLITE_MAX_MMAP_SIZE                  = 0x7fff0000
	SQLITE_MAX_PAGE_COUNT                 = 1073741823
	SQLITE_MAX_PAGE_SIZE                  = 65536
	SQLITE_MAX_PATHLEN                    = 1024
	SQLITE_MAX_SQL_LENGTH                 = 1000000000
	SQLITE_MAX_TRIGGER_DEPTH              = 1000
	SQLITE_MAX_VARIABLE_NUMBER            = 32766
	SQLITE_MAX_VDBE_OP                    = 250000000
	SQLITE_MAX_WORKER_THREADS             = 8
	SQLITE_MSVC_H                         = 0
	SQLITE_MX_JUMP_OPCODE                 = 63
	SQLITE_MinMaxOpt                      = 0x00010000
	SQLITE_NEED_ERR_NAME                  = 0
	SQLITE_NOMEM_BKPT                     = 7
	SQLITE_NOTNULL                        = 0x90
	SQLITE_NTUNE                          = 6
	SQLITE_NULLEQ                         = 0x80
	SQLITE_N_BTREE_META                   = 16
	SQLITE_N_LIMIT                        = 12
	SQLITE_N_STDTYPE                      = 6
	SQLITE_NoCkptOnClose                  = 0x00000800
	SQLITE_NoSchemaError                  = 0x08000000
	SQLITE_NullCallback                   = 0x00000100
	SQLITE_OS_OTHER                       = 0
	SQLITE_OS_SETUP_H                     = 0
	SQLITE_OS_UNIX                        = 1
	SQLITE_OS_WIN                         = 0
	SQLITE_OmitNoopJoin                   = 0x00000100
	SQLITE_OmitOrderBy                    = 0x00040000
	SQLITE_OrderByIdxJoin                 = 0x00000040
	SQLITE_PAGER_H                        = 0
	SQLITE_POWERSAFE_OVERWRITE            = 1
	SQLITE_PREPARE_MASK                   = 0x0f
	SQLITE_PREPARE_SAVESQL                = 0x80
	SQLITE_PRINTF_INTERNAL                = 0x01
	SQLITE_PRINTF_MALLOCED                = 0x04
	SQLITE_PRINTF_SQLFUNC                 = 0x02
	SQLITE_PTRSIZE                        = 8
	SQLITE_PropagateConst                 = 0x00008000
	SQLITE_PushDown                       = 0x00001000
	SQLITE_QueryFlattener                 = 0x00000001
	SQLITE_QueryOnly                      = 0x00100000
	SQLITE_ReadUncommit                   = 0x00000400
	SQLITE_RecTriggers                    = 0x00002000
	SQLITE_ResetDatabase                  = 0x02000000
	SQLITE_ReverseOrder                   = 0x00001000
	SQLITE_SO_ASC                         = 0
	SQLITE_SO_DESC                        = 1
	SQLITE_SO_UNDEFINED                   = -1
	SQLITE_STATE_BUSY                     = 0x6d
	SQLITE_STATE_CLOSED                   = 0xce
	SQLITE_STATE_ERROR                    = 0xd5
	SQLITE_STATE_OPEN                     = 0x76
	SQLITE_STATE_SICK                     = 0xba
	SQLITE_STATE_ZOMBIE                   = 0xa7
	SQLITE_SYSTEM_MALLOC                  = 1
	SQLITE_SeekScan                       = 0x00020000
	SQLITE_ShortColNames                  = 0x00000040
	SQLITE_SimplifyJoin                   = 0x00002000
	SQLITE_SkipScan                       = 0x00004000
	SQLITE_Stat4                          = 0x00000800
	SQLITE_TEMP_FILE_PREFIX               = "etilqs_"
	SQLITE_TOKEN_KEYWORD                  = 0x2
	SQLITE_TOKEN_QUOTED                   = 0x1
	SQLITE_TRACE_LEGACY                   = 0x40
	SQLITE_TRACE_NONLEGACY_MASK           = 0x0f
	SQLITE_TRACE_XPROFILE                 = 0x80
	SQLITE_Transitive                     = 0x00000080
	SQLITE_TriggerEQP                     = 0x01000000
	SQLITE_TrustedSchema                  = 0x00000080
	SQLITE_UTF16NATIVE                    = 2
	SQLITE_VDBE_H                         = 0
	SQLITE_VTABRISK_High                  = 2
	SQLITE_VTABRISK_Low                   = 0
	SQLITE_VTABRISK_Normal                = 1
	SQLITE_WSD                            = 0
	SQLITE_WindowFunc                     = 0x00000002
	SQLITE_WriteSchema                    = 0x00000001
	SRT_Coroutine                         = 13
	SRT_Discard                           = 4
	SRT_DistFifo                          = 5
	SRT_DistQueue                         = 6
	SRT_EphemTab                          = 12
	SRT_Except                            = 2
	SRT_Exists                            = 3
	SRT_Fifo                              = 8
	SRT_Mem                               = 10
	SRT_Output                            = 9
	SRT_Queue                             = 7
	SRT_Set                               = 11
	SRT_Table                             = 14
	SRT_Union                             = 1
	SRT_Upfrom                            = 15
	STDC_HEADERS                          = 1
	TABTYP_NORM                           = 0
	TABTYP_VIEW                           = 2
	TABTYP_VTAB                           = 1
	TF_Autoincrement                      = 0x00000008
	TF_Ephemeral                          = 0x00004000
	TF_Eponymous                          = 0x00008000
	TF_HasGenerated                       = 0x00000060
	TF_HasHidden                          = 0x00000002
	TF_HasNotNull                         = 0x00000800
	TF_HasPrimaryKey                      = 0x00000004
	TF_HasStat1                           = 0x00000010
	TF_HasStat4                           = 0x00002000
	TF_HasStored                          = 0x00000040
	TF_HasVirtual                         = 0x00000020
	TF_NoVisibleRowid                     = 0x00000200
	TF_OOOHidden                          = 0x00000400
	TF_Readonly                           = 0x00000001
	TF_Shadow                             = 0x00001000
	TF_StatsUsed                          = 0x00000100
	TF_Strict                             = 0x00010000
	TF_WithoutRowid                       = 0x00000080
	TK_ABORT                              = 27
	TK_ACTION                             = 28
	TK_ADD                                = 162
	TK_AFTER                              = 29
	TK_AGG_COLUMN                         = 168
	TK_AGG_FUNCTION                       = 167
	TK_ALL                                = 134
	TK_ALTER                              = 161
	TK_ALWAYS                             = 96
	TK_ANALYZE                            = 30
	TK_AND                                = 44
	TK_ANY                                = 101
	TK_AS                                 = 24
	TK_ASC                                = 31
	TK_ASTERISK                           = 179
	TK_ATTACH                             = 32
	TK_AUTOINCR                           = 125
	TK_BEFORE                             = 33
	TK_BEGIN                              = 5
	TK_BETWEEN                            = 48
	TK_BY                                 = 34
	TK_CASCADE                            = 35
	TK_CASE                               = 156
	TK_CAST                               = 36
	TK_CHECK                              = 123
	TK_COLLATE                            = 112
	TK_COLUMN                             = 166
	TK_COLUMNKW                           = 60
	TK_COMMIT                             = 10
	TK_CONFLICT                           = 37
	TK_CONSTRAINT                         = 118
	TK_CREATE                             = 17
	TK_CTIME_KW                           = 100
	TK_CURRENT                            = 85
	TK_DATABASE                           = 38
	TK_DEFAULT                            = 119
	TK_DEFERRABLE                         = 130
	TK_DEFERRED                           = 7
	TK_DELETE                             = 127
	TK_DESC                               = 39
	TK_DETACH                             = 40
	TK_DISTINCT                           = 139
	TK_DO                                 = 61
	TK_DROP                               = 132
	TK_EACH                               = 41
	TK_ELSE                               = 159
	TK_END                                = 11
	TK_ESCAPE                             = 58
	TK_EXCEPT                             = 135
	TK_EXCLUDE                            = 91
	TK_EXCLUSIVE                          = 9
	TK_EXISTS                             = 20
	TK_EXPLAIN                            = 2
	TK_FAIL                               = 42
	TK_FILTER                             = 165
	TK_FIRST                              = 83
	TK_FOLLOWING                          = 86
	TK_FOR                                = 62
	TK_FOREIGN                            = 131
	TK_FROM                               = 141
	TK_FUNCTION                           = 171
	TK_GENERATED                          = 95
	TK_GROUP                              = 145
	TK_GROUPS                             = 92
	TK_HAVING                             = 146
	TK_IF                                 = 18
	TK_IF_NULL_ROW                        = 178
	TK_IGNORE                             = 63
	TK_IMMEDIATE                          = 8
	TK_IN                                 = 49
	TK_INDEX                              = 160
	TK_INDEXED                            = 115
	TK_INITIALLY                          = 64
	TK_INSERT                             = 126
	TK_INSTEAD                            = 65
	TK_INTERSECT                          = 136
	TK_INTO                               = 150
	TK_IS                                 = 45
	TK_ISNOT                              = 170
	TK_ISNULL                             = 50
	TK_JOIN                               = 142
	TK_JOIN_KW                            = 117
	TK_KEY                                = 67
	TK_LAST                               = 84
	TK_LIKE_KW                            = 47
	TK_LIMIT                              = 147
	TK_MATCH                              = 46
	TK_MATERIALIZED                       = 97
	TK_NO                                 = 66
	TK_NOT                                = 19
	TK_NOTHING                            = 151
	TK_NOTNULL                            = 51
	TK_NULL                               = 120
	TK_NULLS                              = 82
	TK_OF                                 = 68
	TK_OFFSET                             = 69
	TK_ON                                 = 114
	TK_OR                                 = 43
	TK_ORDER                              = 144
	TK_OTHERS                             = 93
	TK_OVER                               = 164
	TK_PARTITION                          = 87
	TK_PLAN                               = 4
	TK_PRAGMA                             = 70
	TK_PRECEDING                          = 88
	TK_PRIMARY                            = 121
	TK_QUERY                              = 3
	TK_RAISE                              = 71
	TK_RANGE                              = 89
	TK_RECURSIVE                          = 72
	TK_REFERENCES                         = 124
	TK_REGISTER                           = 175
	TK_REINDEX                            = 98
	TK_RELEASE                            = 14
	TK_RENAME                             = 99
	TK_REPLACE                            = 73
	TK_RESTRICT                           = 74
	TK_RETURNING                          = 149
	TK_ROLLBACK                           = 12
	TK_ROW                                = 75
	TK_ROWS                               = 76
	TK_SAVEPOINT                          = 13
	TK_SELECT                             = 137
	TK_SELECT_COLUMN                      = 177
	TK_SET                                = 129
	TK_SPAN                               = 180
	TK_TABLE                              = 16
	TK_TEMP                               = 21
	TK_THEN                               = 158
	TK_TIES                               = 94
	TK_TO                                 = 15
	TK_TRANSACTION                        = 6
	TK_TRIGGER                            = 77
	TK_TRUEFALSE                          = 169
	TK_TRUTH                              = 174
	TK_UMINUS                             = 172
	TK_UNBOUNDED                          = 90
	TK_UNION                              = 133
	TK_UNIQUE                             = 122
	TK_UPDATE                             = 128
	TK_UPLUS                              = 173
	TK_USING                              = 143
	TK_VACUUM                             = 78
	TK_VALUES                             = 138
	TK_VECTOR                             = 176
	TK_VIEW                               = 79
	TK_VIRTUAL                            = 80
	TK_WHEN                               = 157
	TK_WHERE                              = 148
	TK_WINDOW                             = 163
	TK_WITH                               = 81
	TK_WITHOUT                            = 26
	TRIGGER_AFTER                         = 2
	TRIGGER_BEFORE                        = 1
	UINT16_MAX                            = 0xffff
	UINT32_MAX                            = 0xffffffff
	UINT64_MAX                            = 0xffffffffffffffff
	UINT8_MAX                             = 0xff
	UINTMAX_MAX                           = 18446744073709551615
	UINTPTR_MAX                           = 18446744073709551615
	UINT_FAST16_MAX                       = 4294967295
	UINT_FAST32_MAX                       = 4294967295
	UINT_FAST64_MAX                       = 18446744073709551615
	UINT_FAST8_MAX                        = 4294967295
	UINT_LEAST16_MAX                      = 65535
	UINT_LEAST32_MAX                      = 4294967295
	UINT_LEAST64_MAX                      = 18446744073709551615
	UINT_LEAST8_MAX                       = 255
	WCHAR_MAX                             = 2147483647
	WCHAR_MIN                             = -2147483648
	WHERE_AGG_DISTINCT                    = 0x0400
	WHERE_DISTINCTBY                      = 0x0080
	WHERE_DISTINCT_NOOP                   = 0
	WHERE_DISTINCT_ORDERED                = 2
	WHERE_DISTINCT_UNIQUE                 = 1
	WHERE_DISTINCT_UNORDERED              = 3
	WHERE_DUPLICATES_OK                   = 0x0010
	WHERE_GROUPBY                         = 0x0040
	WHERE_ONEPASS_DESIRED                 = 0x0004
	WHERE_ONEPASS_MULTIROW                = 0x0008
	WHERE_ORDERBY_LIMIT                   = 0x0800
	WHERE_ORDERBY_MAX                     = 0x0002
	WHERE_ORDERBY_MIN                     = 0x0001
	WHERE_ORDERBY_NORMAL                  = 0x0000
	WHERE_OR_SUBCLAUSE                    = 0x0020
	WHERE_SORTBYGROUP                     = 0x0200
	WHERE_USE_LIMIT                       = 0x4000
	WHERE_WANT_DISTINCT                   = 0x0100
	WINT_MAX                              = 2147483647
	WINT_MIN                              = -2147483648
	WRC_Abort                             = 2
	WRC_Continue                          = 0
	WRC_Prune                             = 1
	XN_EXPR                               = -2
	XN_ROWID                              = -1
	X_GNU_SOURCE                          = 0
	X_INTTYPES_H_                         = 0
	X_LARGEFILE_SOURCE                    = 1
	X_LARGE_FILE                          = 1
	X_MACHINE_INTTYPES_H_                 = 0
	X_MACHINE__STDINT_H_                  = 0
	X_SQLITE_OS_H_                        = 0
	X_SYS_STDINT_H_                       = 0
	X_XOPEN_SOURCE                        = 600
	SESSION_STREAM_TCL_VAR                = "sqlite3session_streams"
	BUS_ADRALN                            = 1
	BUS_ADRERR                            = 2
	BUS_OBJERR                            = 3
	BUS_OOMERR                            = 100
	CLD_CONTINUED                         = 6
	CLD_DUMPED                            = 3
	CLD_EXITED                            = 1
	CLD_KILLED                            = 2
	CLD_STOPPED                           = 5
	CLD_TRAPPED                           = 4
	FPE_FLTDIV                            = 3
	FPE_FLTINV                            = 7
	FPE_FLTOVF                            = 4
	FPE_FLTRES                            = 6
	FPE_FLTSUB                            = 8
	FPE_FLTUND                            = 5
	FPE_INTDIV                            = 2
	FPE_INTOVF                            = 1
	ILL_BADSTK                            = 8
	ILL_COPROC                            = 7
	ILL_ILLADR                            = 3
	ILL_ILLOPC                            = 1
	ILL_ILLOPN                            = 2
	ILL_ILLTRP                            = 4
	ILL_PRVOPC                            = 5
	ILL_PRVREG                            = 6
	MAX_PREPARED_STMTS                    = 100
	MINSIGSTKSZ                           = 2048
	NSIG                                  = 32
	NUM_PREPARED_STMTS                    = 10
	POLL_ERR                              = 4
	POLL_HUP                              = 6
	POLL_IN                               = 1
	POLL_MSG                              = 3
	POLL_OUT                              = 2
	POLL_PRI                              = 5
	SA_NOCLDSTOP                          = 0x0008
	SA_NOCLDWAIT                          = 0x0020
	SA_NODEFER                            = 0x0010
	SA_ONSTACK                            = 0x0001
	SA_RESETHAND                          = 0x0004
	SA_RESTART                            = 0x0002
	SA_SIGINFO                            = 0x0040
	SEGV_ACCERR                           = 2
	SEGV_MAPERR                           = 1
	SEGV_PKUERR                           = 100
	SIGABRT                               = 6
	SIGALRM                               = 14
	SIGBUS                                = 10
	SIGCHLD                               = 20
	SIGCONT                               = 19
	SIGEMT                                = 7
	SIGEV_KEVENT                          = 3
	SIGEV_NONE                            = 0
	SIGEV_SIGNAL                          = 1
	SIGEV_THREAD                          = 2
	SIGEV_THREAD_ID                       = 4
	SIGFPE                                = 8
	SIGHUP                                = 1
	SIGILL                                = 4
	SIGINFO                               = 29
	SIGINT                                = 2
	SIGIO                                 = 23
	SIGIOT                                = 6
	SIGKILL                               = 9
	SIGLIBRT                              = 33
	SIGLWP                                = 32
	SIGPIPE                               = 13
	SIGPROF                               = 27
	SIGQUIT                               = 3
	SIGRTMAX                              = 126
	SIGRTMIN                              = 65
	SIGSEGV                               = 11
	SIGSTKSZ                              = 34816
	SIGSTOP                               = 17
	SIGSYS                                = 12
	SIGTERM                               = 15
	SIGTHR                                = 32
	SIGTRAP                               = 5
	SIGTSTP                               = 18
	SIGTTIN                               = 21
	SIGTTOU                               = 22
	SIGURG                                = 16
	SIGUSR1                               = 30
	SIGUSR2                               = 31
	SIGVTALRM                             = 26
	SIGWINCH                              = 28
	SIGXCPU                               = 24
	SIGXFSZ                               = 25
	SIG_BLOCK                             = 1
	SIG_SETMASK                           = 3
	SIG_UNBLOCK                           = 2
	SI_ASYNCIO                            = 0x10004
	SI_KERNEL                             = 0x10006
	SI_LWP                                = 0x10007
	SI_MESGQ                              = 0x10005
	SI_NOINFO                             = 0
	SI_QUEUE                              = 0x10002
	SI_TIMER                              = 0x10003
	SI_UNDEFINED                          = 0
	SI_USER                               = 0x10001
	SQLITE_EVAL_WITHOUTNULLS              = 0x00001
	SQLITE_TCL_NRE                        = 1
	SS_DISABLE                            = 0x0004
	SS_ONSTACK                            = 0x0001
	SV_INTERRUPT                          = 2
	SV_NOCLDSTOP                          = 8
	SV_NODEFER                            = 16
	SV_ONSTACK                            = 1
	SV_RESETHAND                          = 4
	SV_SIGINFO                            = 64
	TCLSH                                 = 1
	TRAP_BRKPT                            = 1
	TRAP_CAP                              = 4
	TRAP_DTRACE                           = 3
	TRAP_TRACE                            = 2
	X_MC_FLAG_MASK                        = 7
	X_MC_FPFMT_NODEV                      = 0x10000
	X_MC_FPFMT_XMM                        = 0x10002
	X_MC_FPOWNED_FPU                      = 0x20001
	X_MC_FPOWNED_NONE                     = 0x20000
	X_MC_FPOWNED_PCB                      = 0x20002
	X_MC_HASBASES                         = 0x2
	X_MC_HASFPXSTATE                      = 0x4
	X_MC_HASSEGS                          = 0x1
	X_SIGNAL_H_                           = 0
	X_SYS_SIGNAL_H_                       = 0
	X_SYS__UCONTEXT_H_                    = 0
	X_X86_SIGNAL_H                        = 1
	X_X86_UCONTEXT_H_                     = 0
	CACHE_STALE                           = 0
	CPUSTATES                             = 5
	CP_IDLE                               = 4
	CP_INTR                               = 3
	CP_NICE                               = 1
	CP_SYS                                = 2
	CP_USER                               = 0
	CURTYPE_BTREE                         = 0
	CURTYPE_PSEUDO                        = 3
	CURTYPE_SORTER                        = 1
	CURTYPE_VTAB                          = 2
	MEM_AffMask                           = 0x003f
	MEM_Agg                               = 0x2000
	MEM_Blob                              = 0x0010
	MEM_Cleared                           = 0x0100
	MEM_Dyn                               = 0x0400
	MEM_Ephem                             = 0x1000
	MEM_FromBind                          = 0x0040
	MEM_Int                               = 0x0004
	MEM_IntReal                           = 0x0020
	MEM_Null                              = 0x0001
	MEM_Real                              = 0x0008
	MEM_Static                            = 0x0800
	MEM_Str                               = 0x0002
	MEM_Subtype                           = 0x8000
	MEM_Term                              = 0x0200
	MEM_TypeMask                          = 0xc1bf
	MEM_Undefined                         = 0x0080
	MEM_Zero                              = 0x4000
	PRIO_MAX                              = 20
	PRIO_MIN                              = -20
	PRIO_PGRP                             = 1
	PRIO_PROCESS                          = 0
	PRIO_USER                             = 2
	RLIMIT_AS                             = 10
	RLIMIT_CORE                           = 4
	RLIMIT_CPU                            = 0
	RLIMIT_DATA                           = 2
	RLIMIT_FSIZE                          = 1
	RLIMIT_KQUEUES                        = 13
	RLIMIT_MEMLOCK                        = 6
	RLIMIT_NOFILE                         = 8
	RLIMIT_NPROC                          = 7
	RLIMIT_NPTS                           = 11
	RLIMIT_RSS                            = 5
	RLIMIT_SBSIZE                         = 9
	RLIMIT_STACK                          = 3
	RLIMIT_SWAP                           = 12
	RLIMIT_UMTXP                          = 14
	RLIMIT_VMEM                           = 10
	RLIM_NLIMITS                          = 15
	RUSAGE_CHILDREN                       = -1
	RUSAGE_SELF                           = 0
	RUSAGE_THREAD                         = 1
	SQLITE_ENABLE_LOCKING_STYLE           = 0
	SQLITE_FRAME_MAGIC                    = 0x879fb71e
	SQLITE_MAX_SCHEMA_RETRY               = 50
	SQLITE_VDBEINT_H                      = 0
	VDBE_DISPLAY_P4                       = 1
	VDBE_MAGIC_DEAD                       = 0x5606c3c8
	VDBE_MAGIC_HALT                       = 0x319c2973
	VDBE_MAGIC_INIT                       = 0x16bceaa5
	VDBE_MAGIC_RESET                      = 0x48fa9f76
	VDBE_MAGIC_RUN                        = 0x2df20da3
	X_SYS_RESOURCE_H_                     = 0
	BTCF_AtLast                           = 0x08
	BTCF_Incrblob                         = 0x10
	BTCF_Multiple                         = 0x20
	BTCF_Pinned                           = 0x40
	BTCF_ValidNKey                        = 0x02
	BTCF_ValidOvfl                        = 0x04
	BTCF_WriteFlag                        = 0x01
	BTCURSOR_MAX_DEPTH                    = 20
	BTS_EXCLUSIVE                         = 0x0040
	BTS_FAST_SECURE                       = 0x000c
	BTS_INITIALLY_EMPTY                   = 0x0010
	BTS_NO_WAL                            = 0x0020
	BTS_OVERWRITE                         = 0x0008
	BTS_PAGESIZE_FIXED                    = 0x0002
	BTS_PENDING                           = 0x0080
	BTS_READ_ONLY                         = 0x0001
	BTS_SECURE_DELETE                     = 0x0004
	CURSOR_FAULT                          = 4
	CURSOR_INVALID                        = 1
	CURSOR_REQUIRESEEK                    = 3
	CURSOR_SKIPNEXT                       = 2
	CURSOR_VALID                          = 0
	PTF_INTKEY                            = 0x01
	PTF_LEAF                              = 0x08
	PTF_LEAFDATA                          = 0x04
	PTF_ZERODATA                          = 0x02
	PTRMAP_BTREE                          = 5
	PTRMAP_FREEPAGE                       = 2
	PTRMAP_OVERFLOW1                      = 3
	PTRMAP_OVERFLOW2                      = 4
	PTRMAP_ROOTPAGE                       = 1
	READ_LOCK                             = 1
	SQLITE_FILE_HEADER                    = "SQLite format 3"
	TRANS_NONE                            = 0
	TRANS_READ                            = 1
	TRANS_WRITE                           = 2
	WRITE_LOCK                            = 2
	N_THREAD                              = 26
	PTHREAD_BARRIER_SERIAL_THREAD         = -1
	PTHREAD_CANCEL_ASYNCHRONOUS           = 2
	PTHREAD_CANCEL_DEFERRED               = 0
	PTHREAD_CANCEL_DISABLE                = 1
	PTHREAD_CANCEL_ENABLE                 = 0
	PTHREAD_CREATE_DETACHED               = 1
	PTHREAD_CREATE_JOINABLE               = 0
	PTHREAD_DESTRUCTOR_ITERATIONS         = 4
	PTHREAD_DETACHED                      = 0x1
	PTHREAD_DONE_INIT                     = 1
	PTHREAD_EXPLICIT_SCHED                = 0
	PTHREAD_INHERIT_SCHED                 = 0x4
	PTHREAD_KEYS_MAX                      = 256
	PTHREAD_MUTEX_ROBUST                  = 1
	PTHREAD_MUTEX_STALLED                 = 0
	PTHREAD_NEEDS_INIT                    = 0
	PTHREAD_NOFLOAT                       = 0x8
	PTHREAD_PRIO_INHERIT                  = 1
	PTHREAD_PRIO_NONE                     = 0
	PTHREAD_PRIO_PROTECT                  = 2
	PTHREAD_PROCESS_PRIVATE               = 0
	PTHREAD_PROCESS_SHARED                = 1
	PTHREAD_SCOPE_PROCESS                 = 0
	PTHREAD_SCOPE_SYSTEM                  = 0x2
	PTHREAD_STACK_MIN                     = 2048
	PTHREAD_THREADS_MAX                   = 18446744073709551615
	SCHED_FIFO                            = 1
	SCHED_OTHER                           = 2
	SCHED_RR                              = 3
	X_PTHREAD_H_                          = 0
	X_SCHED_H_                            = 0
	TCL_THREADS                           = 0
	MX_CHUNK_NUMBER                       = 299
	SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET   = 400
	SQLITE_MULTIPLEX_WAL_8_3_OFFSET       = 700
	DEVSYM_MAX_PATHNAME                   = 512
	DEVSYM_VFS_NAME                       = "devsym"
	WRITECRASH_NAME                       = "writecrash"
	SQLITE_INTARRAY_H                     = 0
	JT_MAX_PATHNAME                       = 512
	JT_VFS_NAME                           = "jt"
	MALLOC_LOG_FRAMES                     = 10
	DEFAULT_SECTOR_SIZE                   = 0x1000
	MAX_PAGE_SIZE                         = 0x10000
	MULTIPLEX_CTRL_ENABLE                 = 214014
	MULTIPLEX_CTRL_SET_CHUNK_SIZE         = 214015
	MULTIPLEX_CTRL_SET_MAX_CHUNKS         = 214016
	SQLITE_MULTIPLEX_CHUNK_SIZE           = 2147418112
	SQLITE_MULTIPLEX_MAX_CHUNKS           = 12
	SQLITE_MULTIPLEX_VFS_NAME             = "multiplex"
	SQLITE_TEST_MULTIPLEX_H               = 0
	MAX_MUTEXES                           = 14
	STATIC_MUTEXES                        = 12
	BLOBSIZE                              = 10485760
	BLOCKSIZE                             = 512
	DATABASE_FILE                         = 1
	FS_VFS_NAME                           = "fs"
	JOURNAL_FILE                          = 2
	INST_MAX_PATHNAME                     = 512
	OS_ACCESS                             = 1
	OS_ANNOTATE                           = 28
	OS_CHECKRESERVEDLOCK                  = 2
	OS_CLOSE                              = 3
	OS_CURRENTTIME                        = 4
	OS_DELETE                             = 5
	OS_DEVCHAR                            = 6
	OS_FILECONTROL                        = 7
	OS_FILESIZE                           = 8
	OS_FULLPATHNAME                       = 9
	OS_LOCK                               = 11
	OS_NUMEVENTS                          = 29
	OS_OPEN                               = 12
	OS_RANDOMNESS                         = 13
	OS_READ                               = 14
	OS_SECTORSIZE                         = 15
	OS_SHMBARRIER                         = 26
	OS_SHMLOCK                            = 25
	OS_SHMMAP                             = 23
	OS_SHMUNMAP                           = 22
	OS_SLEEP                              = 16
	OS_SYNC                               = 17
	OS_TRUNCATE                           = 18
	OS_UNLOCK                             = 19
	OS_WRITE                              = 20
	VFSLOG_BUFFERSIZE                     = 8192
	TESTPCACHE_CLEAR                      = 0xd42670d4
	TESTPCACHE_NPAGE                      = 217
	TESTPCACHE_RESERVE                    = 17
	TESTPCACHE_VALID                      = 0x364585fd
	MSG_Close                             = 6
	MSG_Done                              = 7
	MSG_Finalize                          = 5
	MSG_Open                              = 1
	MSG_Prepare                           = 2
	MSG_Reset                             = 4
	MSG_Step                              = 3
	INHERIT_COPY                          = 1
	INHERIT_NONE                          = 2
	INHERIT_SHARE                         = 0
	INHERIT_ZERO                          = 3
	MADV_AUTOSYNC                         = 7
	MADV_CORE                             = 9
	MADV_DONTNEED                         = 4
	MADV_FREE                             = 5
	MADV_NOCORE                           = 8
	MADV_NORMAL                           = 0
	MADV_NOSYNC                           = 6
	MADV_PROTECT                          = 10
	MADV_RANDOM                           = 1
	MADV_SEQUENTIAL                       = 2
	MADV_WILLNEED                         = 3
	MAP_32BIT                             = 0x00080000
	MAP_ALIGNED_SUPER                     = 16777216
	MAP_ALIGNMENT_MASK                    = 4278190080
	MAP_ALIGNMENT_SHIFT                   = 24
	MAP_ANON                              = 0x1000
	MAP_ANONYMOUS                         = 4096
	MAP_COPY                              = 2
	MAP_EXCL                              = 0x00004000
	MAP_FILE                              = 0x0000
	MAP_FIXED                             = 0x0010
	MAP_GUARD                             = 0x00002000
	MAP_HASSEMAPHORE                      = 0x0200
	MAP_NOCORE                            = 0x00020000
	MAP_NOSYNC                            = 0x0800
	MAP_PREFAULT_READ                     = 0x00040000
	MAP_PRIVATE                           = 0x0002
	MAP_RESERVED0020                      = 0x0020
	MAP_RESERVED0040                      = 0x0040
	MAP_RESERVED0080                      = 0x0080
	MAP_RESERVED0100                      = 0x0100
	MAP_SHARED                            = 0x0001
	MAP_STACK                             = 0x0400
	MCL_CURRENT                           = 0x0001
	MCL_FUTURE                            = 0x0002
	MFD_ALLOW_SEALING                     = 0x00000002
	MFD_CLOEXEC                           = 0x00000001
	MFD_HUGETLB                           = 0x00000004
	MFD_HUGE_16GB                         = 2281701376
	MFD_HUGE_16MB                         = 1610612736
	MFD_HUGE_1GB                          = 2013265920
	MFD_HUGE_1MB                          = 1342177280
	MFD_HUGE_256MB                        = 1879048192
	MFD_HUGE_2GB                          = 2080374784
	MFD_HUGE_2MB                          = 1409286144
	MFD_HUGE_32MB                         = 1677721600
	MFD_HUGE_512KB                        = 1275068416
	MFD_HUGE_512MB                        = 1946157056
	MFD_HUGE_64KB                         = 1073741824
	MFD_HUGE_8MB                          = 1543503872
	MFD_HUGE_MASK                         = 0xFC000000
	MFD_HUGE_SHIFT                        = 26
	MINCORE_INCORE                        = 0x1
	MINCORE_MODIFIED                      = 0x4
	MINCORE_MODIFIED_OTHER                = 0x10
	MINCORE_REFERENCED                    = 0x2
	MINCORE_REFERENCED_OTHER              = 0x8
	MINCORE_SUPER                         = 0x60
	MS_ASYNC                              = 0x0001
	MS_INVALIDATE                         = 0x0002
	MS_SYNC                               = 0x0000
	POSIX_MADV_DONTNEED                   = 4
	POSIX_MADV_NORMAL                     = 0
	POSIX_MADV_RANDOM                     = 1
	POSIX_MADV_SEQUENTIAL                 = 2
	POSIX_MADV_WILLNEED                   = 3
	PROT_EXEC                             = 0x04
	PROT_NONE                             = 0x00
	PROT_READ                             = 0x01
	PROT_WRITE                            = 0x02
	SHM_ALLOW_SEALING                     = 0x00000001
	SHM_GROW_ON_WRITE                     = 0x00000002
	SHM_LARGEPAGE                         = 0x00000004
	SHM_LARGEPAGE_ALLOC_DEFAULT           = 0
	SHM_LARGEPAGE_ALLOC_HARD              = 2
	SHM_LARGEPAGE_ALLOC_NOWAIT            = 1
	SHM_RENAME_EXCHANGE                   = 2
	SHM_RENAME_NOREPLACE                  = 1
	X_MADV_DONTNEED                       = 4
	X_MADV_NORMAL                         = 0
	X_MADV_RANDOM                         = 1
	X_MADV_SEQUENTIAL                     = 2
	X_MADV_WILLNEED                       = 3
	X_PROT_ALL                            = 7
	X_PROT_MAX_SHIFT                      = 16
	X_SYS_MMAN_H_                         = 0
	TCLVAR_NAME_EQ                        = 101
	TCLVAR_NAME_MATCH                     = 109
	TCLVAR_VALUE_GLOB                     = 103
	TCLVAR_VALUE_LIKE                     = 108
	TCLVAR_VALUE_REGEXP                   = 114
	FAULT_INJECT_NONE                     = 0
	FAULT_INJECT_PERSISTENT               = 2
	FAULT_INJECT_TRANSIENT                = 1
	TESTVFS_ACCESS_MASK                   = 0x00004000
	TESTVFS_ALL_MASK                      = 0x001FFFFF
	TESTVFS_CKLOCK_MASK                   = 0x00080000
	TESTVFS_CLOSE_MASK                    = 0x00000800
	TESTVFS_DELETE_MASK                   = 0x00000400
	TESTVFS_FCNTL_MASK                    = 0x00100000
	TESTVFS_FULLPATHNAME_MASK             = 0x00008000
	TESTVFS_LOCK_MASK                     = 0x00040000
	TESTVFS_MAX_ARGS                      = 12
	TESTVFS_MAX_PAGES                     = 1024
	TESTVFS_OPEN_MASK                     = 0x00000100
	TESTVFS_READ_MASK                     = 0x00010000
	TESTVFS_SHMBARRIER_MASK               = 0x00000040
	TESTVFS_SHMCLOSE_MASK                 = 0x00000080
	TESTVFS_SHMLOCK_MASK                  = 0x00000010
	TESTVFS_SHMMAP_MASK                   = 0x00000020
	TESTVFS_SHMOPEN_MASK                  = 0x00000001
	TESTVFS_SYNC_MASK                     = 0x00000200
	TESTVFS_TRUNCATE_MASK                 = 0x00002000
	TESTVFS_UNLOCK_MASK                   = 0x00020000
	TESTVFS_WRITE_MASK                    = 0x00001000
)

// Run-time invariant values:

// Flags for threads and thread attributes.

// Values for process shared/private attributes.

// Flags for cancelling threads

// Flags for once initialization.

// Static once initialization values.

// Static initialization values.

// Default attribute arguments (draft 4, deprecated).

// Mutex types (Single UNIX Specification, Version 2, 1997).
//
// Note that a mutex attribute with one of the following types:
//
//	PTHREAD_MUTEX_NORMAL
//	PTHREAD_MUTEX_RECURSIVE
//
// will deviate from POSIX specified semantics.
const ( /* pthread.h:130:1: */
	PTHREAD_MUTEX_ERRORCHECK  = 1 // Default POSIX mutex
	PTHREAD_MUTEX_RECURSIVE   = 2 // Recursive mutex
	PTHREAD_MUTEX_NORMAL      = 3 // No error checking
	PTHREAD_MUTEX_ADAPTIVE_NP = 4 // Adaptive mutex, spins briefly before blocking on lock
	PTHREAD_MUTEX_TYPE_MAX    = 5
)

// Positions to pass to Tcl_QueueEvent:

const ( /* tcl.h:1387:1: */
	TCL_QUEUE_TAIL = 0
	TCL_QUEUE_HEAD = 1
	TCL_QUEUE_MARK = 2
)

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

const ( /* tcl.h:1609:1: */
	TCL_PATH_ABSOLUTE        = 0
	TCL_PATH_RELATIVE        = 1
	TCL_PATH_VOLUME_RELATIVE = 2
)

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

const ( /* tcl.h:690:1: */
	TCL_INT      = 0
	TCL_DOUBLE   = 1
	TCL_EITHER   = 2
	TCL_WIDE_INT = 3
)

type ptrdiff_t = int64 /* <builtin>:3:26 */

type size_t = uint64 /* <builtin>:9:23 */

type wchar_t = int32 /* <builtin>:15:24 */ // compatibility w/GNU headers

// When the following macro is defined, the system uses 64-bit inode numbers.
// Programs can use this to avoid including <sys/param.h>, with its associated
// namespace pollution.

type va_list = uintptr /* _stdarg.h:41:27 */

// CAPI3REF: Database Connection Handle
// KEYWORDS: {database connection} {database connections}
//
// Each open SQLite database is represented by a pointer to an instance of
// the opaque structure named "sqlite3".  It is useful to think of an sqlite3
// pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
// [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]
// and [sqlite3_close_v2()] are its destructors.  There are many other
// interfaces (such as
// [sqlite3_prepare_v2()], [sqlite3_create_function()], and
// [sqlite3_busy_timeout()] to name but three) that are methods on an
// sqlite3 object.
type sqlite32 = struct {
	FpVfs                   uintptr
	FpVdbe                  uintptr
	FpDfltColl              uintptr
	Fmutex                  uintptr
	FaDb                    uintptr
	FnDb                    int32
	FmDbFlags               u32
	Fflags                  u64
	FlastRowid              i64
	FszMmap                 i64
	FnSchemaLock            u32
	FopenFlags              uint32
	FerrCode                int32
	FerrMask                int32
	FiSysErrno              int32
	FdbOptFlags             u32
	Fenc                    u8
	FautoCommit             u8
	Ftemp_store             u8
	FmallocFailed           u8
	FbBenignMalloc          u8
	FdfltLockMode           u8
	FnextAutovac            int8
	FsuppressErr            u8
	FvtabOnConflict         u8
	FisTransactionSavepoint u8
	FmTrace                 u8
	FnoSharedCache          u8
	FnSqlExec               u8
	FeOpenState             u8
	F__ccgo_pad1            [2]byte
	FnextPagesize           int32
	F__ccgo_pad2            [4]byte
	FnChange                i64
	FnTotalChange           i64
	FaLimit                 [12]int32
	FnMaxSorterMmap         int32
	F__ccgo_pad3            [4]byte
	Finit                   struct {
		FnewTnum       Pgno
		FiDb           u8
		Fbusy          u8
		F__ccgo_pad1   [2]byte
		ForphanTrigger uint8 /* unsigned orphanTrigger: 1, unsigned imposterTable: 1, unsigned reopenMemdb: 1 */
		F__ccgo_pad2   [7]byte
		FazInit        uintptr
	}
	FnVdbeActive        int32
	FnVdbeRead          int32
	FnVdbeWrite         int32
	FnVdbeExec          int32
	FnVDestroy          int32
	FnExtension         int32
	FaExtension         uintptr
	Ftrace              struct{ FxLegacy uintptr }
	FpTraceArg          uintptr
	FxProfile           uintptr
	FpProfileArg        uintptr
	FpCommitArg         uintptr
	FxCommitCallback    uintptr
	FpRollbackArg       uintptr
	FxRollbackCallback  uintptr
	FpUpdateArg         uintptr
	FxUpdateCallback    uintptr
	FpAutovacPagesArg   uintptr
	FxAutovacDestr      uintptr
	FxAutovacPages      uintptr
	FpParse             uintptr
	FpPreUpdateArg      uintptr
	FxPreUpdateCallback uintptr
	FpPreUpdate         uintptr
	FxWalCallback       uintptr
	FpWalArg            uintptr
	FxCollNeeded        uintptr
	FxCollNeeded16      uintptr
	FpCollNeededArg     uintptr
	FpErr               uintptr
	Fu1                 struct {
		F__ccgo_pad1   [0]uint64
		FisInterrupted int32
		F__ccgo_pad2   [4]byte
	}
	Flookaside           Lookaside
	FxAuth               sqlite3_xauth
	FpAuthArg            uintptr
	FxProgress           uintptr
	FpProgressArg        uintptr
	FnProgressOps        uint32
	FnVTrans             int32
	FaModule             Hash
	FpVtabCtx            uintptr
	FaVTrans             uintptr
	FpDisconnect         uintptr
	FaFunc               Hash
	FaCollSeq            Hash
	FbusyHandler         BusyHandler
	FaDbStatic           [2]Db
	FpSavepoint          uintptr
	FnAnalysisLimit      int32
	FbusyTimeout         int32
	FnSavepoint          int32
	FnStatement          int32
	FnDeferredCons       i64
	FnDeferredImmCons    i64
	FpnBytesFreed        uintptr
	FpBlockingConnection uintptr
	FpUnlockConnection   uintptr
	FpUnlockArg          uintptr
	FxUnlockNotify       uintptr
	FpNextBlocked        uintptr
} /* sqlite3.h:272:9 */

// CAPI3REF: 64-Bit Integer Types
// KEYWORDS: sqlite_int64 sqlite_uint64
//
// Because there is no cross-platform way to specify 64-bit integer types
// SQLite includes typedefs for 64-bit signed and unsigned integers.
//
// The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.
// The sqlite_int64 and sqlite_uint64 types are supported for backwards
// compatibility only.
//
// ^The sqlite3_int64 and sqlite_int64 types can store integer values
// between -9223372036854775808 and +9223372036854775807 inclusive.  ^The
// sqlite3_uint64 and sqlite_uint64 types can store integer values
// between 0 and +18446744073709551615 inclusive.
type sqlite_int64 = int64           /* sqlite3.h:301:25 */
type sqlite_uint64 = uint64         /* sqlite3.h:302:34 */
type sqlite3_int64 = sqlite_int64   /* sqlite3.h:304:22 */
type sqlite3_uint64 = sqlite_uint64 /* sqlite3.h:305:23 */

// The type for a callback function.
// This is legacy and deprecated.  It is included for historical
// compatibility and is not documented.
type sqlite3_callback = uintptr /* sqlite3.h:361:13 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.
//
// Only those flags marked as "Ok for sqlite3_open_v2()" may be
// used as the third argument to the [sqlite3_open_v2()] interface.
// The other flags have historically been ignored by sqlite3_open_v2(),
// though future versions of SQLite might change so that an error is
// raised if any of the disallowed bits are passed into sqlite3_open_v2().
// Applications should not depend on the historical behavior.
//
// Note in particular that passing the SQLITE_OPEN_EXCLUSIVE flag into
// [sqlite3_open_v2()] does *not* cause the underlying database file
// to be opened using O_EXCL.  Passing SQLITE_OPEN_EXCLUSIVE into
// [sqlite3_open_v2()] has historically be a no-op and might become an
// error in future versions of SQLite.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file1 = struct{ FpMethods uintptr } /* sqlite3.h:722:9 */

// CAPI3REF: Result Codes
// KEYWORDS: {result code definitions}
//
// Many SQLite functions return an integer result code from the set shown
// here in order to indicate success or failure.
//
// New error codes may be added in future versions of SQLite.
//
// See also: [extended result code definitions]
// beginning-of-error-codes
// end-of-error-codes

// CAPI3REF: Extended Result Codes
// KEYWORDS: {extended result code definitions}
//
// In its default configuration, SQLite API routines return one of 30 integer
// [result codes].  However, experience has shown that many of
// these result codes are too coarse-grained.  They do not provide as
// much information about problems as programmers might like.  In an effort to
// address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
// and later) include
// support for additional result codes that provide more detailed information
// about errors. These [extended result codes] are enabled or disabled
// on a per database connection basis using the
// [sqlite3_extended_result_codes()] API.  Or, the extended code for
// the most recent error can be obtained using
// [sqlite3_extended_errcode()].

// CAPI3REF: Flags For File Open Operations
//
// These bit values are intended for use in the
// 3rd parameter to the [sqlite3_open_v2()] interface and
// in the 4th parameter to the [sqlite3_vfs.xOpen] method.
//
// Only those flags marked as "Ok for sqlite3_open_v2()" may be
// used as the third argument to the [sqlite3_open_v2()] interface.
// The other flags have historically been ignored by sqlite3_open_v2(),
// though future versions of SQLite might change so that an error is
// raised if any of the disallowed bits are passed into sqlite3_open_v2().
// Applications should not depend on the historical behavior.
//
// Note in particular that passing the SQLITE_OPEN_EXCLUSIVE flag into
// [sqlite3_open_v2()] does *not* cause the underlying database file
// to be opened using O_EXCL.  Passing SQLITE_OPEN_EXCLUSIVE into
// [sqlite3_open_v2()] has historically be a no-op and might become an
// error in future versions of SQLite.

// Reserved:                         0x00F00000
// Legacy compatibility:

// CAPI3REF: Device Characteristics
//
// The xDeviceCharacteristics method of the [sqlite3_io_methods]
// object returns an integer which is a vector of these
// bit values expressing I/O characteristics of the mass storage
// device that holds the file that the [sqlite3_io_methods]
// refers to.
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
// after reboot following a crash or power loss, the only bytes in a
// file that were written at the application level might have changed
// and that adjacent bytes, even bytes within the same sector are
// guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
// flag indicates that a file cannot be deleted when open.  The
// SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
// read-only media and cannot be changed even by processes with
// elevated privileges.
//
// The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
// filesystem supports doing multiple write operations atomically when those
// write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
// [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].

// CAPI3REF: File Locking Levels
//
// SQLite uses one of these integer values as the second
// argument to calls it makes to the xLock() and xUnlock() methods
// of an [sqlite3_io_methods] object.

// CAPI3REF: Synchronization Type Flags
//
// When SQLite invokes the xSync() method of an
// [sqlite3_io_methods] object it uses a combination of
// these integer values as the second argument.
//
// When the SQLITE_SYNC_DATAONLY flag is used, it means that the
// sync operation only needs to flush data to mass storage.  Inode
// information need not be flushed. If the lower four bits of the flag
// equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
// If the lower four bits equal SQLITE_SYNC_FULL, that means
// to use Mac OS X style fullsync instead of fsync().
//
// Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
// with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
// settings.  The [synchronous pragma] determines when calls to the
// xSync VFS method occur and applies uniformly across all platforms.
// The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
// energetic or rigorous or forceful the sync operations are and
// only make a difference on Mac OSX for the default SQLite code.
// (Third-party VFS implementations might also make the distinction
// between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
// operating systems natively supported by SQLite, only Mac OSX
// cares about the difference.)

// CAPI3REF: OS Interface Open File Handle
//
// An [sqlite3_file] object represents an open file in the
// [sqlite3_vfs | OS interface layer].  Individual OS interface
// implementations will
// want to subclass this object by appending additional fields
// for their own use.  The pMethods entry is a pointer to an
// [sqlite3_io_methods] object that defines methods for performing
// I/O operations on the open file.
type sqlite3_file = sqlite3_file1 /* sqlite3.h:722:29 */
type sqlite3_io_methods1 = struct {
	FiVersion               int32
	F__ccgo_pad1            [4]byte
	FxClose                 uintptr
	FxRead                  uintptr
	FxWrite                 uintptr
	FxTruncate              uintptr
	FxSync                  uintptr
	FxFileSize              uintptr
	FxLock                  uintptr
	FxUnlock                uintptr
	FxCheckReservedLock     uintptr
	FxFileControl           uintptr
	FxSectorSize            uintptr
	FxDeviceCharacteristics uintptr
	FxShmMap                uintptr
	FxShmLock               uintptr
	FxShmBarrier            uintptr
	FxShmUnmap              uintptr
	FxFetch                 uintptr
	FxUnfetch               uintptr
} /* sqlite3.h:722:9 */

// CAPI3REF: OS Interface File Virtual Methods Object
//
// Every file opened by the [sqlite3_vfs.xOpen] method populates an
// [sqlite3_file] object (or, more commonly, a subclass of the
// [sqlite3_file] object) with a pointer to an instance of this object.
// This object defines the methods used to perform various operations
// against the open file represented by the [sqlite3_file] object.
//
// If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element
// to a non-NULL pointer, then the sqlite3_io_methods.xClose method
// may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The
// only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]
// is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element
// to NULL.
//
// The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or
// [SQLITE_SYNC_FULL].  The first choice is the normal fsync().
// The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]
// flag may be ORed in to indicate that only the data of the file
// and not its inode needs to be synced.
//
// The integer values to xLock() and xUnlock() are one of
// <ul>
// <li> [SQLITE_LOCK_NONE],
// <li> [SQLITE_LOCK_SHARED],
// <li> [SQLITE_LOCK_RESERVED],
// <li> [SQLITE_LOCK_PENDING], or
// <li> [SQLITE_LOCK_EXCLUSIVE].
// </ul>
// xLock() increases the lock. xUnlock() decreases the lock.
// The xCheckReservedLock() method checks whether any database connection,
// either in this process or in some other process, is holding a RESERVED,
// PENDING, or EXCLUSIVE lock on the file.  It returns true
// if such a lock exists and false otherwise.
//
// The xFileControl() method is a generic interface that allows custom
// VFS implementations to directly control an open file using the
// [sqlite3_file_control()] interface.  The second "op" argument is an
// integer opcode.  The third argument is a generic pointer intended to
// point to a structure that may contain arguments or space in which to
// write return values.  Potential uses for xFileControl() might be
// functions to enable blocking locks with timeouts, to change the
// locking strategy (for example to use dot-file locks), to inquire
// about the status of a lock, or to break stale locks.  The SQLite
// core reserves all opcodes less than 100 for its own use.
// A [file control opcodes | list of opcodes] less than 100 is available.
// Applications that define a custom xFileControl method should use opcodes
// greater than 100 to avoid conflicts.  VFS implementations should
// return [SQLITE_NOTFOUND] for file control opcodes that they do not
// recognize.
//
// The xSectorSize() method returns the sector size of the
// device that underlies the file.  The sector size is the
// minimum write that can be performed without disturbing
// other bytes in the file.  The xDeviceCharacteristics()
// method returns a bit vector describing behaviors of the
// underlying device:
//
// <ul>
// <li> [SQLITE_IOCAP_ATOMIC]
// <li> [SQLITE_IOCAP_ATOMIC512]
// <li> [SQLITE_IOCAP_ATOMIC1K]
// <li> [SQLITE_IOCAP_ATOMIC2K]
// <li> [SQLITE_IOCAP_ATOMIC4K]
// <li> [SQLITE_IOCAP_ATOMIC8K]
// <li> [SQLITE_IOCAP_ATOMIC16K]
// <li> [SQLITE_IOCAP_ATOMIC32K]
// <li> [SQLITE_IOCAP_ATOMIC64K]
// <li> [SQLITE_IOCAP_SAFE_APPEND]
// <li> [SQLITE_IOCAP_SEQUENTIAL]
// <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]
// <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]
// <li> [SQLITE_IOCAP_IMMUTABLE]
// <li> [SQLITE_IOCAP_BATCH_ATOMIC]
// </ul>
//
// The SQLITE_IOCAP_ATOMIC property means that all writes of
// any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
// mean that writes of blocks that are nnn bytes in size and
// are aligned to an address which is an integer multiple of
// nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
// that when data is appended to a file, the data is appended
// first then the size of the file is extended, never the other
// way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
// information is written to disk in the same order as calls
// to xWrite().
//
// If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
// in the unread portions of the buffer with zeros.  A VFS that
// fails to zero-fill short reads might seem to work.  However,
// failure to zero-fill short reads will eventually lead to
// database corruption.
type sqlite3_io_methods = sqlite3_io_methods1 /* sqlite3.h:821:35 */

// CAPI3REF: Standard File Control Opcodes
// KEYWORDS: {file control opcodes} {file control opcode}
//
// These integer constants are opcodes for the xFileControl method
// of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
// interface.
//
// <ul>
// <li>[[SQLITE_FCNTL_LOCKSTATE]]
// The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
// opcode causes the xFileControl method to write the current state of
// the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
// [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
// into an integer that the pArg argument points to. This capability
// is used during testing and is only available when the SQLITE_TEST
// compile-time option is used.
//
// <li>[[SQLITE_FCNTL_SIZE_HINT]]
// The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
// layer a hint of how large the database file will grow to be during the
// current transaction.  This hint is not guaranteed to be accurate but it
// is often close.  The underlying VFS might choose to preallocate database
// file space based on this hint in order to help writes to the database
// file run faster.
//
// <li>[[SQLITE_FCNTL_SIZE_LIMIT]]
// The [SQLITE_FCNTL_SIZE_LIMIT] opcode is used by in-memory VFS that
// implements [sqlite3_deserialize()] to set an upper bound on the size
// of the in-memory database.  The argument is a pointer to a [sqlite3_int64].
// If the integer pointed to is negative, then it is filled in with the
// current limit.  Otherwise the limit is set to the larger of the value
// of the integer pointed to and the current database size.  The integer
// pointed to is set to the new limit.
//
// <li>[[SQLITE_FCNTL_CHUNK_SIZE]]
// The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS
// extends and truncates the database file in chunks of a size specified
// by the user. The fourth argument to [sqlite3_file_control()] should
// point to an integer (type int) containing the new chunk-size to use
// for the nominated database. Allocating database file space in large
// chunks (say 1MB at a time), may reduce file-system fragmentation and
// improve performance on some systems.
//
// <li>[[SQLITE_FCNTL_FILE_POINTER]]
// The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with a particular database
// connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].
//
// <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]
// The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with the journal file (either
// the [rollback journal] or the [write-ahead log]) for a particular database
// connection.  See also [SQLITE_FCNTL_FILE_POINTER].
//
// <li>[[SQLITE_FCNTL_SYNC_OMITTED]]
// No longer in use.
//
// <li>[[SQLITE_FCNTL_SYNC]]
// The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and
// sent to the VFS immediately before the xSync method is invoked on a
// database file descriptor. Or, if the xSync method is not invoked
// because the user has configured SQLite with
// [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place
// of the xSync method. In most cases, the pointer argument passed with
// this file-control is NULL. However, if the database file is being synced
// as part of a multi-database commit, the argument points to a nul-terminated
// string containing the transactions super-journal file name. VFSes that
// do not need this signal should silently ignore this opcode. Applications
// should not call [sqlite3_file_control()] with this opcode as doing so may
// disrupt the operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]
// The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite
// and sent to the VFS after a transaction has been committed immediately
// but before the database is unlocked. VFSes that do not need this signal
// should silently ignore this opcode. Applications should not call
// [sqlite3_file_control()] with this opcode as doing so may disrupt the
// operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]
// ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic
// retry counts and intervals for certain disk I/O operations for the
// windows [VFS] in order to provide robustness in the presence of
// anti-virus programs.  By default, the windows VFS will retry file read,
// file write, and file delete operations up to 10 times, with a delay
// of 25 milliseconds before the first retry and with the delay increasing
// by an additional 25 milliseconds with each subsequent retry.  This
// opcode allows these two values (10 retries and 25 milliseconds of delay)
// to be adjusted.  The values are changed for all database connections
// within the same process.  The argument is a pointer to an array of two
// integers where the first integer is the new retry count and the second
// integer is the delay.  If either integer is negative, then the setting
// is not changed but instead the prior value of that setting is written
// into the array entry, allowing the current retry settings to be
// interrogated.  The zDbName parameter is ignored.
//
// <li>[[SQLITE_FCNTL_PERSIST_WAL]]
// ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the
// persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary
// write ahead log ([WAL file]) and shared memory
// files used for transaction control
// are automatically deleted when the latest connection to the database
// closes.  Setting persistent WAL mode causes those files to persist after
// close.  Persisting the files is useful when other processes that do not
// have write permission on the directory containing the database file want
// to read the database file, as the WAL and shared memory files must exist
// in order for the database to be readable.  The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable persistent WAL mode or 1 to enable persistent
// WAL mode.  If the integer is -1, then it is overwritten with the current
// WAL persistence setting.
//
// <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]
// ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the
// persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting
// determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the
// xDeviceCharacteristics methods. The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable zero-damage mode or 1 to enable zero-damage
// mode.  If the integer is -1, then it is overwritten with the current
// zero-damage mode setting.
//
// <li>[[SQLITE_FCNTL_OVERWRITE]]
// ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening
// a write transaction to indicate that, unless it is rolled back for some
// reason, the entire database file will be overwritten by the current
// transaction. This is used by VACUUM operations.
//
// <li>[[SQLITE_FCNTL_VFSNAME]]
// ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of
// all [VFSes] in the VFS stack.  The names are of all VFS shims and the
// final bottom-level VFS are written into memory obtained from
// [sqlite3_malloc()] and the result is stored in the char* variable
// that the fourth parameter of [sqlite3_file_control()] points to.
// The caller is responsible for freeing the memory when done.  As with
// all file-control actions, there is no guarantee that this will actually
// do anything.  Callers should initialize the char* variable to a NULL
// pointer in case this file-control is not implemented.  This file-control
// is intended for diagnostic use only.
//
// <li>[[SQLITE_FCNTL_VFS_POINTER]]
// ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level
// [VFSes] currently in use.  ^(The argument X in
// sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be
// of type "[sqlite3_vfs] **".  This opcodes will set *X
// to a pointer to the top-level VFS.)^
// ^When there are multiple VFS shims in the stack, this opcode finds the
// upper-most shim only.
//
// <li>[[SQLITE_FCNTL_PRAGMA]]
// ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]
// file control is sent to the open [sqlite3_file] object corresponding
// to the database file to which the pragma statement refers. ^The argument
// to the [SQLITE_FCNTL_PRAGMA] file control is an array of
// pointers to strings (char**) in which the second element of the array
// is the name of the pragma and the third element is the argument to the
// pragma or NULL if the pragma has no argument.  ^The handler for an
// [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element
// of the char** argument point to a string obtained from [sqlite3_mprintf()]
// or the equivalent and that string will become the result of the pragma or
// the error message if the pragma fails. ^If the
// [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal
// [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
// file control returns [SQLITE_OK], then the parser assumes that the
// VFS has handled the PRAGMA itself and the parser generates a no-op
// prepared statement if result string is NULL, or that returns a copy
// of the result string if the string is non-NULL.
// ^If the [SQLITE_FCNTL_PRAGMA] file control returns
// any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
// that the VFS encountered an error while handling the [PRAGMA] and the
// compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
// file control occurs at the beginning of pragma statement analysis and so
// it is able to override built-in [PRAGMA] statements.
//
// <li>[[SQLITE_FCNTL_BUSYHANDLER]]
// ^The [SQLITE_FCNTL_BUSYHANDLER]
// file-control may be invoked by SQLite on the database file handle
// shortly after it is opened in order to provide a custom VFS with access
// to the connection's busy-handler callback. The argument is of type (void**)
// - an array of two (void *) values. The first (void *) actually points
// to a function of type (int (*)(void *)). In order to invoke the connection's
// busy-handler, this function should be invoked with the second (void *) in
// the array as the only argument. If it returns non-zero, then the operation
// should be retried. If it returns zero, the custom VFS should abandon the
// current operation.
//
// <li>[[SQLITE_FCNTL_TEMPFILENAME]]
// ^Applications can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control
// to have SQLite generate a
// temporary filename using the same algorithm that is followed to generate
// temporary filenames for TEMP tables and other internal uses.  The
// argument should be a char** which will be filled with the filename
// written into memory obtained from [sqlite3_malloc()].  The caller should
// invoke [sqlite3_free()] on the result to avoid a memory leak.
//
// <li>[[SQLITE_FCNTL_MMAP_SIZE]]
// The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the
// maximum number of bytes that will be used for memory-mapped I/O.
// The argument is a pointer to a value of type sqlite3_int64 that
// is an advisory maximum number of bytes in the file to memory map.  The
// pointer is overwritten with the old value.  The limit is not changed if
// the value originally pointed to is negative, and so the current limit
// can be queried by passing in a pointer to a negative number.  This
// file-control is used internally to implement [PRAGMA mmap_size].
//
// <li>[[SQLITE_FCNTL_TRACE]]
// The [SQLITE_FCNTL_TRACE] file control provides advisory information
// to the VFS about what the higher layers of the SQLite stack are doing.
// This file control is used by some VFS activity tracing [shims].
// The argument is a zero-terminated string.  Higher layers in the
// SQLite stack may generate instances of this file control if
// the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.
//
// <li>[[SQLITE_FCNTL_HAS_MOVED]]
// The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a
// pointer to an integer and it writes a boolean into that integer depending
// on whether or not the file has been renamed, moved, or deleted since it
// was first opened.
//
// <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the
// underlying native file handle associated with a file handle.  This file
// control interprets its argument as a pointer to a native file handle and
// writes the resulting value there.
//
// <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This
// opcode causes the xFileControl method to swap the file handle with the one
// pointed to by the pArg argument.  This capability is used during testing
// and only needs to be supported when SQLITE_TEST is defined.
//
// <li>[[SQLITE_FCNTL_WAL_BLOCK]]
// The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
// be advantageous to block on the next WAL lock if the lock is not immediately
// available.  The WAL subsystem issues this signal during rare
// circumstances in order to fix a problem with priority inversion.
// Applications should <em>not</em> use this file-control.
//
// <li>[[SQLITE_FCNTL_ZIPVFS]]
// The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other
// VFS should return SQLITE_NOTFOUND for this opcode.
//
// <li>[[SQLITE_FCNTL_RBU]]
// The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by
// the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for
// this opcode.
//
// <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]
// If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then
// the file descriptor is placed in "batch write mode", which
// means all subsequent write operations will be deferred and done
// atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems
// that do not support batch atomic writes will return SQLITE_NOTFOUND.
// ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to
// the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or
// [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make
// no VFS interface calls on the same [sqlite3_file] file descriptor
// except for calls to the xWrite method and the xFileControl method
// with [SQLITE_FCNTL_SIZE_HINT].
//
// <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.
// This file control returns [SQLITE_OK] if and only if the writes were
// all performed successfully and have been committed to persistent storage.
// ^Regardless of whether or not it is successful, this file control takes
// the file descriptor out of batch write mode so that all subsequent
// write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.
// ^This file control takes the file descriptor out of batch write mode
// so that all subsequent write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
// The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS
// to block for up to M milliseconds before failing when attempting to
// obtain a file lock using the xLock or xShmLock methods of the VFS.
// The parameter is a pointer to a 32-bit signed integer that contains
// the value that M is to be set to. Before returning, the 32-bit signed
// integer is overwritten with the previous value of M.
//
// <li>[[SQLITE_FCNTL_DATA_VERSION]]
// The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to
// a database file.  The argument is a pointer to a 32-bit unsigned integer.
// The "data version" for the pager is written into the pointer.  The
// "data version" changes whenever any change occurs to the corresponding
// database file, either through SQL statements on the same database
// connection or through transactions committed by separate database
// connections possibly in other processes. The [sqlite3_total_changes()]
// interface can be used to find if any database on the connection has changed,
// but that interface responds to changes on TEMP as well as MAIN and does
// not provide a mechanism to detect changes to MAIN only.  Also, the
// [sqlite3_total_changes()] interface responds to internal changes only and
// omits changes made by other database connections.  The
// [PRAGMA data_version] command provides a mechanism to detect changes to
// a single attached database that occur due to other database connections,
// but omits changes implemented by the database connection on which it is
// called.  This file control is the only mechanism to detect changes that
// happen either internally or externally and that are associated with
// a particular attached database.
//
// <li>[[SQLITE_FCNTL_CKPT_START]]
// The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint
// in wal mode before the client starts to copy pages from the wal
// file to the database file.
//
// <li>[[SQLITE_FCNTL_CKPT_DONE]]
// The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint
// in wal mode after the client has finished copying pages from the wal
// file to the database file, but before the *-shm file is updated to
// record the fact that the pages have been checkpointed.
// </ul>
//
// <li>[[SQLITE_FCNTL_EXTERNAL_READER]]
// The EXPERIMENTAL [SQLITE_FCNTL_EXTERNAL_READER] opcode is used to detect
// whether or not there is a database client in another process with a wal-mode
// transaction open on the database or not. It is only available on unix.The
// (void*) argument passed with this file-control should be a pointer to a
// value of type (int). The integer value is set to 1 if the database is a wal
// mode database and there exists at least one client in another process that
// currently has an SQL transaction open on the database. It is set to 0 if
// the database is not a wal-mode db, or if there is no such connection in any
// other process. This opcode cannot be used to detect transactions opened
// by clients within the current process, only within other processes.
// </ul>
//
// <li>[[SQLITE_FCNTL_CKSM_FILE]]
// Used by the cksmvfs VFS module only.
// </ul>

// deprecated names

// CAPI3REF: Mutex Handle
//
// The mutex module within SQLite defines [sqlite3_mutex] to be an
// abstract type for a mutex object.  The SQLite core never looks
// at the internal representation of an [sqlite3_mutex].  It only
// deals with pointers to the [sqlite3_mutex] object.
//
// Mutexes are created using [sqlite3_mutex_alloc()].
type sqlite3_mutex1 = struct {
	FpReal       uintptr
	FeType       int32
	F__ccgo_pad1 [4]byte
} /* sqlite3.h:1244:9 */

// CAPI3REF: Loadable Extension Thunk
//
// A pointer to the opaque sqlite3_api_routines structure is passed as
// the third parameter to entry points of [loadable extensions].  This
// structure must be typedefed in order to work around compiler warnings
// on some platforms.
type sqlite3_api_routines1 = struct {
	Faggregate_context      uintptr
	Faggregate_count        uintptr
	Fbind_blob              uintptr
	Fbind_double            uintptr
	Fbind_int               uintptr
	Fbind_int64             uintptr
	Fbind_null              uintptr
	Fbind_parameter_count   uintptr
	Fbind_parameter_index   uintptr
	Fbind_parameter_name    uintptr
	Fbind_text              uintptr
	Fbind_text16            uintptr
	Fbind_value             uintptr
	Fbusy_handler           uintptr
	Fbusy_timeout           uintptr
	Fchanges                uintptr
	Fclose                  uintptr
	Fcollation_needed       uintptr
	Fcollation_needed16     uintptr
	Fcolumn_blob            uintptr
	Fcolumn_bytes           uintptr
	Fcolumn_bytes16         uintptr
	Fcolumn_count           uintptr
	Fcolumn_database_name   uintptr
	Fcolumn_database_name16 uintptr
	Fcolumn_decltype        uintptr
	Fcolumn_decltype16      uintptr
	Fcolumn_double          uintptr
	Fcolumn_int             uintptr
	Fcolumn_int64           uintptr
	Fcolumn_name            uintptr
	Fcolumn_name16          uintptr
	Fcolumn_origin_name     uintptr
	Fcolumn_origin_name16   uintptr
	Fcolumn_table_name      uintptr
	Fcolumn_table_name16    uintptr
	Fcolumn_text            uintptr
	Fcolumn_text16          uintptr
	Fcolumn_type            uintptr
	Fcolumn_value           uintptr
	Fcommit_hook            uintptr
	Fcomplete               uintptr
	Fcomplete16             uintptr
	Fcreate_collation       uintptr
	Fcreate_collation16     uintptr
	Fcreate_function        uintptr
	Fcreate_function16      uintptr
	Fcreate_module          uintptr
	Fdata_count             uintptr
	Fdb_handle              uintptr
	Fdeclare_vtab           uintptr
	Fenable_shared_cache    uintptr
	Ferrcode                uintptr
	Ferrmsg                 uintptr
	Ferrmsg16               uintptr
	Fexec                   uintptr
	Fexpired                uintptr
	Ffinalize               uintptr
	Ffree                   uintptr
	Ffree_table             uintptr
	Fget_autocommit         uintptr
	Fget_auxdata            uintptr
	Fget_table              uintptr
	Fglobal_recover         uintptr
	Finterruptx             uintptr
	Flast_insert_rowid      uintptr
	Flibversion             uintptr
	Flibversion_number      uintptr
	Fmalloc                 uintptr
	Fmprintf                uintptr
	Fopen                   uintptr
	Fopen16                 uintptr
	Fprepare                uintptr
	Fprepare16              uintptr
	Fprofile                uintptr
	Fprogress_handler       uintptr
	Frealloc                uintptr
	Freset                  uintptr
	Fresult_blob            uintptr
	Fresult_double          uintptr
	Fresult_error           uintptr
	Fresult_error16         uintptr
	Fresult_int             uintptr
	Fresult_int64           uintptr
	Fresult_null            uintptr
	Fresult_text            uintptr
	Fresult_text16          uintptr
	Fresult_text16be        uintptr
	Fresult_text16le        uintptr
	Fresult_value           uintptr
	Frollback_hook          uintptr
	Fset_authorizer         uintptr
	Fset_auxdata            uintptr
	Fxsnprintf              uintptr
	Fstep                   uintptr
	Ftable_column_metadata  uintptr
	Fthread_cleanup         uintptr
	Ftotal_changes          uintptr
	Ftrace                  uintptr
	Ftransfer_bindings      uintptr
	Fupdate_hook            uintptr
	Fuser_data              uintptr
	Fvalue_blob             uintptr
	Fvalue_bytes            uintptr
	Fvalue_bytes16          uintptr
	Fvalue_double           uintptr
	Fvalue_int              uintptr
	Fvalue_int64            uintptr
	Fvalue_numeric_type     uintptr
	Fvalue_text             uintptr
	Fvalue_text16           uintptr
	Fvalue_text16be         uintptr
	Fvalue_text16le         uintptr
	Fvalue_type             uintptr
	Fvmprintf               uintptr
	Foverload_function      uintptr
	Fprepare_v2             uintptr
	Fprepare16_v2           uintptr
	Fclear_bindings         uintptr
	Fcreate_module_v2       uintptr
	Fbind_zeroblob          uintptr
	Fblob_bytes             uintptr
	Fblob_close             uintptr
	Fblob_open              uintptr
	Fblob_read              uintptr
	Fblob_write             uintptr
	Fcreate_collation_v2    uintptr
	Ffile_control           uintptr
	Fmemory_highwater       uintptr
	Fmemory_used            uintptr
	Fmutex_alloc            uintptr
	Fmutex_enter            uintptr
	Fmutex_free             uintptr
	Fmutex_leave            uintptr
	Fmutex_try              uintptr
	Fopen_v2                uintptr
	Frelease_memory         uintptr
	Fresult_error_nomem     uintptr
	Fresult_error_toobig    uintptr
	Fsleep                  uintptr
	Fsoft_heap_limit        uintptr
	Fvfs_find               uintptr
	Fvfs_register           uintptr
	Fvfs_unregister         uintptr
	Fxthreadsafe            uintptr
	Fresult_zeroblob        uintptr
	Fresult_error_code      uintptr
	Ftest_control           uintptr
	Frandomness             uintptr
	Fcontext_db_handle      uintptr
	Fextended_result_codes  uintptr
	Flimit                  uintptr
	Fnext_stmt              uintptr
	Fsql                    uintptr
	Fstatus                 uintptr
	Fbackup_finish          uintptr
	Fbackup_init            uintptr
	Fbackup_pagecount       uintptr
	Fbackup_remaining       uintptr
	Fbackup_step            uintptr
	Fcompileoption_get      uintptr
	Fcompileoption_used     uintptr
	Fcreate_function_v2     uintptr
	Fdb_config              uintptr
	Fdb_mutex               uintptr
	Fdb_status              uintptr
	Fextended_errcode       uintptr
	Flog                    uintptr
	Fsoft_heap_limit64      uintptr
	Fsourceid               uintptr
	Fstmt_status            uintptr
	Fstrnicmp               uintptr
	Funlock_notify          uintptr
	Fwal_autocheckpoint     uintptr
	Fwal_checkpoint         uintptr
	Fwal_hook               uintptr
	Fblob_reopen            uintptr
	Fvtab_config            uintptr
	Fvtab_on_conflict       uintptr
	Fclose_v2               uintptr
	Fdb_filename            uintptr
	Fdb_readonly            uintptr
	Fdb_release_memory      uintptr
	Ferrstr                 uintptr
	Fstmt_busy              uintptr
	Fstmt_readonly          uintptr
	Fstricmp                uintptr
	Furi_boolean            uintptr
	Furi_int64              uintptr
	Furi_parameter          uintptr
	Fxvsnprintf             uintptr
	Fwal_checkpoint_v2      uintptr
	Fauto_extension         uintptr
	Fbind_blob64            uintptr
	Fbind_text64            uintptr
	Fcancel_auto_extension  uintptr
	Fload_extension         uintptr
	Fmalloc64               uintptr
	Fmsize                  uintptr
	Frealloc64              uintptr
	Freset_auto_extension   uintptr
	Fresult_blob64          uintptr
	Fresult_text64          uintptr
	Fstrglob                uintptr
	Fvalue_dup              uintptr
	Fvalue_free             uintptr
	Fresult_zeroblob64      uintptr
	Fbind_zeroblob64        uintptr
	Fvalue_subtype          uintptr
	Fresult_subtype         uintptr
	Fstatus64               uintptr
	Fstrlike                uintptr
	Fdb_cacheflush          uintptr
	Fsystem_errno           uintptr
	Ftrace_v2               uintptr
	Fexpanded_sql           uintptr
	Fset_last_insert_rowid  uintptr
	Fprepare_v3             uintptr
	Fprepare16_v3           uintptr
	Fbind_pointer           uintptr
	Fresult_pointer         uintptr
	Fvalue_pointer          uintptr
	Fvtab_nochange          uintptr
	Fvalue_nochange         uintptr
	Fvtab_collation         uintptr
	Fkeyword_count          uintptr
	Fkeyword_name           uintptr
	Fkeyword_check          uintptr
	Fstr_new                uintptr
	Fstr_finish             uintptr
	Fstr_appendf            uintptr
	Fstr_vappendf           uintptr
	Fstr_append             uintptr
	Fstr_appendall          uintptr
	Fstr_appendchar         uintptr
	Fstr_reset              uintptr
	Fstr_errcode            uintptr
	Fstr_length             uintptr
	Fstr_value              uintptr
	Fcreate_window_function uintptr
	Fnormalized_sql         uintptr
	Fstmt_isexplain         uintptr
	Fvalue_frombind         uintptr
	Fdrop_modules           uintptr
	Fhard_heap_limit64      uintptr
	Furi_key                uintptr
	Ffilename_database      uintptr
	Ffilename_journal       uintptr
	Ffilename_wal           uintptr
	Fcreate_filename        uintptr
	Ffree_filename          uintptr
	Fdatabase_file_object   uintptr
	Ftxn_state              uintptr
	Fchanges64              uintptr
	Ftotal_changes64        uintptr
	Fautovacuum_pages       uintptr
} /* sqlite3.h:1254:9 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs1 = struct {
	FiVersion          int32
	FszOsFile          int32
	FmxPathname        int32
	F__ccgo_pad1       [4]byte
	FpNext             uintptr
	FzName             uintptr
	FpAppData          uintptr
	FxOpen             uintptr
	FxDelete           uintptr
	FxAccess           uintptr
	FxFullPathname     uintptr
	FxDlOpen           uintptr
	FxDlError          uintptr
	FxDlSym            uintptr
	FxDlClose          uintptr
	FxRandomness       uintptr
	FxSleep            uintptr
	FxCurrentTime      uintptr
	FxGetLastError     uintptr
	FxCurrentTimeInt64 uintptr
	FxSetSystemCall    uintptr
	FxGetSystemCall    uintptr
	FxNextSystemCall   uintptr
} /* sqlite3.h:1425:9 */

// CAPI3REF: OS Interface Object
//
// An instance of the sqlite3_vfs object defines the interface between
// the SQLite core and the underlying operating system.  The "vfs"
// in the name of the object stands for "virtual file system".  See
// the [VFS | VFS documentation] for further information.
//
// The VFS interface is sometimes extended by adding new methods onto
// the end.  Each time such an extension occurs, the iVersion field
// is incremented.  The iVersion value started out as 1 in
// SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
// with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
// to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
// may be appended to the sqlite3_vfs object and the iVersion value
// may increase again in future versions of SQLite.
// Note that due to an oversight, the structure
// of the sqlite3_vfs object changed in the transition from
// SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
// and yet the iVersion field was not increased.
//
// The szOsFile field is the size of the subclassed [sqlite3_file]
// structure used by this VFS.  mxPathname is the maximum length of
// a pathname in this VFS.
//
// Registered sqlite3_vfs objects are kept on a linked list formed by
// the pNext pointer.  The [sqlite3_vfs_register()]
// and [sqlite3_vfs_unregister()] interfaces manage this list
// in a thread-safe way.  The [sqlite3_vfs_find()] interface
// searches the list.  Neither the application code nor the VFS
// implementation should use the pNext pointer.
//
// The pNext field is the only field in the sqlite3_vfs
// structure that SQLite will ever modify.  SQLite will only access
// or modify this field while holding a particular static mutex.
// The application should never modify anything within the sqlite3_vfs
// object once the object has been registered.
//
// The zName field holds the name of the VFS module.  The name must
// be unique across all VFS modules.
//
// [[sqlite3_vfs.xOpen]]
// ^SQLite guarantees that the zFilename parameter to xOpen
// is either a NULL pointer or string obtained
// from xFullPathname() with an optional suffix added.
// ^If a suffix is added to the zFilename parameter, it will
// consist of a single "-" character followed by no more than
// 11 alphanumeric and/or "-" characters.
// ^SQLite further guarantees that
// the string will be valid and unchanged until xClose() is
// called. Because of the previous sentence,
// the [sqlite3_file] can safely store a pointer to the
// filename if it needs to remember the filename for some reason.
// If the zFilename parameter to xOpen is a NULL pointer then xOpen
// must invent its own temporary name for the file.  ^Whenever the
// xFilename parameter is NULL it will also be the case that the
// flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
//
// The flags argument to xOpen() includes all bits set in
// the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
// or [sqlite3_open16()] is used, then flags includes at least
// [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
// If xOpen() opens a file read-only then it sets *pOutFlags to
// include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
//
// ^(SQLite will also add one of the following flags to the xOpen()
// call, depending on the object being opened:
//
// <ul>
// <li>  [SQLITE_OPEN_MAIN_DB]
// <li>  [SQLITE_OPEN_MAIN_JOURNAL]
// <li>  [SQLITE_OPEN_TEMP_DB]
// <li>  [SQLITE_OPEN_TEMP_JOURNAL]
// <li>  [SQLITE_OPEN_TRANSIENT_DB]
// <li>  [SQLITE_OPEN_SUBJOURNAL]
// <li>  [SQLITE_OPEN_SUPER_JOURNAL]
// <li>  [SQLITE_OPEN_WAL]
// </ul>)^
//
// The file I/O implementation can use the object type flags to
// change the way it deals with files.  For example, an application
// that does not care about crash recovery or rollback might make
// the open of a journal file a no-op.  Writes to this journal would
// also be no-ops, and any attempt to read the journal would return
// SQLITE_IOERR.  Or the implementation might recognize that a database
// file will be doing page-aligned sector reads and writes in a random
// order and set up its I/O subsystem accordingly.
//
// SQLite might also add one of the following flags to the xOpen method:
//
// <ul>
// <li> [SQLITE_OPEN_DELETEONCLOSE]
// <li> [SQLITE_OPEN_EXCLUSIVE]
// </ul>
//
// The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
// deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
// will be set for TEMP databases and their journals, transient
// databases, and subjournals.
//
// ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
// with the [SQLITE_OPEN_CREATE] flag, which are both directly
// analogous to the O_EXCL and O_CREAT flags of the POSIX open()
// API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
// SQLITE_OPEN_CREATE, is used to indicate that file should always
// be created, and that it is an error if it already exists.
// It is <i>not</i> used to indicate the file should be opened
// for exclusive access.
//
// ^At least szOsFile bytes of memory are allocated by SQLite
// to hold the [sqlite3_file] structure passed as the third
// argument to xOpen.  The xOpen method does not have to
// allocate the structure; it should just fill it in.  Note that
// the xOpen method must set the sqlite3_file.pMethods to either
// a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
// this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
// element will be valid after xOpen returns regardless of the success
// or failure of the xOpen call.
//
// [[sqlite3_vfs.xAccess]]
// ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
// to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
// test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
// to test whether a file is at least readable.  The SQLITE_ACCESS_READ
// flag is never actually used and is not implemented in the built-in
// VFSes of SQLite.  The file is named by the second argument and can be a
// directory. The xAccess method returns [SQLITE_OK] on success or some
// non-zero error code if there is an I/O error or if the name of
// the file given in the second argument is illegal.  If SQLITE_OK
// is returned, then non-zero or zero is written into *pResOut to indicate
// whether or not the file is accessible.
//
// ^SQLite will always allocate at least mxPathname+1 bytes for the
// output buffer xFullPathname.  The exact size of the output buffer
// is also passed as a parameter to both  methods. If the output buffer
// is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
// handled as a fatal error by SQLite, vfs implementations should endeavor
// to prevent this by setting mxPathname to a sufficiently large value.
//
// The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
// interfaces are not strictly a part of the filesystem, but they are
// included in the VFS structure for completeness.
// The xRandomness() function attempts to return nBytes bytes
// of good-quality randomness into zOut.  The return value is
// the actual number of bytes of randomness obtained.
// The xSleep() method causes the calling thread to sleep for at
// least the number of microseconds given.  ^The xCurrentTime()
// method returns a Julian Day Number for the current date and time as
// a floating point value.
// ^The xCurrentTimeInt64() method returns, as an integer, the Julian
// Day Number multiplied by 86400000 (the number of milliseconds in
// a 24-hour day).
// ^SQLite will use the xCurrentTimeInt64() method to get the current
// date and time if that method is available (if iVersion is 2 or
// greater and the function pointer is not NULL) and will fall back
// to xCurrentTime() if xCurrentTimeInt64() is unavailable.
//
// ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
// are not used by the SQLite core.  These optional interfaces are provided
// by some VFSes to facilitate testing of the VFS code. By overriding
// system calls with functions under its control, a test program can
// simulate faults and error conditions that would otherwise be difficult
// or impossible to induce.  The set of system calls that can be overridden
// varies from one VFS to another, and from one version of the same VFS to the
// next.  Applications that use these interfaces must be prepared for any
// or all of these interfaces to be NULL or for their behavior to change
// from one release to the next.  Applications must not attempt to access
// any of these methods if the iVersion of the VFS is less than 3.
type sqlite3_vfs = sqlite3_vfs1    /* sqlite3.h:1425:28 */
type sqlite3_syscall_ptr = uintptr /* sqlite3.h:1426:14 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods1 = struct {
	FxMalloc   uintptr
	FxFree     uintptr
	FxRealloc  uintptr
	FxSize     uintptr
	FxRoundup  uintptr
	FxInit     uintptr
	FxShutdown uintptr
	FpAppData  uintptr
} /* sqlite3.h:1723:9 */

// CAPI3REF: Memory Allocation Routines
//
// An instance of this object defines the interface between SQLite
// and low-level memory allocation routines.
//
// This object is used in only one place in the SQLite interface.
// A pointer to an instance of this object is the argument to
// [sqlite3_config()] when the configuration option is
// [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
// By creating an instance of this object
// and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
// during configuration, an application can specify an alternative
// memory allocation subsystem for SQLite to use for all of its
// dynamic memory needs.
//
// Note that SQLite comes with several [built-in memory allocators]
// that are perfectly adequate for the overwhelming majority of applications
// and that this object is only useful to a tiny minority of applications
// with specialized memory allocation requirements.  This object is
// also used during testing of SQLite in order to specify an alternative
// memory allocator that simulates memory out-of-memory conditions in
// order to verify that SQLite recovers gracefully from such
// conditions.
//
// The xMalloc, xRealloc, and xFree methods must work like the
// malloc(), realloc() and free() functions from the standard C library.
// ^SQLite guarantees that the second argument to
// xRealloc is always a value returned by a prior call to xRoundup.
//
// xSize should return the allocated size of a memory allocation
// previously obtained from xMalloc or xRealloc.  The allocated size
// is always at least as big as the requested size but may be larger.
//
// The xRoundup method returns what would be the allocated size of
// a memory allocation given a particular requested size.  Most memory
// allocators round up memory allocations at least to the next multiple
// of 8.  Some allocators round up to a larger multiple or to a power of 2.
// Every memory allocation request coming in through [sqlite3_malloc()]
// or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
// that causes the corresponding memory allocation to fail.
//
// The xInit method initializes the memory allocator.  For example,
// it might allocate any required mutexes or initialize internal data
// structures.  The xShutdown method is invoked (indirectly) by
// [sqlite3_shutdown()] and should deallocate any resources acquired
// by xInit.  The pAppData pointer is used as the only parameter to
// xInit and xShutdown.
//
// SQLite holds the [SQLITE_MUTEX_STATIC_MAIN] mutex when it invokes
// the xInit method, so the xInit method need not be threadsafe.  The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  For all other methods, SQLite
// holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
// [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
// it is by default) and so the methods are automatically serialized.
// However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
// methods must be threadsafe or else make their own arrangements for
// serialization.
//
// SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
type sqlite3_mem_methods = sqlite3_mem_methods1 /* sqlite3.h:1723:36 */

// CAPI3REF: Dynamically Typed Value Object
// KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
//
// SQLite uses the sqlite3_value object to represent all values
// that can be stored in a database table. SQLite uses dynamic typing
// for the values it stores.  ^Values stored in sqlite3_value objects
// can be integers, floating point values, strings, BLOBs, or NULL.
//
// An sqlite3_value object may be either "protected" or "unprotected".
// Some interfaces require a protected sqlite3_value.  Other interfaces
// will accept either a protected or an unprotected sqlite3_value.
// Every interface that accepts sqlite3_value arguments specifies
// whether or not it requires a protected sqlite3_value.  The
// [sqlite3_value_dup()] interface can be used to construct a new
// protected sqlite3_value from an unprotected sqlite3_value.
//
// The terms "protected" and "unprotected" refer to whether or not
// a mutex is held.  An internal mutex is held for a protected
// sqlite3_value object but no mutex is held for an unprotected
// sqlite3_value object.  If SQLite is compiled to be single-threaded
// (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
// or if SQLite is run in one of reduced mutex modes
// [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
// then there is no distinction between protected and unprotected
// sqlite3_value objects and they can be used interchangeably.  However,
// for maximum code portability it is recommended that applications
// still make the distinction between protected and unprotected
// sqlite3_value objects even when not strictly required.
//
// ^The sqlite3_value objects that are passed as parameters into the
// implementation of [application-defined SQL functions] are protected.
// ^The sqlite3_value object returned by
// [sqlite3_column_value()] is unprotected.
// Unprotected sqlite3_value objects may only be used as arguments
// to [sqlite3_result_value()], [sqlite3_bind_value()], and
// [sqlite3_value_dup()].
// The [sqlite3_value_blob | sqlite3_value_type()] family of
// interfaces require protected sqlite3_value objects.
type sqlite3_value1 = struct {
	Fu        struct{ Fr float64 }
	Fflags    u16
	Fenc      u8
	FeSubtype u8
	Fn        int32
	Fz        uintptr
	FzMalloc  uintptr
	FszMalloc int32
	FuTemp    u32
	Fdb       uintptr
	FxDel     uintptr
} /* sqlite3.h:4354:9 */

// CAPI3REF: SQL Function Context Object
//
// The context in which an SQL function executes is stored in an
// sqlite3_context object.  ^A pointer to an sqlite3_context object
// is always first parameter to [application-defined SQL functions].
// The application-defined SQL function implementation will pass this
// pointer through into calls to [sqlite3_result_int | sqlite3_result()],
// [sqlite3_aggregate_context()], [sqlite3_user_data()],
// [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],
// and/or [sqlite3_set_auxdata()].
type sqlite3_context1 = struct {
	FpOut        uintptr
	FpFunc       uintptr
	FpMem        uintptr
	FpVdbe       uintptr
	FiOp         int32
	FisError     int32
	FskipFlag    u8
	Fargc        u8
	F__ccgo_pad1 [6]byte
	Fargv        [1]uintptr
} /* sqlite3.h:4368:9 */

// CAPI3REF: Constants Defining Special Destructor Behavior
//
// These are special values for the destructor that is passed in as the
// final argument to routines like [sqlite3_result_blob()].  ^If the destructor
// argument is SQLITE_STATIC, it means that the content pointer is constant
// and will never change.  It does not need to be destroyed.  ^The
// SQLITE_TRANSIENT value means that the content will likely change in
// the near future and that SQLite should make its own private copy of
// the content before returning.
//
// The typedef is necessary to work around problems in certain
// C++ compilers.
type sqlite3_destructor_type = uintptr /* sqlite3.h:5733:14 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab1 = struct {
	FpModule     uintptr
	FnRef        int32
	F__ccgo_pad1 [4]byte
	FzErrMsg     uintptr
} /* sqlite3.h:6918:9 */

// The interface to the virtual-table mechanism is currently considered
// to be experimental.  The interface might change in incompatible ways.
// If this is a problem for you, do not use the interface at this time.
//
// When the virtual-table mechanism stabilizes, we will declare the
// interface fixed, support it indefinitely, and remove this comment.

// Structures used by the virtual table interface
type sqlite3_vtab = sqlite3_vtab1 /* sqlite3.h:6918:29 */
type sqlite3_index_info1 = struct {
	FnConstraint      int32
	F__ccgo_pad1      [4]byte
	FaConstraint      uintptr
	FnOrderBy         int32
	F__ccgo_pad2      [4]byte
	FaOrderBy         uintptr
	FaConstraintUsage uintptr
	FidxNum           int32
	F__ccgo_pad3      [4]byte
	FidxStr           uintptr
	FneedToFreeIdxStr int32
	ForderByConsumed  int32
	FestimatedCost    float64
	FestimatedRows    sqlite3_int64
	FidxFlags         int32
	F__ccgo_pad4      [4]byte
	FcolUsed          sqlite3_uint64
} /* sqlite3.h:6919:9 */

type sqlite3_index_info = sqlite3_index_info1        /* sqlite3.h:6919:35 */
type sqlite3_vtab_cursor1 = struct{ FpVtab uintptr } /* sqlite3.h:6920:9 */

type sqlite3_vtab_cursor = sqlite3_vtab_cursor1 /* sqlite3.h:6920:36 */
type sqlite3_module1 = struct {
	FiVersion      int32
	F__ccgo_pad1   [4]byte
	FxCreate       uintptr
	FxConnect      uintptr
	FxBestIndex    uintptr
	FxDisconnect   uintptr
	FxDestroy      uintptr
	FxOpen         uintptr
	FxClose        uintptr
	FxFilter       uintptr
	FxNext         uintptr
	FxEof          uintptr
	FxColumn       uintptr
	FxRowid        uintptr
	FxUpdate       uintptr
	FxBegin        uintptr
	FxSync         uintptr
	FxCommit       uintptr
	FxRollback     uintptr
	FxFindFunction uintptr
	FxRename       uintptr
	FxSavepoint    uintptr
	FxRelease      uintptr
	FxRollbackTo   uintptr
	FxShadowName   uintptr
} /* sqlite3.h:6918:9 */

type sqlite3_module = sqlite3_module1 /* sqlite3.h:6921:31 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint = struct {
	FiColumn     int32
	Fop          uint8
	Fusable      uint8
	F__ccgo_pad1 [2]byte
	FiTermOffset int32
} /* sqlite3.h:6919:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_orderby = struct {
	FiColumn     int32
	Fdesc        uint8
	F__ccgo_pad1 [3]byte
} /* sqlite3.h:6919:9 */

// CAPI3REF: Virtual Table Indexing Information
// KEYWORDS: sqlite3_index_info
//
// The sqlite3_index_info structure and its substructures is used as part
// of the [virtual table] interface to
// pass information into and receive the reply from the [xBestIndex]
// method of a [virtual table module].  The fields under **Inputs** are the
// inputs to xBestIndex and are read-only.  xBestIndex inserts its
// results into the **Outputs** fields.
//
// ^(The aConstraint[] array records WHERE clause constraints of the form:
//
// <blockquote>column OP expr</blockquote>
//
// where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
// stored in aConstraint[].op using one of the
// [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
// ^(The index of the column is stored in
// aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
// expr on the right-hand side can be evaluated (and thus the constraint
// is usable) and false if it cannot.)^
//
// ^The optimizer automatically inverts terms of the form "expr OP column"
// and makes other simplifications to the WHERE clause in an attempt to
// get as many WHERE clause terms into the form shown above as possible.
// ^The aConstraint[] array only reports WHERE clause terms that are
// relevant to the particular virtual table being queried.
//
// ^Information about the ORDER BY clause is stored in aOrderBy[].
// ^Each term of aOrderBy records a column of the ORDER BY clause.
//
// The colUsed field indicates which columns of the virtual table may be
// required by the current scan. Virtual table columns are numbered from
// zero in the order in which they appear within the CREATE TABLE statement
// passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
// the corresponding bit is set within the colUsed mask if the column may be
// required by SQLite. If the table has at least 64 columns and any column
// to the right of the first 63 is required, then bit 63 of colUsed is also
// set. In other words, column iCol may be required if the expression
// (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
// non-zero.
//
// The [xBestIndex] method must fill aConstraintUsage[] with information
// about what parameters to pass to xFilter.  ^If argvIndex>0 then
// the right-hand side of the corresponding aConstraint[] is evaluated
// and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
// is true, then the constraint is assumed to be fully handled by the
// virtual table and might not be checked again by the byte code.)^ ^(The
// aConstraintUsage[].omit flag is an optimization hint. When the omit flag
// is left in its default setting of false, the constraint will always be
// checked separately in byte code.  If the omit flag is change to true, then
// the constraint may or may not be checked in byte code.  In other words,
// when the omit flag is true there is no guarantee that the constraint will
// not be checked again using byte code.)^
//
// ^The idxNum and idxPtr values are recorded and passed into the
// [xFilter] method.
// ^[sqlite3_free()] is used to free idxPtr if and only if
// needToFreeIdxPtr is true.
//
// ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
// the correct order to satisfy the ORDER BY clause so that no separate
// sorting step is required.
//
// ^The estimatedCost value is an estimate of the cost of a particular
// strategy. A cost of N indicates that the cost of the strategy is similar
// to a linear scan of an SQLite table with N rows. A cost of log(N)
// indicates that the expense of the operation is similar to that of a
// binary search on a unique indexed field of an SQLite table with N rows.
//
// ^The estimatedRows value is an estimate of the number of rows that
// will be returned by the strategy.
//
// The xBestIndex method may optionally populate the idxFlags field with a
// mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
// SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
// assumes that the strategy may visit at most one row.
//
// Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
// SQLite also assumes that if a call to the xUpdate() method is made as
// part of the same statement to delete or update a virtual table row and the
// implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
// any database changes. In other words, if the xUpdate() returns
// SQLITE_CONSTRAINT, the database contents must be exactly as they were
// before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
// set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
// the xUpdate method are automatically rolled back by SQLite.
//
// IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
// structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
// If a virtual table extension is
// used with an SQLite version earlier than 3.8.2, the results of attempting
// to read or write the estimatedRows field are undefined (but are likely
// to include crashing the application). The estimatedRows field should
// therefore only be used if [sqlite3_libversion_number()] returns a
// value greater than or equal to 3008002. Similarly, the idxFlags field
// was added for [version 3.9.0] ([dateof:3.9.0]).
// It may therefore only be used if
// sqlite3_libversion_number() returns a value greater than or equal to
// 3009000.
type sqlite3_index_constraint_usage = struct {
	FargvIndex   int32
	Fomit        uint8
	F__ccgo_pad1 [3]byte
} /* sqlite3.h:6919:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods1 = struct {
	FxMutexInit    uintptr
	FxMutexEnd     uintptr
	FxMutexAlloc   uintptr
	FxMutexFree    uintptr
	FxMutexEnter   uintptr
	FxMutexTry     uintptr
	FxMutexLeave   uintptr
	FxMutexHeld    uintptr
	FxMutexNotheld uintptr
} /* sqlite3.h:7753:9 */

// CAPI3REF: Mutex Methods Object
//
// An instance of this structure defines the low-level routines
// used to allocate and use mutexes.
//
// Usually, the default mutex implementations provided by SQLite are
// sufficient, however the application has the option of substituting a custom
// implementation for specialized deployments or systems for which SQLite
// does not provide a suitable implementation. In this case, the application
// creates and populates an instance of this structure to pass
// to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
// Additionally, an instance of this structure can be used as an
// output variable when querying the system for the current mutex
// implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
//
// ^The xMutexInit method defined by this structure is invoked as
// part of system initialization by the sqlite3_initialize() function.
// ^The xMutexInit routine is called by SQLite exactly once for each
// effective call to [sqlite3_initialize()].
//
// ^The xMutexEnd method defined by this structure is invoked as
// part of system shutdown by the sqlite3_shutdown() function. The
// implementation of this method is expected to release all outstanding
// resources obtained by the mutex methods implementation, especially
// those obtained by the xMutexInit method.  ^The xMutexEnd()
// interface is invoked exactly once for each call to [sqlite3_shutdown()].
//
// ^(The remaining seven methods defined by this structure (xMutexAlloc,
// xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
// xMutexNotheld) implement the following interfaces (respectively):
//
// <ul>
//   <li>  [sqlite3_mutex_alloc()] </li>
//   <li>  [sqlite3_mutex_free()] </li>
//   <li>  [sqlite3_mutex_enter()] </li>
//   <li>  [sqlite3_mutex_try()] </li>
//   <li>  [sqlite3_mutex_leave()] </li>
//   <li>  [sqlite3_mutex_held()] </li>
//   <li>  [sqlite3_mutex_notheld()] </li>
// </ul>)^
//
// The only difference is that the public sqlite3_XXX functions enumerated
// above silently ignore any invocations that pass a NULL pointer instead
// of a valid mutex handle. The implementations of the methods defined
// by this structure are not required to handle this case. The results
// of passing a NULL pointer instead of a valid mutex handle are undefined
// (i.e. it is acceptable to provide an implementation that segfaults if
// it is passed a NULL pointer).
//
// The xMutexInit() method must be threadsafe.  It must be harmless to
// invoke xMutexInit() multiple times within the same process and without
// intervening calls to xMutexEnd().  Second and subsequent calls to
// xMutexInit() must be no-ops.
//
// xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
// and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
// allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
// memory allocation for a fast or recursive mutex.
//
// ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
// called, but only if the prior call to xMutexInit returned SQLITE_OK.
// If xMutexInit fails in any way, it is expected to clean up after itself
// prior to returning.
type sqlite3_mutex_methods = sqlite3_mutex_methods1 /* sqlite3.h:7753:38 */

// CAPI3REF: Dynamic String Object
// KEYWORDS: {dynamic string}
//
// An instance of the sqlite3_str object contains a dynamically-sized
// string under construction.
//
// The lifecycle of an sqlite3_str object is as follows:
// <ol>
// <li> ^The sqlite3_str object is created using [sqlite3_str_new()].
// <li> ^Text is appended to the sqlite3_str object using various
// methods, such as [sqlite3_str_appendf()].
// <li> ^The sqlite3_str object is destroyed and the string it created
// is returned using the [sqlite3_str_finish()] interface.
// </ol>
type sqlite3_str1 = struct {
	Fdb          uintptr
	FzText       uintptr
	FnAlloc      u32
	FmxAlloc     u32
	FnChar       u32
	FaccError    u8
	FprintfFlags u8
	F__ccgo_pad1 [2]byte
} /* sqlite3.h:8016:9 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page1 = struct {
	FpBuf   uintptr
	FpExtra uintptr
} /* sqlite3.h:8509:9 */

// CAPI3REF: Custom Page Cache Object
//
// The sqlite3_pcache_page object represents a single page in the
// page cache.  The page cache will allocate instances of this
// object.  Various methods of the page cache use pointers to instances
// of this object as parameters or as their return value.
//
// See [sqlite3_pcache_methods2] for additional information.
type sqlite3_pcache_page = sqlite3_pcache_page1 /* sqlite3.h:8509:36 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods21 = struct {
	FiVersion    int32
	F__ccgo_pad1 [4]byte
	FpArg        uintptr
	FxInit       uintptr
	FxShutdown   uintptr
	FxCreate     uintptr
	FxCachesize  uintptr
	FxPagecount  uintptr
	FxFetch      uintptr
	FxUnpin      uintptr
	FxRekey      uintptr
	FxTruncate   uintptr
	FxDestroy    uintptr
	FxShrink     uintptr
} /* sqlite3.h:8674:9 */

// CAPI3REF: Application Defined Page Cache.
// KEYWORDS: {page cache}
//
// ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
// register an alternative page cache implementation by passing in an
// instance of the sqlite3_pcache_methods2 structure.)^
// In many applications, most of the heap memory allocated by
// SQLite is used for the page cache.
// By implementing a
// custom page cache using this API, an application can better control
// the amount of memory consumed by SQLite, the way in which
// that memory is allocated and released, and the policies used to
// determine exactly which parts of a database file are cached and for
// how long.
//
// The alternative page cache mechanism is an
// extreme measure that is only needed by the most demanding applications.
// The built-in page cache is recommended for most uses.
//
// ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
// internal buffer by SQLite within the call to [sqlite3_config].  Hence
// the application may discard the parameter after the call to
// [sqlite3_config()] returns.)^
//
// [[the xInit() page cache method]]
// ^(The xInit() method is called once for each effective
// call to [sqlite3_initialize()])^
// (usually only once during the lifetime of the process). ^(The xInit()
// method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
// The intent of the xInit() method is to set up global data structures
// required by the custom page cache implementation.
// ^(If the xInit() method is NULL, then the
// built-in default page cache is used instead of the application defined
// page cache.)^
//
// [[the xShutdown() page cache method]]
// ^The xShutdown() method is called by [sqlite3_shutdown()].
// It can be used to clean up
// any outstanding resources before process shutdown, if required.
// ^The xShutdown() method may be NULL.
//
// ^SQLite automatically serializes calls to the xInit method,
// so the xInit method need not be threadsafe.  ^The
// xShutdown method is only called from [sqlite3_shutdown()] so it does
// not need to be threadsafe either.  All other methods must be threadsafe
// in multithreaded applications.
//
// ^SQLite will never invoke xInit() more than once without an intervening
// call to xShutdown().
//
// [[the xCreate() page cache methods]]
// ^SQLite invokes the xCreate() method to construct a new cache instance.
// SQLite will typically create one cache instance for each open database file,
// though this is not guaranteed. ^The
// first parameter, szPage, is the size in bytes of the pages that must
// be allocated by the cache.  ^szPage will always a power of two.  ^The
// second parameter szExtra is a number of bytes of extra storage
// associated with each page cache entry.  ^The szExtra parameter will
// a number less than 250.  SQLite will use the
// extra szExtra bytes on each page to store metadata about the underlying
// database page on disk.  The value passed into szExtra depends
// on the SQLite version, the target platform, and how SQLite was compiled.
// ^The third argument to xCreate(), bPurgeable, is true if the cache being
// created will be used to cache database pages of a file stored on disk, or
// false if it is used for an in-memory database. The cache implementation
// does not have to do anything special based with the value of bPurgeable;
// it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
// never invoke xUnpin() except to deliberately delete a page.
// ^In other words, calls to xUnpin() on a cache with bPurgeable set to
// false will always have the "discard" flag set to true.
// ^Hence, a cache created with bPurgeable false will
// never contain any unpinned pages.
//
// [[the xCachesize() page cache method]]
// ^(The xCachesize() method may be called at any time by SQLite to set the
// suggested maximum cache-size (number of pages stored by) the cache
// instance passed as the first argument. This is the value configured using
// the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
// parameter, the implementation is not required to do anything with this
// value; it is advisory only.
//
// [[the xPagecount() page cache methods]]
// The xPagecount() method must return the number of pages currently
// stored in the cache, both pinned and unpinned.
//
// [[the xFetch() page cache methods]]
// The xFetch() method locates a page in the cache and returns a pointer to
// an sqlite3_pcache_page object associated with that page, or a NULL pointer.
// The pBuf element of the returned sqlite3_pcache_page object will be a
// pointer to a buffer of szPage bytes used to store the content of a
// single database page.  The pExtra element of sqlite3_pcache_page will be
// a pointer to the szExtra bytes of extra storage that SQLite has requested
// for each entry in the page cache.
//
// The page to be fetched is determined by the key. ^The minimum key value
// is 1.  After it has been retrieved using xFetch, the page is considered
// to be "pinned".
//
// If the requested page is already in the page cache, then the page cache
// implementation must return a pointer to the page buffer with its content
// intact.  If the requested page is not already in the cache, then the
// cache implementation should use the value of the createFlag
// parameter to help it determined what action to take:
//
// <table border=1 width=85% align=center>
// <tr><th> createFlag <th> Behavior when page is not already in cache
// <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
// <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
//                 Otherwise return NULL.
// <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
//                 NULL if allocating a new page is effectively impossible.
// </table>
//
// ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
// will only use a createFlag of 2 after a prior call with a createFlag of 1
// failed.)^  In between the xFetch() calls, SQLite may
// attempt to unpin one or more cache pages by spilling the content of
// pinned pages to disk and synching the operating system disk cache.
//
// [[the xUnpin() page cache method]]
// ^xUnpin() is called by SQLite with a pointer to a currently pinned page
// as its second argument.  If the third parameter, discard, is non-zero,
// then the page must be evicted from the cache.
// ^If the discard parameter is
// zero, then the page may be discarded or retained at the discretion of
// page cache implementation. ^The page cache implementation
// may choose to evict unpinned pages at any time.
//
// The cache must not perform any reference counting. A single
// call to xUnpin() unpins the page regardless of the number of prior calls
// to xFetch().
//
// [[the xRekey() page cache methods]]
// The xRekey() method is used to change the key value associated with the
// page passed as the second argument. If the cache
// previously contains an entry associated with newKey, it must be
// discarded. ^Any prior cache entry associated with newKey is guaranteed not
// to be pinned.
//
// When SQLite calls the xTruncate() method, the cache must discard all
// existing cache entries with page numbers (keys) greater than or equal
// to the value of the iLimit parameter passed to xTruncate(). If any
// of these pages are pinned, they are implicitly unpinned, meaning that
// they can be safely discarded.
//
// [[the xDestroy() page cache method]]
// ^The xDestroy() method is used to delete a cache allocated by xCreate().
// All resources associated with the specified cache should be freed. ^After
// calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
// handle invalid, and will not use it with any other sqlite3_pcache_methods2
// functions.
//
// [[the xShrink() page cache method]]
// ^SQLite invokes the xShrink() method when it wants the page cache to
// free up as much of heap memory as possible.  The page cache implementation
// is not obligated to free any memory, but well-behaved implementations should
// do their best.
type sqlite3_pcache_methods2 = sqlite3_pcache_methods21 /* sqlite3.h:8674:40 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods1 = struct {
	FpArg       uintptr
	FxInit      uintptr
	FxShutdown  uintptr
	FxCreate    uintptr
	FxCachesize uintptr
	FxPagecount uintptr
	FxFetch     uintptr
	FxUnpin     uintptr
	FxRekey     uintptr
	FxTruncate  uintptr
	FxDestroy   uintptr
} /* sqlite3.h:8697:9 */

// This is the obsolete pcache_methods object that has now been replaced
// by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
// retained in the header file for backwards compatibility only.
type sqlite3_pcache_methods = sqlite3_pcache_methods1 /* sqlite3.h:8697:39 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot1 = struct{ Fhidden [48]uint8 } /* sqlite3.h:9765:9 */

// CAPI3REF: Database Snapshot
// KEYWORDS: {snapshot} {sqlite3_snapshot}
//
// An instance of the snapshot object records the state of a [WAL mode]
// database for some specific point in history.
//
// In [WAL mode], multiple [database connections] that are open on the
// same database file can each be reading a different historical version
// of the database file.  When a [database connection] begins a read
// transaction, that connection sees an unchanging copy of the database
// as it existed for the point in time when the transaction first started.
// Subsequent changes to the database from other connections are not seen
// by the reader until a new read transaction is started.
//
// The sqlite3_snapshot object records state information about an historical
// version of the database file so that it is possible to later open a new read
// transaction that sees that historical version of the database rather than
// the most recent version.
type sqlite3_snapshot = sqlite3_snapshot1 /* sqlite3.h:9767:3 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry1 = struct {
	FpContext    uintptr
	FnParam      int32
	F__ccgo_pad1 [4]byte
	FaParam      uintptr
	FpUser       uintptr
	FxDelUser    uintptr
} /* sqlite3.h:10096:9 */

// CAPI3REF: Flags for sqlite3_deserialize()
//
// The following are allowed values for 6th argument (the F argument) to
// the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
//
// The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
// in the P argument is held in memory obtained from [sqlite3_malloc64()]
// and that SQLite should take ownership of this memory and automatically
// free it when it has finished using it.  Without this flag, the caller
// is responsible for freeing any dynamically allocated memory.
//
// The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
// grow the size of the database using calls to [sqlite3_realloc64()].  This
// flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
// Without this flag, the deserialized database cannot increase in size beyond
// the number of bytes specified by the M parameter.
//
// The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
// should be treated as read-only.

// Undo the hack that converts floating point types to integer for
// builds on processors without floating point support.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

type sqlite3_rtree_geometry = sqlite3_rtree_geometry1 /* sqlite3.h:10096:39 */
type sqlite3_rtree_query_info1 = struct {
	FpContext      uintptr
	FnParam        int32
	F__ccgo_pad1   [4]byte
	FaParam        uintptr
	FpUser         uintptr
	FxDelUser      uintptr
	FaCoord        uintptr
	FanQueue       uintptr
	FnCoord        int32
	FiLevel        int32
	FmxLevel       int32
	F__ccgo_pad2   [4]byte
	FiRowid        sqlite3_int64
	FrParentScore  sqlite3_rtree_dbl
	FeParentWithin int32
	FeWithin       int32
	FrScore        sqlite3_rtree_dbl
	FapSqlParam    uintptr
} /* sqlite3.h:10097:9 */

type sqlite3_rtree_query_info = sqlite3_rtree_query_info1 /* sqlite3.h:10097:41 */

// The double-precision datatype used by RTree depends on the
// SQLITE_RTREE_INT_ONLY compile-time option.
type sqlite3_rtree_dbl = float64 /* sqlite3.h:10105:18 */

// CAPI3REF: Values for sqlite3session_config().

// Make sure we can call this stuff from C++.

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi1 = struct {
	FiVersion           int32
	F__ccgo_pad1        [4]byte
	FxUserData          uintptr
	FxColumnCount       uintptr
	FxRowCount          uintptr
	FxColumnTotalSize   uintptr
	FxTokenize          uintptr
	FxPhraseCount       uintptr
	FxPhraseSize        uintptr
	FxInstCount         uintptr
	FxInst              uintptr
	FxRowid             uintptr
	FxColumnText        uintptr
	FxColumnSize        uintptr
	FxQueryPhrase       uintptr
	FxSetAuxdata        uintptr
	FxGetAuxdata        uintptr
	FxPhraseFirst       uintptr
	FxPhraseNext        uintptr
	FxPhraseFirstColumn uintptr
	FxPhraseNextColumn  uintptr
} /* sqlite3.h:11952:9 */

// CAPI3REF: Values for sqlite3session_config().

// Make sure we can call this stuff from C++.

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

// ************************************************************************
//
// CUSTOM AUXILIARY FUNCTIONS
//
// Virtual table implementations may overload SQL functions by implementing
// the sqlite3_module.xFindFunction() method.

type Fts5ExtensionApi = Fts5ExtensionApi1 /* sqlite3.h:11952:33 */
type Fts5PhraseIter1 = struct {
	Fa uintptr
	Fb uintptr
} /* sqlite3.h:11954:9 */

type Fts5PhraseIter = Fts5PhraseIter1 /* sqlite3.h:11954:31 */

type fts5_extension_function = uintptr /* sqlite3.h:11956:14 */
type fts5_tokenizer1 = struct {
	FxCreate   uintptr
	FxDelete   uintptr
	FxTokenize uintptr
} /* sqlite3.h:12415:9 */

type fts5_tokenizer = fts5_tokenizer1 /* sqlite3.h:12415:31 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api1 = struct {
	FiVersion         int32
	F__ccgo_pad1      [4]byte
	FxCreateTokenizer uintptr
	FxFindTokenizer   uintptr
	FxCreateFunction  uintptr
} /* sqlite3.h:12451:9 */

// Flags that may be passed as the third argument to xTokenize()

// Flags that may be passed by the tokenizer implementation back to FTS5
// as the third argument to the supplied xToken callback.

//
// END OF CUSTOM TOKENIZERS
//

// ************************************************************************
//
// FTS5 EXTENSION REGISTRATION API
type fts5_api = fts5_api1 /* sqlite3.h:12451:25 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

type sqlite3expert1 = struct {
	FiSample     int32
	F__ccgo_pad1 [4]byte
	Fdb          uintptr
	Fdbm         uintptr
	Fdbv         uintptr
	FpTable      uintptr
	FpScan       uintptr
	FpWrite      uintptr
	FpStatement  uintptr
	FbRun        int32
	F__ccgo_pad2 [4]byte
	FpzErrmsg    uintptr
	Frc          int32
	F__ccgo_pad3 [4]byte
	FhIdx        IdxHash
	FzCandidates uintptr
} /* sqlite3expert.h:17:9 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

type sqlite3expert = sqlite3expert1 /* sqlite3expert.h:17:30 */

// -
// Copyright (c) 2011, 2012 The FreeBSD Foundation
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type locale_t = uintptr /* _strings.h:31:25 */

type ssize_t = int64 /* string.h:132:19 */

// xlocale extensions

type rsize_t = size_t /* string.h:151:16 */

type errno_t = int32 /* string.h:156:13 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chris Torek.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdio.h	8.5 (Berkeley) 4/29/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2003 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type fpos_t = int64 /* stdio.h:47:18 */

type off_t = int64 /* stdio.h:62:18 */

type off64_t = int64 /* stdio.h:72:19 */

// NB: to fit things in six character monocase externals, the stdio
// code uses the prefix `__s' for stdio objects, typically followed
// by a three-character attempt at a mnemonic.

// stdio buffers
type __sbuf = struct {
	F_base       uintptr
	F_size       int32
	F__ccgo_pad1 [4]byte
} /* stdio.h:91:1 */

// stdio state variables.
//
// The following always hold:
//
//	if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
//		_lbfsize is -_bf._size, else _lbfsize is 0
//	if _flags&__SRD, _w is 0
//	if _flags&__SWR, _r is 0
//
// This ensures that the getc and putc macros (or inline functions) never
// try to write or read from a file that is in `read' or `write' mode.
// (Moreover, they can, and do, automatically switch from read mode to
// write mode, and back, on "r+" and "w+" files.)
//
// _lbfsize is used only to make the inline line-buffered output stream
// code as compact as possible.
//
// _ub, _up, and _ur are used when ungetc() pushes back more characters
// than fit in the current _bf, or when ungetc() pushes back a character
// that does not match the previous one in _bf.  When this happens,
// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
//
// Certain members of __sFILE are accessed directly via macros or
// inline functions.  To preserve ABI compat, these members must not
// be disturbed.  These members are marked below with (*).
type __sFILE = struct {
	F_p          uintptr
	F_r          int32
	F_w          int32
	F_flags      int16
	F_file       int16
	F__ccgo_pad1 [4]byte
	F_bf         struct {
		F_base       uintptr
		F_size       int32
		F__ccgo_pad1 [4]byte
	}
	F_lbfsize    int32
	F__ccgo_pad2 [4]byte
	F_cookie     uintptr
	F_close      uintptr
	F_read       uintptr
	F_seek       uintptr
	F_write      uintptr
	F_ub         struct {
		F_base       uintptr
		F_size       int32
		F__ccgo_pad1 [4]byte
	}
	F_up   uintptr
	F_ur   int32
	F_ubuf [3]uint8
	F_nbuf [1]uint8
	F_lb   struct {
		F_base       uintptr
		F_size       int32
		F__ccgo_pad1 [4]byte
	}
	F_blksize     int32
	F__ccgo_pad3  [4]byte
	F_offset      fpos_t
	F_fl_mutex    uintptr
	F_fl_owner    uintptr
	F_fl_count    int32
	F_orientation int32
	F_mbstate     struct {
		F__ccgo_pad1 [0]uint64
		F__mbstate8  [128]int8
	}
	F_flags2     int32
	F__ccgo_pad4 [4]byte
} /* stdio.h:124:1 */

type FILE = __sFILE /* stdio.h:165:24 */
type cookie_io_functions_t = struct {
	Fread  uintptr
	Fwrite uintptr
	Fseek  uintptr
	Fclose uintptr
} /* stdio.h:428:3 */

// See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
// B.8.2.7 for the rationale behind the *_unlocked() macros.

type i64 = sqlite3_int64  /* sqlite3expert.c:37:23 */
type u64 = sqlite3_uint64 /* sqlite3expert.c:38:24 */

type IdxColumn1 = struct {
	FzName       uintptr
	FzColl       uintptr
	FiPk         int32
	F__ccgo_pad1 [4]byte
} /* sqlite3expert.h:17:9 */

type IdxColumn = IdxColumn1 /* sqlite3expert.c:40:26 */
type IdxConstraint1 = struct {
	FzColl  uintptr
	FbRange int32
	FiCol   int32
	FbFlag  int32
	FbDesc  int32
	FpNext  uintptr
	FpLink  uintptr
} /* sqlite3expert.h:17:9 */

type IdxConstraint = IdxConstraint1 /* sqlite3expert.c:41:30 */
type IdxScan1 = struct {
	FpTab        uintptr
	FiDb         int32
	F__ccgo_pad1 [4]byte
	Fcovering    i64
	FpOrder      uintptr
	FpEq         uintptr
	FpRange      uintptr
	FpNextScan   uintptr
} /* sqlite3expert.h:17:9 */

type IdxScan = IdxScan1 /* sqlite3expert.c:42:24 */
type IdxStatement1 = struct {
	FiId         int32
	F__ccgo_pad1 [4]byte
	FzSql        uintptr
	FzIdx        uintptr
	FzEQP        uintptr
	FpNext       uintptr
} /* sqlite3expert.h:17:9 */

type IdxStatement = IdxStatement1 /* sqlite3expert.c:43:29 */
type IdxTable1 = struct {
	FnCol        int32
	F__ccgo_pad1 [4]byte
	FzName       uintptr
	FaCol        uintptr
	FpNext       uintptr
} /* sqlite3expert.h:17:9 */

type IdxTable = IdxTable1 /* sqlite3expert.c:44:25 */
type IdxWrite1 = struct {
	FpTab        uintptr
	FeOp         int32
	F__ccgo_pad1 [4]byte
	FpNext       uintptr
} /* sqlite3expert.h:17:9 */

type IdxWrite = IdxWrite1 /* sqlite3expert.c:45:25 */

// A hash table for storing strings. With space for a payload string
// with each entry. Methods are:
//
//   idxHashInit()
//   idxHashClear()
//   idxHashAdd()
//   idxHashSearch()
type IdxHashEntry1 = struct {
	FzKey      uintptr
	FzVal      uintptr
	FzVal2     uintptr
	FpHashNext uintptr
	FpNext     uintptr
} /* sqlite3expert.h:17:9 */

// A hash table for storing strings. With space for a payload string
// with each entry. Methods are:
//
//   idxHashInit()
//   idxHashClear()
//   idxHashAdd()
//   idxHashSearch()
type IdxHashEntry = IdxHashEntry1 /* sqlite3expert.c:137:29 */
type IdxHash1 = struct {
	FpFirst uintptr
	FaHash  [1023]uintptr
} /* sqlite3expert.h:17:9 */

type IdxHash = IdxHash1 /* sqlite3expert.c:138:24 */

// Allocate and return nByte bytes of zeroed memory using sqlite3_malloc().
// If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
func idxMalloc(tls *libc.TLS, pRc uintptr, nByte int32) uintptr { /* sqlite3expert.c:175:13: */
	var pRet uintptr

	pRet = sqlite3.Xsqlite3_malloc(tls, nByte)
	if pRet != 0 {
		libc.Xmemset(tls, pRet, 0, uint64(nByte))
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	}
	return pRet
}

// Initialize an IdxHash hash table.
func idxHashInit(tls *libc.TLS, pHash uintptr) { /* sqlite3expert.c:191:13: */
	libc.Xmemset(tls, pHash, 0, uint64(unsafe.Sizeof(IdxHash{})))
}

// Reset an IdxHash hash table.
func idxHashClear(tls *libc.TLS, pHash uintptr) { /* sqlite3expert.c:198:13: */
	var i int32
	for i = 0; i < IDX_HASH_SIZE; i++ {
		var pEntry uintptr
		var pNext uintptr
		for pEntry = *(*uintptr)(unsafe.Pointer(pHash + 8 + uintptr(i)*8)); pEntry != 0; pEntry = pNext {
			pNext = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext
			sqlite3.Xsqlite3_free(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2)
			sqlite3.Xsqlite3_free(tls, pEntry)
		}
	}
	libc.Xmemset(tls, pHash, 0, uint64(unsafe.Sizeof(IdxHash{})))
}

// Return the index of the hash bucket that the string specified by the
// arguments to this function belongs.
func idxHashString(tls *libc.TLS, z uintptr, n int32) int32 { /* sqlite3expert.c:216:12: */
	var ret uint32 = uint32(0)
	var i int32
	for i = 0; i < n; i++ {
		ret = ret + (ret<<3 + uint32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(i))))))
	}
	return int32(ret % uint32(IDX_HASH_SIZE))
}

// If zKey is already present in the hash table, return non-zero and do
// nothing. Otherwise, add an entry with key zKey and payload string zVal to
// the hash table passed as the second argument.
func idxHashAdd(tls *libc.TLS, pRc uintptr, pHash uintptr, zKey uintptr, zVal uintptr) int32 { /* sqlite3expert.c:230:12: */
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var iHash int32 = idxHashString(tls, zKey, nKey)
	var nVal int32 = func() int32 {
		if zVal != 0 {
			return int32(libc.Xstrlen(tls, zVal))
		}
		return 0
	}()
	var pEntry uintptr

	for pEntry = *(*uintptr)(unsafe.Pointer(pHash + 8 + uintptr(iHash)*8)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if int32(libc.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey && 0 == libc.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint64(nKey)) {
			return 1
		}
	}
	pEntry = idxMalloc(tls, pRc, int32(uint64(unsafe.Sizeof(IdxHashEntry{}))+uint64(nKey)+uint64(1)+uint64(nVal)+uint64(1)))
	if pEntry != 0 {
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey = pEntry + 1*40
		libc.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint64(nKey))
		if zVal != 0 {
			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey + uintptr(nKey+1)
			libc.Xmemcpy(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal, zVal, uint64(nVal))
		}
		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext = *(*uintptr)(unsafe.Pointer(pHash + 8 + uintptr(iHash)*8))
		*(*uintptr)(unsafe.Pointer(pHash + 8 + uintptr(iHash)*8)) = pEntry

		(*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext = (*IdxHash)(unsafe.Pointer(pHash)).FpFirst
		(*IdxHash)(unsafe.Pointer(pHash)).FpFirst = pEntry
	}
	return 0
}

// If zKey/nKey is present in the hash table, return a pointer to the
// hash-entry object.
func idxHashFind(tls *libc.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr { /* sqlite3expert.c:267:21: */
	var iHash int32
	var pEntry uintptr
	if nKey < 0 {
		nKey = int32(libc.Xstrlen(tls, zKey))
	}
	iHash = idxHashString(tls, zKey, nKey)

	for pEntry = *(*uintptr)(unsafe.Pointer(pHash + 8 + uintptr(iHash)*8)); pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpHashNext {
		if int32(libc.Xstrlen(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey)) == nKey && 0 == libc.Xmemcmp(tls, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey, zKey, uint64(nKey)) {
			return pEntry
		}
	}
	return uintptr(0)
}

// If the hash table contains an entry with a key equal to the string
// passed as the final two arguments to this function, return a pointer
// to the payload string. Otherwise, if zKey/nKey is not present in the
// hash table, return NULL.
func idxHashSearch(tls *libc.TLS, pHash uintptr, zKey uintptr, nKey int32) uintptr { /* sqlite3expert.c:287:19: */
	var pEntry uintptr = idxHashFind(tls, pHash, zKey, nKey)
	if pEntry != 0 {
		return (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal
	}
	return uintptr(0)
}

// Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
// variable to point to a copy of nul-terminated string zColl.
func idxNewConstraint(tls *libc.TLS, pRc uintptr, zColl uintptr) uintptr { /* sqlite3expert.c:297:22: */
	var pNew uintptr
	var nColl int32 = int32(libc.Xstrlen(tls, zColl))

	pNew = idxMalloc(tls, pRc, int32(uint64(unsafe.Sizeof(IdxConstraint{}))*uint64(nColl)+uint64(1)))
	if pNew != 0 {
		(*IdxConstraint)(unsafe.Pointer(pNew)).FzColl = pNew + 1*40
		libc.Xmemcpy(tls, (*IdxConstraint)(unsafe.Pointer(pNew)).FzColl, zColl, uint64(nColl+1))
	}
	return pNew
}

// An error associated with database handle db has just occurred. Pass
// the error message to callback function xOut.
func idxDatabaseError(tls *libc.TLS, db uintptr, pzErrmsg uintptr) { /* sqlite3expert.c:314:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
}

// Prepare an SQL statement.
func idxPrepareStmt(tls *libc.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zSql uintptr) int32 { /* sqlite3expert.c:324:12: */
	var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, ppStmt, uintptr(0))
	if rc != SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
		idxDatabaseError(tls, db, pzErrmsg)
	}
	return rc
}

// Prepare an SQL statement using the results of a printf() formatting.
func idxPrintfPrepareStmt(tls *libc.TLS, db uintptr, ppStmt uintptr, pzErrmsg uintptr, zFmt uintptr, va uintptr) int32 { /* sqlite3expert.c:341:12: */
	var ap va_list
	_ = ap
	var rc int32
	var zSql uintptr
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		rc = idxPrepareStmt(tls, db, ppStmt, pzErrmsg, zSql)
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	_ = ap
	return rc
}

// ************************************************************************
//
// Beginning of virtual table implementation.
type ExpertVtab1 = struct {
	Fbase    sqlite3_vtab
	FpTab    uintptr
	FpExpert uintptr
} /* sqlite3expert.c:367:9 */

// ************************************************************************
//
// Beginning of virtual table implementation.
type ExpertVtab = ExpertVtab1 /* sqlite3expert.c:367:27 */

type ExpertCsr1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpData uintptr
} /* sqlite3expert.c:374:9 */

type ExpertCsr = ExpertCsr1 /* sqlite3expert.c:374:26 */

func expertDequote(tls *libc.TLS, zIn uintptr) uintptr { /* sqlite3expert.c:380:13: */
	var n int32 = int32(libc.Xstrlen(tls, zIn))
	var zRet uintptr = sqlite3.Xsqlite3_malloc(tls, n)

	if zRet != 0 {
		var iOut int32 = 0
		var iIn int32 = 0
		for iIn = 1; iIn < n-1; iIn++ {
			if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == '\'' {

				iIn++
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
		}
		*(*int8)(unsafe.Pointer(zRet + uintptr(iOut))) = int8(0)
	}

	return zRet
}

// This function is the implementation of both the xConnect and xCreate
// methods of the r-tree virtual table.
//
//   argv[0]   -> module name
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> column names...
func expertConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:412:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pExpert uintptr = pAux
	var p uintptr = uintptr(0)
	// var rc int32 at bp, 4

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3 /* "internal error!" */, 0)
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_ERROR
	} else {
		var zCreateTable uintptr = expertDequote(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))
		if zCreateTable != 0 {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				p = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(ExpertVtab{})))
			}
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				(*ExpertVtab)(unsafe.Pointer(p)).FpExpert = pExpert
				(*ExpertVtab)(unsafe.Pointer(p)).FpTab = (*sqlite3expert)(unsafe.Pointer(pExpert)).FpTable

			}
			sqlite3.Xsqlite3_free(tls, zCreateTable)
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_NOMEM
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = p
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func expertDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* sqlite3expert.c:448:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

func expertBestIndex(tls *libc.TLS, pVtab uintptr, pIdxInfo uintptr) int32 { /* sqlite3expert.c:454:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pVtab
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var n int32 = 0
	var pScan uintptr
	var opmask int32 = SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_GT | SQLITE_INDEX_CONSTRAINT_LT | SQLITE_INDEX_CONSTRAINT_GE | SQLITE_INDEX_CONSTRAINT_LE

	pScan = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(IdxScan{})))
	if pScan != 0 {
		var i int32

		// Link the new scan object into the list
		(*IdxScan)(unsafe.Pointer(pScan)).FpTab = (*ExpertVtab)(unsafe.Pointer(p)).FpTab
		(*IdxScan)(unsafe.Pointer(pScan)).FpNextScan = (*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan
		(*sqlite3expert)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpExpert)).FpScan = pScan

		// Add the constraints to the IdxScan object
		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12
			if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 &&
				(*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn >= 0 &&
				(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn)*24)).FiPk == 0 &&
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop)&opmask != 0 {
				var pNew uintptr
				var zColl uintptr = sqlite3.Xsqlite3_vtab_collation(tls, pIdxInfo, i)
				pNew = idxNewConstraint(tls, bp /* &rc */, zColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn
					if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpEq
						(*IdxScan)(unsafe.Pointer(pScan)).FpEq = pNew
					} else {
						(*IdxConstraint)(unsafe.Pointer(pNew)).FbRange = 1
						(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpRange
						(*IdxScan)(unsafe.Pointer(pScan)).FpRange = pNew
					}
				}
				n++
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = n
			}
		}

		// Add the ORDER BY to the IdxScan object
		for i = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy - 1; i >= 0; i-- {
			var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).FiColumn
			if iCol >= 0 {
				var pNew uintptr = idxNewConstraint(tls, bp /* &rc */, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(p)).FpTab)).FaCol+uintptr(iCol)*24)).FzColl)
				if pNew != 0 {
					(*IdxConstraint)(unsafe.Pointer(pNew)).FiCol = iCol
					(*IdxConstraint)(unsafe.Pointer(pNew)).FbDesc = int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(i)*8)).Fdesc)
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpNext = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxConstraint)(unsafe.Pointer(pNew)).FpLink = (*IdxScan)(unsafe.Pointer(pScan)).FpOrder
					(*IdxScan)(unsafe.Pointer(pScan)).FpOrder = pNew
					n++
				}
			}
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000.0 / float64(n+1)
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func expertUpdate(tls *libc.TLS, pVtab uintptr, nData int32, azData uintptr, pRowid uintptr) int32 { /* sqlite3expert.c:521:12: */
	_ = pVtab
	_ = nData
	_ = azData
	_ = pRowid
	return SQLITE_OK
}

// Virtual table module xOpen method.
func expertOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* sqlite3expert.c:537:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pCsr uintptr
	_ = pVTab
	pCsr = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(ExpertCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Virtual table module xClose method.
func expertClose(tls *libc.TLS, cur uintptr) int32 { /* sqlite3expert.c:549:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// Virtual table module xEof method.
//
// Return non-zero if the cursor does not currently point to a valid
// record (i.e if the scan has finished), or zero otherwise.
func expertEof(tls *libc.TLS, cur uintptr) int32 { /* sqlite3expert.c:562:12: */
	var pCsr uintptr = cur
	return libc.Bool32((*ExpertCsr)(unsafe.Pointer(pCsr)).FpData == uintptr(0))
}

// Virtual table module xNext method.
func expertNext(tls *libc.TLS, cur uintptr) int32 { /* sqlite3expert.c:570:12: */
	var pCsr uintptr = cur
	var rc int32 = SQLITE_OK

	rc = sqlite3.Xsqlite3_step(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	if rc != SQLITE_ROW {
		rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
		(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	} else {
		rc = SQLITE_OK
	}

	return rc
}

// Virtual table module xRowid method.
func expertRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* sqlite3expert.c:589:12: */
	_ = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

// Virtual table module xColumn method.
func expertColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* sqlite3expert.c:598:12: */
	var pCsr uintptr = cur
	var pVal uintptr
	pVal = sqlite3.Xsqlite3_column_value(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData, i)
	if pVal != 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, pVal)
	}
	return SQLITE_OK
}

// Virtual table module xFilter method.
func expertFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* sqlite3expert.c:611:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var pExpert uintptr = (*ExpertVtab)(unsafe.Pointer(pVtab)).FpExpert
	var rc int32

	_ = idxNum
	_ = idxStr
	_ = argc
	_ = argv
	rc = sqlite3.Xsqlite3_finalize(tls, (*ExpertCsr)(unsafe.Pointer(pCsr)).FpData)
	(*ExpertCsr)(unsafe.Pointer(pCsr)).FpData = uintptr(0)
	if rc == SQLITE_OK {
		rc = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pExpert)).Fdb, pCsr+8, pVtab+16,
			ts+19 /* "SELECT * FROM ma..." */, libc.VaList(bp, (*IdxTable)(unsafe.Pointer((*ExpertVtab)(unsafe.Pointer(pVtab)).FpTab)).FzName))
	}

	if rc == SQLITE_OK {
		rc = expertNext(tls, cur)
	}
	return rc
}

func idxRegisterVtab(tls *libc.TLS, p uintptr) int32 { /* sqlite3expert.c:639:12: */

	return sqlite3.Xsqlite3_create_module(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+56 /* "expert" */, uintptr(unsafe.Pointer(&expertModule)), p)
}

var expertModule = sqlite3_module{
	FiVersion:    2, // iVersion
	FxCreate:     0, // xCreate - create a table
	FxConnect:    0, // xConnect - connect to an existing table
	FxBestIndex:  0, // xBestIndex - Determine search strategy
	FxDisconnect: 0, // xDisconnect - Disconnect from a table
	FxDestroy:    0, // xDestroy - Drop a table
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xShadowName
} /* sqlite3expert.c:640:25 */

//
// End of virtual table implementation.
//
// Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
// is called, set it to the return value of sqlite3_finalize() before
// returning. Otherwise, discard the sqlite3_finalize() return value.
func idxFinalize(tls *libc.TLS, pRc uintptr, pStmt uintptr) { /* sqlite3expert.c:677:13: */
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = rc
	}
}

// Attempt to allocate an IdxTable structure corresponding to table zTab
// in the main database of connection db. If successful, set (*ppOut) to
// point to the new object and return SQLITE_OK. Otherwise, return an
// SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
// set to point to an error string.
//
// It is the responsibility of the caller to eventually free either the
// IdxTable object or error message using sqlite3_free().
func idxGetTableInfo(tls *libc.TLS, db uintptr, zTab uintptr, ppOut uintptr, pzErrmsg uintptr) int32 { /* sqlite3expert.c:692:12: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)) = uintptr(0)
	var nCol int32 = 0
	var nTab int32 = int32(libc.Xstrlen(tls, zTab))
	var nByte int32 = int32(uint64(unsafe.Sizeof(IdxTable{})) + uint64(nTab) + uint64(1))
	var pNew uintptr = uintptr(0)
	// var rc int32 at bp+24, 4

	var rc2 int32
	var pCsr uintptr = uintptr(0)
	var nPk int32 = 0

	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxPrintfPrepareStmt(tls, db, bp+8 /* &p1 */, pzErrmsg, ts+63 /* "PRAGMA table_xin..." */, libc.VaList(bp, zTab))
	for *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8))) {
		var zCol uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 1)
		*(*uintptr)(unsafe.Pointer(bp + 16 /* zColSeq */)) = uintptr(0)
		nByte = nByte + (1 + int32(libc.Xstrlen(tls, zCol)))
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+85 /* "main" */, zTab, zCol, uintptr(0), bp+16 /* &zColSeq */, uintptr(0), uintptr(0), uintptr(0))
		if *(*uintptr)(unsafe.Pointer(bp + 16)) == uintptr(0) {
			*(*uintptr)(unsafe.Pointer(bp + 16 /* zColSeq */)) = ts + 90 /* "binary" */
		}
		nByte = nByte + (1 + int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 16)))))
		nCol++
		nPk = nPk + libc.Bool32(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 5) > 0)
	}
	rc2 = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))
	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = rc2
	}

	nByte = int32(uint64(nByte) + uint64(unsafe.Sizeof(IdxColumn{}))*uint64(nCol))
	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		pNew = idxMalloc(tls, bp+24 /* &rc */, nByte)
	}
	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		(*IdxTable)(unsafe.Pointer(pNew)).FaCol = pNew + 1*32
		(*IdxTable)(unsafe.Pointer(pNew)).FnCol = nCol
		pCsr = (*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24
	}

	nCol = 0
	for *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8))) {
		var zCol uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)), 1)
		*(*uintptr)(unsafe.Pointer(bp + 32 /* zColSeq */)) = uintptr(0)
		var nCopy int32 = int32(libc.Xstrlen(tls, zCol)) + 1
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24)).FzName = pCsr
		(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24)).FiPk = libc.Bool32(sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8)), 5) == 1 && nPk == 1)
		libc.Xmemcpy(tls, pCsr, zCol, uint64(nCopy))
		pCsr += uintptr(nCopy)

		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = sqlite3.Xsqlite3_table_column_metadata(tls,
			db, ts+85 /* "main" */, zTab, zCol, uintptr(0), bp+32 /* &zColSeq */, uintptr(0), uintptr(0), uintptr(0))
		if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
			if *(*uintptr)(unsafe.Pointer(bp + 32)) == uintptr(0) {
				*(*uintptr)(unsafe.Pointer(bp + 32 /* zColSeq */)) = ts + 90 /* "binary" */
			}
			nCopy = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 32)))) + 1
			(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pNew)).FaCol + uintptr(nCol)*24)).FzColl = pCsr
			libc.Xmemcpy(tls, pCsr, *(*uintptr)(unsafe.Pointer(bp + 32 /* zColSeq */)), uint64(nCopy))
			pCsr += uintptr(nCopy)
		}

		nCol++
	}
	idxFinalize(tls, bp+24 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 8 /* p1 */)))

	if *(*int32)(unsafe.Pointer(bp + 24)) != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, pNew)
		pNew = uintptr(0)
	} else if pNew != uintptr(0) {
		(*IdxTable)(unsafe.Pointer(pNew)).FzName = pCsr
		if (*IdxTable)(unsafe.Pointer(pNew)).FzName != uintptr(0) {
			libc.Xmemcpy(tls, (*IdxTable)(unsafe.Pointer(pNew)).FzName, zTab, uint64(nTab+1))
		}
	}

	*(*uintptr)(unsafe.Pointer(ppOut)) = pNew
	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

// This function is a no-op if *pRc is set to anything other than
// SQLITE_OK when it is called.
//
// If *pRc is initially set to SQLITE_OK, then the text specified by
// the printf() style arguments is appended to zIn and the result returned
// in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
// zIn before returning.
func idxAppendText(tls *libc.TLS, pRc uintptr, zIn uintptr, zFmt uintptr, va uintptr) uintptr { /* sqlite3expert.c:779:13: */
	var ap va_list
	_ = ap
	var zAppend uintptr = uintptr(0)
	var zRet uintptr = uintptr(0)
	var nIn int32
	if zIn != 0 {
		nIn = int32(libc.Xstrlen(tls, zIn))
	} else {
		nIn = 0
	}
	var nAppend int32 = 0
	ap = va
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		zAppend = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
		if zAppend != 0 {
			nAppend = int32(libc.Xstrlen(tls, zAppend))
			zRet = sqlite3.Xsqlite3_malloc(tls, nIn+nAppend+1)
		}
		if zAppend != 0 && zRet != 0 {
			if nIn != 0 {
				libc.Xmemcpy(tls, zRet, zIn, uint64(nIn))
			}
			libc.Xmemcpy(tls, zRet+uintptr(nIn), zAppend, uint64(nAppend+1))
		} else {
			sqlite3.Xsqlite3_free(tls, zRet)
			zRet = uintptr(0)
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
		sqlite3.Xsqlite3_free(tls, zAppend)
		sqlite3.Xsqlite3_free(tls, zIn)
	}
	_ = ap
	return zRet
}

// Return true if zId must be quoted in order to use it as an SQL
// identifier, or false otherwise.
func idxIdentifierRequiresQuotes(tls *libc.TLS, zId uintptr) int32 { /* sqlite3expert.c:811:12: */
	var i int32
	for i = 0; *(*int8)(unsafe.Pointer(zId + uintptr(i))) != 0; i++ {
		if !(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) == '_') &&
			!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= '0' && int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= '9') &&
			!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'a' && int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'z') &&
			!(int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) >= 'A' && int32(*(*int8)(unsafe.Pointer(zId + uintptr(i)))) <= 'Z') {
			return 1
		}
	}
	return 0
}

// This function appends an index column definition suitable for constraint
// pCons to the string passed as zIn and returns the result.
func idxAppendColDefn(tls *libc.TLS, pRc uintptr, zIn uintptr, pTab uintptr, pCons uintptr) uintptr { /* sqlite3expert.c:829:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zRet uintptr = zIn
	var p uintptr = (*IdxTable)(unsafe.Pointer(pTab)).FaCol + uintptr((*IdxConstraint)(unsafe.Pointer(pCons)).FiCol)*24
	if zRet != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+97 /* ", " */, 0)
	}

	if idxIdentifierRequiresQuotes(tls, (*IdxColumn)(unsafe.Pointer(p)).FzName) != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+100 /* "%Q" */, libc.VaList(bp, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	} else {
		zRet = idxAppendText(tls, pRc, zRet, ts /* "%s" */, libc.VaList(bp+8, (*IdxColumn)(unsafe.Pointer(p)).FzName))
	}

	if sqlite3.Xsqlite3_stricmp(tls, (*IdxColumn)(unsafe.Pointer(p)).FzColl, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
		if idxIdentifierRequiresQuotes(tls, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl) != 0 {
			zRet = idxAppendText(tls, pRc, zRet, ts+103 /* " COLLATE %Q" */, libc.VaList(bp+16, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		} else {
			zRet = idxAppendText(tls, pRc, zRet, ts+115 /* " COLLATE %s" */, libc.VaList(bp+24, (*IdxConstraint)(unsafe.Pointer(pCons)).FzColl))
		}
	}

	if (*IdxConstraint)(unsafe.Pointer(pCons)).FbDesc != 0 {
		zRet = idxAppendText(tls, pRc, zRet, ts+127 /* " DESC" */, 0)
	}
	return zRet
}

// Search database dbm for an index compatible with the one idxCreateFromCons()
// would create from arguments pScan, pEq and pTail. If no error occurs and
// such an index is found, return non-zero. Or, if no such index is found,
// return zero.
//
// If an error occurs, set *pRc to an SQLite error code and return zero.
func idxFindCompatible(tls *libc.TLS, pRc uintptr, dbm uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 { /* sqlite3expert.c:867:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var zTbl uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)) = uintptr(0)
	var pIter uintptr
	var nEq int32 = 0 // Number of elements in pEq
	// var rc int32 at bp+32, 4

	// Count the elements in list pEq
	for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
		nEq++
	}

	*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+16 /* &pIdxList */, uintptr(0), ts+133 /* "PRAGMA index_lis..." */, libc.VaList(bp, zTbl))
	for *(*int32)(unsafe.Pointer(bp + 32)) == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16))) == SQLITE_ROW {
		var bMatch int32 = 1
		var pT uintptr = pTail
		*(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)) = uintptr(0)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)), 1)

		// Zero the IdxConstraint.bFlag values in the pEq list
		for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
			(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 0
		}

		*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+24 /* &pInfo */, uintptr(0), ts+154 /* "PRAGMA index_xIn..." */, libc.VaList(bp+8, zIdx))
		for *(*int32)(unsafe.Pointer(bp + 32)) == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24))) == SQLITE_ROW {
			var iIdx int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)), 0)
			var iCol int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)), 1)
			var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)), 4)

			if iIdx < nEq {
				for pIter = pEq; pIter != 0; pIter = (*IdxConstraint)(unsafe.Pointer(pIter)).FpLink {
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag != 0 {
						continue
					}
					if (*IdxConstraint)(unsafe.Pointer(pIter)).FiCol != iCol {
						continue
					}
					if sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pIter)).FzColl, zColl) != 0 {
						continue
					}
					(*IdxConstraint)(unsafe.Pointer(pIter)).FbFlag = 1
					break
				}
				if pIter == uintptr(0) {
					bMatch = 0
					break
				}
			} else {
				if pT != 0 {
					if (*IdxConstraint)(unsafe.Pointer(pT)).FiCol != iCol || sqlite3.Xsqlite3_stricmp(tls, (*IdxConstraint)(unsafe.Pointer(pT)).FzColl, zColl) != 0 {
						bMatch = 0
						break
					}
					pT = (*IdxConstraint)(unsafe.Pointer(pT)).FpLink
				}
			}
		}
		idxFinalize(tls, bp+32 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 24 /* pInfo */)))

		if *(*int32)(unsafe.Pointer(bp + 32)) == SQLITE_OK && bMatch != 0 {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)))
			return 1
		}
	}
	idxFinalize(tls, bp+32 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 16 /* pIdxList */)))

	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 32 /* rc */))
	return 0
}

// Callback for sqlite3_exec() with query with leading count(*) column.
// The first argument is expected to be an int*, referent to be incremented
// if that leading column is not exactly '0'.
func countNonzeros(tls *libc.TLS, pCount uintptr, nc int32, azResults uintptr, azColumns uintptr) int32 { /* sqlite3expert.c:938:12: */
	_ = azColumns // Suppress unused parameter warning
	if nc > 0 && (int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(azResults))))) != '0' || int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(azResults)) + 1))) != 0) {
		*(*int32)(unsafe.Pointer(pCount)) += 1
	}
	return 0
}

func idxCreateFromCons(tls *libc.TLS, p uintptr, pScan uintptr, pEq uintptr, pTail uintptr) int32 { /* sqlite3expert.c:947:12: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var dbm uintptr = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = SQLITE_OK
	if (pEq != 0 || pTail != 0) && 0 == idxFindCompatible(tls, bp+48, dbm, pScan, pEq, pTail) {
		var pTab uintptr = (*IdxScan)(unsafe.Pointer(pScan)).FpTab
		var zCols uintptr = uintptr(0)
		var zIdx uintptr = uintptr(0)
		var pCons uintptr
		var h uint32 = uint32(0)
		var zFmt uintptr

		for pCons = pEq; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+48 /* &rc */, zCols, pTab, pCons)
		}
		for pCons = pTail; pCons != 0; pCons = (*IdxConstraint)(unsafe.Pointer(pCons)).FpLink {
			zCols = idxAppendColDefn(tls, bp+48 /* &rc */, zCols, pTab, pCons)
		}

		if *(*int32)(unsafe.Pointer(bp + 48)) == SQLITE_OK {
			// Hash the list of columns to come up with a name for the index
			var zTable uintptr = (*IdxTable)(unsafe.Pointer((*IdxScan)(unsafe.Pointer(pScan)).FpTab)).FzName
			var quoteTable int32 = idxIdentifierRequiresQuotes(tls, zTable)
			var zName uintptr = uintptr(0) // Index name
			var collisions int32 = 0
			for ok := true; ok; ok = collisions < 50 && zName != uintptr(0) {
				// var i int32 at bp+52, 4

				var zFind uintptr
				for *(*int32)(unsafe.Pointer(bp + 52 /* i */)) = 0; *(*int8)(unsafe.Pointer(zCols + uintptr(*(*int32)(unsafe.Pointer(bp + 52 /* i */))))) != 0; *(*int32)(unsafe.Pointer(bp + 52 /* i */))++ {
					h = h + (h<<3 + uint32(*(*int8)(unsafe.Pointer(zCols + uintptr(*(*int32)(unsafe.Pointer(bp + 52 /* i */)))))))
				}
				sqlite3.Xsqlite3_free(tls, zName)
				zName = sqlite3.Xsqlite3_mprintf(tls, ts+176 /* "%s_idx_%08x" */, libc.VaList(bp, zTable, h))
				if zName == uintptr(0) {
					break
				}
				// Is is unique among table, view and index names?
				zFmt = ts + 188 /* "SELECT count(*) ..." */
				zFind = sqlite3.Xsqlite3_mprintf(tls, zFmt, libc.VaList(bp+16, zName))
				*(*int32)(unsafe.Pointer(bp + 52 /* i */)) = 0
				*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = sqlite3.Xsqlite3_exec(tls, dbm, zFind, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
				}{countNonzeros})), bp+52 /* &i */, uintptr(0))

				sqlite3.Xsqlite3_free(tls, zFind)
				if *(*int32)(unsafe.Pointer(bp + 52)) == 0 {
					collisions = 0
					break
				}
				collisions++
			}
			if collisions != 0 {
				// This return means "Gave up trying to find a unique index name."
				*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = SQLITE_BUSY | int32(3)<<8
			} else if zName == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = SQLITE_NOMEM
			} else {
				if quoteTable != 0 {
					zFmt = ts + 274 /* "CREATE INDEX \"%w..." */
				} else {
					zFmt = ts + 304 /* "CREATE INDEX %s ..." */
				}
				zIdx = sqlite3.Xsqlite3_mprintf(tls, zFmt, libc.VaList(bp+24, zName, zTable, zCols))
				if !(zIdx != 0) {
					*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = SQLITE_NOMEM
				} else {
					*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = sqlite3.Xsqlite3_exec(tls, dbm, zIdx, uintptr(0), uintptr(0), (*sqlite3expert)(unsafe.Pointer(p)).FpzErrmsg)
					if *(*int32)(unsafe.Pointer(bp + 48)) != SQLITE_OK {
						*(*int32)(unsafe.Pointer(bp + 48 /* rc */)) = SQLITE_BUSY | int32(3)<<8
					} else {
						idxHashAdd(tls, bp+48 /* &rc */, p+88, zName, zIdx)
					}
				}
				sqlite3.Xsqlite3_free(tls, zName)
				sqlite3.Xsqlite3_free(tls, zIdx)
			}
		}

		sqlite3.Xsqlite3_free(tls, zCols)
	}
	return *(*int32)(unsafe.Pointer(bp + 48 /* rc */))
}

// Return true if list pList (linked by IdxConstraint.pLink) contains
// a constraint compatible with *p. Otherwise return false.
func idxFindConstraint(tls *libc.TLS, pList uintptr, p uintptr) int32 { /* sqlite3expert.c:1035:12: */
	var pCmp uintptr
	for pCmp = pList; pCmp != 0; pCmp = (*IdxConstraint)(unsafe.Pointer(pCmp)).FpLink {
		if (*IdxConstraint)(unsafe.Pointer(p)).FiCol == (*IdxConstraint)(unsafe.Pointer(pCmp)).FiCol {
			return 1
		}
	}
	return 0
}

func idxCreateFromWhere(tls *libc.TLS, p uintptr, pScan uintptr, pTail uintptr) int32 { /* sqlite3expert.c:1043:12: */
	var p1 uintptr = uintptr(0)
	var pCon uintptr
	var rc int32

	// Gather up all the == constraints.
	for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpEq; pCon != 0; pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {
		if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
			(*IdxConstraint)(unsafe.Pointer(pCon)).FpLink = p1
			p1 = pCon
		}
	}

	// Create an index using the == constraints collected above. And the
	// range constraint/ORDER BY terms passed in by the caller, if any.
	rc = idxCreateFromCons(tls, p, pScan, p1, pTail)

	// If no range/ORDER BY passed by the caller, create a version of the
	// index for each range constraint.
	if pTail == uintptr(0) {
		for pCon = (*IdxScan)(unsafe.Pointer(pScan)).FpRange; rc == SQLITE_OK && pCon != 0; pCon = (*IdxConstraint)(unsafe.Pointer(pCon)).FpNext {

			if !(idxFindConstraint(tls, p1, pCon) != 0) && !(idxFindConstraint(tls, pTail, pCon) != 0) {
				rc = idxCreateFromCons(tls, p, pScan, p1, pCon)
			}
		}
	}

	return rc
}

// Create candidate indexes in database [dbm] based on the data in
// linked-list pScan.
func idxCreateCandidates(tls *libc.TLS, p uintptr) int32 { /* sqlite3expert.c:1082:12: */
	var rc int32 = SQLITE_OK
	var pIter uintptr

	for pIter = (*sqlite3expert)(unsafe.Pointer(p)).FpScan; pIter != 0 && rc == SQLITE_OK; pIter = (*IdxScan)(unsafe.Pointer(pIter)).FpNextScan {
		rc = idxCreateFromWhere(tls, p, pIter, uintptr(0))
		if rc == SQLITE_OK && (*IdxScan)(unsafe.Pointer(pIter)).FpOrder != 0 {
			rc = idxCreateFromWhere(tls, p, pIter, (*IdxScan)(unsafe.Pointer(pIter)).FpOrder)
		}
	}

	return rc
}

// Free all elements of the linked list starting at pConstraint.
func idxConstraintFree(tls *libc.TLS, pConstraint uintptr) { /* sqlite3expert.c:1099:13: */
	var pNext uintptr
	var p uintptr

	for p = pConstraint; p != 0; p = pNext {
		pNext = (*IdxConstraint)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free all elements of the linked list starting from pScan up until pLast
// (pLast is not freed).
func idxScanFree(tls *libc.TLS, pScan uintptr, pLast uintptr) { /* sqlite3expert.c:1113:13: */
	var p uintptr
	var pNext uintptr
	for p = pScan; p != pLast; p = pNext {
		pNext = (*IdxScan)(unsafe.Pointer(p)).FpNextScan
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpOrder)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpEq)
		idxConstraintFree(tls, (*IdxScan)(unsafe.Pointer(p)).FpRange)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free all elements of the linked list starting from pStatement up
// until pLast (pLast is not freed).
func idxStatementFree(tls *libc.TLS, pStatement uintptr, pLast uintptr) { /* sqlite3expert.c:1129:13: */
	var p uintptr
	var pNext uintptr
	for p = pStatement; p != pLast; p = pNext {
		pNext = (*IdxStatement)(unsafe.Pointer(p)).FpNext
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzEQP)
		sqlite3.Xsqlite3_free(tls, (*IdxStatement)(unsafe.Pointer(p)).FzIdx)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Free the linked list of IdxTable objects starting at pTab.
func idxTableFree(tls *libc.TLS, pTab uintptr) { /* sqlite3expert.c:1143:13: */
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxTable)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

// Free the linked list of IdxWrite objects starting at pTab.
func idxWriteFree(tls *libc.TLS, pTab uintptr) { /* sqlite3expert.c:1155:13: */
	var pIter uintptr
	var pNext uintptr
	for pIter = pTab; pIter != 0; pIter = pNext {
		pNext = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext
		sqlite3.Xsqlite3_free(tls, pIter)
	}
}

// This function is called after candidate indexes have been created. It
// runs all the queries to see which indexes they prefer, and populates
// IdxStatement.zIdx and IdxStatement.zEQP with the results.
func idxFindIndexes(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1171:5: */
	bp := tls.Alloc(8228)
	defer tls.Free(8228)

	var pStmt uintptr
	var dbm uintptr
	// var rc int32 at bp+8224, 4

	// var hIdx IdxHash at bp+24, 8192

	var zSql uintptr
	var nIdx int32
	var zIdx uintptr
	// int iId = sqlite3_column_int(pExplain, 0);
	// int iParent = sqlite3_column_int(pExplain, 1);
	// int iNotUsed = sqlite3_column_int(pExplain, 2);
	var zDetail uintptr
	var nDetail int32
	var i int32
	var pEntry uintptr
	// var pExplain uintptr at bp+8216, 8
	dbm = (*sqlite3expert)(unsafe.Pointer(p)).Fdbm
	*(*int32)(unsafe.Pointer(bp + 8224 /* rc */)) = SQLITE_OK
	idxHashInit(tls, bp+24 /* &hIdx */)

	pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
__1:
	if !(*(*int32)(unsafe.Pointer(bp + 8224)) == SQLITE_OK && pStmt != 0) {
		goto __3
	}
	*(*uintptr)(unsafe.Pointer(bp + 8216 /* pExplain */)) = uintptr(0)
	idxHashClear(tls, bp+24 /* &hIdx */)
	*(*int32)(unsafe.Pointer(bp + 8224 /* rc */)) = idxPrintfPrepareStmt(tls, dbm, bp+8216 /* &pExplain */, pzErr,
		ts+330 /* "EXPLAIN QUERY PL..." */, libc.VaList(bp, (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql))
__4:
	if !(*(*int32)(unsafe.Pointer(bp + 8224)) == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8216))) == SQLITE_ROW) {
		goto __5
	}
	// int iId = sqlite3_column_int(pExplain, 0);
	// int iParent = sqlite3_column_int(pExplain, 1);
	// int iNotUsed = sqlite3_column_int(pExplain, 2);
	zDetail = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8216 /* pExplain */)), 3)

	if !!(zDetail != 0) {
		goto __6
	}
	goto __4
__6:
	;
	nDetail = int32(libc.Xstrlen(tls, zDetail))

	i = 0
__7:
	if !(i < nDetail) {
		goto __9
	}
	zIdx = uintptr(0)
	if !(i+13 < nDetail && libc.Xmemcmp(tls, zDetail+uintptr(i), ts+352, uint64(13)) == 0) {
		goto __10
	}
	zIdx = zDetail + uintptr(i+13)
	goto __11
__10:
	if !(i+22 < nDetail &&
		libc.Xmemcmp(tls, zDetail+uintptr(i), ts+366, uint64(22)) == 0) {
		goto __12
	}
	zIdx = zDetail + uintptr(i+22)
__12:
	;
__11:
	;
	if !(zIdx != 0) {
		goto __13
	}
	nIdx = 0
__14:
	if !(int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != 0 && (int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx)))) != ' ' || int32(*(*int8)(unsafe.Pointer(zIdx + uintptr(nIdx+1)))) != '(')) {
		goto __15
	}
	nIdx++
	goto __14
__15:
	;
	zSql = idxHashSearch(tls, p+88, zIdx, nIdx)
	if !(zSql != 0) {
		goto __16
	}
	idxHashAdd(tls, bp+8224 /* &rc */, bp+24 /* &hIdx */, zSql, uintptr(0))
	if !(*(*int32)(unsafe.Pointer(bp + 8224)) != 0) {
		goto __17
	}
	goto find_indexes_out
__17:
	;
__16:
	;
	goto __9
__13:
	;
	goto __8
__8:
	i++
	goto __7
	goto __9
__9:
	;

	if !(int32(*(*int8)(unsafe.Pointer(zDetail))) != '-') {
		goto __18
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP = idxAppendText(tls, bp+8224 /* &rc */, (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP, ts+389 /* "%s\n" */, libc.VaList(bp+8, zDetail))
__18:
	;
	goto __4
__5:
	;

	pEntry = (*IdxHash)(unsafe.Pointer(bp + 24 /* &hIdx */)).FpFirst
__19:
	if !(pEntry != 0) {
		goto __21
	}
	(*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx = idxAppendText(tls, bp+8224 /* &rc */, (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx, ts+393 /* "%s;\n" */, libc.VaList(bp+16, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzKey))
	goto __20
__20:
	pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext
	goto __19
	goto __21
__21:
	;

	idxFinalize(tls, bp+8224 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 8216 /* pExplain */)))
	goto __2
__2:
	pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext
	goto __1
	goto __3
__3:
	;

find_indexes_out:
	idxHashClear(tls, bp+24 /* &hIdx */)
	return *(*int32)(unsafe.Pointer(bp + 8224 /* rc */))
}

func idxAuthCallback(tls *libc.TLS, pCtx uintptr, eOp int32, z3 uintptr, z4 uintptr, zDb uintptr, zTrigger uintptr) int32 { /* sqlite3expert.c:1241:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	_ = z4
	_ = zTrigger
	if eOp == SQLITE_INSERT || eOp == SQLITE_UPDATE || eOp == SQLITE_DELETE {
		if sqlite3.Xsqlite3_stricmp(tls, zDb, ts+85) == 0 {
			var p uintptr = pCtx
			var pTab uintptr
			for pTab = (*sqlite3expert)(unsafe.Pointer(p)).FpTable; pTab != 0; pTab = (*IdxTable)(unsafe.Pointer(pTab)).FpNext {
				if 0 == sqlite3.Xsqlite3_stricmp(tls, z3, (*IdxTable)(unsafe.Pointer(pTab)).FzName) {
					break
				}
			}
			if pTab != 0 {
				var pWrite uintptr
				for pWrite = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite; pWrite != 0; pWrite = (*IdxWrite)(unsafe.Pointer(pWrite)).FpNext {
					if (*IdxWrite)(unsafe.Pointer(pWrite)).FpTab == pTab && (*IdxWrite)(unsafe.Pointer(pWrite)).FeOp == eOp {
						break
					}
				}
				if pWrite == uintptr(0) {
					pWrite = idxMalloc(tls, bp /* &rc */, int32(unsafe.Sizeof(IdxWrite{})))
					if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpTab = pTab
						(*IdxWrite)(unsafe.Pointer(pWrite)).FeOp = eOp
						(*IdxWrite)(unsafe.Pointer(pWrite)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
						(*sqlite3expert)(unsafe.Pointer(p)).FpWrite = pWrite
					}
				}
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func idxProcessOneTrigger(tls *libc.TLS, p uintptr, pWrite uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1279:12: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var pTab uintptr = (*IdxWrite)(unsafe.Pointer(pWrite)).FpTab
	var zTab uintptr = (*IdxTable)(unsafe.Pointer(pTab)).FzName
	var zSql uintptr = ts + 398 /* "SELECT 'CREATE T..." */
	*(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = SQLITE_OK
	var zWrite uintptr = uintptr(0)

	// Create the table and its triggers in the temp schema
	*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+80 /* &pSelect */, pzErr, zSql, libc.VaList(bp, zTab, zTab))
	for *(*int32)(unsafe.Pointer(bp + 88)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80))) {
		var zCreate uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)), 0)
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zCreate, uintptr(0), uintptr(0), pzErr)
	}
	idxFinalize(tls, bp+88 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 80 /* pSelect */)))

	// Rename the table in the temp schema to zInt
	if *(*int32)(unsafe.Pointer(bp + 88)) == SQLITE_OK {
		var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+524 /* "ALTER TABLE temp..." */, libc.VaList(bp+16, zTab, zInt))
		if z == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = SQLITE_NOMEM
		} else {
			*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, z, uintptr(0), uintptr(0), pzErr)
			sqlite3.Xsqlite3_free(tls, z)
		}
	}

	switch (*IdxWrite)(unsafe.Pointer(pWrite)).FeOp {
	case SQLITE_INSERT:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+557 /* "INSERT INTO %Q V..." */, libc.VaList(bp+32, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+580 /* "%s?" */, libc.VaList(bp+40, func() uintptr {
					if i == 0 {
						return ts + 584 /* "" */
					}
					return ts + 97 /* ", " */
				}()))
			}
			zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+585 /* ")" */, 0)
			break

		}
	case SQLITE_UPDATE:
		{
			var i int32
			zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+587 /* "UPDATE %Q SET " */, libc.VaList(bp+48, zInt))
			for i = 0; i < (*IdxTable)(unsafe.Pointer(pTab)).FnCol; i++ {
				zWrite = idxAppendText(tls, bp+88 /* &rc */, zWrite, ts+602 /* "%s%Q=?" */, libc.VaList(bp+56, func() uintptr {
					if i == 0 {
						return ts + 584 /* "" */
					}
					return ts + 97 /* ", " */
				}(),
					(*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(pTab)).FaCol+uintptr(i)*24)).FzName))
			}
			break

		}
	default:
		{

			if *(*int32)(unsafe.Pointer(bp + 88)) == SQLITE_OK {
				zWrite = sqlite3.Xsqlite3_mprintf(tls, ts+609 /* "DELETE FROM %Q" */, libc.VaList(bp+72, zInt))
				if zWrite == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = SQLITE_NOMEM
				}
			}

		}
	}

	if *(*int32)(unsafe.Pointer(bp + 88)) == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 96 /* pX */)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zWrite, -1, bp+96 /* &pX */, uintptr(0))
		idxFinalize(tls, bp+88 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 96 /* pX */)))
		if *(*int32)(unsafe.Pointer(bp + 88)) != SQLITE_OK {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zWrite)

	if *(*int32)(unsafe.Pointer(bp + 88)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 88 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zDrop, uintptr(0), uintptr(0), pzErr)
	}

	return *(*int32)(unsafe.Pointer(bp + 88 /* rc */))
}

var zInt uintptr = ts + 624  /* "t592690916721053..." */ /* sqlite3expert.c:1284:21 */
var zDrop uintptr = ts + 662 /* "DROP TABLE t5926..." */ /* sqlite3expert.c:1285:21 */

func idxProcessTriggers(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1361:12: */
	var rc int32 = SQLITE_OK
	var pEnd uintptr = uintptr(0)
	var pFirst uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite

	for rc == SQLITE_OK && pFirst != pEnd {
		var pIter uintptr
		for pIter = pFirst; rc == SQLITE_OK && pIter != pEnd; pIter = (*IdxWrite)(unsafe.Pointer(pIter)).FpNext {
			rc = idxProcessOneTrigger(tls, p, pIter, pzErr)
		}
		pEnd = pFirst
		pFirst = (*sqlite3expert)(unsafe.Pointer(p)).FpWrite
	}

	return rc
}

func idxCreateVtabSchema(tls *libc.TLS, p uintptr, pzErrmsg uintptr) int32 { /* sqlite3expert.c:1379:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = idxRegisterVtab(tls, p)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)) = uintptr(0)

	// For each table in the main db schema:
	//
	//   1) Add an entry to the p->pTable list, and
	//   2) Create the equivalent virtual table in dbv.
	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, bp+40 /* &pSchema */, pzErrmsg,

		ts+711 /* "SELECT type, nam..." */)
	for *(*int32)(unsafe.Pointer(bp + 56)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40))) {
		var zType uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 0)
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 1)
		var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)), 2)

		if int32(*(*int8)(unsafe.Pointer(zType))) == 'v' || int32(*(*int8)(unsafe.Pointer(zType + 1))) == 'r' {
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), pzErrmsg)
		} else {
			// var pTab uintptr at bp+48, 8

			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = idxGetTableInfo(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, zName, bp+48 /* &pTab */, pzErrmsg)
			if *(*int32)(unsafe.Pointer(bp + 56)) == SQLITE_OK {
				var i int32
				var zInner uintptr = uintptr(0)
				var zOuter uintptr = uintptr(0)
				(*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpTable
				(*sqlite3expert)(unsafe.Pointer(p)).FpTable = *(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */))

				// The statement the vtab will pass to sqlite3_declare_vtab()
				zInner = idxAppendText(tls, bp+56 /* &rc */, uintptr(0), ts+979 /* "CREATE TABLE x(" */, 0)
				for i = 0; i < (*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FnCol; i++ {
					zInner = idxAppendText(tls, bp+56 /* &rc */, zInner, ts+995, /* "%s%Q COLLATE %s" */
						libc.VaList(bp, func() uintptr {
							if i == 0 {
								return ts + 584 /* "" */
							}
							return ts + 97 /* ", " */
						}(), (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FaCol+uintptr(i)*24)).FzName, (*IdxColumn)(unsafe.Pointer((*IdxTable)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* pTab */)))).FaCol+uintptr(i)*24)).FzColl))
				}
				zInner = idxAppendText(tls, bp+56 /* &rc */, zInner, ts+585 /* ")" */, 0)

				// The CVT statement to create the vtab
				zOuter = idxAppendText(tls, bp+56 /* &rc */, uintptr(0),
					ts+1011 /* "CREATE VIRTUAL T..." */, libc.VaList(bp+24, zName, zInner))
				if *(*int32)(unsafe.Pointer(bp + 56)) == SQLITE_OK {
					*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zOuter, uintptr(0), uintptr(0), pzErrmsg)
				}
				sqlite3.Xsqlite3_free(tls, zInner)
				sqlite3.Xsqlite3_free(tls, zOuter)
			}
		}
	}
	idxFinalize(tls, bp+56 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pSchema */)))
	return *(*int32)(unsafe.Pointer(bp + 56 /* rc */))
}

type IdxSampleCtx = struct {
	FiTarget     int32
	F__ccgo_pad1 [4]byte
	Ftarget      float64
	FnRow        float64
	FnRet        float64
} /* sqlite3expert.c:1439:1 */

func idxSampleFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* sqlite3expert.c:1446:13: */
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var bRet int32

	_ = argv

	if (*IdxSampleCtx)(unsafe.Pointer(p)).FnRow == 0.0 {
		bRet = 1
	} else {
		bRet = libc.Bool32((*IdxSampleCtx)(unsafe.Pointer(p)).FnRet/(*IdxSampleCtx)(unsafe.Pointer(p)).FnRow <= (*IdxSampleCtx)(unsafe.Pointer(p)).Ftarget)
		if bRet == 0 {
			// var rnd uint16 at bp, 2

			sqlite3.Xsqlite3_randomness(tls, 2, bp /* &rnd */)
			bRet = libc.Bool32(int32(*(*uint16)(unsafe.Pointer(bp)))%100 <= (*IdxSampleCtx)(unsafe.Pointer(p)).FiTarget)
		}
	}

	sqlite3.Xsqlite3_result_int(tls, pCtx, bRet)
	*(*float64)(unsafe.Pointer(p + 16)) += 1.0
	*(*float64)(unsafe.Pointer(p + 24)) += float64(bRet)
}

type IdxRemCtx = struct {
	FnSlot       int32
	F__ccgo_pad1 [4]byte
	FaSlot       [1]struct {
		FeType       int32
		F__ccgo_pad1 [4]byte
		FiVal        i64
		FrVal        float64
		FnByte       int32
		Fn           int32
		Fz           uintptr
	}
} /* sqlite3expert.c:1472:1 */

type IdxRemSlot = struct {
	FeType       int32
	F__ccgo_pad1 [4]byte
	FiVal        i64
	FrVal        float64
	FnByte       int32
	Fn           int32
	Fz           uintptr
} /* sqlite3expert.c:1472:1 */

// Implementation of scalar function rem().
func idxRemFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* sqlite3expert.c:1487:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pSlot uintptr
	var iSlot int32

	iSlot = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))

	pSlot = p + 8 + uintptr(iSlot)*40

	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case SQLITE_NULL:
		// no-op
		break

	case SQLITE_INTEGER:
		sqlite3.Xsqlite3_result_int64(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal)
		break

	case SQLITE_FLOAT:
		sqlite3.Xsqlite3_result_double(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal)
		break

	case SQLITE_BLOB:
		sqlite3.Xsqlite3_result_blob(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, libc.UintptrFromInt32(-1))
		break

	case SQLITE_TEXT:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn, libc.UintptrFromInt32(-1))
		break
	}

	(*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	switch (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType {
	case SQLITE_NULL:
		// no-op
		break

	case SQLITE_INTEGER:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FiVal = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		break

	case SQLITE_FLOAT:
		(*IdxRemSlot)(unsafe.Pointer(pSlot)).FrVal = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		break

	case SQLITE_BLOB:
		fallthrough
	case SQLITE_TEXT:
		{
			var nByte int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
			if nByte > (*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte {
				var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, nByte*2)
				if zNew == uintptr(0) {
					sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
					return
				}
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).FnByte = nByte * 2
				(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz = zNew
			}
			(*IdxRemSlot)(unsafe.Pointer(pSlot)).Fn = nByte
			if (*IdxRemSlot)(unsafe.Pointer(pSlot)).FeType == SQLITE_BLOB {
				libc.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))), uint64(nByte))
			} else {
				libc.Xmemcpy(tls, (*IdxRemSlot)(unsafe.Pointer(pSlot)).Fz, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))), uint64(nByte))
			}
			break

		}
	}
}

func idxLargestIndex(tls *libc.TLS, db uintptr, pnMax uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1560:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = SQLITE_OK
	var zMax uintptr = ts + 1052 /* "SELECT max(i.seq..." */
	*(*uintptr)(unsafe.Pointer(bp /* pMax */)) = uintptr(0)

	*(*int32)(unsafe.Pointer(pnMax)) = 0
	*(*int32)(unsafe.Pointer(bp + 8 /* rc */)) = idxPrepareStmt(tls, db, bp /* &pMax */, pzErr, zMax)
	if *(*int32)(unsafe.Pointer(bp + 8)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp))) {
		*(*int32)(unsafe.Pointer(pnMax)) = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp)), 0) + 1
	}
	idxFinalize(tls, bp+8 /* &rc */, *(*uintptr)(unsafe.Pointer(bp /* pMax */)))

	return *(*int32)(unsafe.Pointer(bp + 8 /* rc */))
}

func idxPopulateOneStat1(tls *libc.TLS, p uintptr, pIndexXInfo uintptr, pWriteStat uintptr, zTab uintptr, zIdx uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1580:12: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var zCols uintptr = uintptr(0)
	var zOrder uintptr = uintptr(0)
	var zQuery uintptr = uintptr(0)
	var nCol int32 = 0
	var i int32
	*(*uintptr)(unsafe.Pointer(bp + 120 /* pQuery */)) = uintptr(0)
	var aStat uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = SQLITE_OK

	// Formulate the query text
	sqlite3.Xsqlite3_bind_text(tls, pIndexXInfo, 1, zIdx, -1, uintptr(0))
	for SQLITE_OK == *(*int32)(unsafe.Pointer(bp + 112)) && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pIndexXInfo) {
		var zComma uintptr
		if zCols == uintptr(0) {
			zComma = ts + 584 /* "" */
		} else {
			zComma = ts + 97 /* ", " */
		}
		var zName uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 0)
		var zColl uintptr = sqlite3.Xsqlite3_column_text(tls, pIndexXInfo, 1)
		zCols = idxAppendText(tls, bp+112 /* &rc */, zCols,
			ts+1189 /* "%sx.%Q IS rem(%d..." */, libc.VaList(bp, zComma, zName, nCol, zName, zColl))
		zOrder = idxAppendText(tls, bp+112 /* &rc */, zOrder, ts+1224 /* "%s%d" */, libc.VaList(bp+40, zComma, libc.PreIncInt32(&nCol, 1)))
	}
	sqlite3.Xsqlite3_reset(tls, pIndexXInfo)
	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
		if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1229 /* "SELECT %s FROM %..." */, libc.VaList(bp+56, zCols, zTab, zOrder))
		} else {
			zQuery = sqlite3.Xsqlite3_mprintf(tls,
				ts+1261 /* "SELECT %s FROM t..." */, libc.VaList(bp+80, zCols, zOrder))
		}
	}
	sqlite3.Xsqlite3_free(tls, zCols)
	sqlite3.Xsqlite3_free(tls, zOrder)

	// Formulate the query text
	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = idxPrepareStmt(tls, dbrem, bp+120 /* &pQuery */, pzErr, zQuery)
	}
	sqlite3.Xsqlite3_free(tls, zQuery)

	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
		aStat = idxMalloc(tls, bp+112 /* &rc */, int32(uint64(unsafe.Sizeof(int32(0)))*uint64(nCol+1)))
	}
	if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 120))) {
		var pEntry uintptr
		var zStat uintptr = uintptr(0)
		for i = 0; i <= nCol; i++ {
			*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4)) = 1
		}
		for *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 120))) {
			*(*int32)(unsafe.Pointer(aStat))++
			for i = 0; i < nCol; i++ {
				if sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 120)), i) == 0 {
					break
				}
			}
			for ; i < nCol; i++ {
				*(*int32)(unsafe.Pointer(aStat + uintptr(i+1)*4))++
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
			var s0 int32 = *(*int32)(unsafe.Pointer(aStat))
			zStat = sqlite3.Xsqlite3_mprintf(tls, ts+1333 /* "%d" */, libc.VaList(bp+96, s0))
			if zStat == uintptr(0) {
				*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = SQLITE_NOMEM
			}
			for i = 1; *(*int32)(unsafe.Pointer(bp + 112 /* rc */)) == SQLITE_OK && i <= nCol; i++ {
				zStat = idxAppendText(tls, bp+112 /* &rc */, zStat, ts+1336 /* " %d" */, libc.VaList(bp+104, (s0+*(*int32)(unsafe.Pointer(aStat + uintptr(i)*4))/2) / *(*int32)(unsafe.Pointer(aStat + uintptr(i)*4))))
			}
		}

		if *(*int32)(unsafe.Pointer(bp + 112)) == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 1, zTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 2, zIdx, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pWriteStat, 3, zStat, -1, uintptr(0))
			sqlite3.Xsqlite3_step(tls, pWriteStat)
			*(*int32)(unsafe.Pointer(bp + 112 /* rc */)) = sqlite3.Xsqlite3_reset(tls, pWriteStat)
		}

		pEntry = idxHashFind(tls, p+88, zIdx, int32(libc.Xstrlen(tls, zIdx)))
		if pEntry != 0 {

			(*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 = zStat
		} else {
			sqlite3.Xsqlite3_free(tls, zStat)
		}
	}
	sqlite3.Xsqlite3_free(tls, aStat)
	idxFinalize(tls, bp+112 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 120 /* pQuery */)))

	return *(*int32)(unsafe.Pointer(bp + 112 /* rc */))
}

func idxBuildSampleTable(tls *libc.TLS, p uintptr, zTab uintptr) int32 { /* sqlite3expert.c:1680:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	var zSql uintptr

	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, ts+1340 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+1404 /* "CREATE TABLE tem..." */, libc.VaList(bp, zTab))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	return rc
}

// This function is called as part of sqlite3_expert_analyze(). Candidate
// indexes have already been created in database sqlite3expert.dbm, this
// function populates sqlite_stat1 table in the same database.
//
// The stat1 data is generated by querying the
func idxPopulateStat1(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1704:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = SQLITE_OK
	*(*int32)(unsafe.Pointer(bp /* nMax */)) = 0
	var pCtx uintptr = uintptr(0)
	// var samplectx IdxSampleCtx at bp+8, 32

	var i int32
	var iPrev i64 = int64(-100000)
	*(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 48 /* pIndexXInfo */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 56 /* pWrite */)) = uintptr(0)

	var zAllIndex uintptr = ts + 1480   /* "SELECT s.rowid, ..." */
	var zIndexXInfo uintptr = ts + 1594 /* "SELECT name, col..." */
	var zWrite uintptr = ts + 1649      /* "INSERT INTO sqli..." */

	// If iSample==0, no sqlite_stat1 data is required.
	if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 0 {
		return SQLITE_OK
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxLargestIndex(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp /* &nMax */, pzErr)
	if *(*int32)(unsafe.Pointer(bp)) <= 0 || *(*int32)(unsafe.Pointer(bp + 4)) != SQLITE_OK {
		return *(*int32)(unsafe.Pointer(bp + 4 /* rc */))
	}

	*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+1690 /* "ANALYZE; PRAGMA ..." */, uintptr(0), uintptr(0), uintptr(0))

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		var nByte int32 = int32(uint64(unsafe.Sizeof(IdxRemCtx{})) + uint64(unsafe.Sizeof(IdxRemSlot{}))*uint64(*(*int32)(unsafe.Pointer(bp))))
		pCtx = idxMalloc(tls, bp+4 /* &rc */, nByte)
	}

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		var dbrem uintptr = func() uintptr {
			if (*sqlite3expert)(unsafe.Pointer(p)).FiSample == 100 {
				return (*sqlite3expert)(unsafe.Pointer(p)).Fdb
			}
			return (*sqlite3expert)(unsafe.Pointer(p)).Fdbv
		}()
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_create_function(tls,
			dbrem, ts+1724 /* "rem" */, 2, SQLITE_UTF8, pCtx, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{idxRemFunc})), uintptr(0), uintptr(0))
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_create_function(tls,
			(*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+1728 /* "sample" */, 0, SQLITE_UTF8, bp+8 /* &samplectx */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{idxSampleFunc})), uintptr(0), uintptr(0))
	}

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		(*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot = *(*int32)(unsafe.Pointer(bp)) + 1
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+40 /* &pAllIndex */, pzErr, zAllIndex)
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+48 /* &pIndexXInfo */, pzErr, zIndexXInfo)
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, bp+56 /* &pWrite */, pzErr, zWrite)
	}

	for *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40))) {
		var iRowid i64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 0)
		var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 1)
		var zIdx uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)), 2)
		if (*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100 && iPrev != iRowid {
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).Ftarget = float64((*sqlite3expert)(unsafe.Pointer(p)).FiSample) / 100.0
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FiTarget = (*sqlite3expert)(unsafe.Pointer(p)).FiSample
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FnRow = 0.0
			(*IdxSampleCtx)(unsafe.Pointer(bp + 8 /* &samplectx */)).FnRet = 0.0
			*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxBuildSampleTable(tls, p, zTab)
			if *(*int32)(unsafe.Pointer(bp + 4)) != SQLITE_OK {
				break
			}
		}
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = idxPopulateOneStat1(tls, p, *(*uintptr)(unsafe.Pointer(bp + 48 /* pIndexXInfo */)), *(*uintptr)(unsafe.Pointer(bp + 56 /* pWrite */)), zTab, zIdx, pzErr)
		iPrev = iRowid
	}
	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK && (*sqlite3expert)(unsafe.Pointer(p)).FiSample < 100 {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv,
			ts+1340 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	}

	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pAllIndex */)))
	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 48 /* pIndexXInfo */)))
	idxFinalize(tls, bp+4 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 56 /* pWrite */)))

	if pCtx != 0 {
		for i = 0; i < (*IdxRemCtx)(unsafe.Pointer(pCtx)).FnSlot; i++ {
			sqlite3.Xsqlite3_free(tls, (*IdxRemSlot)(unsafe.Pointer(pCtx+8+uintptr(i)*40)).Fz)
		}
		sqlite3.Xsqlite3_free(tls, pCtx)
	}

	if *(*int32)(unsafe.Pointer(bp + 4)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 4 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm, ts+1735 /* "ANALYZE sqlite_s..." */, uintptr(0), uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdb, ts+1340 /* "DROP TABLE IF EX..." */, uintptr(0), uintptr(0), uintptr(0))
	return *(*int32)(unsafe.Pointer(bp + 4 /* rc */))
}

// Allocate a new sqlite3expert object.
func sqlite3_expert_new(tls *libc.TLS, db uintptr, pzErrmsg uintptr) uintptr { /* sqlite3expert.c:1803:15: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = SQLITE_OK
	var pNew uintptr

	pNew = idxMalloc(tls, bp+16 /* &rc */, int32(unsafe.Sizeof(sqlite3expert{})))

	// Open two in-memory databases to work with. The "vtab database" (dbv)
	// will contain a virtual table corresponding to each real table in
	// the user database schema, and a copy of each view. It is used to
	// collect information regarding the WHERE, ORDER BY and other clauses
	// of the user's query.
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		(*sqlite3expert)(unsafe.Pointer(pNew)).Fdb = db
		(*sqlite3expert)(unsafe.Pointer(pNew)).FiSample = 100
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_open(tls, ts+1757 /* ":memory:" */, pNew+24)
	}
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_open(tls, ts+1757 /* ":memory:" */, pNew+16)
		if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
			sqlite3.Xsqlite3_db_config(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, SQLITE_DBCONFIG_TRIGGER_EQP, libc.VaList(bp, 1, uintptr(0)))
		}
	}

	// Copy the entire schema of database [db] into [dbm].
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		// var pSql uintptr at bp+24, 8

		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = idxPrintfPrepareStmt(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdb, bp+24 /* &pSql */, pzErrmsg,

			ts+1766 /* "SELECT sql FROM ..." */, 0)
		for *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24))) {
			var zSql uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pSql */)), 0)
			*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_exec(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbm, zSql, uintptr(0), uintptr(0), pzErrmsg)
		}
		idxFinalize(tls, bp+16 /* &rc */, *(*uintptr)(unsafe.Pointer(bp + 24 /* pSql */)))
	}

	// Create the vtab schema
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = idxCreateVtabSchema(tls, pNew, pzErrmsg)
	}

	// Register the auth callback with dbv
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		sqlite3.Xsqlite3_set_authorizer(tls, (*sqlite3expert)(unsafe.Pointer(pNew)).Fdbv, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
		}{idxAuthCallback})), pNew)
	}

	// If an error has occurred, free the new object and reutrn NULL. Otherwise,
	// return the new sqlite3expert handle.
	if *(*int32)(unsafe.Pointer(bp + 16)) != SQLITE_OK {
		sqlite3_expert_destroy(tls, pNew)
		pNew = uintptr(0)
	}
	return pNew
}

// Configure an sqlite3expert object.
func sqlite3_expert_config(tls *libc.TLS, p uintptr, op int32, va uintptr) int32 { /* sqlite3expert.c:1864:5: */
	var rc int32 = SQLITE_OK
	var ap va_list
	_ = ap
	ap = va
	switch op {
	case EXPERT_CONFIG_SAMPLE:
		{
			var iVal int32 = int32(libc.VaInt32(&ap))
			if iVal < 0 {
				iVal = 0
			}
			if iVal > 100 {
				iVal = 100
			}
			(*sqlite3expert)(unsafe.Pointer(p)).FiSample = iVal
			break

		}
	default:
		rc = SQLITE_NOTFOUND
		break
	}

	_ = ap
	return rc
}

// Add an SQL statement to the analysis.
func sqlite3_expert_sql(tls *libc.TLS, p uintptr, zSql uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1888:5: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pScanOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpScan
	var pStmtOrig uintptr = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = SQLITE_OK
	*(*uintptr)(unsafe.Pointer(bp + 8 /* zStmt */)) = zSql

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun != 0 {
		return SQLITE_MISUSE
	}

	for *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK && *(*uintptr)(unsafe.Pointer(bp + 8)) != 0 && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)))) != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
		*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = sqlite3.Xsqlite3_prepare_v2(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, *(*uintptr)(unsafe.Pointer(bp + 8 /* zStmt */)), -1, bp /* &pStmt */, bp+8 /* &zStmt */)
		if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
			if *(*uintptr)(unsafe.Pointer(bp)) != 0 {
				var pNew uintptr
				var z uintptr = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				var n int32 = int32(libc.Xstrlen(tls, z))
				pNew = idxMalloc(tls, bp+16 /* &rc */, int32(uint64(unsafe.Sizeof(IdxStatement{}))+uint64(n)+uint64(1)))
				if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
					(*IdxStatement)(unsafe.Pointer(pNew)).FzSql = pNew + 1*40
					libc.Xmemcpy(tls, (*IdxStatement)(unsafe.Pointer(pNew)).FzSql, z, uint64(n+1))
					(*IdxStatement)(unsafe.Pointer(pNew)).FpNext = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement
					if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
						(*IdxStatement)(unsafe.Pointer(pNew)).FiId = (*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1
					}
					(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pNew
				}
				sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
			}
		} else {
			idxDatabaseError(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv, pzErr)
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 16)) != SQLITE_OK {
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, pScanOrig)
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, pStmtOrig)
		(*sqlite3expert)(unsafe.Pointer(p)).FpScan = pScanOrig
		(*sqlite3expert)(unsafe.Pointer(p)).FpStatement = pStmtOrig
	}

	return *(*int32)(unsafe.Pointer(bp + 16 /* rc */))
}

func sqlite3_expert_analyze(tls *libc.TLS, p uintptr, pzErr uintptr) int32 { /* sqlite3expert.c:1933:5: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var rc int32 at bp+24, 4

	var pEntry uintptr

	// Do trigger processing to collect any extra IdxScan structures
	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxProcessTriggers(tls, p, pzErr)

	// Create candidate indexes within the in-memory database file
	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxCreateCandidates(tls, p)
	} else if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_BUSY|int32(3)<<8 {
		if pzErr != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+1865 /* "Cannot find a un..." */, 0)
		}
		return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
	}

	// Generate the stat1 data
	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxPopulateStat1(tls, p, pzErr)
	}

	// Formulate the EXPERT_REPORT_CANDIDATES text
	for pEntry = (*sqlite3expert)(unsafe.Pointer(p)).FhIdx.FpFirst; pEntry != 0; pEntry = (*IdxHashEntry)(unsafe.Pointer(pEntry)).FpNext {
		(*sqlite3expert)(unsafe.Pointer(p)).FzCandidates = idxAppendText(tls, bp+24 /* &rc */, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates,
			ts+1909 /* "%s;%s%s\n" */, libc.VaList(bp, (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal,
				func() uintptr {
					if (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2 != 0 {
						return ts + 1918 /* " -- stat1: " */
					}
					return ts + 584 /* "" */
				}(), (*IdxHashEntry)(unsafe.Pointer(pEntry)).FzVal2))
	}

	// Figure out which of the candidate indexes are preferred by the query
	// planner and report the results to the user.
	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = idxFindIndexes(tls, p, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {
		(*sqlite3expert)(unsafe.Pointer(p)).FbRun = 1
	}
	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

// Return the total number of statements that have been added to this
// sqlite3expert using sqlite3_expert_sql().
func sqlite3_expert_count(tls *libc.TLS, p uintptr) int32 { /* sqlite3expert.c:1978:5: */
	var nRet int32 = 0
	if (*sqlite3expert)(unsafe.Pointer(p)).FpStatement != 0 {
		nRet = (*IdxStatement)(unsafe.Pointer((*sqlite3expert)(unsafe.Pointer(p)).FpStatement)).FiId + 1
	}
	return nRet
}

// Return a component of the report.
func sqlite3_expert_report(tls *libc.TLS, p uintptr, iStmt int32, eReport int32) uintptr { /* sqlite3expert.c:1987:12: */
	var zRet uintptr = uintptr(0)
	var pStmt uintptr

	if (*sqlite3expert)(unsafe.Pointer(p)).FbRun == 0 {
		return uintptr(0)
	}
	for pStmt = (*sqlite3expert)(unsafe.Pointer(p)).FpStatement; pStmt != 0 && (*IdxStatement)(unsafe.Pointer(pStmt)).FiId != iStmt; pStmt = (*IdxStatement)(unsafe.Pointer(pStmt)).FpNext {
	}
	switch eReport {
	case EXPERT_REPORT_SQL:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzSql
		}
		break
	case EXPERT_REPORT_INDEXES:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzIdx
		}
		break
	case EXPERT_REPORT_PLAN:
		if pStmt != 0 {
			zRet = (*IdxStatement)(unsafe.Pointer(pStmt)).FzEQP
		}
		break
	case EXPERT_REPORT_CANDIDATES:
		zRet = (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates
		break
	}
	return zRet
}

// Free an sqlite3expert object.
func sqlite3_expert_destroy(tls *libc.TLS, p uintptr) { /* sqlite3expert.c:2013:6: */
	if p != 0 {
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbm)
		sqlite3.Xsqlite3_close(tls, (*sqlite3expert)(unsafe.Pointer(p)).Fdbv)
		idxScanFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpScan, uintptr(0))
		idxStatementFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpStatement, uintptr(0))
		idxTableFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpTable)
		idxWriteFree(tls, (*sqlite3expert)(unsafe.Pointer(p)).FpWrite)
		idxHashClear(tls, p+88)
		sqlite3.Xsqlite3_free(tls, (*sqlite3expert)(unsafe.Pointer(p)).FzCandidates)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
// B.8.2.7 for the rationale behind the *_unlocked() macros.

//----------------------------------------------------------------------------
// Support for functions with a variable number of arguments.
//
// The following TCL_VARARGS* macros are to support old extensions
// written for older versions of Tcl where the macros permitted
// support for the varargs.h system as well as stdarg.h .
//
// New code should just directly be written to use stdarg.h conventions.

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause
//
// Copyright (c) 2017 Poul-Henning Kamp.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Allow a part of Tcl's API to be explicitly marked as deprecated.
//
// Used to make TIP 330/336 generate moans even if people use the
// compatibility macros. Change your code, guys! We won't support you forever.

//----------------------------------------------------------------------------
// Macros used to declare a function to be exported by a DLL. Used by Windows,
// maps to no-op declarations on non-Windows systems. The default build on
// windows is for a DLL, which causes the DLLIMPORT and DLLEXPORT macros to be
// nonempty. To build a static library, the macro STATIC_BUILD should be
// defined.
//
// Note: when building static but linking dynamically to MSVCRT we must still
//       correctly decorate the C library imported function.  Use CRTIMPORT
//       for this purpose.  _DLL is defined by the compiler when linking to
//       MSVCRT.

// These macros are used to control whether functions are being declared for
// import or export. If a function is being declared while it is being built
// to be included in a shared library, then it should have the DLLEXPORT
// storage class. If is being declared for use by a module that is going to
// link against the shared library, then it should have the DLLIMPORT storage
// class. If the symbol is beind declared for a static build or for use from a
// stub library, then the storage class should be empty.
//
// The convention is that a macro called BUILD_xxxx, where xxxx is the name of
// a library we are building, is set on the compile line for sources that are
// to be placed in the library. When this macro is set, the storage class will
// be set to DLLEXPORT. At the end of the header file, the storage class will
// be reset to DLLIMPORT.

// The following _ANSI_ARGS_ macro is to support old extensions
// written for older versions of Tcl where it permitted support
// for compilers written in the pre-prototype era of C.
//
// New code should use prototypes.

// Definitions that allow this header file to be used either with or without
// ANSI C features.

// Make sure EXTERN isn't defined elsewhere.

//----------------------------------------------------------------------------
// The following code is copied from winnt.h. If we don't replicate it here,
// then <windows.h> can't be included after tcl.h, since tcl.h also defines
// VOID. This block is skipped under Cygwin and Mingw.

// Macro to use instead of "void" for arguments that must have type "void *"
// in ANSI C; maps them to type "char *" in non-ANSI systems.

// Miscellaneous declarations.

type ClientData = uintptr /* tcl.h:340:15 */

// Darwin specific configure overrides (to support fat compiles, where
// configure runs only once for multiple architectures):

// Define Tcl_WideInt to be a type that is (at least) 64-bits wide, and define
// Tcl_WideUInt to be the unsigned variant of that type (assuming that where
// we have one, we can have the other.)
//
// Also defines the following macros:
// TCL_WIDE_INT_IS_LONG - if wide ints are really longs (i.e. we're on a
//	LP64 system such as modern Solaris or Linux ... not including Win64)
// Tcl_WideAsLong - forgetful converter from wideInt to long.
// Tcl_LongAsWide - sign-extending converter from long to wideInt.
// Tcl_WideAsDouble - converter from wideInt to double.
// Tcl_DoubleAsWide - converter from double to wideInt.
//
// The following invariant should hold for any long value 'longVal':
//	longVal == Tcl_WideAsLong(Tcl_LongAsWide(longVal))
//
// Note on converting between Tcl_WideInt and strings. This implementation (in
// tclObj.c) depends on the function
// sprintf(...,"%" TCL_LL_MODIFIER "d",...).

type Tcl_WideInt = int64   /* tcl.h:415:28 */
type Tcl_WideUInt = uint64 /* tcl.h:416:36 */

// The next short section of defines are only done when not running on Windows
// or some other strange platform.

type stat = struct {
	Fst_dev      dev_t
	Fst_ino      ino_t
	Fst_nlink    nlink_t
	Fst_mode     mode_t
	Fst_padding0 int16
	Fst_uid      uid_t
	Fst_gid      gid_t
	Fst_padding1 int32
	Fst_rdev     dev_t
	Fst_atim     struct {
		Ftv_sec  time_t
		Ftv_nsec int64
	}
	Fst_mtim struct {
		Ftv_sec  time_t
		Ftv_nsec int64
	}
	Fst_ctim struct {
		Ftv_sec  time_t
		Ftv_nsec int64
	}
	Fst_birthtim struct {
		Ftv_sec  time_t
		Ftv_nsec int64
	}
	Fst_size    off_t
	Fst_blocks  blkcnt_t
	Fst_blksize blksize_t
	Fst_flags   fflags_t
	Fst_gen     uint64
	Fst_spare   [10]uint64
} /* stat.h:160:1 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp1 = struct {
	FresultDontUse    uintptr
	FfreeProcDontUse  uintptr
	FerrorLineDontUse int32
	F__ccgo_pad1      [4]byte
} /* tcl.h:493:9 */

//----------------------------------------------------------------------------
// Data structures defined opaquely in this module. The definitions below just
// provide dummy types. A few fields are made visible in Tcl_Interp
// structures, namely those used for returning a string result from commands.
// Direct access to the result field is discouraged in Tcl 8.0. The
// interpreter result is either an object or a string, and the two values are
// kept consistent unless some C code sets interp->result directly.
// Programmers should use either the function Tcl_GetObjResult() or
// Tcl_GetStringResult() to read the interpreter's result. See the SetResult
// man page for details.
//
// Note: any change to the Tcl_Interp definition below must be mirrored in the
// "real" definition in tclInt.h.
//
// Note: Tcl_ObjCmdProc functions do not directly set result and freeProc.
// Instead, they set a Tcl_Obj member in the "real" structure that can be
// accessed with Tcl_GetObjResult() and Tcl_SetObjResult().

type Tcl_Interp = Tcl_Interp1 /* tcl.h:525:1 */

type Tcl_AsyncHandler = uintptr       /* tcl.h:527:34 */
type Tcl_Channel = uintptr            /* tcl.h:528:29 */
type Tcl_ChannelTypeVersion = uintptr /* tcl.h:529:40 */
type Tcl_Command = uintptr            /* tcl.h:530:29 */
type Tcl_Condition = uintptr          /* tcl.h:531:31 */
type Tcl_Dict = uintptr               /* tcl.h:532:26 */
type Tcl_EncodingState = uintptr      /* tcl.h:533:35 */
type Tcl_Encoding = uintptr           /* tcl.h:534:30 */
type Tcl_Event1 = struct {
	Fproc    uintptr
	FnextPtr uintptr
} /* tcl.h:535:9 */

type Tcl_Event = Tcl_Event1      /* tcl.h:535:26 */
type Tcl_InterpState = uintptr   /* tcl.h:536:33 */
type Tcl_LoadHandle = uintptr    /* tcl.h:537:32 */
type Tcl_Mutex = uintptr         /* tcl.h:538:27 */
type Tcl_Pid = uintptr           /* tcl.h:539:25 */
type Tcl_RegExp = uintptr        /* tcl.h:540:28 */
type Tcl_ThreadDataKey = uintptr /* tcl.h:541:35 */
type Tcl_ThreadId = uintptr      /* tcl.h:542:30 */
type Tcl_TimerToken = uintptr    /* tcl.h:543:32 */
type Tcl_Trace = uintptr         /* tcl.h:544:27 */
type Tcl_Var = uintptr           /* tcl.h:545:25 */
type Tcl_ZlibStream = uintptr    /* tcl.h:546:32 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices1 = struct {
	Fstart int64
	Fend   int64
} /* tcl.h:623:9 */

// Threading function return types used for abstracting away platform
// differences when writing a Tcl_ThreadCreateProc. See the NewThread function
// in generic/tclThreadTest.c for it's usage.

// Definition of values for default stacksize and the possible flags to be
// given to Tcl_CreateThread.

// Flag values passed to Tcl_StringCaseMatch.

// Flag values passed to Tcl_GetRegExpFromObj.

// Flags values passed to Tcl_RegExpExecObj.

// Structures filled in by Tcl_RegExpInfo. Note that all offset values are
// relative to the start of the match string, not the beginning of the entire
// string.

type Tcl_RegExpIndices = Tcl_RegExpIndices1 /* tcl.h:628:3 */

type Tcl_RegExpInfo1 = struct {
	Fnsubs       int32
	F__ccgo_pad1 [4]byte
	Fmatches     uintptr
	FextendStart int64
	Freserved    int64
} /* tcl.h:630:9 */

type Tcl_RegExpInfo = Tcl_RegExpInfo1 /* tcl.h:637:3 */

// Picky compilers complain if this typdef doesn't appear before the struct's
// reference in tclDecls.h.

type Tcl_Stat_ = uintptr    /* tcl.h:644:21 */
type Tcl_OldStat_ = uintptr /* tcl.h:645:21 */

//----------------------------------------------------------------------------
// When a TCL command returns, the interpreter contains a result from the
// command. Programmers are strongly encouraged to use one of the functions
// Tcl_GetObjResult() or Tcl_GetStringResult() to read the interpreter's
// result. See the SetResult man page for details. Besides this result, the
// command function returns an integer code, which is one of the following:
//
// TCL_OK		Command completed normally; the interpreter's result
//			contains the command's result.
// TCL_ERROR		The command couldn't be completed successfully; the
//			interpreter's result describes what went wrong.
// TCL_RETURN		The command requests that the current function return;
//			the interpreter's result contains the function's
//			return value.
// TCL_BREAK		The command requests that the innermost loop be
//			exited; the interpreter's result is meaningless.
// TCL_CONTINUE		Go on to the next iteration of the current loop; the
//			interpreter's result is meaningless.

//----------------------------------------------------------------------------
// Flags to control what substitutions are performed by Tcl_SubstObj():

// Argument descriptors for math function callbacks in expressions:

type Tcl_ValueType = uint32 /* tcl.h:692:3 */

type Tcl_Value1 = struct {
	Ftype        Tcl_ValueType
	F__ccgo_pad1 [4]byte
	FintValue    int64
	FdoubleValue float64
	FwideValue   Tcl_WideInt
} /* tcl.h:694:9 */

type Tcl_Value = Tcl_Value1 /* tcl.h:700:3 */

// Forward declaration of Tcl_Obj to prevent an error when the forward
// reference to Tcl_Obj is encountered in the function types declared below.

type Tcl_Obj1 = struct {
	FrefCount    int32
	F__ccgo_pad1 [4]byte
	Fbytes       uintptr
	Flength      int32
	F__ccgo_pad2 [4]byte
	FtypePtr     uintptr
	FinternalRep struct {
		FlongValue   int64
		F__ccgo_pad1 [8]byte
	}
} /* tcl.h:707:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType1 = struct {
	Fname             uintptr
	FfreeIntRepProc   uintptr
	FdupIntRepProc    uintptr
	FupdateStringProc uintptr
	FsetFromAnyProc   uintptr
} /* tcl.h:707:1 */

//----------------------------------------------------------------------------
// The following structure represents a type of object, which is a particular
// internal representation for an object plus a set of functions that provide
// standard operations on objects of that type.

type Tcl_ObjType = Tcl_ObjType1 /* tcl.h:796:3 */

// One of the following structures exists for each object in the Tcl system.
// An object stores a value as either a string, some internal representation,
// or both.

type Tcl_Obj = Tcl_Obj1 /* tcl.h:843:3 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult1 = struct {
	Fresult       uintptr
	FfreeProc     uintptr
	FobjResultPtr uintptr
	FappendResult uintptr
	FappendAvl    int32
	FappendUsed   int32
	FresultSpace  [201]int8
	F__ccgo_pad1  [7]byte
} /* tcl.h:864:9 */

//----------------------------------------------------------------------------
// The following structure contains the state needed by Tcl_SaveResult. No-one
// outside of Tcl should access any of these fields. This structure is
// typically allocated on the stack.

type Tcl_SavedResult = Tcl_SavedResult1 /* tcl.h:872:3 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace1 = struct {
	Fname       uintptr
	FfullName   uintptr
	FclientData ClientData
	FdeleteProc uintptr
	FparentPtr  uintptr
} /* tcl.h:881:9 */

//----------------------------------------------------------------------------
// The following definitions support Tcl's namespace facility. Note: the first
// five fields must match exactly the fields in a Namespace structure (see
// tclInt.h).

type Tcl_Namespace = Tcl_Namespace1 /* tcl.h:897:3 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame1 = struct {
	FnsPtr       uintptr
	Fdummy1      int32
	Fdummy2      int32
	Fdummy3      uintptr
	Fdummy4      uintptr
	Fdummy5      uintptr
	Fdummy6      int32
	F__ccgo_pad1 [4]byte
	Fdummy7      uintptr
	Fdummy8      uintptr
	Fdummy9      int32
	F__ccgo_pad2 [4]byte
	Fdummy10     uintptr
	Fdummy11     uintptr
	Fdummy12     uintptr
	Fdummy13     uintptr
} /* tcl.h:922:9 */

//----------------------------------------------------------------------------
// The following structure represents a call frame, or activation record. A
// call frame defines a naming context for a procedure call: its local scope
// (for local variables) and its namespace scope (used for non-local
// variables; often the global :: namespace). A call frame can also define the
// naming context for a namespace eval or namespace inscope command: the
// namespace in which the command's code should execute. The Tcl_CallFrame
// structures exist only while procedures or namespace eval/inscope's are
// being executed, and provide a Tcl call stack.
//
// A call frame is initialized and pushed using Tcl_PushCallFrame and popped
// using Tcl_PopCallFrame. Storage for a Tcl_CallFrame must be provided by the
// Tcl_PushCallFrame caller, and callers typically allocate them on the C call
// stack for efficiency. For this reason, Tcl_CallFrame is defined as a
// structure and not as an opaque token. However, most Tcl_CallFrame fields
// are hidden since applications should not access them directly; others are
// declared as "dummyX".
//
// WARNING!! The structure definition must be kept consistent with the
// CallFrame structure in tclInt.h. If you change one, change the other.

type Tcl_CallFrame = Tcl_CallFrame1 /* tcl.h:937:3 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo1 = struct {
	FisNativeObjectProc int32
	F__ccgo_pad1        [4]byte
	FobjProc            uintptr
	FobjClientData      ClientData
	Fproc               uintptr
	FclientData         ClientData
	FdeleteProc         uintptr
	FdeleteData         ClientData
	FnamespacePtr       uintptr
} /* tcl.h:954:9 */

//----------------------------------------------------------------------------
// Information about commands that is returned by Tcl_GetCommandInfo and
// passed to Tcl_SetCommandInfo. objProc is an objc/objv object-based command
// function while proc is a traditional Tcl argc/argv string-based function.
// Tcl_CreateObjCommand and Tcl_CreateCommand ensure that both objProc and
// proc are non-NULL and can be called to execute the command. However, it may
// be faster to call one instead of the other. The member isNativeObjectProc
// is set to 1 if an object-based function was registered by
// Tcl_CreateObjCommand, and to 0 if a string-based function was registered by
// Tcl_CreateCommand. The other function is typically set to a compatibility
// wrapper that does string-to-object or object-to-string argument conversions
// then calls the other function.

type Tcl_CmdInfo = Tcl_CmdInfo1 /* tcl.h:973:3 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString1 = struct {
	Fstring      uintptr
	Flength      int32
	FspaceAvl    int32
	FstaticSpace [200]int8
} /* tcl.h:983:9 */

//----------------------------------------------------------------------------
// The structure defined below is used to hold dynamic strings. The only
// fields that clients should use are string and length, accessible via the
// macros Tcl_DStringValue and Tcl_DStringLength.

type Tcl_DString = Tcl_DString1 /* tcl.h:993:3 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType1 = struct {
	Fversion         int32
	Fflags           int32
	FhashKeyProc     uintptr
	FcompareKeysProc uintptr
	FallocEntryProc  uintptr
	FfreeEntryProc   uintptr
} /* tcl.h:1152:9 */

// Definitions for the maximum number of digits of precision that may be
// specified in the "tcl_precision" variable, and the number of bytes of
// buffer space required by Tcl_PrintDouble.

// Definition for a number of bytes of buffer space sufficient to hold the
// string representation of an integer in base 10 (assuming the existence of
// 64-bit integers).

// Flag values passed to Tcl_ConvertElement.
// TCL_DONT_USE_BRACES forces it not to enclose the element in braces, but to
//	use backslash quoting instead.
// TCL_DONT_QUOTE_HASH disables the default quoting of the '#' character. It
//	is safe to leave the hash unquoted when the element is not the first
//	element of a list, and this flag can be used by the caller to indicate
//	that condition.

// Flag that may be passed to Tcl_GetIndexFromObj to force it to disallow
// abbreviated strings.

//----------------------------------------------------------------------------
// Flag values passed to Tcl_RecordAndEval, Tcl_EvalObj, Tcl_EvalObjv.
// WARNING: these bit choices must not conflict with the bit choices for
// evalFlag bits in tclInt.h!
//
// Meanings:
//	TCL_NO_EVAL:		Just record this command
//	TCL_EVAL_GLOBAL:	Execute script in global namespace
//	TCL_EVAL_DIRECT:	Do not compile this script
//	TCL_EVAL_INVOKE:	Magical Tcl_EvalObjv mode for aliases/ensembles
//				o Run in iPtr->lookupNsPtr or global namespace
//				o Cut out of error traces
//				o Don't reset the flags controlling ensemble
//				  error message rewriting.
//	TCL_CANCEL_UNWIND:	Magical Tcl_CancelEval mode that causes the
//				stack for the script in progress to be
//				completely unwound.
//	TCL_EVAL_NOERR:	Do no exception reporting at all, just return
//				as the caller will report.

// Special freeProc values that may be passed to Tcl_SetResult (see the man
// page for details):

// Flag values passed to variable-related functions.
// WARNING: these bit choices must not conflict with the bit choice for
// TCL_CANCEL_UNWIND, above.

// Required to support old variable/vdelete/vinfo traces.
// Indicate the semantics of the result of a trace.

// Flag values for ensemble commands.

// Flag values passed to command-related functions.

// The TCL_PARSE_PART1 flag is deprecated and has no effect. The part1 is now
// always parsed whenever the part2 is NULL. (This is to avoid a common error
// when converting code to use the new object based APIs and forgetting to
// give the flag)

// Types for linked variables:

//----------------------------------------------------------------------------
// Forward declarations of Tcl_HashTable and related types.

type Tcl_HashKeyType = Tcl_HashKeyType1 /* tcl.h:1152:32 */
type Tcl_HashTable1 = struct {
	Fbuckets       uintptr
	FstaticBuckets [4]uintptr
	FnumBuckets    int32
	FnumEntries    int32
	FrebuildSize   int32
	FdownShift     int32
	Fmask          int32
	FkeyType       int32
	FfindProc      uintptr
	FcreateProc    uintptr
	FtypePtr       uintptr
} /* tcl.h:1153:9 */

type Tcl_HashTable = Tcl_HashTable1 /* tcl.h:1153:30 */
type Tcl_HashEntry1 = struct {
	FnextPtr    uintptr
	FtablePtr   uintptr
	Fhash       uintptr
	FclientData ClientData
	Fkey        struct{ FoneWordValue uintptr }
} /* tcl.h:1153:9 */

type Tcl_HashEntry = Tcl_HashEntry1 /* tcl.h:1154:30 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch1 = struct {
	FtablePtr     uintptr
	FnextIndex    int32
	F__ccgo_pad1  [4]byte
	FnextEntryPtr uintptr
} /* tcl.h:1308:9 */

// Structure definition for information used to keep track of searches through
// hash tables:

type Tcl_HashSearch = Tcl_HashSearch1 /* tcl.h:1314:3 */

// Acceptable key types for hash tables:
//
// TCL_STRING_KEYS:		The keys are strings, they are copied into the
//				entry.
// TCL_ONE_WORD_KEYS:		The keys are pointers, the pointer is stored
//				in the entry.
// TCL_CUSTOM_TYPE_KEYS:	The keys are arbitrary types which are copied
//				into the entry.
// TCL_CUSTOM_PTR_KEYS:		The keys are pointers to arbitrary types, the
//				pointer is stored in the entry.
//
// While maintaining binary compatibility the above have to be distinct values
// as they are used to differentiate between old versions of the hash table
// which don't have a typePtr and new ones which do. Once binary compatibility
// is discarded in favour of making more wide spread changes TCL_STRING_KEYS
// can be the same as TCL_CUSTOM_TYPE_KEYS, and TCL_ONE_WORD_KEYS can be the
// same as TCL_CUSTOM_PTR_KEYS because they simply determine how the key is
// accessed from the entry and not the behaviour.

// Structure definition for information used to keep track of searches through
// dictionaries. These fields should not be accessed by code outside
// tclDictObj.c

type Tcl_DictSearch = struct {
	Fnext          uintptr
	Fepoch         int32
	F__ccgo_pad1   [4]byte
	FdictionaryPtr Tcl_Dict
} /* tcl.h:1354:3 */

// Positions to pass to Tcl_QueueEvent:

type Tcl_QueuePosition = uint32 /* tcl.h:1389:3 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time1 = struct {
	Fsec  int64
	Fusec int64
} /* tcl.h:1405:9 */

// Values to pass to Tcl_SetServiceMode to specify the behavior of notifier
// event routines.

// The following structure keeps is used to hold a time value, either as an
// absolute time (the number of seconds from the epoch) or as an elapsed time.
// On Unix systems the epoch is Midnight Jan 1, 1970 GMT.

type Tcl_Time = Tcl_Time1 /* tcl.h:1408:3 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType1 = struct {
	FtypeName         uintptr
	Fversion          Tcl_ChannelTypeVersion
	FcloseProc        uintptr
	FinputProc        uintptr
	FoutputProc       uintptr
	FseekProc         uintptr
	FsetOptionProc    uintptr
	FgetOptionProc    uintptr
	FwatchProc        uintptr
	FgetHandleProc    uintptr
	Fclose2Proc       uintptr
	FblockModeProc    uintptr
	FflushProc        uintptr
	FhandlerProc      uintptr
	FwideSeekProc     uintptr
	FthreadActionProc uintptr
	FtruncateProc     uintptr
} /* tcl.h:1524:9 */

// struct Tcl_ChannelType:
//
// One such structure exists for each type (kind) of channel. It collects
// together in one place all the functions that are part of the specific
// channel type.
//
// It is recommend that the Tcl_Channel* functions are used to access elements
// of this structure, instead of direct accessing.

type Tcl_ChannelType = Tcl_ChannelType1 /* tcl.h:1592:3 */

// The following flags determine whether the blockModeProc above should set
// the channel into blocking or nonblocking mode. They are passed as arguments
// to the blockModeProc function in the above structure.

//----------------------------------------------------------------------------
// Enum for different types of file paths.

type Tcl_PathType = uint32 /* tcl.h:1613:3 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData1 = struct {
	Ftype       int32
	Fperm       int32
	FmacType    uintptr
	FmacCreator uintptr
} /* tcl.h:1620:9 */

// The following structure is used to pass glob type data amongst the various
// glob routines and Tcl_FSMatchInDirectory.

type Tcl_GlobTypeData = Tcl_GlobTypeData1 /* tcl.h:1625:3 */
// We have to declare the utime structure here.
type utimbuf = struct {
	Factime  time_t
	Fmodtime time_t
} /* utime.h:46:1 */

type Tcl_FSVersion = uintptr /* tcl.h:1700:31 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem1 = struct {
	FtypeName                 uintptr
	FstructureLength          int32
	F__ccgo_pad1              [4]byte
	Fversion                  Tcl_FSVersion
	FpathInFilesystemProc     uintptr
	FdupInternalRepProc       uintptr
	FfreeInternalRepProc      uintptr
	FinternalToNormalizedProc uintptr
	FcreateInternalRepProc    uintptr
	FnormalizePathProc        uintptr
	FfilesystemPathTypeProc   uintptr
	FfilesystemSeparatorProc  uintptr
	FstatProc                 uintptr
	FaccessProc               uintptr
	FopenFileChannelProc      uintptr
	FmatchInDirectoryProc     uintptr
	FutimeProc                uintptr
	FlinkProc                 uintptr
	FlistVolumesProc          uintptr
	FfileAttrStringsProc      uintptr
	FfileAttrsGetProc         uintptr
	FfileAttrsSetProc         uintptr
	FcreateDirectoryProc      uintptr
	FremoveDirectoryProc      uintptr
	FdeleteFileProc           uintptr
	FcopyFileProc             uintptr
	FrenameFileProc           uintptr
	FcopyDirectoryProc        uintptr
	FlstatProc                uintptr
	FloadFileProc             uintptr
	FgetCwdProc               uintptr
	FchdirProc                uintptr
} /* tcl.h:1726:9 */

//----------------------------------------------------------------------------
// Data structures related to hooking into the filesystem

// Filesystem version tag.  This was introduced in 8.4.

// struct Tcl_Filesystem:
//
// One such structure exists for each type (kind) of filesystem. It collects
// together in one place all the functions that are part of the specific
// filesystem. Tcl always accesses the filesystem through one of these
// structures.
//
// Not all entries need be non-NULL; any which are NULL are simply ignored.
// However, a complete filesystem should provide all of these functions. The
// explanations in the structure show the importance of each function.

type Tcl_Filesystem = Tcl_Filesystem1 /* tcl.h:1873:3 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs1 = struct {
	FsetTimerProc          uintptr
	FwaitForEventProc      uintptr
	FcreateFileHandlerProc uintptr
	FdeleteFileHandlerProc uintptr
	FinitNotifierProc      uintptr
	FfinalizeNotifierProc  uintptr
	FalertNotifierProc     uintptr
	FserviceModeHookProc   uintptr
} /* tcl.h:1894:9 */

// The following definitions are used as values for the 'linkAction' flag to
// Tcl_FSLink, or the linkProc of any filesystem. Any combination of flags can
// be given. For link creation, the linkProc should create a link which
// matches any of the types given.
//
// TCL_CREATE_SYMBOLIC_LINK -	Create a symbolic or soft link.
// TCL_CREATE_HARD_LINK -	Create a hard link.

//----------------------------------------------------------------------------
// The following structure represents the Notifier functions that you can
// override with the Tcl_SetNotifier call.

type Tcl_NotifierProcs = Tcl_NotifierProcs1 /* tcl.h:1903:3 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token1 = struct {
	Ftype          int32
	F__ccgo_pad1   [4]byte
	Fstart         uintptr
	Fsize          int32
	FnumComponents int32
} /* tcl.h:1914:9 */

//----------------------------------------------------------------------------
// The following data structures and declarations are for the new Tcl parser.
//
// For each word of a command, and for each piece of a word such as a variable
// reference, one of the following structures is created to describe the
// token.

type Tcl_Token = Tcl_Token1 /* tcl.h:1924:3 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse1 = struct {
	FcommentStart    uintptr
	FcommentSize     int32
	F__ccgo_pad1     [4]byte
	FcommandStart    uintptr
	FcommandSize     int32
	FnumWords        int32
	FtokenPtr        uintptr
	FnumTokens       int32
	FtokensAvailable int32
	FerrorType       int32
	F__ccgo_pad2     [4]byte
	Fstring          uintptr
	Fend             uintptr
	Finterp          uintptr
	Fterm            uintptr
	Fincomplete      int32
	F__ccgo_pad3     [4]byte
	FstaticTokens    [20]Tcl_Token
} /* tcl.h:2030:9 */

// Type values defined for Tcl_Token structures. These values are defined as
// mask bits so that it's easy to check for collections of types.
//
// TCL_TOKEN_WORD -		The token describes one word of a command,
//				from the first non-blank character of the word
//				(which may be " or {) up to but not including
//				the space, semicolon, or bracket that
//				terminates the word. NumComponents counts the
//				total number of sub-tokens that make up the
//				word. This includes, for example, sub-tokens
//				of TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SIMPLE_WORD -	This token is just like TCL_TOKEN_WORD except
//				that the word is guaranteed to consist of a
//				single TCL_TOKEN_TEXT sub-token.
// TCL_TOKEN_TEXT -		The token describes a range of literal text
//				that is part of a word. NumComponents is
//				always 0.
// TCL_TOKEN_BS -		The token describes a backslash sequence that
//				must be collapsed. NumComponents is always 0.
// TCL_TOKEN_COMMAND -		The token describes a command whose result
//				must be substituted into the word. The token
//				includes the enclosing brackets. NumComponents
//				is always 0.
// TCL_TOKEN_VARIABLE -		The token describes a variable substitution,
//				including the dollar sign, variable name, and
//				array index (if there is one) up through the
//				right parentheses. NumComponents tells how
//				many additional tokens follow to represent the
//				variable name. The first token will be a
//				TCL_TOKEN_TEXT token that describes the
//				variable name. If the variable is an array
//				reference then there will be one or more
//				additional tokens, of type TCL_TOKEN_TEXT,
//				TCL_TOKEN_BS, TCL_TOKEN_COMMAND, and
//				TCL_TOKEN_VARIABLE, that describe the array
//				index; numComponents counts the total number
//				of nested tokens that make up the variable
//				reference, including sub-tokens of
//				TCL_TOKEN_VARIABLE tokens.
// TCL_TOKEN_SUB_EXPR -		The token describes one subexpression of an
//				expression, from the first non-blank character
//				of the subexpression up to but not including
//				the space, brace, or bracket that terminates
//				the subexpression. NumComponents counts the
//				total number of following subtokens that make
//				up the subexpression; this includes all
//				subtokens for any nested TCL_TOKEN_SUB_EXPR
//				tokens. For example, a numeric value used as a
//				primitive operand is described by a
//				TCL_TOKEN_SUB_EXPR token followed by a
//				TCL_TOKEN_TEXT token. A binary subexpression
//				is described by a TCL_TOKEN_SUB_EXPR token
//				followed by the TCL_TOKEN_OPERATOR token for
//				the operator, then TCL_TOKEN_SUB_EXPR tokens
//				for the left then the right operands.
// TCL_TOKEN_OPERATOR -		The token describes one expression operator.
//				An operator might be the name of a math
//				function such as "abs". A TCL_TOKEN_OPERATOR
//				token is always preceded by one
//				TCL_TOKEN_SUB_EXPR token for the operator's
//				subexpression, and is followed by zero or more
//				TCL_TOKEN_SUB_EXPR tokens for the operator's
//				operands. NumComponents is always 0.
// TCL_TOKEN_EXPAND_WORD -	This token is just like TCL_TOKEN_WORD except
//				that it marks a word that began with the
//				literal character prefix "{*}". This word is
//				marked to be expanded - that is, broken into
//				words after substitution is complete.

// Parsing error types. On any parsing error, one of these values will be
// stored in the error field of the Tcl_Parse structure defined below.

// A structure of the following type is filled in by Tcl_ParseCommand. It
// describes a single command parsed from an input string.

type Tcl_Parse = Tcl_Parse1 /* tcl.h:2083:3 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType1 = struct {
	FencodingName uintptr
	FtoUtfProc    uintptr
	FfromUtfProc  uintptr
	FfreeProc     uintptr
	FclientData   ClientData
	FnullSize     int32
	F__ccgo_pad1  [4]byte
} /* tcl.h:2091:9 */

//----------------------------------------------------------------------------
// The following structure represents a user-defined encoding. It collects
// together all the functions that are used by the specific encoding.

type Tcl_EncodingType = Tcl_EncodingType1 /* tcl.h:2111:3 */

// The following definitions are used as values for the conversion control
// flags argument when converting text from one character set to another:
//
// TCL_ENCODING_START -		Signifies that the source buffer is the first
//				block in a (potentially multi-block) input
//				stream. Tells the conversion function to reset
//				to an initial state and perform any
//				initialization that needs to occur before the
//				first byte is converted. If the source buffer
//				contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_END -		Signifies that the source buffer is the last
//				block in a (potentially multi-block) input
//				stream. Tells the conversion routine to
//				perform any finalization that needs to occur
//				after the last byte is converted and then to
//				reset to an initial state. If the source
//				buffer contains the entire input stream to be
//				converted, this flag should be set.
// TCL_ENCODING_STOPONERROR -	If set, then the converter will return
//				immediately upon encountering an invalid byte
//				sequence or a source character that has no
//				mapping in the target encoding. If clear, then
//				the converter will skip the problem,
//				substituting one or more "close" characters in
//				the destination buffer and then continue to
//				convert the source.
// TCL_ENCODING_NO_TERMINATE - 	If set, Tcl_ExternalToUtf will not append a
//				terminating NUL byte.  Knowing that it will
//				not need space to do so, it will fill all
//				dstLen bytes with encoded UTF-8 content, as
//				other circumstances permit.  If clear, the
//				default behavior is to reserve a byte in
//				the dst space for NUL termination, and to
//				append the NUL byte.
// TCL_ENCODING_CHAR_LIMIT -	If set and dstCharsPtr is not NULL, then
//				Tcl_ExternalToUtf takes the initial value
//				of *dstCharsPtr is taken as a limit of the
//				maximum number of chars to produce in the
//				encoded UTF-8 content.  Otherwise, the
//				number of chars produced is controlled only
//				by other limiting factors.

// The following definitions are the error codes returned by the conversion
// routines:
//
// TCL_OK -			All characters were converted.
// TCL_CONVERT_NOSPACE -	The output buffer would not have been large
//				enough for all of the converted data; as many
//				characters as could fit were converted though.
// TCL_CONVERT_MULTIBYTE -	The last few bytes in the source string were
//				the beginning of a multibyte sequence, but
//				more bytes were needed to complete this
//				sequence. A subsequent call to the conversion
//				routine should pass the beginning of this
//				unconverted sequence plus additional bytes
//				from the source stream to properly convert the
//				formerly split-up multibyte sequence.
// TCL_CONVERT_SYNTAX -		The source stream contained an invalid
//				character sequence. This may occur if the
//				input stream has been damaged or if the input
//				encoding method was misidentified. This error
//				is reported only if TCL_ENCODING_STOPONERROR
//				was specified.
// TCL_CONVERT_UNKNOWN -	The source string contained a character that
//				could not be represented in the target
//				encoding. This error is reported only if
//				TCL_ENCODING_STOPONERROR was specified.

// The maximum number of bytes that are necessary to represent a single
// Unicode character in UTF-8. The valid values should be 3, 4 or 6
// (or perhaps 1 if we want to support a non-unicode enabled core). If 3 or
// 4, then Tcl_UniChar must be 2-bytes in size (UCS-2) (the default). If 6,
// then Tcl_UniChar must be 4-bytes in size (UCS-4). At this time UCS-2 mode
// is the default and recommended mode. UCS-4 is experimental and not
// recommended. It works for the core, but most extensions expect UCS-2.

// This represents a Unicode character. Any changes to this should also be
// reflected in regcustom.h.

type Tcl_UniChar = uint16 /* tcl.h:2228:24 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config1 = struct {
	Fkey   uintptr
	Fvalue uintptr
} /* tcl.h:2237:9 */

//----------------------------------------------------------------------------
// TIP #59: The following structure is used in calls 'Tcl_RegisterConfig' to
// provide the system with the embedded configuration data.

type Tcl_Config = Tcl_Config1 /* tcl.h:2242:3 */
type mp_digit = uint32        /* tcl.h:2268:22 */

//----------------------------------------------------------------------------
// Definitions needed for Tcl_ParseArgvObj routines.
// Based on tkArgv.c.
// Modifications from the original are copyright (c) Sam Bromley 2006

type Tcl_ArgvInfo = struct {
	Ftype        int32
	F__ccgo_pad1 [4]byte
	FkeyStr      uintptr
	FsrcPtr      uintptr
	FdstPtr      uintptr
	FhelpStr     uintptr
	FclientData  ClientData
} /* tcl.h:2289:3 */

type TclPlatStubs1 = struct {
	Fmagic       int32
	F__ccgo_pad1 [4]byte
	Fhooks       uintptr
} /* tclDecls.h:1840:11 */

type TclStubHooks = struct {
	FtclPlatStubs    uintptr
	FtclIntStubs     uintptr
	FtclIntPlatStubs uintptr
} /* tclDecls.h:1843:3 */

type TclStubs1 = struct {
	Fmagic                                  int32
	F__ccgo_pad1                            [4]byte
	Fhooks                                  uintptr
	Ftcl_PkgProvideEx                       uintptr
	Ftcl_PkgRequireEx                       uintptr
	Ftcl_Panic                              uintptr
	Ftcl_Alloc                              uintptr
	Ftcl_Free                               uintptr
	Ftcl_Realloc                            uintptr
	Ftcl_DbCkalloc                          uintptr
	Ftcl_DbCkfree                           uintptr
	Ftcl_DbCkrealloc                        uintptr
	Ftcl_CreateFileHandler                  uintptr
	Ftcl_DeleteFileHandler                  uintptr
	Ftcl_SetTimer                           uintptr
	Ftcl_Sleep                              uintptr
	Ftcl_WaitForEvent                       uintptr
	Ftcl_AppendAllObjTypes                  uintptr
	Ftcl_AppendStringsToObj                 uintptr
	Ftcl_AppendToObj                        uintptr
	Ftcl_ConcatObj                          uintptr
	Ftcl_ConvertToType                      uintptr
	Ftcl_DbDecrRefCount                     uintptr
	Ftcl_DbIncrRefCount                     uintptr
	Ftcl_DbIsShared                         uintptr
	Ftcl_DbNewBooleanObj                    uintptr
	Ftcl_DbNewByteArrayObj                  uintptr
	Ftcl_DbNewDoubleObj                     uintptr
	Ftcl_DbNewListObj                       uintptr
	Ftcl_DbNewLongObj                       uintptr
	Ftcl_DbNewObj                           uintptr
	Ftcl_DbNewStringObj                     uintptr
	Ftcl_DuplicateObj                       uintptr
	FtclFreeObj                             uintptr
	Ftcl_GetBoolean                         uintptr
	Ftcl_GetBooleanFromObj                  uintptr
	Ftcl_GetByteArrayFromObj                uintptr
	Ftcl_GetDouble                          uintptr
	Ftcl_GetDoubleFromObj                   uintptr
	Ftcl_GetIndexFromObj                    uintptr
	Ftcl_GetInt                             uintptr
	Ftcl_GetIntFromObj                      uintptr
	Ftcl_GetLongFromObj                     uintptr
	Ftcl_GetObjType                         uintptr
	Ftcl_GetStringFromObj                   uintptr
	Ftcl_InvalidateStringRep                uintptr
	Ftcl_ListObjAppendList                  uintptr
	Ftcl_ListObjAppendElement               uintptr
	Ftcl_ListObjGetElements                 uintptr
	Ftcl_ListObjIndex                       uintptr
	Ftcl_ListObjLength                      uintptr
	Ftcl_ListObjReplace                     uintptr
	Ftcl_NewBooleanObj                      uintptr
	Ftcl_NewByteArrayObj                    uintptr
	Ftcl_NewDoubleObj                       uintptr
	Ftcl_NewIntObj                          uintptr
	Ftcl_NewListObj                         uintptr
	Ftcl_NewLongObj                         uintptr
	Ftcl_NewObj                             uintptr
	Ftcl_NewStringObj                       uintptr
	Ftcl_SetBooleanObj                      uintptr
	Ftcl_SetByteArrayLength                 uintptr
	Ftcl_SetByteArrayObj                    uintptr
	Ftcl_SetDoubleObj                       uintptr
	Ftcl_SetIntObj                          uintptr
	Ftcl_SetListObj                         uintptr
	Ftcl_SetLongObj                         uintptr
	Ftcl_SetObjLength                       uintptr
	Ftcl_SetStringObj                       uintptr
	Ftcl_AddErrorInfo                       uintptr
	Ftcl_AddObjErrorInfo                    uintptr
	Ftcl_AllowExceptions                    uintptr
	Ftcl_AppendElement                      uintptr
	Ftcl_AppendResult                       uintptr
	Ftcl_AsyncCreate                        uintptr
	Ftcl_AsyncDelete                        uintptr
	Ftcl_AsyncInvoke                        uintptr
	Ftcl_AsyncMark                          uintptr
	Ftcl_AsyncReady                         uintptr
	Ftcl_BackgroundError                    uintptr
	Ftcl_Backslash                          uintptr
	Ftcl_BadChannelOption                   uintptr
	Ftcl_CallWhenDeleted                    uintptr
	Ftcl_CancelIdleCall                     uintptr
	Ftcl_Close                              uintptr
	Ftcl_CommandComplete                    uintptr
	Ftcl_Concat                             uintptr
	Ftcl_ConvertElement                     uintptr
	Ftcl_ConvertCountedElement              uintptr
	Ftcl_CreateAlias                        uintptr
	Ftcl_CreateAliasObj                     uintptr
	Ftcl_CreateChannel                      uintptr
	Ftcl_CreateChannelHandler               uintptr
	Ftcl_CreateCloseHandler                 uintptr
	Ftcl_CreateCommand                      uintptr
	Ftcl_CreateEventSource                  uintptr
	Ftcl_CreateExitHandler                  uintptr
	Ftcl_CreateInterp                       uintptr
	Ftcl_CreateMathFunc                     uintptr
	Ftcl_CreateObjCommand                   uintptr
	Ftcl_CreateSlave                        uintptr
	Ftcl_CreateTimerHandler                 uintptr
	Ftcl_CreateTrace                        uintptr
	Ftcl_DeleteAssocData                    uintptr
	Ftcl_DeleteChannelHandler               uintptr
	Ftcl_DeleteCloseHandler                 uintptr
	Ftcl_DeleteCommand                      uintptr
	Ftcl_DeleteCommandFromToken             uintptr
	Ftcl_DeleteEvents                       uintptr
	Ftcl_DeleteEventSource                  uintptr
	Ftcl_DeleteExitHandler                  uintptr
	Ftcl_DeleteHashEntry                    uintptr
	Ftcl_DeleteHashTable                    uintptr
	Ftcl_DeleteInterp                       uintptr
	Ftcl_DetachPids                         uintptr
	Ftcl_DeleteTimerHandler                 uintptr
	Ftcl_DeleteTrace                        uintptr
	Ftcl_DontCallWhenDeleted                uintptr
	Ftcl_DoOneEvent                         uintptr
	Ftcl_DoWhenIdle                         uintptr
	Ftcl_DStringAppend                      uintptr
	Ftcl_DStringAppendElement               uintptr
	Ftcl_DStringEndSublist                  uintptr
	Ftcl_DStringFree                        uintptr
	Ftcl_DStringGetResult                   uintptr
	Ftcl_DStringInit                        uintptr
	Ftcl_DStringResult                      uintptr
	Ftcl_DStringSetLength                   uintptr
	Ftcl_DStringStartSublist                uintptr
	Ftcl_Eof                                uintptr
	Ftcl_ErrnoId                            uintptr
	Ftcl_ErrnoMsg                           uintptr
	Ftcl_Eval                               uintptr
	Ftcl_EvalFile                           uintptr
	Ftcl_EvalObj                            uintptr
	Ftcl_EventuallyFree                     uintptr
	Ftcl_Exit                               uintptr
	Ftcl_ExposeCommand                      uintptr
	Ftcl_ExprBoolean                        uintptr
	Ftcl_ExprBooleanObj                     uintptr
	Ftcl_ExprDouble                         uintptr
	Ftcl_ExprDoubleObj                      uintptr
	Ftcl_ExprLong                           uintptr
	Ftcl_ExprLongObj                        uintptr
	Ftcl_ExprObj                            uintptr
	Ftcl_ExprString                         uintptr
	Ftcl_Finalize                           uintptr
	Ftcl_FindExecutable                     uintptr
	Ftcl_FirstHashEntry                     uintptr
	Ftcl_Flush                              uintptr
	Ftcl_FreeResult                         uintptr
	Ftcl_GetAlias                           uintptr
	Ftcl_GetAliasObj                        uintptr
	Ftcl_GetAssocData                       uintptr
	Ftcl_GetChannel                         uintptr
	Ftcl_GetChannelBufferSize               uintptr
	Ftcl_GetChannelHandle                   uintptr
	Ftcl_GetChannelInstanceData             uintptr
	Ftcl_GetChannelMode                     uintptr
	Ftcl_GetChannelName                     uintptr
	Ftcl_GetChannelOption                   uintptr
	Ftcl_GetChannelType                     uintptr
	Ftcl_GetCommandInfo                     uintptr
	Ftcl_GetCommandName                     uintptr
	Ftcl_GetErrno                           uintptr
	Ftcl_GetHostName                        uintptr
	Ftcl_GetInterpPath                      uintptr
	Ftcl_GetMaster                          uintptr
	Ftcl_GetNameOfExecutable                uintptr
	Ftcl_GetObjResult                       uintptr
	Ftcl_GetOpenFile                        uintptr
	Ftcl_GetPathType                        uintptr
	Ftcl_Gets                               uintptr
	Ftcl_GetsObj                            uintptr
	Ftcl_GetServiceMode                     uintptr
	Ftcl_GetSlave                           uintptr
	Ftcl_GetStdChannel                      uintptr
	Ftcl_GetStringResult                    uintptr
	Ftcl_GetVar                             uintptr
	Ftcl_GetVar2                            uintptr
	Ftcl_GlobalEval                         uintptr
	Ftcl_GlobalEvalObj                      uintptr
	Ftcl_HideCommand                        uintptr
	Ftcl_Init                               uintptr
	Ftcl_InitHashTable                      uintptr
	Ftcl_InputBlocked                       uintptr
	Ftcl_InputBuffered                      uintptr
	Ftcl_InterpDeleted                      uintptr
	Ftcl_IsSafe                             uintptr
	Ftcl_JoinPath                           uintptr
	Ftcl_LinkVar                            uintptr
	Freserved188                            uintptr
	Ftcl_MakeFileChannel                    uintptr
	Ftcl_MakeSafe                           uintptr
	Ftcl_MakeTcpClientChannel               uintptr
	Ftcl_Merge                              uintptr
	Ftcl_NextHashEntry                      uintptr
	Ftcl_NotifyChannel                      uintptr
	Ftcl_ObjGetVar2                         uintptr
	Ftcl_ObjSetVar2                         uintptr
	Ftcl_OpenCommandChannel                 uintptr
	Ftcl_OpenFileChannel                    uintptr
	Ftcl_OpenTcpClient                      uintptr
	Ftcl_OpenTcpServer                      uintptr
	Ftcl_Preserve                           uintptr
	Ftcl_PrintDouble                        uintptr
	Ftcl_PutEnv                             uintptr
	Ftcl_PosixError                         uintptr
	Ftcl_QueueEvent                         uintptr
	Ftcl_Read                               uintptr
	Ftcl_ReapDetachedProcs                  uintptr
	Ftcl_RecordAndEval                      uintptr
	Ftcl_RecordAndEvalObj                   uintptr
	Ftcl_RegisterChannel                    uintptr
	Ftcl_RegisterObjType                    uintptr
	Ftcl_RegExpCompile                      uintptr
	Ftcl_RegExpExec                         uintptr
	Ftcl_RegExpMatch                        uintptr
	Ftcl_RegExpRange                        uintptr
	Ftcl_Release                            uintptr
	Ftcl_ResetResult                        uintptr
	Ftcl_ScanElement                        uintptr
	Ftcl_ScanCountedElement                 uintptr
	Ftcl_SeekOld                            uintptr
	Ftcl_ServiceAll                         uintptr
	Ftcl_ServiceEvent                       uintptr
	Ftcl_SetAssocData                       uintptr
	Ftcl_SetChannelBufferSize               uintptr
	Ftcl_SetChannelOption                   uintptr
	Ftcl_SetCommandInfo                     uintptr
	Ftcl_SetErrno                           uintptr
	Ftcl_SetErrorCode                       uintptr
	Ftcl_SetMaxBlockTime                    uintptr
	Ftcl_SetPanicProc                       uintptr
	Ftcl_SetRecursionLimit                  uintptr
	Ftcl_SetResult                          uintptr
	Ftcl_SetServiceMode                     uintptr
	Ftcl_SetObjErrorCode                    uintptr
	Ftcl_SetObjResult                       uintptr
	Ftcl_SetStdChannel                      uintptr
	Ftcl_SetVar                             uintptr
	Ftcl_SetVar2                            uintptr
	Ftcl_SignalId                           uintptr
	Ftcl_SignalMsg                          uintptr
	Ftcl_SourceRCFile                       uintptr
	Ftcl_SplitList                          uintptr
	Ftcl_SplitPath                          uintptr
	Ftcl_StaticPackage                      uintptr
	Ftcl_StringMatch                        uintptr
	Ftcl_TellOld                            uintptr
	Ftcl_TraceVar                           uintptr
	Ftcl_TraceVar2                          uintptr
	Ftcl_TranslateFileName                  uintptr
	Ftcl_Ungets                             uintptr
	Ftcl_UnlinkVar                          uintptr
	Ftcl_UnregisterChannel                  uintptr
	Ftcl_UnsetVar                           uintptr
	Ftcl_UnsetVar2                          uintptr
	Ftcl_UntraceVar                         uintptr
	Ftcl_UntraceVar2                        uintptr
	Ftcl_UpdateLinkedVar                    uintptr
	Ftcl_UpVar                              uintptr
	Ftcl_UpVar2                             uintptr
	Ftcl_VarEval                            uintptr
	Ftcl_VarTraceInfo                       uintptr
	Ftcl_VarTraceInfo2                      uintptr
	Ftcl_Write                              uintptr
	Ftcl_WrongNumArgs                       uintptr
	Ftcl_DumpActiveMemory                   uintptr
	Ftcl_ValidateAllMemory                  uintptr
	Ftcl_AppendResultVA                     uintptr
	Ftcl_AppendStringsToObjVA               uintptr
	Ftcl_HashStats                          uintptr
	Ftcl_ParseVar                           uintptr
	Ftcl_PkgPresent                         uintptr
	Ftcl_PkgPresentEx                       uintptr
	Ftcl_PkgProvide                         uintptr
	Ftcl_PkgRequire                         uintptr
	Ftcl_SetErrorCodeVA                     uintptr
	Ftcl_VarEvalVA                          uintptr
	Ftcl_WaitPid                            uintptr
	Ftcl_PanicVA                            uintptr
	Ftcl_GetVersion                         uintptr
	Ftcl_InitMemory                         uintptr
	Ftcl_StackChannel                       uintptr
	Ftcl_UnstackChannel                     uintptr
	Ftcl_GetStackedChannel                  uintptr
	Ftcl_SetMainLoop                        uintptr
	Freserved285                            uintptr
	Ftcl_AppendObjToObj                     uintptr
	Ftcl_CreateEncoding                     uintptr
	Ftcl_CreateThreadExitHandler            uintptr
	Ftcl_DeleteThreadExitHandler            uintptr
	Ftcl_DiscardResult                      uintptr
	Ftcl_EvalEx                             uintptr
	Ftcl_EvalObjv                           uintptr
	Ftcl_EvalObjEx                          uintptr
	Ftcl_ExitThread                         uintptr
	Ftcl_ExternalToUtf                      uintptr
	Ftcl_ExternalToUtfDString               uintptr
	Ftcl_FinalizeThread                     uintptr
	Ftcl_FinalizeNotifier                   uintptr
	Ftcl_FreeEncoding                       uintptr
	Ftcl_GetCurrentThread                   uintptr
	Ftcl_GetEncoding                        uintptr
	Ftcl_GetEncodingName                    uintptr
	Ftcl_GetEncodingNames                   uintptr
	Ftcl_GetIndexFromObjStruct              uintptr
	Ftcl_GetThreadData                      uintptr
	Ftcl_GetVar2Ex                          uintptr
	Ftcl_InitNotifier                       uintptr
	Ftcl_MutexLock                          uintptr
	Ftcl_MutexUnlock                        uintptr
	Ftcl_ConditionNotify                    uintptr
	Ftcl_ConditionWait                      uintptr
	Ftcl_NumUtfChars                        uintptr
	Ftcl_ReadChars                          uintptr
	Ftcl_RestoreResult                      uintptr
	Ftcl_SaveResult                         uintptr
	Ftcl_SetSystemEncoding                  uintptr
	Ftcl_SetVar2Ex                          uintptr
	Ftcl_ThreadAlert                        uintptr
	Ftcl_ThreadQueueEvent                   uintptr
	Ftcl_UniCharAtIndex                     uintptr
	Ftcl_UniCharToLower                     uintptr
	Ftcl_UniCharToTitle                     uintptr
	Ftcl_UniCharToUpper                     uintptr
	Ftcl_UniCharToUtf                       uintptr
	Ftcl_UtfAtIndex                         uintptr
	Ftcl_UtfCharComplete                    uintptr
	Ftcl_UtfBackslash                       uintptr
	Ftcl_UtfFindFirst                       uintptr
	Ftcl_UtfFindLast                        uintptr
	Ftcl_UtfNext                            uintptr
	Ftcl_UtfPrev                            uintptr
	Ftcl_UtfToExternal                      uintptr
	Ftcl_UtfToExternalDString               uintptr
	Ftcl_UtfToLower                         uintptr
	Ftcl_UtfToTitle                         uintptr
	Ftcl_UtfToUniChar                       uintptr
	Ftcl_UtfToUpper                         uintptr
	Ftcl_WriteChars                         uintptr
	Ftcl_WriteObj                           uintptr
	Ftcl_GetString                          uintptr
	Ftcl_GetDefaultEncodingDir              uintptr
	Ftcl_SetDefaultEncodingDir              uintptr
	Ftcl_AlertNotifier                      uintptr
	Ftcl_ServiceModeHook                    uintptr
	Ftcl_UniCharIsAlnum                     uintptr
	Ftcl_UniCharIsAlpha                     uintptr
	Ftcl_UniCharIsDigit                     uintptr
	Ftcl_UniCharIsLower                     uintptr
	Ftcl_UniCharIsSpace                     uintptr
	Ftcl_UniCharIsUpper                     uintptr
	Ftcl_UniCharIsWordChar                  uintptr
	Ftcl_UniCharLen                         uintptr
	Ftcl_UniCharNcmp                        uintptr
	Ftcl_UniCharToUtfDString                uintptr
	Ftcl_UtfToUniCharDString                uintptr
	Ftcl_GetRegExpFromObj                   uintptr
	Ftcl_EvalTokens                         uintptr
	Ftcl_FreeParse                          uintptr
	Ftcl_LogCommandInfo                     uintptr
	Ftcl_ParseBraces                        uintptr
	Ftcl_ParseCommand                       uintptr
	Ftcl_ParseExpr                          uintptr
	Ftcl_ParseQuotedString                  uintptr
	Ftcl_ParseVarName                       uintptr
	Ftcl_GetCwd                             uintptr
	Ftcl_Chdir                              uintptr
	Ftcl_Access                             uintptr
	Ftcl_Stat                               uintptr
	Ftcl_UtfNcmp                            uintptr
	Ftcl_UtfNcasecmp                        uintptr
	Ftcl_StringCaseMatch                    uintptr
	Ftcl_UniCharIsControl                   uintptr
	Ftcl_UniCharIsGraph                     uintptr
	Ftcl_UniCharIsPrint                     uintptr
	Ftcl_UniCharIsPunct                     uintptr
	Ftcl_RegExpExecObj                      uintptr
	Ftcl_RegExpGetInfo                      uintptr
	Ftcl_NewUnicodeObj                      uintptr
	Ftcl_SetUnicodeObj                      uintptr
	Ftcl_GetCharLength                      uintptr
	Ftcl_GetUniChar                         uintptr
	Ftcl_GetUnicode                         uintptr
	Ftcl_GetRange                           uintptr
	Ftcl_AppendUnicodeToObj                 uintptr
	Ftcl_RegExpMatchObj                     uintptr
	Ftcl_SetNotifier                        uintptr
	Ftcl_GetAllocMutex                      uintptr
	Ftcl_GetChannelNames                    uintptr
	Ftcl_GetChannelNamesEx                  uintptr
	Ftcl_ProcObjCmd                         uintptr
	Ftcl_ConditionFinalize                  uintptr
	Ftcl_MutexFinalize                      uintptr
	Ftcl_CreateThread                       uintptr
	Ftcl_ReadRaw                            uintptr
	Ftcl_WriteRaw                           uintptr
	Ftcl_GetTopChannel                      uintptr
	Ftcl_ChannelBuffered                    uintptr
	Ftcl_ChannelName                        uintptr
	Ftcl_ChannelVersion                     uintptr
	Ftcl_ChannelBlockModeProc               uintptr
	Ftcl_ChannelCloseProc                   uintptr
	Ftcl_ChannelClose2Proc                  uintptr
	Ftcl_ChannelInputProc                   uintptr
	Ftcl_ChannelOutputProc                  uintptr
	Ftcl_ChannelSeekProc                    uintptr
	Ftcl_ChannelSetOptionProc               uintptr
	Ftcl_ChannelGetOptionProc               uintptr
	Ftcl_ChannelWatchProc                   uintptr
	Ftcl_ChannelGetHandleProc               uintptr
	Ftcl_ChannelFlushProc                   uintptr
	Ftcl_ChannelHandlerProc                 uintptr
	Ftcl_JoinThread                         uintptr
	Ftcl_IsChannelShared                    uintptr
	Ftcl_IsChannelRegistered                uintptr
	Ftcl_CutChannel                         uintptr
	Ftcl_SpliceChannel                      uintptr
	Ftcl_ClearChannelHandlers               uintptr
	Ftcl_IsChannelExisting                  uintptr
	Ftcl_UniCharNcasecmp                    uintptr
	Ftcl_UniCharCaseMatch                   uintptr
	Ftcl_FindHashEntry                      uintptr
	Ftcl_CreateHashEntry                    uintptr
	Ftcl_InitCustomHashTable                uintptr
	Ftcl_InitObjHashTable                   uintptr
	Ftcl_CommandTraceInfo                   uintptr
	Ftcl_TraceCommand                       uintptr
	Ftcl_UntraceCommand                     uintptr
	Ftcl_AttemptAlloc                       uintptr
	Ftcl_AttemptDbCkalloc                   uintptr
	Ftcl_AttemptRealloc                     uintptr
	Ftcl_AttemptDbCkrealloc                 uintptr
	Ftcl_AttemptSetObjLength                uintptr
	Ftcl_GetChannelThread                   uintptr
	Ftcl_GetUnicodeFromObj                  uintptr
	Ftcl_GetMathFuncInfo                    uintptr
	Ftcl_ListMathFuncs                      uintptr
	Ftcl_SubstObj                           uintptr
	Ftcl_DetachChannel                      uintptr
	Ftcl_IsStandardChannel                  uintptr
	Ftcl_FSCopyFile                         uintptr
	Ftcl_FSCopyDirectory                    uintptr
	Ftcl_FSCreateDirectory                  uintptr
	Ftcl_FSDeleteFile                       uintptr
	Ftcl_FSLoadFile                         uintptr
	Ftcl_FSMatchInDirectory                 uintptr
	Ftcl_FSLink                             uintptr
	Ftcl_FSRemoveDirectory                  uintptr
	Ftcl_FSRenameFile                       uintptr
	Ftcl_FSLstat                            uintptr
	Ftcl_FSUtime                            uintptr
	Ftcl_FSFileAttrsGet                     uintptr
	Ftcl_FSFileAttrsSet                     uintptr
	Ftcl_FSFileAttrStrings                  uintptr
	Ftcl_FSStat                             uintptr
	Ftcl_FSAccess                           uintptr
	Ftcl_FSOpenFileChannel                  uintptr
	Ftcl_FSGetCwd                           uintptr
	Ftcl_FSChdir                            uintptr
	Ftcl_FSConvertToPathType                uintptr
	Ftcl_FSJoinPath                         uintptr
	Ftcl_FSSplitPath                        uintptr
	Ftcl_FSEqualPaths                       uintptr
	Ftcl_FSGetNormalizedPath                uintptr
	Ftcl_FSJoinToPath                       uintptr
	Ftcl_FSGetInternalRep                   uintptr
	Ftcl_FSGetTranslatedPath                uintptr
	Ftcl_FSEvalFile                         uintptr
	Ftcl_FSNewNativePath                    uintptr
	Ftcl_FSGetNativePath                    uintptr
	Ftcl_FSFileSystemInfo                   uintptr
	Ftcl_FSPathSeparator                    uintptr
	Ftcl_FSListVolumes                      uintptr
	Ftcl_FSRegister                         uintptr
	Ftcl_FSUnregister                       uintptr
	Ftcl_FSData                             uintptr
	Ftcl_FSGetTranslatedStringPath          uintptr
	Ftcl_FSGetFileSystemForPath             uintptr
	Ftcl_FSGetPathType                      uintptr
	Ftcl_OutputBuffered                     uintptr
	Ftcl_FSMountsChanged                    uintptr
	Ftcl_EvalTokensStandard                 uintptr
	Ftcl_GetTime                            uintptr
	Ftcl_CreateObjTrace                     uintptr
	Ftcl_GetCommandInfoFromToken            uintptr
	Ftcl_SetCommandInfoFromToken            uintptr
	Ftcl_DbNewWideIntObj                    uintptr
	Ftcl_GetWideIntFromObj                  uintptr
	Ftcl_NewWideIntObj                      uintptr
	Ftcl_SetWideIntObj                      uintptr
	Ftcl_AllocStatBuf                       uintptr
	Ftcl_Seek                               uintptr
	Ftcl_Tell                               uintptr
	Ftcl_ChannelWideSeekProc                uintptr
	Ftcl_DictObjPut                         uintptr
	Ftcl_DictObjGet                         uintptr
	Ftcl_DictObjRemove                      uintptr
	Ftcl_DictObjSize                        uintptr
	Ftcl_DictObjFirst                       uintptr
	Ftcl_DictObjNext                        uintptr
	Ftcl_DictObjDone                        uintptr
	Ftcl_DictObjPutKeyList                  uintptr
	Ftcl_DictObjRemoveKeyList               uintptr
	Ftcl_NewDictObj                         uintptr
	Ftcl_DbNewDictObj                       uintptr
	Ftcl_RegisterConfig                     uintptr
	Ftcl_CreateNamespace                    uintptr
	Ftcl_DeleteNamespace                    uintptr
	Ftcl_AppendExportList                   uintptr
	Ftcl_Export                             uintptr
	Ftcl_Import                             uintptr
	Ftcl_ForgetImport                       uintptr
	Ftcl_GetCurrentNamespace                uintptr
	Ftcl_GetGlobalNamespace                 uintptr
	Ftcl_FindNamespace                      uintptr
	Ftcl_FindCommand                        uintptr
	Ftcl_GetCommandFromObj                  uintptr
	Ftcl_GetCommandFullName                 uintptr
	Ftcl_FSEvalFileEx                       uintptr
	Ftcl_SetExitProc                        uintptr
	Ftcl_LimitAddHandler                    uintptr
	Ftcl_LimitRemoveHandler                 uintptr
	Ftcl_LimitReady                         uintptr
	Ftcl_LimitCheck                         uintptr
	Ftcl_LimitExceeded                      uintptr
	Ftcl_LimitSetCommands                   uintptr
	Ftcl_LimitSetTime                       uintptr
	Ftcl_LimitSetGranularity                uintptr
	Ftcl_LimitTypeEnabled                   uintptr
	Ftcl_LimitTypeExceeded                  uintptr
	Ftcl_LimitTypeSet                       uintptr
	Ftcl_LimitTypeReset                     uintptr
	Ftcl_LimitGetCommands                   uintptr
	Ftcl_LimitGetTime                       uintptr
	Ftcl_LimitGetGranularity                uintptr
	Ftcl_SaveInterpState                    uintptr
	Ftcl_RestoreInterpState                 uintptr
	Ftcl_DiscardInterpState                 uintptr
	Ftcl_SetReturnOptions                   uintptr
	Ftcl_GetReturnOptions                   uintptr
	Ftcl_IsEnsemble                         uintptr
	Ftcl_CreateEnsemble                     uintptr
	Ftcl_FindEnsemble                       uintptr
	Ftcl_SetEnsembleSubcommandList          uintptr
	Ftcl_SetEnsembleMappingDict             uintptr
	Ftcl_SetEnsembleUnknownHandler          uintptr
	Ftcl_SetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleSubcommandList          uintptr
	Ftcl_GetEnsembleMappingDict             uintptr
	Ftcl_GetEnsembleUnknownHandler          uintptr
	Ftcl_GetEnsembleFlags                   uintptr
	Ftcl_GetEnsembleNamespace               uintptr
	Ftcl_SetTimeProc                        uintptr
	Ftcl_QueryTimeProc                      uintptr
	Ftcl_ChannelThreadActionProc            uintptr
	Ftcl_NewBignumObj                       uintptr
	Ftcl_DbNewBignumObj                     uintptr
	Ftcl_SetBignumObj                       uintptr
	Ftcl_GetBignumFromObj                   uintptr
	Ftcl_TakeBignumFromObj                  uintptr
	Ftcl_TruncateChannel                    uintptr
	Ftcl_ChannelTruncateProc                uintptr
	Ftcl_SetChannelErrorInterp              uintptr
	Ftcl_GetChannelErrorInterp              uintptr
	Ftcl_SetChannelError                    uintptr
	Ftcl_GetChannelError                    uintptr
	Ftcl_InitBignumFromDouble               uintptr
	Ftcl_GetNamespaceUnknownHandler         uintptr
	Ftcl_SetNamespaceUnknownHandler         uintptr
	Ftcl_GetEncodingFromObj                 uintptr
	Ftcl_GetEncodingSearchPath              uintptr
	Ftcl_SetEncodingSearchPath              uintptr
	Ftcl_GetEncodingNameFromEnvironment     uintptr
	Ftcl_PkgRequireProc                     uintptr
	Ftcl_AppendObjToErrorInfo               uintptr
	Ftcl_AppendLimitedToObj                 uintptr
	Ftcl_Format                             uintptr
	Ftcl_AppendFormatToObj                  uintptr
	Ftcl_ObjPrintf                          uintptr
	Ftcl_AppendPrintfToObj                  uintptr
	Ftcl_CancelEval                         uintptr
	Ftcl_Canceled                           uintptr
	Ftcl_CreatePipe                         uintptr
	Ftcl_NRCreateCommand                    uintptr
	Ftcl_NREvalObj                          uintptr
	Ftcl_NREvalObjv                         uintptr
	Ftcl_NRCmdSwap                          uintptr
	Ftcl_NRAddCallback                      uintptr
	Ftcl_NRCallObjProc                      uintptr
	Ftcl_GetFSDeviceFromStat                uintptr
	Ftcl_GetFSInodeFromStat                 uintptr
	Ftcl_GetModeFromStat                    uintptr
	Ftcl_GetLinkCountFromStat               uintptr
	Ftcl_GetUserIdFromStat                  uintptr
	Ftcl_GetGroupIdFromStat                 uintptr
	Ftcl_GetDeviceTypeFromStat              uintptr
	Ftcl_GetAccessTimeFromStat              uintptr
	Ftcl_GetModificationTimeFromStat        uintptr
	Ftcl_GetChangeTimeFromStat              uintptr
	Ftcl_GetSizeFromStat                    uintptr
	Ftcl_GetBlocksFromStat                  uintptr
	Ftcl_GetBlockSizeFromStat               uintptr
	Ftcl_SetEnsembleParameterList           uintptr
	Ftcl_GetEnsembleParameterList           uintptr
	Ftcl_ParseArgsObjv                      uintptr
	Ftcl_GetErrorLine                       uintptr
	Ftcl_SetErrorLine                       uintptr
	Ftcl_TransferResult                     uintptr
	Ftcl_InterpActive                       uintptr
	Ftcl_BackgroundException                uintptr
	Ftcl_ZlibDeflate                        uintptr
	Ftcl_ZlibInflate                        uintptr
	Ftcl_ZlibCRC32                          uintptr
	Ftcl_ZlibAdler32                        uintptr
	Ftcl_ZlibStreamInit                     uintptr
	Ftcl_ZlibStreamGetCommandName           uintptr
	Ftcl_ZlibStreamEof                      uintptr
	Ftcl_ZlibStreamChecksum                 uintptr
	Ftcl_ZlibStreamPut                      uintptr
	Ftcl_ZlibStreamGet                      uintptr
	Ftcl_ZlibStreamClose                    uintptr
	Ftcl_ZlibStreamReset                    uintptr
	Ftcl_SetStartupScript                   uintptr
	Ftcl_GetStartupScript                   uintptr
	Ftcl_CloseEx                            uintptr
	Ftcl_NRExprObj                          uintptr
	Ftcl_NRSubstObj                         uintptr
	Ftcl_LoadFile                           uintptr
	Ftcl_FindSymbol                         uintptr
	Ftcl_FSUnloadFile                       uintptr
	Ftcl_ZlibStreamSetCompressionDictionary uintptr
	Freserved631                            uintptr
	Freserved632                            uintptr
	Freserved633                            uintptr
	Freserved634                            uintptr
	Freserved635                            uintptr
	Freserved636                            uintptr
	Freserved637                            uintptr
	Freserved638                            uintptr
	Freserved639                            uintptr
	Freserved640                            uintptr
	Freserved641                            uintptr
	Freserved642                            uintptr
	Freserved643                            uintptr
	Freserved644                            uintptr
	Freserved645                            uintptr
	Freserved646                            uintptr
	Freserved647                            uintptr
	Freserved648                            uintptr
	FtclUnusedStubEntry                     uintptr
} /* tclDecls.h:1845:9 */

type TclStubs = TclStubs1 /* tclDecls.h:2523:3 */

// !END!: Do not edit above this line.

// Deprecated Tcl procedures:

// Include platform specific public function declarations that are accessible
// via the stubs table. Make all TclOO symbols MODULE_SCOPE (which only
// has effect on building it as a shared library). See ticket [3010352].

// tclPlatDecls.h --
//
//	Declarations of platform specific Tcl APIs.
//
// Copyright (c) 1998-1999 by Scriptics Corporation.
// All rights reserved.

// WARNING: This file is automatically generated by the tools/genStubs.tcl
// script.  Any modifications to the function declarations below should be made
// in the generic/tcl.decls script.

// TCHAR is needed here for win32, so if it is not defined yet do it here.
// This way, we don't need to include <tchar.h> just for one define.

// !BEGIN!: Do not edit below this line.

// Exported function declarations:

type TclPlatStubs = TclPlatStubs1 /* tclPlatDecls.h:86:3 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Extract an sqlite3* db handle from the object passed as the second
// argument. If successful, set *pDb to point to the db handle and return
// TCL_OK. Otherwise, return TCL_ERROR.
func dbHandleFromObj(tls *libc.TLS, interp uintptr, pObj uintptr, pDb uintptr) int32 { /* test_expert.c:36:12: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var info Tcl_CmdInfo at bp+24, 64

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, pObj), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930 /* "no such handle: " */, tcl.XTcl_GetString(tls, pObj), 0))
		return TCL_ERROR
	}

	*(*uintptr)(unsafe.Pointer(pDb)) = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &info */)).FobjClientData))
	return TCL_OK
}

// Tclcmd:  $expert sql SQL
//          $expert analyze
//          $expert count
//          $expert report STMT EREPORT
//          $expert destroy
func testExpertCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_expert.c:55:26: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var pExpert uintptr = clientData
	*(*[6]Subcmd)(unsafe.Pointer(bp /* aSub */)) = [6]Subcmd{
		{FzSub: ts + 1947 /* "sql" */, FnArg: 1, FzMsg: ts + 1951 /* "TABLE" */},           // 0
		{FzSub: ts + 1957 /* "analyze" */, FzMsg: ts + 584 /* "" */},                       // 1
		{FzSub: ts + 1965 /* "count" */, FzMsg: ts + 584 /* "" */},                         // 2
		{FzSub: ts + 1971 /* "report" */, FnArg: 2, FzMsg: ts + 1978 /* "STMT EREPORT" */}, // 3
		{FzSub: ts + 1991 /* "destroy" */, FzMsg: ts + 584 /* "" */},                       // 4
		{},
	}
	// var iSub int32 at bp+144, 4

	var rc int32 = TCL_OK
	*(*uintptr)(unsafe.Pointer(bp + 152 /* zErr */)) = uintptr(0)

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999 /* "SUBCOMMAND ..." */)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &aSub[0] */, int32(unsafe.Sizeof(Subcmd{})), ts+2014 /* "sub-command" */, 0, bp+144 /* &iSub */)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+(*Subcmd)(unsafe.Pointer(bp+uintptr(*(*int32)(unsafe.Pointer(bp + 144)))*24)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*Subcmd)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 144 /* iSub */)))*24)).FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 144 /* iSub */)) {
	case 0:
		{ // sql
			var zArg uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			rc = sqlite3_expert_sql(tls, pExpert, zArg, bp+152 /* &zErr */)
			break

		}

	case 1:
		{ // analyze
			rc = sqlite3_expert_analyze(tls, pExpert, bp+152 /* &zErr */)
			break

		}

	case 2:
		{ // count
			var n int32 = sqlite3_expert_count(tls, pExpert)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, n))
			break

		}

	case 3:
		{ // report
			*(*[5]uintptr)(unsafe.Pointer(bp + 168 /* aEnum */)) = [5]uintptr{
				ts + 1947 /* "sql" */, ts + 2026 /* "indexes" */, ts + 2034 /* "plan" */, ts + 2039 /* "candidates" */, uintptr(0),
			}
			// var iEnum int32 at bp+208, 4

			// var iStmt int32 at bp+160, 4

			var zReport uintptr

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+160) != 0 ||
				tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+168, int32(unsafe.Sizeof(uintptr(0))), ts+1971, 0, bp+208) != 0 {
				return TCL_ERROR
			}

			zReport = sqlite3_expert_report(tls, pExpert, *(*int32)(unsafe.Pointer(bp + 160 /* iStmt */)), 1+*(*int32)(unsafe.Pointer(bp + 208)))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zReport, -1))
			break

		}

	default: // destroy

		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
		break
	}

	if rc != TCL_OK {
		if *(*uintptr)(unsafe.Pointer(bp + 152)) != 0 {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 152 /* zErr */)), -1))
		} else {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		}
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 152 /* zErr */)))
	return rc
}

type Subcmd = struct {
	FzSub        uintptr
	FnArg        int32
	F__ccgo_pad1 [4]byte
	FzMsg        uintptr
} /* test_expert.c:62:3 */

func testExpertDel(tls *libc.TLS, clientData uintptr) { /* test_expert.c:150:27: */
	var pExpert uintptr = clientData
	sqlite3_expert_destroy(tls, pExpert)
}

// sqlite3_expert_new DB
func test_sqlite3_expert_new(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_expert.c:158:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+40, 8

	var zCmd uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 48 /* zErr */)) = uintptr(0)
	var pExpert uintptr
	var rc int32 = TCL_OK

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if dbHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	zCmd = sqlite3.Xsqlite3_mprintf(tls, ts+2053 /* "sqlite3expert%d" */, libc.VaList(bp, libc.PreIncInt32(&iCmd, 1)))
	if zCmd == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, ts+2069 /* "out of memory" */, uintptr(0)))
		return TCL_ERROR
	}

	pExpert = sqlite3_expert_new(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), bp+48 /* &zErr */)
	if pExpert == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(bp + 48 /* zErr */)), uintptr(0)))
		rc = TCL_ERROR
	} else {
		var p uintptr = pExpert
		tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{testExpertCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testExpertDel})))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zCmd, -1))
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* zErr */)))
	return rc
}

var iCmd int32 = 0 /* test_expert.c:164:14 */

func TestExpert_Init(tls *libc.TLS, interp uintptr) int32 { /* test_expert.c:202:5: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*[1]struct {
		FzCmd  uintptr
		FxProc uintptr
	})(unsafe.Pointer(bp)) = [1]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{
		{FzCmd: ts + 2083 /* "sqlite3_expert_n..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3_expert_new}))},
	}
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof([1]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{}))/uint64(unsafe.Sizeof(struct {
		FzCmd  uintptr
		FxProc uintptr
	}{})); i++ {
		var p uintptr = bp + uintptr(i)*16
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FzCmd, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

// 2011 Jan 27
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// This file is not part of the production FTS code. It is only used for
// testing. It contains a virtual table implementation that provides direct
// access to the full-text index of an FTS table.

// 2009 Nov 12
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//

// FTS3/FTS4 require virtual tables

// FTS4 is really an extension for FTS3.  It is enabled using the
// SQLITE_ENABLE_FTS3 macro.  But to avoid confusion we also all
// the SQLITE_ENABLE_FTS4 macro to serve as an alisse for SQLITE_ENABLE_FTS3.

// Decode a pointer to an sqlite3 object.
func f5tDbPointer(tls *libc.TLS, interp uintptr, pObj uintptr, ppDb uintptr) int32 { /* fts5_tcl.c:54:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 64

	var z uintptr = tcl.XTcl_GetString(tls, pObj)
	if tcl.XTcl_GetCommandInfo(tls, interp, z, bp) != 0 {
		p = (*Tcl_CmdInfo)(unsafe.Pointer(bp /* &cmdInfo */)).FobjClientData
		*(*uintptr)(unsafe.Pointer(ppDb)) = (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb
		return TCL_OK
	}
	return TCL_ERROR
}

// End of code that accesses the SqliteDb struct.
//

func f5tResultToErrorCode(tls *libc.TLS, zRes uintptr) int32 { /* fts5_tcl.c:69:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	*(*[4]ErrorCode)(unsafe.Pointer(bp /* aErr */)) = [4]ErrorCode{
		{Frc: SQLITE_DONE, FzError: ts + 2102 /* "SQLITE_DONE" */},
		{Frc: SQLITE_ERROR, FzError: ts + 2114 /* "SQLITE_ERROR" */},
		{FzError: ts + 2127 /* "SQLITE_OK" */},
		{FzError: ts + 584 /* "" */},
	}
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof([4]ErrorCode{}))/uint64(unsafe.Sizeof(ErrorCode{})); i++ {
		if 0 == sqlite3.Xsqlite3_stricmp(tls, zRes, (*ErrorCode)(unsafe.Pointer(bp+uintptr(i)*16)).FzError) {
			return (*ErrorCode)(unsafe.Pointer(bp /* &aErr */ + uintptr(i)*16)).Frc
		}
	}

	return SQLITE_ERROR
}

type ErrorCode = struct {
	Frc          int32
	F__ccgo_pad1 [4]byte
	FzError      uintptr
} /* fts5_tcl.c:70:3 */

func f5tDbAndApi(tls *libc.TLS, interp uintptr, pObj uintptr, ppDb uintptr, ppApi uintptr) int32 { /* fts5_tcl.c:90:26: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)) = uintptr(0)
	var rc int32 = f5tDbPointer(tls, interp, pObj, bp+48 /* &db */)
	if rc != TCL_OK {
		return TCL_ERROR
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 64 /* pApi */)) = uintptr(0)

		rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), ts+2137 /* "SELECT fts5(?1)" */, -1, bp+56 /* &pStmt */, uintptr(0))
		if rc != SQLITE_OK {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2153 /* "error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))), 0))
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_bind_pointer(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)), 1, bp+64 /* &pApi */, ts+2161 /* "fts5_api_ptr" */, uintptr(0))
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))

		if sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) != SQLITE_OK {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+2153 /* "error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))), 0))
			return TCL_ERROR
		}

		*(*uintptr)(unsafe.Pointer(ppDb)) = *(*uintptr)(unsafe.Pointer(bp + 48 /* db */))
		*(*uintptr)(unsafe.Pointer(ppApi)) = *(*uintptr)(unsafe.Pointer(bp + 64 /* pApi */))
	}

	return TCL_OK
}

type F5tFunction1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* fts5_tcl.c:124:9 */

type F5tFunction = F5tFunction1 /* fts5_tcl.c:124:28 */

type F5tApi1 = struct {
	FpApi uintptr
	FpFts uintptr
} /* fts5_tcl.c:130:9 */

type F5tApi = F5tApi1 /* fts5_tcl.c:130:23 */

// An object of this type is used with the xSetAuxdata() and xGetAuxdata()
// API test wrappers. The tcl interface allows a single tcl value to be
// saved using xSetAuxdata(). Instead of simply storing a pointer to the
// tcl object, the code in this file wraps it in an sqlite3_malloc'd
// instance of the following struct so that if the destructor is not
// correctly invoked it will be reported as an SQLite memory leak.
type F5tAuxData1 = struct{ FpObj uintptr } /* fts5_tcl.c:144:9 */

// An object of this type is used with the xSetAuxdata() and xGetAuxdata()
// API test wrappers. The tcl interface allows a single tcl value to be
// saved using xSetAuxdata(). Instead of simply storing a pointer to the
// tcl object, the code in this file wraps it in an sqlite3_malloc'd
// instance of the following struct so that if the destructor is not
// correctly invoked it will be reported as an SQLite memory leak.
type F5tAuxData = F5tAuxData1 /* fts5_tcl.c:144:27 */

func xTokenizeCb(tls *libc.TLS, pCtx uintptr, tflags int32, zToken uintptr, nToken int32, iStart int32, iEnd int32) int32 { /* fts5_tcl.c:149:12: */
	var p uintptr = pCtx
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	var rc int32

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zToken, nToken))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, iStart))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, iEnd))

	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc == TCL_OK {
		rc = f5tResultToErrorCode(tls, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp))
	}

	return rc
}

func xQueryPhraseCb(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr) int32 { /* fts5_tcl.c:175:12: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var p uintptr = pCtx
	var pEval uintptr
	var rc int32
	// var zCmd [64]int8 at bp+8, 64

	// var sApi F5tApi at bp+72, 16

	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpApi = pApi
	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpFts = pFts
	libc.Xsprintf(tls, bp+8 /* &zCmd[0] */, ts+2174 /* "f5t_2_%lld" */, libc.VaList(bp, libc.PostIncInt64(&iCmd1, 1)))
	tcl.XTcl_CreateObjCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{xF5tApi})), bp+72 /* &sApi */, uintptr(0))

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, bp+8 /* &zCmd[0] */, -1))
	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */)

	if rc == TCL_OK {
		rc = f5tResultToErrorCode(tls, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp))
	}

	return rc
}

var iCmd1 sqlite3_int64 = int64(0) /* fts5_tcl.c:181:24 */

func xSetAuxdataDestructor(tls *libc.TLS, p uintptr) { /* fts5_tcl.c:207:13: */
	var pData uintptr = p
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tAuxData)(unsafe.Pointer(pData)).FpObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, pData)
}

//      api sub-command...
//
// Description...
func xF5tApi(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:218:26: */
	bp := tls.Alloc(684)
	defer tls.Free(684)

	*(*[19]Sub)(unsafe.Pointer(bp + 32 /* aSub */)) = [19]Sub{
		{FzName: ts + 2185 /* "xColumnCount" */, FzMsg: ts + 584 /* "" */},                                      //  0
		{FzName: ts + 2198 /* "xRowCount" */, FzMsg: ts + 584 /* "" */},                                         //  1
		{FzName: ts + 2208 /* "xColumnTotalSize" */, FnArg: 1, FzMsg: ts + 2225 /* "COL" */},                    //  2
		{FzName: ts + 2229 /* "xTokenize" */, FnArg: 2, FzMsg: ts + 2239 /* "TEXT SCRIPT" */},                   //  3
		{FzName: ts + 2251 /* "xPhraseCount" */, FzMsg: ts + 584 /* "" */},                                      //  4
		{FzName: ts + 2264 /* "xPhraseSize" */, FnArg: 1, FzMsg: ts + 2276 /* "PHRASE" */},                      //  5
		{FzName: ts + 2283 /* "xInstCount" */, FzMsg: ts + 584 /* "" */},                                        //  6
		{FzName: ts + 2294 /* "xInst" */, FnArg: 1, FzMsg: ts + 2300 /* "IDX" */},                               //  7
		{FzName: ts + 2304 /* "xRowid" */, FzMsg: ts + 584 /* "" */},                                            //  8
		{FzName: ts + 2311 /* "xColumnText" */, FnArg: 1, FzMsg: ts + 2225 /* "COL" */},                         //  9
		{FzName: ts + 2323 /* "xColumnSize" */, FnArg: 1, FzMsg: ts + 2225 /* "COL" */},                         // 10
		{FzName: ts + 2335 /* "xQueryPhrase" */, FnArg: 2, FzMsg: ts + 2348 /* "PHRASE SCRIPT" */},              // 11
		{FzName: ts + 2362 /* "xSetAuxdata" */, FnArg: 1, FzMsg: ts + 2374 /* "VALUE" */},                       // 12
		{FzName: ts + 2380 /* "xGetAuxdata" */, FnArg: 1, FzMsg: ts + 2392 /* "CLEAR" */},                       // 13
		{FzName: ts + 2398 /* "xSetAuxdataInt" */, FnArg: 1, FzMsg: ts + 2413 /* "INTEGER" */},                  // 14
		{FzName: ts + 2421 /* "xGetAuxdataInt" */, FnArg: 1, FzMsg: ts + 2392 /* "CLEAR" */},                    // 15
		{FzName: ts + 2436 /* "xPhraseForeach" */, FnArg: 4, FzMsg: ts + 2451 /* "IPHRASE COLVAR O..." */},      // 16
		{FzName: ts + 2480 /* "xPhraseColumnFor..." */, FnArg: 3, FzMsg: ts + 2501 /* "IPHRASE COLVAR S..." */}, // 17
		{},
	}
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 488 /* iSub */)) = 0
	var p uintptr = clientData

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2523 /* "SUB-COMMAND" */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+32 /* &aSub[0] */, int32(unsafe.Sizeof(Sub{})), ts+2523 /* "SUB-COMMAND" */, 0, bp+488 /* &iSub */)
	if rc != TCL_OK {
		return rc
	}
	if (*Sub)(unsafe.Pointer(bp+32+uintptr(*(*int32)(unsafe.Pointer(bp + 488)))*24)).FnArg != objc-2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, (*Sub)(unsafe.Pointer(bp+32 /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 488 /* iSub */)))*24)).FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 488 /* iSub */)) {
	case 0:
		{
			var nCol int32
			nCol = (*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nCol))
			}
			break

		}
	case 1:
		{
			// var nRow sqlite3_int64 at bp+496, 8

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxRowCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+496 /* &nRow */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 496 /* nRow */))))
			}
			break

		}
	case 2:
		{
			// var iCol int32 at bp+504, 4

			// var nSize sqlite3_int64 at bp+512, 8

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+504) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnTotalSize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 504 /* iCol */)), bp+512 /* &nSize */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 512 /* nSize */))))
			}
			break

		}
	case 3:
		{
			// var nText int32 at bp+520, 4

			var zText uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+520 /* &nText */)
			// var ctx F5tFunction at bp+528, 16

			(*F5tFunction)(unsafe.Pointer(bp + 528 /* &ctx */)).Finterp = interp
			(*F5tFunction)(unsafe.Pointer(bp + 528 /* &ctx */)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 3*8))
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxTokenize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, zText, *(*int32)(unsafe.Pointer(bp + 520 /* nText */)), bp+528 /* &ctx */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
			}{xTokenizeCb})))
			if rc == SQLITE_OK {
				tcl.XTcl_ResetResult(tls, interp)
			}
			return rc

		}
	case 4:
		{
			var nPhrase int32
			nPhrase = (*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nPhrase))
			}
			break

		}
	case 5:
		{
			// var iPhrase int32 at bp+544, 4

			var sz int32
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+544) != 0 {
				return TCL_ERROR
			}
			sz = (*struct {
				f func(*libc.TLS, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseSize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 544 /* iPhrase */)))
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sz))
			}
			break

		}
	case 6:
		{
			// var nInst int32 at bp+548, 4

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxInstCount})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+548 /* &nInst */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 548 /* nInst */))))
			}
			break

		}
	case 7:
		{
			// var iIdx int32 at bp+552, 4

			// var ip int32 at bp+556, 4

			// var ic int32 at bp+560, 4

			// var io int32 at bp+564, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+552) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxInst})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 552 /* iIdx */)), bp+556 /* &ip */, bp+560 /* &ic */, bp+564 /* &io */)
			if rc == SQLITE_OK {
				var pList uintptr = tcl.XTcl_NewObj(tls)
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 556 /* ip */))))
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 560 /* ic */))))
				tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 564 /* io */))))
				tcl.XTcl_SetObjResult(tls, interp, pList)
			}
			break

		}
	case 8:
		{
			var iRowid sqlite3_int64 = (*struct {
				f func(*libc.TLS, uintptr) sqlite3_int64
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxRowid})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, iRowid))
			break

		}
	case 9:
		{
			*(*uintptr)(unsafe.Pointer(bp + 576 /* z */)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 584 /* n */)) = 0
			// var iCol int32 at bp+568, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+568) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnText})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 568 /* iCol */)), bp+576 /* &z */, bp+584 /* &n */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 576 /* z */)), *(*int32)(unsafe.Pointer(bp + 584 /* n */))))
			}
			break

		}
	case 10:
		{
			*(*int32)(unsafe.Pointer(bp + 592 /* n */)) = 0
			// var iCol int32 at bp+588, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+588) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxColumnSize})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 588 /* iCol */)), bp+592 /* &n */)
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 592 /* n */))))
			}
			break

		}
	case 11:
		{
			// var iPhrase int32 at bp+596, 4

			// var ctx F5tFunction at bp+600, 16

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+596) != 0 {
				return TCL_ERROR
			}
			(*F5tFunction)(unsafe.Pointer(bp + 600 /* &ctx */)).Finterp = interp
			(*F5tFunction)(unsafe.Pointer(bp + 600 /* &ctx */)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 3*8))
			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxQueryPhrase})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 596 /* iPhrase */)), bp+600 /* &ctx */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{xQueryPhraseCb})))
			if rc == SQLITE_OK {
				tcl.XTcl_ResetResult(tls, interp)
			}
			break

		}
	case 12:
		{
			var pData uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(F5tAuxData{})))
			if pData == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2069 /* "out of memory" */, 0))
				return TCL_ERROR
			}
			(*F5tAuxData)(unsafe.Pointer(pData)).FpObj = *(*uintptr)(unsafe.Pointer(objv + 2*8))
			(*Tcl_Obj)(unsafe.Pointer((*F5tAuxData)(unsafe.Pointer(pData)).FpObj)).FrefCount++
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxSetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, pData, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{xSetAuxdataDestructor})))
			break

		}
	case 13:
		{
			var pData uintptr
			// var bClear int32 at bp+616, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+616) != 0 {
				return TCL_ERROR
			}
			pData = (*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxGetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 616 /* bClear */)))
			if pData == uintptr(0) {
				tcl.XTcl_ResetResult(tls, interp)
			} else {
				tcl.XTcl_SetObjResult(tls, interp, (*F5tAuxData)(unsafe.Pointer(pData)).FpObj)
				if *(*int32)(unsafe.Pointer(bp + 616)) != 0 {
					xSetAuxdataDestructor(tls, pData)
				}
			}
			break

		}

	// These two - xSetAuxdataInt and xGetAuxdataInt - are similar to the
	// xSetAuxdata and xGetAuxdata methods implemented above. The difference
	// is that they may only save an integer value as auxiliary data, and
	// do not specify a destructor function.
	case 14:
		{
			// var iVal int32 at bp+620, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+620) != 0 {
				return TCL_ERROR
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxSetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, uintptr(0)+uintptr(*(*int32)(unsafe.Pointer(bp + 620 /* iVal */))), uintptr(0))
			break

		}
	case 15:
		{
			var iVal int32
			// var bClear int32 at bp+624, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+624) != 0 {
				return TCL_ERROR
			}
			iVal = int32((int64((*struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxGetAuxdata})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 624)))) - int64(uintptr(0))) / 1)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iVal))
			break

		}

	case 16:
		{
			// var iPhrase int32 at bp+628, 4

			// var iCol int32 at bp+648, 4

			// var iOff int32 at bp+652, 4

			var zColvar uintptr
			var zOffvar uintptr
			var pScript uintptr = *(*uintptr)(unsafe.Pointer(objv + 5*8))
			// var iter Fts5PhraseIter at bp+632, 16

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+628) != 0 {
				return TCL_ERROR
			}
			zColvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
			zOffvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))

			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseFirst})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 628 /* iPhrase */)), bp+632 /* &iter */, bp+648 /* &iCol */, bp+652 /* &iOff */)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3ErrName(tls, rc), 0))
				return TCL_ERROR
			}
			for ; *(*int32)(unsafe.Pointer(bp + 648)) >= 0; (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseNext})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+632 /* &iter */, bp+648 /* &iCol */, bp+652 /* &iOff */) {
				tcl.XTcl_SetVar2Ex(tls, interp, zColvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 648 /* iCol */))), 0)
				tcl.XTcl_SetVar2Ex(tls, interp, zOffvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 652 /* iOff */))), 0)
				rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
				if rc == TCL_CONTINUE {
					rc = TCL_OK
				}
				if rc != TCL_OK {
					if rc == TCL_BREAK {
						rc = TCL_OK
					}
					break
				}
			}

			break

		}

	case 17:
		{
			// var iPhrase int32 at bp+656, 4

			// var iCol int32 at bp+680, 4

			var zColvar uintptr
			var pScript uintptr = *(*uintptr)(unsafe.Pointer(objv + 4*8))
			// var iter Fts5PhraseIter at bp+664, 16

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+656) != 0 {
				return TCL_ERROR
			}
			zColvar = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))

			rc = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseFirstColumn})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, *(*int32)(unsafe.Pointer(bp + 656 /* iPhrase */)), bp+664 /* &iter */, bp+680 /* &iCol */)
			if rc != SQLITE_OK {
				tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
				return TCL_ERROR
			}
			for ; *(*int32)(unsafe.Pointer(bp + 680)) >= 0; (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr)
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer((*F5tApi)(unsafe.Pointer(p)).FpApi)).FxPhraseNextColumn})).f(tls, (*F5tApi)(unsafe.Pointer(p)).FpFts, bp+664 /* &iter */, bp+680 /* &iCol */) {
				tcl.XTcl_SetVar2Ex(tls, interp, zColvar, uintptr(0), tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 680 /* iCol */))), 0)
				rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
				if rc == TCL_CONTINUE {
					rc = TCL_OK
				}
				if rc != TCL_OK {
					if rc == TCL_BREAK {
						rc = TCL_OK
					}
					break
				}
			}

			break

		}

	default:

		break
	}

	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}

	return TCL_OK
}

type Sub = struct {
	FzName       uintptr
	FnArg        int32
	F__ccgo_pad1 [4]byte
	FzMsg        uintptr
} /* fts5_tcl.c:224:3 */

func xF5tFunction(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, nVal int32, apVal uintptr) { /* fts5_tcl.c:517:13: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var p uintptr = (*struct {
		f func(*libc.TLS, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxUserData})).f(tls, pFts)
	var pEval uintptr // Script to evaluate
	var i int32
	var rc int32
	// var zCmd [64]int8 at bp+8, 64

	// var sApi F5tApi at bp+72, 16

	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpApi = pApi
	(*F5tApi)(unsafe.Pointer(bp + 72 /* &sApi */)).FpFts = pFts

	libc.Xsprintf(tls, bp+8 /* &zCmd[0] */, ts+2535 /* "f5t_%lld" */, libc.VaList(bp, libc.PostIncInt64(&iCmd2, 1)))
	tcl.XTcl_CreateObjCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{xF5tApi})), bp+72 /* &sApi */, uintptr(0))
	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tFunction)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, bp+8 /* &zCmd[0] */, -1))

	for i = 0; i < nVal; i++ {
		var pObj uintptr = uintptr(0)
		switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))) {
		case SQLITE_TEXT:
			pObj = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))), -1)
			break
		case SQLITE_BLOB:
			pObj = tcl.XTcl_NewByteArrayObj(tls,
				sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))), sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))))
			break
		case SQLITE_INTEGER:
			pObj = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))))
			break
		case SQLITE_FLOAT:
			pObj = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))))
			break
		default:
			pObj = tcl.XTcl_NewObj(tls)
			break
		}
		tcl.XTcl_ListObjAppendElement(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, pObj)
	}

	rc = tcl.XTcl_EvalObjEx(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, pEval, TCL_GLOBAL_ONLY)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteCommand(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp, bp+8 /* &zCmd[0] */)

	if rc != TCL_OK {
		sqlite3.Xsqlite3_result_error(tls, pCtx, tcl.XTcl_GetStringResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp), -1)
	} else {
		var pVar uintptr = tcl.XTcl_GetObjResult(tls, (*F5tFunction)(unsafe.Pointer(p)).Finterp)
		// var n int32 at bp+88, 4

		var zType uintptr = func() uintptr {
			if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
				return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
			}
			return ts + 584
		}()
		var c int8 = *(*int8)(unsafe.Pointer(zType))
		if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2544) == 0 && (*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0) {
			// Only return a BLOB type if the Tcl variable is a bytearray and
			// has no string representation.
			var data uintptr = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+88 /* &n */)
			sqlite3.Xsqlite3_result_blob(tls, pCtx, data, *(*int32)(unsafe.Pointer(bp + 88 /* n */)), libc.UintptrFromInt32(-1))
		} else if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2554) == 0 {
			tcl.XTcl_GetIntFromObj(tls, uintptr(0), pVar, bp+88 /* &n */)
			sqlite3.Xsqlite3_result_int(tls, pCtx, *(*int32)(unsafe.Pointer(bp + 88 /* n */)))
		} else if int32(c) == 'd' && libc.Xstrcmp(tls, zType, ts+2562) == 0 {
			// var r float64 at bp+96, 8

			tcl.XTcl_GetDoubleFromObj(tls, uintptr(0), pVar, bp+96 /* &r */)
			sqlite3.Xsqlite3_result_double(tls, pCtx, *(*float64)(unsafe.Pointer(bp + 96 /* r */)))
		} else if int32(c) == 'w' && libc.Xstrcmp(tls, zType, ts+2569) == 0 || int32(c) == 'i' && libc.Xstrcmp(tls, zType, ts+2577) == 0 {
			// var v Tcl_WideInt at bp+104, 8

			tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), pVar, bp+104 /* &v */)
			sqlite3.Xsqlite3_result_int64(tls, pCtx, *(*Tcl_WideInt)(unsafe.Pointer(bp + 104 /* v */)))
		} else {
			var data uintptr = tcl.XTcl_GetStringFromObj(tls, pVar, bp+88 /* &n */)
			sqlite3.Xsqlite3_result_text(tls, pCtx, data, *(*int32)(unsafe.Pointer(bp + 88 /* n */)), libc.UintptrFromInt32(-1))
		}
	}
}

var iCmd2 sqlite3_int64 = int64(0) /* fts5_tcl.c:529:24 */

func xF5tDestroy(tls *libc.TLS, pCtx uintptr) { /* fts5_tcl.c:600:13: */
	var p uintptr = pCtx
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tFunction)(unsafe.Pointer(p)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, p)
}

//      sqlite3_fts5_create_function DB NAME SCRIPT
//
// Description...
func f5tCreateFunction(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:611:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zName uintptr
	var pScript uintptr
	*(*uintptr)(unsafe.Pointer(bp + 24 /* db */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 32 /* pApi */)) = uintptr(0)
	var pCtx uintptr = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2581 /* "DB NAME SCRIPT" */)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+24, bp+32) != 0 {
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*8))
	pCtx = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tFunction{})))
	(*F5tFunction)(unsafe.Pointer(pCtx)).Finterp = interp
	(*F5tFunction)(unsafe.Pointer(pCtx)).FpScript = pScript
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, fts5_extension_function, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* pApi */)))).FxCreateFunction})).f(tls,
		*(*uintptr)(unsafe.Pointer(bp + 32 /* pApi */)), zName, pCtx, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr)
		}{xF5tFunction})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{xF5tDestroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2153 /* "error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */))), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

type F5tTokenizeCtx1 = struct {
	FpRet        uintptr
	FbSubst      int32
	F__ccgo_pad1 [4]byte
	FzInput      uintptr
} /* fts5_tcl.c:648:9 */

type F5tTokenizeCtx = F5tTokenizeCtx1 /* fts5_tcl.c:648:31 */

func xTokenizeCb2(tls *libc.TLS, pCtx uintptr, tflags int32, zToken uintptr, nToken int32, iStart int32, iEnd int32) int32 { /* fts5_tcl.c:655:12: */
	var p uintptr = pCtx
	if (*F5tTokenizeCtx)(unsafe.Pointer(p)).FbSubst != 0 {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, zToken, nToken))
		tcl.XTcl_ListObjAppendElement(tls,
			uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, (*F5tTokenizeCtx)(unsafe.Pointer(p)).FzInput+uintptr(iStart), iEnd-iStart))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewStringObj(tls, zToken, nToken))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewIntObj(tls, iStart))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), (*F5tTokenizeCtx)(unsafe.Pointer(p)).FpRet, tcl.XTcl_NewIntObj(tls, iEnd))
	}
	return SQLITE_OK
}

//      sqlite3_fts5_tokenize DB TOKENIZER TEXT
//
// Description...
func f5tTokenize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:681:26: */
	bp := tls.Alloc(200)
	defer tls.Free(200)

	var zText uintptr
	// var nText int32 at bp+128, 4

	*(*uintptr)(unsafe.Pointer(bp + 96 /* db */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 104 /* pApi */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 168 /* pTok */)) = uintptr(0)
	// var tokenizer fts5_tokenizer at bp+144, 24

	var pRet uintptr = uintptr(0)
	// var pUserdata uintptr at bp+136, 8

	var rc int32
	// var nArg int32 at bp+112, 4

	// var azArg uintptr at bp+120, 8

	// var ctx F5tTokenizeCtx at bp+176, 24

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2596 /* "?-subst? DB NAME..." */)
		return TCL_ERROR
	}
	if objc == 5 {
		var zOpt uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
		if libc.Xstrcmp(tls, ts+2618, zOpt) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2625 /* "unrecognized opt..." */, zOpt, 0))
			return TCL_ERROR
		}
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*8)), bp+96, bp+104) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_SplitList(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*8))), bp+112, bp+120) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 112)) == 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+2647 /* "no such tokenize..." */, 0))
		tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(bp + 120 /* azArg */)))
		return TCL_ERROR
	}
	zText = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8)), bp+128 /* &nText */)

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 104 /* pApi */)))).FxFindTokenizer})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* pApi */)), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 120 /* azArg */)))), bp+136 /* &pUserdata */, bp+144 /* &tokenizer */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+2647 /* "no such tokenize..." */, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 120 /* azArg */)))), 0))
		return TCL_ERROR
	}

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_tokenizer)(unsafe.Pointer(bp + 144 /* &tokenizer */)).FxCreate})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 136 /* pUserdata */)), *(*uintptr)(unsafe.Pointer(bp + 120 /* azArg */))+1*8, *(*int32)(unsafe.Pointer(bp + 112 /* nArg */))-1, bp+168 /* &pTok */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, ts+2667 /* "error in tokeniz..." */, 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 176 /* &ctx */)).FbSubst = libc.Bool32(objc == 5)
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 176 /* &ctx */)).FpRet = pRet
	(*F5tTokenizeCtx)(unsafe.Pointer(bp + 176 /* &ctx */)).FzInput = zText
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_tokenizer)(unsafe.Pointer(bp + 144 /* &tokenizer */)).FxTokenize})).f(tls,
		*(*uintptr)(unsafe.Pointer(bp + 168 /* pTok */)), bp+176 /* &ctx */, FTS5_TOKENIZE_DOCUMENT, zText, *(*int32)(unsafe.Pointer(bp + 128 /* nText */)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
		}{xTokenizeCb2})))
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*fts5_tokenizer)(unsafe.Pointer(bp + 144 /* &tokenizer */)).FxDelete})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pTok */)))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+80, ts+2696 /* "error in tokeniz..." */, 0))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pRet
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		return TCL_ERROR
	}

	tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(bp + 120 /* azArg */)))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return TCL_OK
}

// ************************************************************************
//
// Start of tokenizer wrapper.

type F5tTokenizerContext1 = struct {
	FpCtx   uintptr
	FxToken uintptr
} /* fts5_tcl.c:761:9 */

// ************************************************************************
//
// Start of tokenizer wrapper.

type F5tTokenizerContext = F5tTokenizerContext1 /* fts5_tcl.c:761:36 */
type F5tTokenizerModule1 = struct {
	Finterp   uintptr
	FpScript  uintptr
	FpContext uintptr
} /* fts5_tcl.c:763:9 */

type F5tTokenizerModule = F5tTokenizerModule1 /* fts5_tcl.c:763:35 */
type F5tTokenizerInstance1 = struct {
	Finterp   uintptr
	FpScript  uintptr
	FpContext uintptr
} /* fts5_tcl.c:764:9 */

type F5tTokenizerInstance = F5tTokenizerInstance1 /* fts5_tcl.c:764:37 */

func f5tTokenizerCreate(tls *libc.TLS, pCtx uintptr, azArg uintptr, nArg int32, ppOut uintptr) int32 { /* fts5_tcl.c:783:12: */
	var pMod uintptr = pCtx
	var pEval uintptr
	var rc int32 = TCL_OK
	var i int32

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	for i = 0; rc == TCL_OK && i < nArg; i++ {
		var pObj uintptr = tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8)), -1)
		rc = tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp, pEval, pObj)
	}

	if rc == TCL_OK {
		rc = tcl.XTcl_EvalObjEx(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp, pEval, TCL_GLOBAL_ONLY)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	if rc == TCL_OK {
		var pInst uintptr
		pInst = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerInstance{})))
		libc.Xmemset(tls, pInst, 0, uint64(unsafe.Sizeof(F5tTokenizerInstance{})))
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript = tcl.XTcl_GetObjResult(tls, (*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp)
		(*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpContext
		(*Tcl_Obj)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript)).FrefCount++
		*(*uintptr)(unsafe.Pointer(ppOut)) = pInst
	}

	return rc
}

func f5tTokenizerDelete(tls *libc.TLS, p uintptr) { /* fts5_tcl.c:821:13: */
	var pInst uintptr = p
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pInst)
}

func f5tTokenizerTokenize(tls *libc.TLS, p uintptr, pCtx uintptr, flags int32, pText uintptr, nText int32, xToken uintptr) int32 { /* fts5_tcl.c:827:12: */
	var pInst uintptr = p
	var pOldCtx uintptr
	var xOldToken uintptr
	var pEval uintptr
	var rc int32
	var zFlags uintptr

	pOldCtx = (*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx
	xOldToken = (*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken

	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx = pCtx
	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken = xToken

	pEval = tcl.XTcl_DuplicateObj(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	switch flags {
	case FTS5_TOKENIZE_DOCUMENT:
		zFlags = ts + 2727 /* "document" */
		break
	case FTS5_TOKENIZE_AUX:
		zFlags = ts + 2736 /* "aux" */
		break
	case FTS5_TOKENIZE_QUERY:
		zFlags = ts + 2740 /* "query" */
		break
	case FTS5_TOKENIZE_PREFIX | FTS5_TOKENIZE_QUERY:
		zFlags = ts + 2746 /* "prefixquery" */
		break
	default:

		zFlags = ts + 2758 /* "invalid" */
		break
	}

	tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zFlags, -1))
	tcl.XTcl_ListObjAppendElement(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, pText, nText))
	rc = tcl.XTcl_EvalObjEx(tls, (*F5tTokenizerInstance)(unsafe.Pointer(pInst)).Finterp, pEval, TCL_GLOBAL_ONLY)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FpCtx = pOldCtx
	(*F5tTokenizerContext)(unsafe.Pointer((*F5tTokenizerInstance)(unsafe.Pointer(pInst)).FpContext)).FxToken = xOldToken
	return rc
}

// sqlite3_fts5_token ?-colocated? TEXT START END
func f5tTokenizerReturn(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:887:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var p uintptr
	// var iStart int32 at bp+24, 4

	// var iEnd int32 at bp+28, 4

	// var nToken int32 at bp+20, 4

	var tflags int32
	var zToken uintptr
	var rc int32
	// var nArg int32 at bp+16, 4

	var zArg uintptr
	p = clientData
	tflags = 0

	if !(objc == 5) {
		goto __1
	}
	zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16 /* &nArg */)
	if !(*(*int32)(unsafe.Pointer(bp + 16)) <= 10 && *(*int32)(unsafe.Pointer(bp + 16)) >= 2 && libc.Xmemcmp(tls, ts+2766, zArg, uint64(*(*int32)(unsafe.Pointer(bp + 16)))) == 0) {
		goto __3
	}
	tflags = tflags | FTS5_TOKEN_COLOCATED
	goto __4
__3:
	goto usage
__4:
	;
	goto __2
__1:
	if !(objc != 4) {
		goto __5
	}
	goto usage
__5:
	;
__2:
	;

	zToken = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*8)), bp+20 /* &nToken */)
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*8)), bp+24) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8)), bp+28) != 0) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	if !((*F5tTokenizerContext)(unsafe.Pointer(p)).FxToken == uintptr(0)) {
		goto __7
	}
	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp, ts+2777 /* "sqlite3_fts5_tok..." */, 0))
	return TCL_ERROR
__7:
	;

	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*F5tTokenizerContext)(unsafe.Pointer(p)).FxToken})).f(tls, (*F5tTokenizerContext)(unsafe.Pointer(p)).FpCtx, tflags, zToken, *(*int32)(unsafe.Pointer(bp + 20 /* nToken */)), *(*int32)(unsafe.Pointer(bp + 24 /* iStart */)), *(*int32)(unsafe.Pointer(bp + 28 /* iEnd */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	if rc == SQLITE_OK {
		return TCL_OK
	}
	return TCL_ERROR

usage:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2835 /* "?-colocated? TEX..." */)
	return TCL_ERROR
}

func f5tDelTokenizer(tls *libc.TLS, pCtx uintptr) { /* fts5_tcl.c:936:13: */
	var pMod uintptr = pCtx
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pMod)
}

//      sqlite3_fts5_create_tokenizer DB NAME SCRIPT
//
// Register a tokenizer named NAME implemented by script SCRIPT. When
// a tokenizer instance is created (fts5_tokenizer.xCreate), any tokenizer
// arguments are appended to SCRIPT and the result executed.
//
// The value returned by (SCRIPT + args) is itself a tcl script. This
// script - call it SCRIPT2 - is executed to tokenize text using the
// tokenizer instance "returned" by SCRIPT. Specifically, to tokenize
// text SCRIPT2 is invoked with a single argument appended to it - the
// text to tokenize.
//
// SCRIPT2 should invoke the [sqlite3_fts5_token] command once for each
// token within the tokenized text.
func f5tCreateTokenizer(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:958:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var pContext uintptr = clientData
	// var db uintptr at bp+16, 8

	// var pApi uintptr at bp+24, 8

	var zName uintptr
	var pScript uintptr
	// var t fts5_tokenizer at bp+32, 24

	var pMod uintptr
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2581 /* "DB NAME SCRIPT" */)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16, bp+24) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*8))

	(*fts5_tokenizer)(unsafe.Pointer(bp + 32 /* &t */)).FxCreate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{f5tTokenizerCreate}))
	(*fts5_tokenizer)(unsafe.Pointer(bp + 32 /* &t */)).FxTokenize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
	}{f5tTokenizerTokenize}))
	(*fts5_tokenizer)(unsafe.Pointer(bp + 32 /* &t */)).FxDelete = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{f5tTokenizerDelete}))

	pMod = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerModule{})))
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).Finterp = interp
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpScript = pScript
	(*F5tTokenizerModule)(unsafe.Pointer(pMod)).FpContext = pContext
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* pApi */)))).FxCreateTokenizer})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pApi */)), zName, pMod, bp+32 /* &t */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{f5tDelTokenizer})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2863 /* "error in fts5_ap..." */, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func xF5tFree(tls *libc.TLS, clientData ClientData) { /* fts5_tcl.c:1001:27: */
	tcl.XTcl_Free(tls, clientData)
}

//      sqlite3_fts5_may_be_corrupt BOOLEAN
//
// Set or clear the global "may-be-corrupt" flag. Return the old value.
func f5tMayBeCorrupt(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1010:26: */
	return TCL_OK
}

func f5t_fts5HashKey(tls *libc.TLS, nSlot int32, p uintptr, n int32) uint32 { /* fts5_tcl.c:1035:21: */
	var i int32
	var h uint32 = uint32(13)
	for i = n - 1; i >= 0; i-- {
		h = h<<3 ^ h ^ uint32(*(*int8)(unsafe.Pointer(p + uintptr(i))))
	}
	return h % uint32(nSlot)
}

func f5tTokenHash(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1044:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp+4, 4

	var iVal uint32
	// var nSlot int32 at bp, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2900 /* "NSLOT TOKEN" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	z = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &n */)

	iVal = f5t_fts5HashKey(tls, *(*int32)(unsafe.Pointer(bp /* nSlot */)), z, *(*int32)(unsafe.Pointer(bp + 4 /* n */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(iVal)))
	return TCL_OK
}

func f5tRegisterMatchinfo(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1069:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if f5tDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3Fts5TestRegisterMatchinfo(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

func f5tRegisterTok(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* fts5_tcl.c:1094:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 8 /* pApi */)) = uintptr(0)

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if f5tDbAndApi(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp, bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3Fts5TestRegisterTok(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*uintptr)(unsafe.Pointer(bp + 8 /* pApi */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Entry point.
func Fts5tcl_Init(tls *libc.TLS, interp uintptr) int32 { /* fts5_tcl.c:1123:5: */
	var i int32
	var pContext uintptr

	pContext = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(F5tTokenizerContext{})))
	libc.Xmemset(tls, pContext, 0, uint64(unsafe.Sizeof(F5tTokenizerContext{})))

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd))/uint64(unsafe.Sizeof(struct {
		FzName        uintptr
		FxProc        uintptr
		FbTokenizeCtx int32
		F__ccgo_pad1  [4]byte
	}{})); i++ {
		var p uintptr = uintptr(unsafe.Pointer(&aCmd)) + uintptr(i)*24
		var pCtx uintptr = uintptr(0)
		if (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
			F__ccgo_pad1  [4]byte
		})(unsafe.Pointer(p)).FbTokenizeCtx != 0 {
			pCtx = pContext
		}
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
			F__ccgo_pad1  [4]byte
		})(unsafe.Pointer(p)).FzName, (*struct {
			FzName        uintptr
			FxProc        uintptr
			FbTokenizeCtx int32
			F__ccgo_pad1  [4]byte
		})(unsafe.Pointer(p)).FxProc, pCtx, func() uintptr {
			if i != 0 {
				return uintptr(0)
			}
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{xF5tFree}))
		}())
	}

	return TCL_OK
}

var aCmd = [8]struct {
	FzName        uintptr
	FxProc        uintptr
	FbTokenizeCtx int32
	F__ccgo_pad1  [4]byte
}{
	{FzName: ts + 2912 /* "sqlite3_fts5_cre..." */, FxProc: 0, FbTokenizeCtx: 1},
	{FzName: ts + 2942 /* "sqlite3_fts5_tok..." */, FxProc: 0, FbTokenizeCtx: 1},
	{FzName: ts + 2961 /* "sqlite3_fts5_tok..." */, FxProc: 0},
	{FzName: ts + 2983 /* "sqlite3_fts5_cre..." */, FxProc: 0},
	{FzName: ts + 3012 /* "sqlite3_fts5_may..." */, FxProc: 0},
	{FzName: ts + 3040 /* "sqlite3_fts5_tok..." */, FxProc: 0},
	{FzName: ts + 3064 /* "sqlite3_fts5_reg..." */, FxProc: 0},
	{FzName: ts + 3096 /* "sqlite3_fts5_reg..." */, FxProc: 0},
} /* fts5_tcl.c:1128:5 */

type Fts5MatchinfoCtx1 = struct {
	FnCol        int32
	FnPhrase     int32
	FzArg        uintptr
	FnRet        int32
	F__ccgo_pad1 [4]byte
	FaRet        uintptr
} /* fts5_test_mi.c:50:9 */

type Fts5MatchinfoCtx = Fts5MatchinfoCtx1 /* fts5_test_mi.c:50:33 */

type u32 = uint32 /* fts5_test_mi.c:53:22 */

// Return a pointer to the fts5_api pointer for database connection db.
// If an error occurs, return NULL and leave an error in the database
// handle (accessible using sqlite3_errcode()/errmsg()).
func fts5_api_from_db(tls *libc.TLS, db uintptr, ppApi uintptr) int32 { /* fts5_test_mi.c:71:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
	var rc int32

	*(*uintptr)(unsafe.Pointer(ppApi)) = uintptr(0)
	rc = sqlite3.Xsqlite3_prepare(tls, db, ts+2137 /* "SELECT fts5(?1)" */, -1, bp /* &pStmt */, uintptr(0))
	if rc == SQLITE_OK {
		sqlite3.Xsqlite3_bind_pointer(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 1, ppApi, ts+2161 /* "fts5_api_ptr" */, uintptr(0))
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	}

	return rc
}

// Argument f should be a flag accepted by matchinfo() (a valid character
// in the string passed as the second argument). If it is not, -1 is
// returned. Otherwise, if f is a valid matchinfo flag, the value returned
// is the number of 32-bit integers added to the output array if the
// table has nCol columns and the query nPhrase phrases.
func fts5MatchinfoFlagsize(tls *libc.TLS, nCol int32, nPhrase int32, f int8) int32 { /* fts5_test_mi.c:94:12: */
	var ret int32 = -1
	switch int32(f) {
	case 'p':
		ret = 1
		break
	case 'c':
		ret = 1
		break
	case 'x':
		ret = 3 * nCol * nPhrase
		break
	case 'y':
		ret = nCol * nPhrase
		break
	case 'b':
		ret = (nCol + 31) / 32 * nPhrase
		break
	case 'n':
		ret = 1
		break
	case 'a':
		ret = nCol
		break
	case 'l':
		ret = nCol
		break
	case 's':
		ret = nCol
		break
	}
	return ret
}

func fts5MatchinfoIter(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, x uintptr) int32 { /* fts5_test_mi.c:110:12: */
	var i int32
	var n int32 = 0
	var rc int32 = SQLITE_OK
	var f int8
	for i = 0; libc.AssignInt8(&f, *(*int8)(unsafe.Pointer((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg + uintptr(i)))) != 0; i++ {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{x})).f(tls, pApi, pFts, p, f, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet+uintptr(n)*4)
		if rc != SQLITE_OK {
			break
		}
		n = n + fts5MatchinfoFlagsize(tls, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase, f)
	}
	return rc
}

func fts5MatchinfoXCb(tls *libc.TLS, pApi uintptr, pFts uintptr, pUserData uintptr) int32 { /* fts5_test_mi.c:128:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var iter Fts5PhraseIter at bp, 16

	// var iCol int32 at bp+16, 4

	// var iOff int32 at bp+20, 4

	var aOut uintptr = pUserData
	var iPrev int32 = -1

	for (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseFirst})).f(tls, pFts, 0, bp /* &iter */, bp+16 /* &iCol */, bp+20 /* &iOff */); *(*int32)(unsafe.Pointer(bp + 16 /* iCol */)) >= 0; (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseNext})).f(tls, pFts, bp /* &iter */, bp+16 /* &iCol */, bp+20 /* &iOff */) {
		*(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 16))*3+1)*4))++
		if *(*int32)(unsafe.Pointer(bp + 16)) != iPrev {
			*(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 16))*3+2)*4))++
		}
		iPrev = *(*int32)(unsafe.Pointer(bp + 16 /* iCol */))
	}

	return SQLITE_OK
}

func fts5MatchinfoGlobalCb(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, f int8, aOut uintptr) int32 { /* fts5_test_mi.c:150:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	switch int32(f) {
	case 'p':
		*(*u32)(unsafe.Pointer(aOut)) = u32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase)
		break

	case 'c':
		*(*u32)(unsafe.Pointer(aOut)) = u32((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol)
		break

	case 'x':
		{
			var i int32
			for i = 0; i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase && rc == SQLITE_OK; i++ {
				var pPtr uintptr = aOut + uintptr(i*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol*3)*4
				rc = (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxQueryPhrase})).f(tls, pFts, i, pPtr, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr) int32
				}{fts5MatchinfoXCb})))
			}
			break

		}

	case 'n':
		{
			// var nRow sqlite3_int64 at bp, 8

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxRowCount})).f(tls, pFts, bp /* &nRow */)
			*(*u32)(unsafe.Pointer(aOut)) = u32(*(*sqlite3_int64)(unsafe.Pointer(bp /* nRow */)))
			break

		}

	case 'a':
		{
			*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* nRow */)) = int64(0)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxRowCount})).f(tls, pFts, bp+8 /* &nRow */)
			if *(*sqlite3_int64)(unsafe.Pointer(bp + 8)) == int64(0) {
				libc.Xmemset(tls, aOut, 0, uint64(unsafe.Sizeof(u32(0)))*uint64((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol))
			} else {
				var i int32
				for i = 0; rc == SQLITE_OK && i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol; i++ {
					// var nToken sqlite3_int64 at bp+16, 8

					rc = (*struct {
						f func(*libc.TLS, uintptr, int32, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxColumnTotalSize})).f(tls, pFts, i, bp+16 /* &nToken */)
					if rc == SQLITE_OK {
						*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32((int64(2)**(*sqlite3_int64)(unsafe.Pointer(bp + 16)) + *(*sqlite3_int64)(unsafe.Pointer(bp + 8))) / (int64(2) * *(*sqlite3_int64)(unsafe.Pointer(bp + 8))))
					}
				}
			}
			break

		}

	}
	return rc
}

func fts5MatchinfoLocalCb(tls *libc.TLS, pApi uintptr, pFts uintptr, p uintptr, f int8, aOut uintptr) int32 { /* fts5_test_mi.c:205:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var i int32
	var rc int32 = SQLITE_OK

	switch int32(f) {
	case 'b':
		{
			var iPhrase int32
			var nInt int32 = ((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol + 31) / 32 * (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase
			for i = 0; i < nInt; i++ {
				*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32(0)
			}

			for iPhrase = 0; iPhrase < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; iPhrase++ {
				// var iter Fts5PhraseIter at bp, 16

				// var iCol int32 at bp+16, 4

				for (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseFirstColumn})).f(tls, pFts, iPhrase, bp /* &iter */, bp+16 /* &iCol */); *(*int32)(unsafe.Pointer(bp + 16 /* iCol */)) >= 0; (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseNextColumn})).f(tls, pFts, bp /* &iter */, bp+16 /* &iCol */) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(iPhrase*(((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol+31)/32)+*(*int32)(unsafe.Pointer(bp + 16))/32)*4)) |= u32(u32(1)) << (*(*int32)(unsafe.Pointer(bp + 16)) % 32)
				}
			}

			break

		}

	case 'x':
		fallthrough
	case 'y':
		{
			var nMul int32 = func() int32 {
				if int32(f) == 'x' {
					return 3
				}
				return 1
			}()
			var iPhrase int32

			for i = 0; i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; i++ {
				*(*u32)(unsafe.Pointer(aOut + uintptr(i*nMul)*4)) = u32(0)
			}

			for iPhrase = 0; iPhrase < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase; iPhrase++ {
				// var iter Fts5PhraseIter at bp+24, 16

				// var iOff int32 at bp+44, 4

				// var iCol int32 at bp+40, 4

				for (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseFirst})).f(tls, pFts, iPhrase, bp+24 /* &iter */, bp+40 /* &iCol */, bp+44 /* &iOff */); *(*int32)(unsafe.Pointer(bp + 44 /* iOff */)) >= 0; (*struct {
					f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseNext})).f(tls, pFts, bp+24 /* &iter */, bp+40 /* &iCol */, bp+44 /* &iOff */) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(nMul*(*(*int32)(unsafe.Pointer(bp + 40))+iPhrase*(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol))*4))++
				}
			}

			break

		}

	case 'l':
		{
			for i = 0; rc == SQLITE_OK && i < (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol; i++ {
				// var nToken int32 at bp+48, 4

				rc = (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxColumnSize})).f(tls, pFts, i, bp+48 /* &nToken */)
				*(*u32)(unsafe.Pointer(aOut + uintptr(i)*4)) = u32(*(*int32)(unsafe.Pointer(bp + 48 /* nToken */)))
			}
			break

		}

	case 's':
		{
			// var nInst int32 at bp+52, 4

			libc.Xmemset(tls, aOut, 0, uint64(unsafe.Sizeof(u32(0)))*uint64((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol))

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxInstCount})).f(tls, pFts, bp+52 /* &nInst */)
			for i = 0; rc == SQLITE_OK && i < *(*int32)(unsafe.Pointer(bp + 52 /* nInst */)); i++ {
				// var iPhrase int32 at bp+56, 4

				// var iOff int32 at bp+64, 4

				*(*int32)(unsafe.Pointer(bp + 60 /* iCol */)) = 0
				var iNextPhrase int32
				var iNextOff int32
				var nSeq u32 = u32(1)
				var j int32

				rc = (*struct {
					f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxInst})).f(tls, pFts, i, bp+56 /* &iPhrase */, bp+60 /* &iCol */, bp+64 /* &iOff */)
				iNextPhrase = *(*int32)(unsafe.Pointer(bp + 56)) + 1
				iNextOff = *(*int32)(unsafe.Pointer(bp + 64)) + (*struct {
					f func(*libc.TLS, uintptr, int32) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseSize})).f(tls, pFts, 0)
				for j = i + 1; rc == SQLITE_OK && j < *(*int32)(unsafe.Pointer(bp + 52 /* nInst */)); j++ {
					// var ip int32 at bp+68, 4

					// var ic int32 at bp+72, 4

					// var io int32 at bp+76, 4

					rc = (*struct {
						f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxInst})).f(tls, pFts, j, bp+68 /* &ip */, bp+72 /* &ic */, bp+76 /* &io */)
					if *(*int32)(unsafe.Pointer(bp + 72)) != *(*int32)(unsafe.Pointer(bp + 60)) || *(*int32)(unsafe.Pointer(bp + 76)) > iNextOff {
						break
					}
					if *(*int32)(unsafe.Pointer(bp + 68)) == iNextPhrase && *(*int32)(unsafe.Pointer(bp + 76)) == iNextOff {
						nSeq++
						iNextPhrase = *(*int32)(unsafe.Pointer(bp + 68)) + 1
						iNextOff = *(*int32)(unsafe.Pointer(bp + 76)) + (*struct {
							f func(*libc.TLS, uintptr, int32) int32
						})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseSize})).f(tls, pFts, *(*int32)(unsafe.Pointer(bp + 68)))
					}
				}

				if nSeq > *(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 60)))*4)) {
					*(*u32)(unsafe.Pointer(aOut + uintptr(*(*int32)(unsafe.Pointer(bp + 60 /* iCol */)))*4)) = nSeq
				}
			}

			break

		}
	}
	return rc
}

func fts5MatchinfoNew(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, zArg uintptr) uintptr { /* fts5_test_mi.c:301:25: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var nCol int32
	var nPhrase int32
	var i int32
	var nInt int32
	var nByte sqlite3_int64
	var rc int32

	nCol = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxColumnCount})).f(tls, pFts)
	nPhrase = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxPhraseCount})).f(tls, pFts)

	nInt = 0
	for i = 0; *(*int8)(unsafe.Pointer(zArg + uintptr(i))) != 0; i++ {
		var n int32 = fts5MatchinfoFlagsize(tls, nCol, nPhrase, *(*int8)(unsafe.Pointer(zArg + uintptr(i))))
		if n < 0 {
			var zErr uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+3131 /* "unrecognized mat..." */, libc.VaList(bp, int32(*(*int8)(unsafe.Pointer(zArg + uintptr(i))))))
			sqlite3.Xsqlite3_result_error(tls, pCtx, zErr, -1)
			sqlite3.Xsqlite3_free(tls, zErr)
			return uintptr(0)
		}
		nInt = nInt + n
	}

	nByte = sqlite3_int64(uint64(unsafe.Sizeof(Fts5MatchinfoCtx{})) +
		uint64(unsafe.Sizeof(u32(0)))*uint64(nInt) +
		uint64(i+1)) // The p->zArg string
	p = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if p == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return uintptr(0)
	}
	libc.Xmemset(tls, p, 0, uint64(nByte))

	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnCol = nCol
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnPhrase = nPhrase
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet = p + 1*32
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnRet = nInt
	(*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg = (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet + uintptr(nInt)*4
	libc.Xmemcpy(tls, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg, zArg, uint64(i))

	rc = fts5MatchinfoIter(tls, pApi, pFts, p, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
	}{fts5MatchinfoGlobalCb})))
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
		sqlite3.Xsqlite3_free(tls, p)
		p = uintptr(0)
	}

	return p
}

func fts5MatchinfoFunc(tls *libc.TLS, pApi uintptr, pFts uintptr, pCtx uintptr, nVal int32, apVal uintptr) { /* fts5_test_mi.c:357:13: */
	var zArg uintptr
	var p uintptr
	var rc int32 = SQLITE_OK

	if nVal > 0 {
		zArg = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	} else {
		zArg = ts + 3163 /* "pcx" */
	}

	p = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxGetAuxdata})).f(tls, pFts, 0)
	if p == uintptr(0) || sqlite3.Xsqlite3_stricmp(tls, zArg, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FzArg) != 0 {
		p = fts5MatchinfoNew(tls, pApi, pFts, pCtx, zArg)
		if p == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5ExtensionApi)(unsafe.Pointer(pApi)).FxSetAuxdata})).f(tls, pFts, p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}

	if rc == SQLITE_OK {
		rc = fts5MatchinfoIter(tls, pApi, pFts, p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int8, uintptr) int32
		}{fts5MatchinfoLocalCb})))
	}
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	} else {
		// No errors has occured, so return a copy of the array of integers.
		var nByte int32 = int32(uint64((*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FnRet) * uint64(unsafe.Sizeof(u32(0))))
		sqlite3.Xsqlite3_result_blob(tls, pCtx, (*Fts5MatchinfoCtx)(unsafe.Pointer(p)).FaRet, nByte, libc.UintptrFromInt32(-1))
	}
}

func sqlite3Fts5TestRegisterMatchinfo(tls *libc.TLS, db uintptr) int32 { /* fts5_test_mi.c:396:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 // Return code
	// var pApi uintptr at bp, 8
	// FTS5 API functions

	// Extract the FTS5 API pointer from the database handle. The
	// fts5_api_from_db() function above is copied verbatim from the
	// FTS5 documentation. Refer there for details.
	rc = fts5_api_from_db(tls, db, bp /* &pApi */)
	if rc != SQLITE_OK {
		return rc
	}

	/* If fts5_api_from_db() returns NULL, then either FTS5 is not registered
	 ** with this database handle, or an error (OOM perhaps?) has occurred.
	 **
	 ** Also check that the fts5_api object is version 2 or newer.
	 */
	if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) || (*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).FiVersion < 2 {
		return SQLITE_ERROR
	}

	// Register the implementation of matchinfo()
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, fts5_extension_function, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pApi */)))).FxCreateFunction})).f(tls, *(*uintptr)(unsafe.Pointer(bp /* pApi */)), ts+3167 /* "matchinfo" */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr)
	}{fts5MatchinfoFunc})), uintptr(0))

	return rc
}

type Fts5tokTable1 = struct {
	Fbase sqlite3_vtab
	Ftok  fts5_tokenizer
	FpTok uintptr
} /* fts5_test_tok.c:47:9 */

type Fts5tokTable = Fts5tokTable1 /* fts5_test_tok.c:47:29 */
type Fts5tokCursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiRowid      int32
	F__ccgo_pad1 [4]byte
	FzInput      uintptr
	FnRow        int32
	F__ccgo_pad2 [4]byte
	FaRow        uintptr
} /* fts5_test_tok.c:48:9 */

type Fts5tokCursor = Fts5tokCursor1 /* fts5_test_tok.c:48:30 */
type Fts5tokRow1 = struct {
	FzToken      uintptr
	FiStart      int32
	FiEnd        int32
	FiPos        int32
	F__ccgo_pad1 [4]byte
} /* fts5_test_tok.c:48:9 */

type Fts5tokRow = Fts5tokRow1 /* fts5_test_tok.c:49:27 */

func fts5tokDequote(tls *libc.TLS, z uintptr) { /* fts5_test_tok.c:81:13: */
	var q int8 = *(*int8)(unsafe.Pointer(z))

	if int32(q) == '[' || int32(q) == '\'' || int32(q) == '"' || int32(q) == '`' {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}

		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(q) {
					// Character iIn was the close quote.
					iIn++
					break
				} else {
					// Character iIn and iIn+1 form an escaped quote character. Skip
					// the input cursor past both and copy a single quote character
					// to the output buffer.
					iIn = iIn + 2
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
				}
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}

		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// The second argument, argv[], is an array of pointers to nul-terminated
// strings. This function makes a copy of the array and strings into a
// single block of memory. It then dequotes any of the strings that appear
// to be quoted.
//
// If successful, output parameter *pazDequote is set to point at the
// array of dequoted strings and SQLITE_OK is returned. The caller is
// responsible for eventually calling sqlite3_free() to free the array
// in this case. Or, if an error occurs, an SQLite error code is returned.
// The final value of *pazDequote is undefined in this case.
func fts5tokDequoteArray(tls *libc.TLS, argc int32, argv uintptr, pazDequote uintptr) int32 { /* fts5_test_tok.c:123:12: */
	var rc int32 = SQLITE_OK // Return code
	if argc == 0 {
		*(*uintptr)(unsafe.Pointer(pazDequote)) = uintptr(0)
	} else {
		var i int32
		var nByte int32 = 0
		var azDequote uintptr

		for i = 0; i < argc; i++ {
			nByte = nByte + int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))+uint64(1))
		}

		*(*uintptr)(unsafe.Pointer(pazDequote)) = libc.AssignUintptr(&azDequote, sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(uintptr(0)))*uint64(argc)+uint64(nByte))))
		if azDequote == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			var pSpace uintptr = azDequote + uintptr(argc)*8
			for i = 0; i < argc; i++ {
				var n int32 = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
				*(*uintptr)(unsafe.Pointer(azDequote + uintptr(i)*8)) = pSpace
				libc.Xmemcpy(tls, pSpace, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), uint64(n+1))
				fts5tokDequote(tls, pSpace)
				pSpace += uintptr(n + 1)
			}
		}
	}

	return rc
}

// Schema of the tokenizer table.

// This function does all the work for both the xConnect and xCreate methods.
// These tables have no persistent representation of their own, so xConnect
// and xCreate are identical operations.
//
//   argv[0]: module name
//   argv[1]: database name
//   argv[2]: table name
//   argv[3]: first argument (tokenizer name)
func fts5tokConnectMethod(tls *libc.TLS, db uintptr, pCtx uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fts5_test_tok.c:173:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pApi uintptr = pCtx
	var pTab uintptr = uintptr(0)
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp /* azDequote */)) = uintptr(0)
	var nDequote int32 = 0

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+3177 /* "CREATE TABLE x(i..." */)

	if rc == SQLITE_OK {
		nDequote = argc - 3
		rc = fts5tokDequoteArray(tls, nDequote, argv+3*8, bp /* &azDequote */)
	}

	if rc == SQLITE_OK {
		pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Fts5tokTable{})))
		if pTab == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pTab, 0, uint64(unsafe.Sizeof(Fts5tokTable{})))
		}
	}

	if rc == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(bp + 8 /* pTokCtx */)) = uintptr(0)
		var zModule uintptr = uintptr(0)
		if nDequote > 0 {
			zModule = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* azDequote */))))
		}

		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*fts5_api)(unsafe.Pointer(pApi)).FxFindTokenizer})).f(tls, pApi, zModule, bp+8 /* &pTokCtx */, pTab+24 /* &.tok */)
		if rc == SQLITE_OK {
			var azArg uintptr = func() uintptr {
				if nDequote > 1 {
					return *(*uintptr)(unsafe.Pointer(bp)) + 1*8
				}
				return uintptr(0)
			}()
			var nArg int32
			if nDequote > 0 {
				nArg = nDequote - 1
			} else {
				nArg = 0
			}
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5tokTable)(unsafe.Pointer(pTab)).Ftok.FxCreate})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pTokCtx */)), azArg, nArg, pTab+48 /* &.pTok */)
		}
	}

	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, pTab)
		pTab = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp /* azDequote */)))
	return rc
}

// This function does the work for both the xDisconnect and xDestroy methods.
// These tables have no persistent representation of their own, so xDisconnect
// and xDestroy are identical operations.
func fts5tokDisconnectMethod(tls *libc.TLS, pVtab uintptr) int32 { /* fts5_test_tok.c:235:12: */
	var pTab uintptr = pVtab
	if (*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Fts5tokTable)(unsafe.Pointer(pTab)).Ftok.FxDelete})).f(tls, (*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok)
	}
	sqlite3.Xsqlite3_free(tls, pTab)
	return SQLITE_OK
}

// xBestIndex - Analyze a WHERE and ORDER BY clause.
func fts5tokBestIndexMethod(tls *libc.TLS, pVTab uintptr, pInfo uintptr) int32 { /* fts5_test_tok.c:247:12: */
	var i int32

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pInfo)).FnConstraint; i++ {
		if (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).Fusable != 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraint+uintptr(i)*12)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FidxNum = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FestimatedCost = float64(1)
			return SQLITE_OK
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pInfo)).FidxNum = 0

	return SQLITE_OK
}

// xOpen - Open a cursor.
func fts5tokOpenMethod(tls *libc.TLS, pVTab uintptr, ppCsr uintptr) int32 { /* fts5_test_tok.c:275:12: */
	var pCsr uintptr

	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Fts5tokCursor{})))
	if pCsr == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint64(unsafe.Sizeof(Fts5tokCursor{})))

	*(*uintptr)(unsafe.Pointer(ppCsr)) = pCsr
	return SQLITE_OK
}

// Reset the tokenizer cursor passed as the only argument. As if it had
// just been returned by fts5tokOpenMethod().
func fts5tokResetCursor(tls *libc.TLS, pCsr uintptr) { /* fts5_test_tok.c:292:13: */
	var i int32
	for i = 0; i < (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow; i++ {
		sqlite3.Xsqlite3_free(tls, (*Fts5tokRow)(unsafe.Pointer((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow+uintptr(i)*24)).FzToken)
	}
	sqlite3.Xsqlite3_free(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput)
	sqlite3.Xsqlite3_free(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput = uintptr(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow = uintptr(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow = 0
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid = 0
}

// xClose - Close a cursor.
func fts5tokCloseMethod(tls *libc.TLS, pCursor uintptr) int32 { /* fts5_test_tok.c:308:12: */
	var pCsr uintptr = pCursor
	fts5tokResetCursor(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// xNext - Advance the cursor to the next row, if any.
func fts5tokNextMethod(tls *libc.TLS, pCursor uintptr) int32 { /* fts5_test_tok.c:318:12: */
	var pCsr uintptr = pCursor
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid++
	return SQLITE_OK
}

func fts5tokCb(tls *libc.TLS, pCtx uintptr, tflags int32, pToken uintptr, nToken int32, iStart int32, iEnd int32) int32 { /* fts5_test_tok.c:324:12: */
	var pCsr uintptr = pCtx
	var pRow uintptr

	if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow&((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow-1) == 0 {
		var nNew int32
		if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow != 0 {
			nNew = (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow * 2
		} else {
			nNew = 32
		}
		var aNew uintptr
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow, uint64(uint64(nNew)*uint64(unsafe.Sizeof(Fts5tokRow{}))))
		if aNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, aNew+uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)*24, 0, uint64(unsafe.Sizeof(Fts5tokRow{}))*uint64(nNew-(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow))
		(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow = aNew
	}

	pRow = (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow + uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)*24
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FiStart = iStart
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FiEnd = iEnd
	if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow != 0 {
		(*Fts5tokRow)(unsafe.Pointer(pRow)).FiPos = (*Fts5tokRow)(unsafe.Pointer(pRow+libc.UintptrFromInt32(-1)*24)).FiPos + func() int32 {
			if tflags&FTS5_TOKEN_COLOCATED != 0 {
				return 0
			}
			return 1
		}()
	}
	(*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken = sqlite3.Xsqlite3_malloc(tls, nToken+1)
	if (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemcpy(tls, (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken, pToken, uint64(nToken))
	*(*int8)(unsafe.Pointer((*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken + uintptr(nToken))) = int8(0)
	(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow++

	return SQLITE_OK
}

// xFilter - Initialize a cursor to point at the start of its data.
func fts5tokFilterMethod(tls *libc.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, nVal int32, apVal uintptr) int32 { /* fts5_test_tok.c:362:12: */
	var rc int32 = SQLITE_ERROR
	var pCsr uintptr = pCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab

	fts5tokResetCursor(tls, pCsr)
	if idxNum == 1 {
		var zByte uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
		var nByte int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))
		(*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput = sqlite3.Xsqlite3_malloc(tls, nByte+1)
		if (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			if nByte > 0 {
				libc.Xmemcpy(tls, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput, zByte, uint64(nByte))
			}
			*(*int8)(unsafe.Pointer((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput + uintptr(nByte))) = int8(0)
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*Fts5tokTable)(unsafe.Pointer(pTab)).Ftok.FxTokenize})).f(tls,
				(*Fts5tokTable)(unsafe.Pointer(pTab)).FpTok, pCsr, 0, zByte, nByte, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, int32, int32) int32
				}{fts5tokCb})))
		}
	}

	if rc != SQLITE_OK {
		return rc
	}
	return fts5tokNextMethod(tls, pCursor)
}

// xEof - Return true if the cursor is at EOF, or false otherwise.
func fts5tokEofMethod(tls *libc.TLS, pCursor uintptr) int32 { /* fts5_test_tok.c:396:12: */
	var pCsr uintptr = pCursor
	return libc.Bool32((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid > (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FnRow)
}

// xColumn - Return a column value.
func fts5tokColumnMethod(tls *libc.TLS, pCursor uintptr, pCtx uintptr, iCol int32) int32 { /* fts5_test_tok.c:404:12: */
	var pCsr uintptr = pCursor
	var pRow uintptr = (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FaRow + uintptr((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid-1)*24

	// CREATE TABLE x(input, token, start, end, position)
	switch iCol {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*Fts5tokCursor)(unsafe.Pointer(pCsr)).FzInput, -1, libc.UintptrFromInt32(-1))
		break
	case 1:
		sqlite3.Xsqlite3_result_text(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FzToken, -1, libc.UintptrFromInt32(-1))
		break
	case 2:
		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiStart)
		break
	case 3:
		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiEnd)
		break
	default:

		sqlite3.Xsqlite3_result_int(tls, pCtx, (*Fts5tokRow)(unsafe.Pointer(pRow)).FiPos)
		break
	}
	return SQLITE_OK
}

// xRowid - Return the current rowid for the cursor.
func fts5tokRowidMethod(tls *libc.TLS, pCursor uintptr, pRowid uintptr) int32 { /* fts5_test_tok.c:437:12: */
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3_int64((*Fts5tokCursor)(unsafe.Pointer(pCsr)).FiRowid)
	return SQLITE_OK
}

// Register the fts5tok module with database connection db. Return SQLITE_OK
// if successful or an error code if sqlite3_create_module() fails.
func sqlite3Fts5TestRegisterTok(tls *libc.TLS, db uintptr, pApi uintptr) int32 { /* fts5_test_tok.c:450:5: */
	var rc int32 // Return code

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3235 /* "fts5tokenize" */, uintptr(unsafe.Pointer(&fts5tok_module)), pApi)
	return rc
}

var fts5tok_module = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen
	FxClose:      0, // xClose
	FxFilter:     0, // xFilter
	FxNext:       0, // xNext
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn
	FxRowid:      0, // xShadowName
} /* fts5_test_tok.c:451:31 */

// CAPI3REF: Loadable Extension Thunk
//
// A pointer to the opaque sqlite3_api_routines structure is passed as
// the third parameter to entry points of [loadable extensions].  This
// structure must be typedefed in order to work around compiler warnings
// on some platforms.
type sqlite3_api_routines = sqlite3_api_routines1 /* sqlite3.h:1254:37 */

// This is the function signature used for all extension entry points.  It
// is also defined in the file "loadext.c".
type sqlite3_loadext_entry = uintptr /* sqlite3ext.h:353:13 */

// The append mark at the end of the database is:
//
//     Start-Of-SQLite3-NNNNNNNN
//     123456789 123456789 12345
//
// The NNNNNNNN represents a 64-bit big-endian unsigned integer which is
// the offset to page 1, and also the length of the prefix content.

// Maximum size of the combined prefix + database + append-mark.  This
// must be less than 0x40000000 to avoid locking issues on Windows.

// Try to align the database to an even multiple of APND_ROUNDUP bytes.

// Forward declaration of objects used by this utility
type ApndVfs = sqlite3_vfs1 /* appendvfs.c:85:28 */
type ApndFile1 = struct {
	Fbase   sqlite3_file
	FiPgOne sqlite3_int64
	FiMark  sqlite3_int64
} /* appendvfs.c:86:9 */

type ApndFile = ApndFile1 /* appendvfs.c:86:25 */

var apnd_vfs = sqlite3_vfs{
	FiVersion:          3,         // szOsFile (set when registered)
	FmxPathname:        1024,      // pNext
	FzName:             ts + 3248, /* "apndvfs" */ /* pAppData (set when registered) */
	FxOpen:             0,         // xOpen
	FxDelete:           0,         // xDelete
	FxAccess:           0,         // xAccess
	FxFullPathname:     0,         // xFullPathname
	FxDlOpen:           0,         // xDlOpen
	FxDlError:          0,         // xDlError
	FxDlSym:            0,         // xDlSym
	FxDlClose:          0,         // xDlClose
	FxRandomness:       0,         // xRandomness
	FxSleep:            0,         // xSleep
	FxCurrentTime:      0,         // xCurrentTime
	FxGetLastError:     0,         // xGetLastError
	FxCurrentTimeInt64: 0,         // xCurrentTimeInt64
	FxSetSystemCall:    0,         // xSetSystemCall
	FxGetSystemCall:    0,         // xGetSystemCall
	FxNextSystemCall:   0,         // xNextSystemCall
} /* appendvfs.c:177:20 */

var apnd_io_methods = sqlite3_io_methods{
	FiVersion:               3, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
	FxFetch:                 0, // xFetch
	FxUnfetch:               0, // xUnfetch
} /* appendvfs.c:202:33 */

// Close an apnd-file.
func apndClose(tls *libc.TLS, pFile uintptr) int32 { /* appendvfs.c:227:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxClose})).f(tls, pFile)
}

// Read data from an apnd-file.
func apndRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* appendvfs.c:235:12: */
	var paf uintptr = pFile
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, zBuf, iAmt, (*ApndFile)(unsafe.Pointer(paf)).FiPgOne+iOfst)
}

// Add the append-mark onto what should become the end of the file.
//  If and only if this succeeds, internal ApndFile.iMark is updated.
//  Parameter iWriteEnd is the appendvfs-relative offset of the new mark.
func apndWriteMark(tls *libc.TLS, paf uintptr, pFile uintptr, iWriteEnd sqlite_int64) int32 { /* appendvfs.c:251:12: */
	bp := tls.Alloc(25)
	defer tls.Free(25)

	var iPgOne sqlite_int64 = (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
	// var a [25]uint8 at bp, 25

	var i int32 = APND_MARK_FOS_SZ
	var rc int32

	libc.Xmemcpy(tls, bp /* &a[0] */, ts+3256 /* "Start-Of-SQLite3..." */, uint64(APND_MARK_PREFIX_SZ))
	for libc.PreDecInt32(&i, 1) >= 0 {
		*(*uint8)(unsafe.Pointer(bp /* &a[0] */ + uintptr(APND_MARK_PREFIX_SZ+i))) = uint8(iPgOne & int64(0xff))
		iPgOne >>= 8
	}
	iWriteEnd = iWriteEnd + (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
	if SQLITE_OK == libc.AssignInt32(&rc, (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxWrite})).f(tls, pFile, bp, APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ, iWriteEnd)) {
		(*ApndFile)(unsafe.Pointer(paf)).FiMark = iWriteEnd
	}
	return rc
}

// Write data to an apnd-file.
func apndWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* appendvfs.c:277:12: */
	var paf uintptr = pFile
	var iWriteEnd sqlite_int64 = iOfst + sqlite_int64(iAmt)
	if iWriteEnd >= int64(0x40000000) {
		return SQLITE_FULL
	}
	pFile = pFile + uintptr(1)*24
	// If append-mark is absent or will be overwritten, write it.
	if (*ApndFile)(unsafe.Pointer(paf)).FiMark < int64(0) || (*ApndFile)(unsafe.Pointer(paf)).FiPgOne+iWriteEnd > (*ApndFile)(unsafe.Pointer(paf)).FiMark {
		var rc int32 = apndWriteMark(tls, paf, pFile, iWriteEnd)
		if SQLITE_OK != rc {
			return rc
		}
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxWrite})).f(tls, pFile, zBuf, iAmt, (*ApndFile)(unsafe.Pointer(paf)).FiPgOne+iOfst)
}

// Truncate an apnd-file.
func apndTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* appendvfs.c:298:12: */
	var paf uintptr = pFile
	pFile = pFile + uintptr(1)*24
	// The append mark goes out first so truncate failure does not lose it.
	if SQLITE_OK != apndWriteMark(tls, paf, pFile, size) {
		return SQLITE_IOERR
	}
	// Truncate underlying file just past append mark
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxTruncate})).f(tls, pFile, (*ApndFile)(unsafe.Pointer(paf)).FiMark+int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ))
}

// Sync an apnd-file.
func apndSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* appendvfs.c:310:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSync})).f(tls, pFile, flags)
}

// Return the current file-size of an apnd-file.
// If the append mark is not yet there, the file-size is 0.
func apndFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* appendvfs.c:319:12: */
	var paf uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = func() int64 {
		if (*ApndFile)(unsafe.Pointer(paf)).FiMark >= int64(0) {
			return (*ApndFile)(unsafe.Pointer(paf)).FiMark - (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
		}
		return int64(0)
	}()
	return SQLITE_OK
}

// Lock an apnd-file.
func apndLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* appendvfs.c:328:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxLock})).f(tls, pFile, eLock)
}

// Unlock an apnd-file.
func apndUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* appendvfs.c:336:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnlock})).f(tls, pFile, eLock)
}

// Check if another file-handle holds a RESERVED lock on an apnd-file.
func apndCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* appendvfs.c:344:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxCheckReservedLock})).f(tls, pFile, pResOut)
}

// File control method. For custom operations on an apnd-file.
func apndFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* appendvfs.c:352:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var paf uintptr = pFile
	var rc int32
	pFile = pFile + uintptr(1)*24
	if op == SQLITE_FCNTL_SIZE_HINT {
		*(*sqlite3_int64)(unsafe.Pointer(pArg)) += (*ApndFile)(unsafe.Pointer(paf)).FiPgOne
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFileControl})).f(tls, pFile, op, pArg)
	if rc == SQLITE_OK && op == SQLITE_FCNTL_VFSNAME {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+3274 /* "apnd(%lld)/%z" */, libc.VaList(bp, (*ApndFile)(unsafe.Pointer(paf)).FiPgOne, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Return the sector-size in bytes for an apnd-file.
func apndSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* appendvfs.c:367:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSectorSize})).f(tls, pFile)
}

// Return the device characteristic flags supported by an apnd-file.
func apndDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* appendvfs.c:375:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxDeviceCharacteristics})).f(tls, pFile)
}

// Create a shared memory file mapping
func apndShmMap(tls *libc.TLS, pFile uintptr, iPg int32, pgsz int32, bExtend int32, pp uintptr) int32 { /* appendvfs.c:381:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmMap})).f(tls, pFile, iPg, pgsz, bExtend, pp)
}

// Perform locking on a shared-memory segment
func apndShmLock(tls *libc.TLS, pFile uintptr, offset int32, n int32, flags int32) int32 { /* appendvfs.c:393:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmLock})).f(tls, pFile, offset, n, flags)
}

// Memory barrier operation on shared memory
func apndShmBarrier(tls *libc.TLS, pFile uintptr) { /* appendvfs.c:399:13: */
	pFile = pFile + uintptr(1)*24
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmBarrier})).f(tls, pFile)
}

// Unmap a shared memory segment
func apndShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* appendvfs.c:405:12: */
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmUnmap})).f(tls, pFile, deleteFlag)
}

// Fetch a page of a memory-mapped file
func apndFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 { /* appendvfs.c:411:12: */
	var p uintptr = pFile
	if (*ApndFile)(unsafe.Pointer(p)).FiMark < int64(0) || iOfst+sqlite3_int64(iAmt) > (*ApndFile)(unsafe.Pointer(p)).FiMark {
		return SQLITE_IOERR // Cannot read what is not yet there.
	}
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFetch})).f(tls, pFile, iOfst+(*ApndFile)(unsafe.Pointer(p)).FiPgOne, iAmt, pp)
}

// Release a memory-mapped page
func apndUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, pPage uintptr) int32 { /* appendvfs.c:426:12: */
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*24
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnfetch})).f(tls, pFile, iOfst+(*ApndFile)(unsafe.Pointer(p)).FiPgOne, pPage)
}

// Try to read the append-mark off the end of a file.  Return the
// start of the appended database if the append-mark is present.
// If there is no valid append-mark, return -1;
//
// An append-mark is only valid if the NNNNNNNN start-of-database offset
// indicates that the appended database contains at least one page.  The
// start-of-database value must be a multiple of 512.
func apndReadMark(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) sqlite3_int64 { /* appendvfs.c:441:22: */
	bp := tls.Alloc(25)
	defer tls.Free(25)

	var rc int32
	var i int32
	var iMark sqlite3_int64
	var msbs int32 = 8 * (APND_MARK_FOS_SZ - 1)
	// var a [25]uint8 at bp, 25

	if int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ) != sz&int64(0x1ff) {
		return int64(-1)
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, bp /* &a[0] */, APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ, sz-int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ))
	if rc != 0 {
		return int64(-1)
	}
	if libc.Xmemcmp(tls, bp, ts+3256, uint64(APND_MARK_PREFIX_SZ)) != 0 {
		return int64(-1)
	}
	iMark = sqlite3_int64(int32(*(*uint8)(unsafe.Pointer(bp + 17)))&0x7f) << msbs
	for i = 1; i < 8; i++ {
		msbs = msbs - 8
		iMark = iMark | sqlite3_int64(*(*uint8)(unsafe.Pointer(bp + uintptr(APND_MARK_PREFIX_SZ+i))))<<msbs
	}
	if iMark > sz-int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ)-int64(512) {
		return int64(-1)
	}
	if iMark&int64(0x1ff) != 0 {
		return int64(-1)
	}
	return iMark
}

var apvfsSqliteHdr = *(*[16]int8)(unsafe.Pointer(ts + 3288 /* "SQLite format 3" */)) /* appendvfs.c:461:19 */

// Check to see if the file is an appendvfs SQLite database file.
// Return true iff it is such. Parameter sz is the file's size.
func apndIsAppendvfsDatabase(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) int32 { /* appendvfs.c:466:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var zHdr [16]int8 at bp, 16

	var iMark sqlite3_int64 = apndReadMark(tls, sz, pFile)
	if iMark >= int64(0) {
		// If file has the correct end-marker, the expected odd size, and the
		// SQLite DB type marker where the end-marker puts it, then it
		// is an appendvfs database.
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, bp /* &zHdr[0] */, int32(unsafe.Sizeof([16]int8{})), iMark)
		if SQLITE_OK == rc &&
			libc.Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&apvfsSqliteHdr)), uint64(unsafe.Sizeof([16]int8{}))) == 0 &&
			sz&int64(0x1ff) == int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ) &&
			sz >= int64(512+(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ)) {
			return 1 // It's an appendvfs database
		}
	}
	return 0
}

// Check to see if the file is an ordinary SQLite database file.
// Return true iff so. Parameter sz is the file's size.
func apndIsOrdinaryDatabaseFile(tls *libc.TLS, sz sqlite3_int64, pFile uintptr) int32 { /* appendvfs.c:491:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var zHdr [16]int8 at bp, 16

	if apndIsAppendvfsDatabase(tls, sz, pFile) != 0 ||
		sz&int64(0x1ff) != int64(0) ||
		SQLITE_OK != (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, bp, int32(unsafe.Sizeof([16]int8{})), int64(0)) ||
		libc.Xmemcmp(tls, bp, uintptr(unsafe.Pointer(&apvfsSqliteHdr)), uint64(unsafe.Sizeof([16]int8{}))) != 0 {
		return 0
	} else {
		return 1
	}
	return int32(0)
}

// Open an apnd file handle.
func apndOpen(tls *libc.TLS, pApndVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* appendvfs.c:507:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pApndFile uintptr = pFile
	var pBaseFile uintptr = pFile + uintptr(1)*24
	var pBaseVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pApndVfs)).FpAppData
	var rc int32
	*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) = int64(0)
	if flags&SQLITE_OPEN_MAIN_DB == 0 {
		// The appendvfs is not to be used for transient or temporary databases.
		// Just use the base VFS open to initialize the given file object and
		// open the underlying file. (Appendvfs is then unused for this file.)
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pBaseVfs)).FxOpen})).f(tls, pBaseVfs, zName, pFile, flags, pOutFlags)
	}
	libc.Xmemset(tls, pApndFile, 0, uint64(unsafe.Sizeof(ApndFile{})))
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&apnd_io_methods))
	(*ApndFile)(unsafe.Pointer(pApndFile)).FiMark = int64(-1) // Append mark not yet written

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pBaseVfs)).FxOpen})).f(tls, pBaseVfs, zName, pBaseFile, flags, pOutFlags)
	if rc == SQLITE_OK {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods)).FxFileSize})).f(tls, pBaseFile, bp /* &sz */)
		if rc != 0 {
			(*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods)).FxClose})).f(tls, pBaseFile)
		}
	}
	if rc != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
		return rc
	}
	if apndIsOrdinaryDatabaseFile(tls, *(*sqlite3_int64)(unsafe.Pointer(bp)), pBaseFile) != 0 {
		// The file being opened appears to be just an ordinary DB. Copy
		// the base dispatch-table so this instance mimics the base VFS.
		libc.Xmemmove(tls, pApndFile, pBaseFile, uint64((*sqlite3_vfs)(unsafe.Pointer(pBaseVfs)).FszOsFile))
		return SQLITE_OK
	}
	(*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne = apndReadMark(tls, *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)), pFile)
	if (*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne >= int64(0) {
		(*ApndFile)(unsafe.Pointer(pApndFile)).FiMark = *(*sqlite3_int64)(unsafe.Pointer(bp)) - int64(APND_MARK_PREFIX_SZ+APND_MARK_FOS_SZ) // Append mark found
		return SQLITE_OK
	}
	if flags&SQLITE_OPEN_CREATE == 0 {
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pBaseFile)).FpMethods)).FxClose})).f(tls, pBaseFile)
		rc = SQLITE_CANTOPEN
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
	} else {
		// Round newly added appendvfs location to #define'd page boundary.
		// Note that nothing has yet been written to the underlying file.
		// The append mark will be written along with first content write.
		// Until then, paf->iMark value indicates it is not yet written.
		(*ApndFile)(unsafe.Pointer(pApndFile)).FiPgOne = (*(*sqlite3_int64)(unsafe.Pointer(bp)) + int64(APND_ROUNDUP-1)) & libc.CplInt64(int64(APND_ROUNDUP-1))
	}
	return rc
}

// Delete an apnd file.
// For an appendvfs, this could mean delete the appendvfs portion,
// leaving the appendee as it was before it gained an appendvfs.
// For now, this code deletes the underlying file too.
func apndDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* appendvfs.c:574:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDelete})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, dirSync)
}

// All other VFS methods are pass-thrus.
func apndAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* appendvfs.c:581:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxAccess})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, flags, pResOut)
}

func apndFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* appendvfs.c:589:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxFullPathname})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, nOut, zOut)
}

func apndDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* appendvfs.c:597:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlOpen})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath)
}

func apndDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* appendvfs.c:600:13: */
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zErrMsg)
}

func apndDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* appendvfs.c:603:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlSym})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p, zSym)
}

func apndDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* appendvfs.c:606:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlClose})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pHandle)
}

func apndRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* appendvfs.c:609:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxRandomness})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zBufOut)
}

func apndSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* appendvfs.c:612:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSleep})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nMicro)
}

func apndCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* appendvfs.c:615:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxCurrentTime})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pTimeOut)
}

func apndGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* appendvfs.c:618:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetLastError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, a, b)
}

func apndCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 { /* appendvfs.c:621:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxCurrentTimeInt64})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p)
}

func apndSetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr, pCall sqlite3_syscall_ptr) int32 { /* appendvfs.c:624:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName, pCall)
}

func apndGetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) sqlite3_syscall_ptr { /* appendvfs.c:631:28: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func apndNextSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) uintptr { /* appendvfs.c:637:19: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxNextSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

// This routine is called when the extension is loaded.
// Register the new VFS.
func sqlite3_appendvfs_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* appendvfs.c:649:5: */
	var rc int32 = SQLITE_OK
	var pOrig uintptr
	_ = pApi

	_ = pzErrMsg
	_ = db
	pOrig = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if pOrig == uintptr(0) {
		return SQLITE_ERROR
	}
	apnd_vfs.FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FiVersion
	apnd_vfs.FpAppData = pOrig
	apnd_vfs.FszOsFile = int32(uint64((*sqlite3_vfs)(unsafe.Pointer(pOrig)).FszOsFile) + uint64(unsafe.Sizeof(ApndFile{})))
	rc = sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&apnd_vfs)), 0)
	if rc == SQLITE_OK {
		rc = SQLITE_OK | int32(1)<<8
	}
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2003 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type rune_t = int32 /* stdlib.h:46:18 */

type div_t = struct {
	Fquot int32
	Frem  int32
} /* stdlib.h:66:3 */

type ldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:71:3 */

// Functions added in C99 which we make conditionally available in the
// BSD^C89 namespace if the compiler supports `long long'.
// The #if test is more complicated than it ought to be because
// __BSD_VISIBLE implies __ISO_C_VISIBLE == 1999 *even if* `long long'
// is not supported in the compilation environment (which therefore means
// that it can't really be ISO C99).
//
// (The only other extension made by C99 in thie header is _Exit().)
// LONGLONG
type lldiv_t = struct {
	Fquot int64
	Frem  int64
} /* stdlib.h:142:3 */

// K.3.6
type constraint_handler_t = uintptr /* stdlib.h:349:14 */

// Use inline functions if we are allowed to and the compiler supports them.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Paul Borman at Krystal Technologies.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)runetype.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// The lower 8 bits of runetype[] contain the digit value of the rune.
type _RuneEntry = struct {
	F__min       int32
	F__max       int32
	F__map       int32
	F__ccgo_pad1 [4]byte
	F__types     uintptr
} /* runetype.h:55:3 */

type _RuneRange = struct {
	F__nranges   int32
	F__ccgo_pad1 [4]byte
	F__ranges    uintptr
} /* runetype.h:60:3 */

type _RuneLocale = struct {
	F__magic        [8]int8
	F__encoding     [32]int8
	F__sgetrune     uintptr
	F__sputrune     uintptr
	F__invalid_rune int32
	F__ccgo_pad1    [4]byte
	F__runetype     [256]uint64
	F__maplower     [256]int32
	F__mapupper     [256]int32
	F__runetype_ext _RuneRange
	F__maplower_ext _RuneRange
	F__mapupper_ext _RuneRange
	F__variable     uintptr
	F__variable_len int32
	F__ccgo_pad2    [4]byte
} /* runetype.h:85:3 */

func __getCurrentRuneLocale(tls *libc.TLS) uintptr { /* runetype.h:95:35: */

	if libc.X_ThreadRuneLocale != 0 {
		return libc.X_ThreadRuneLocale
	}
	return libc.X_CurrentRuneLocale
}

func __maskrune(tls *libc.TLS, _c int32, _f uint64) int32 { /* _ctype.h:100:1: */
	return int32(func() uint64 {
		if _c < 0 || _c >= int32(1)<<8 {
			return libc.X___runetype(tls, _c)
		}
		return *(*uint64)(unsafe.Pointer(__getCurrentRuneLocale(tls) + 64 + uintptr(_c)*8))
	}() & _f)
}

func __sbmaskrune(tls *libc.TLS, _c int32, _f uint64) int32 { /* _ctype.h:107:1: */
	if _c < 0 || _c >= libc.X__mb_sb_limit {
		return 0
	}
	return int32(*(*uint64)(unsafe.Pointer(__getCurrentRuneLocale(tls) + 64 + uintptr(_c)*8)) & _f)
}

func __sbistype(tls *libc.TLS, _c int32, _f uint64) int32 { /* _ctype.h:120:1: */
	return libc.BoolInt32(!!(__sbmaskrune(tls, _c, _f) != 0))
}

func __sbmaskrune_l(tls *libc.TLS, __c int32, __f uint64, __loc locale_t) int32 { /* _ctype.h:104:1: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __limit int32 at bp, 4

	var runes uintptr = libc.X__runes_for_locale(tls, __loc, bp /* &__limit */)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return 0
	}
	return int32(*(*uint64)(unsafe.Pointer(runes + 64 + uintptr(__c)*8)) & __f)
}

func __sbistype_l(tls *libc.TLS, __c int32, __f uint64, __loc locale_t) int32 { /* _ctype.h:113:1: */
	return libc.BoolInt32(!!(tcl.X__sbmaskrune_l(tls, __c, __f, __loc) != 0))
}

func isalnum_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:124:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_A|X_CTYPE_D|X_CTYPE_N), __l)
}

func isalpha_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:125:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_A), __l)
}

func isblank_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:126:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_B), __l)
}

func iscntrl_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:127:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_C), __l)
}

func isdigit_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:128:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_D), __l)
}

func isgraph_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:129:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_G), __l)
}

func ishexnumber_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:130:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_X), __l)
}

func isideogram_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:131:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_I), __l)
}

func islower_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:132:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_L), __l)
}

func isnumber_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:133:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_D|X_CTYPE_N), __l)
}

func isphonogram_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:134:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_Q), __l)
}

func isprint_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:135:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_R), __l)
}

func ispunct_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:136:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_P), __l)
}

func isrune_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:137:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(0xFFFFFF00), __l)
}

func isspace_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:138:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_S), __l)
}

func isspecial_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:139:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_T), __l)
}

func isupper_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:140:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_U), __l)
}

func isxdigit_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:141:1: */
	return tcl.X__sbistype_l(tls, __c, uint64(X_CTYPE_X), __l)
}

func digittoint_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:186:21: */
	return tcl.X__sbmaskrune_l(tls, __c, uint64(0xFF), __l)
}

func tolower_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:189:21: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __limit int32 at bp, 4

	var __runes uintptr = libc.X__runes_for_locale(tls, __l, bp /* &__limit */)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return __c
	}
	return *(*int32)(unsafe.Pointer(__runes + 2112 + uintptr(__c)*4))
}

func toupper_l(tls *libc.TLS, __c int32, __l locale_t) int32 { /* _ctype.h:196:21: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var __limit int32 at bp, 4

	var __runes uintptr = libc.X__runes_for_locale(tls, __l, bp /* &__limit */)
	if __c < 0 || __c >= *(*int32)(unsafe.Pointer(bp)) {
		return __c
	}
	return *(*int32)(unsafe.Pointer(__runes + 3136 + uintptr(__c)*4))
}

// POSIX.1-2001 specifies _tolower() and _toupper() to be macros equivalent to
// tolower() and toupper() respectively, minus extra checking to ensure that
// the argument is a lower or uppercase letter respectively.  We've chosen to
// implement these macros with the same error checking as tolower() and
// toupper() since this doesn't violate the specification itself, only its
// intent.  We purposely leave _tolower() and _toupper() undocumented to
// discourage their use.
//
// XXX isascii() and toascii() should similarly be undocumented.

// Forward declaration of objects used by this implementation
type amatch_vtab1 = struct {
	Fbase        sqlite3_vtab
	FzClassName  uintptr
	FzDb         uintptr
	FzSelf       uintptr
	FzCostTab    uintptr
	FzVocabTab   uintptr
	FzVocabWord  uintptr
	FzVocabLang  uintptr
	FpRule       uintptr
	FrIns        amatch_cost
	FrDel        amatch_cost
	FrSub        amatch_cost
	F__ccgo_pad1 [4]byte
	Fdb          uintptr
	FpVCheck     uintptr
	FnCursor     int32
	F__ccgo_pad2 [4]byte
} /* amatch.c:172:9 */

// POSIX.1-2001 specifies _tolower() and _toupper() to be macros equivalent to
// tolower() and toupper() respectively, minus extra checking to ensure that
// the argument is a lower or uppercase letter respectively.  We've chosen to
// implement these macros with the same error checking as tolower() and
// toupper() since this doesn't violate the specification itself, only its
// intent.  We purposely leave _tolower() and _toupper() undocumented to
// discourage their use.
//
// XXX isascii() and toascii() should similarly be undocumented.

// Forward declaration of objects used by this implementation
type amatch_vtab = amatch_vtab1 /* amatch.c:172:28 */
type amatch_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiRowid      sqlite3_int64
	FiLang       amatch_langid
	FrLimit      amatch_cost
	FnBuf        int32
	FoomErr      int32
	FnWord       int32
	F__ccgo_pad1 [4]byte
	FzBuf        uintptr
	FzInput      uintptr
	FpVtab       uintptr
	FpAllWords   uintptr
	FpCurrent    uintptr
	FpCost       uintptr
	FpWord       uintptr
} /* amatch.c:173:9 */

type amatch_cursor = amatch_cursor1 /* amatch.c:173:30 */
type amatch_rule1 = struct {
	FpNext       uintptr
	FzFrom       uintptr
	FrCost       amatch_cost
	FiLang       amatch_langid
	FnFrom       amatch_len
	FnTo         amatch_len
	FzTo         [4]int8
	F__ccgo_pad1 [2]byte
} /* amatch.c:172:9 */

type amatch_rule = amatch_rule1 /* amatch.c:174:28 */
type amatch_word1 = struct {
	FpNext  uintptr
	FsCost  amatch_avl
	FsWord  amatch_avl
	FrCost  amatch_cost
	FiSeq   int32
	FzCost  [10]int8
	FnMatch int16
	FzWord  [4]int8
} /* amatch.c:173:9 */

type amatch_word = amatch_word1 /* amatch.c:175:28 */
type amatch_avl1 = struct {
	FpWord       uintptr
	FzKey        uintptr
	FpBefore     uintptr
	FpAfter      uintptr
	FpUp         uintptr
	Fheight      int16
	Fimbalance   int16
	F__ccgo_pad1 [4]byte
} /* amatch.c:173:9 */

type amatch_avl = amatch_avl1 /* amatch.c:176:27 */

// Recompute the amatch_avl.height and amatch_avl.imbalance fields for p.
// Assume that the children of p have correct heights.
func amatchAvlRecomputeHeight(tls *libc.TLS, p uintptr) { /* amatch.c:199:13: */
	var hBefore int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*amatch_avl)(unsafe.Pointer(p)).Fimbalance = int16(int32(hBefore) - int32(hAfter)) // -: pAfter higher.  +: pBefore higher
	(*amatch_avl)(unsafe.Pointer(p)).Fheight = int16(func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}() + 1)
}

//     P                B
//    / \              / **   B   Z    ==>     X   P
//  / \                  / ** X   Y                Y   Z
//
func amatchAvlRotateBefore(tls *libc.TLS, pP uintptr) uintptr { /* amatch.c:214:19: */
	var pB uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pB)).FpAfter
	(*amatch_avl)(unsafe.Pointer(pB)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*amatch_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pB)
	return pB
}

//     P                A
//    / \              / **   X   A    ==>     P   Z
//      / \          / **     Y   Z        X   Y
//
func amatchAvlRotateAfter(tls *libc.TLS, pP uintptr) uintptr { /* amatch.c:235:19: */
	var pA uintptr = (*amatch_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*amatch_avl)(unsafe.Pointer(pA)).FpBefore
	(*amatch_avl)(unsafe.Pointer(pA)).FpUp = (*amatch_avl)(unsafe.Pointer(pP)).FpUp
	(*amatch_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*amatch_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*amatch_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	amatchAvlRecomputeHeight(tls, pP)
	amatchAvlRecomputeHeight(tls, pA)
	return pA
}

// Return a pointer to the pBefore or pAfter pointer in the parent
// of p that points to p.  Or if p is the root node, return pp.
func amatchAvlFromPtr(tls *libc.TLS, p uintptr, pp uintptr) uintptr { /* amatch.c:252:19: */
	var pUp uintptr = (*amatch_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*amatch_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return pUp + 24
	}
	return pUp + 16
}

// Rebalance all nodes starting with p and working up to the root.
// Return the new root.
func amatchAvlBalance(tls *libc.TLS, p uintptr) uintptr { /* amatch.c:263:19: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp /* p */))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		amatchAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)))
		if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) >= 2 {
			var pB uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore
			if int32((*amatch_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore = amatchAvlRotateAfter(tls, pB)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, amatchAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		} else if int32((*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) <= -2 {
			var pA uintptr = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter
			if int32((*amatch_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter = amatchAvlRotateBefore(tls, pA)
			}
			pp = amatchAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, amatchAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp /* p */))
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = (*amatch_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpUp
	}
	return pTop
}

// Search the tree rooted at p for an entry with zKey.  Return a pointer
// to the entry or return NULL.
func amatchAvlSearch(tls *libc.TLS, p uintptr, zKey uintptr) uintptr { /* amatch.c:288:19: */
	var c int32
	for p != 0 && libc.AssignInt32(&c, libc.Xstrcmp(tls, zKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey)) != 0 {
		if c < 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

// Find the first node (the one with the smallest key).
func amatchAvlFirst(tls *libc.TLS, p uintptr) uintptr { /* amatch.c:298:19: */
	if p != 0 {
		for (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

// Insert a new node pNew.  Return NULL on success.  If the key is not
// unique, then do not perform the insert but instead leave pNew unchanged
// and return a pointer to an existing node with the same key.
func amatchAvlInsert(tls *libc.TLS, ppHead uintptr, pNew uintptr) uintptr { /* amatch.c:356:19: */
	var c int32
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			c = libc.Xstrcmp(tls, (*amatch_avl)(unsafe.Pointer(pNew)).FzKey, (*amatch_avl)(unsafe.Pointer(p)).FzKey)
			if c < 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if c > 0 {
				if (*amatch_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*amatch_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*amatch_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*amatch_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*amatch_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*amatch_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, p)
	// assert( amatchAvlIntegrity(*ppHead) );
	// assert( amatchAvlIntegrity2(*ppHead) );
	return uintptr(0)
}

// Remove node pOld from the tree.  pOld must be an element of the tree or
// the AVL tree will become corrupt.
func amatchAvlRemove(tls *libc.TLS, ppHead uintptr, pOld uintptr) { /* amatch.c:399:13: */
	var ppParent uintptr
	var pBalance uintptr = uintptr(0)
	// assert( amatchAvlSearch(*ppHead, pOld->zKey)==pOld );
	ppParent = amatchAvlFromPtr(tls, pOld, ppHead)
	if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0) && (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = uintptr(0)
		pBalance = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore != 0 && (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter != 0 {
		var pX uintptr
		var pY uintptr
		pX = amatchAvlFirst(tls, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		*(*uintptr)(unsafe.Pointer(amatchAvlFromPtr(tls, pX, uintptr(0)))) = (*amatch_avl)(unsafe.Pointer(pX)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		}
		pBalance = (*amatch_avl)(unsafe.Pointer(pX)).FpUp
		(*amatch_avl)(unsafe.Pointer(pX)).FpAfter = (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter
		if (*amatch_avl)(unsafe.Pointer(pX)).FpAfter != 0 {
			(*amatch_avl)(unsafe.Pointer((*amatch_avl)(unsafe.Pointer(pX)).FpAfter)).FpUp = pX
		} else {

			pBalance = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpBefore = libc.AssignUintptr(&pY, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		if pY != 0 {
			(*amatch_avl)(unsafe.Pointer(pY)).FpUp = pX
		}
		(*amatch_avl)(unsafe.Pointer(pX)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
		*(*uintptr)(unsafe.Pointer(ppParent)) = pX
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = libc.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	} else if (*amatch_avl)(unsafe.Pointer(pOld)).FpAfter == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(ppParent)) = libc.AssignUintptr(&pBalance, (*amatch_avl)(unsafe.Pointer(pOld)).FpBefore)
		(*amatch_avl)(unsafe.Pointer(pBalance)).FpUp = (*amatch_avl)(unsafe.Pointer(pOld)).FpUp
	}
	*(*uintptr)(unsafe.Pointer(ppHead)) = amatchAvlBalance(tls, pBalance)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpUp = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpBefore = uintptr(0)
	(*amatch_avl)(unsafe.Pointer(pOld)).FpAfter = uintptr(0)
	// assert( amatchAvlIntegrity(*ppHead) );
	// assert( amatchAvlIntegrity2(*ppHead) );
}

//
// End of the AVL Tree implementation
//

// Various types.
//
// amatch_cost is the "cost" of an edit operation.
//
// amatch_len is the length of a matching string.
//
// amatch_langid is an ruleset identifier.
type amatch_cost = int32   /* amatch.c:452:13 */
type amatch_len = int8     /* amatch.c:453:21 */
type amatch_langid = int32 /* amatch.c:454:13 */

// The two input rule lists are both sorted in order of increasing
// cost.  Merge them together into a single list, sorted by cost, and
// return a pointer to the head of that list.
func amatchMergeRules(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* amatch.c:534:20: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var head amatch_rule at bp, 32

	var pTail uintptr

	pTail = bp /* &head */
	for pA != 0 && pB != 0 {
		if (*amatch_rule)(unsafe.Pointer(pA)).FrCost <= (*amatch_rule)(unsafe.Pointer(pB)).FrCost {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*amatch_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*amatch_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*amatch_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*amatch_rule)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Statement pStmt currently points to a row in the amatch data table. This
// function allocates and populates a amatch_rule structure according to
// the content of the row.
//
// If successful, *ppRule is set to point to the new object and SQLITE_OK
// is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
// to an error message and an SQLite error code returned.
func amatchLoadOneRule(tls *libc.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 { /* amatch.c:567:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iLang sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var rCost amatch_cost = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = SQLITE_OK       // Return code
	var nFrom int32                // Size of string zFrom, in bytes
	var nTo int32                  // Size of string zTo, in bytes
	var pRule uintptr = uintptr(0) // New rule object to return

	if zFrom == uintptr(0) {
		zFrom = ts + 584 /* "" */
	}
	if zTo == uintptr(0) {
		zTo = ts + 584 /* "" */
	}
	nFrom = int32(libc.Xstrlen(tls, zFrom))
	nTo = int32(libc.Xstrlen(tls, zTo))

	// Silently ignore null transformations
	if libc.Xstrcmp(tls, zFrom, zTo) == 0 {
		if int32(*(*int8)(unsafe.Pointer(zFrom))) == '?' && int32(*(*int8)(unsafe.Pointer(zFrom + 1))) == 0 {
			if (*amatch_vtab)(unsafe.Pointer(p)).FrSub == 0 || (*amatch_vtab)(unsafe.Pointer(p)).FrSub > rCost {
				(*amatch_vtab)(unsafe.Pointer(p)).FrSub = rCost
			}
		}
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return SQLITE_OK
	}

	if rCost <= 0 || rCost > AMATCH_MX_COST {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3304, /* "%s: cost must be..." */
			libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_COST))
		rc = SQLITE_ERROR
	} else if nFrom > AMATCH_MX_LENGTH || nTo > AMATCH_MX_LENGTH {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3338, /* "%s: maximum stri..." */
			libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_LENGTH))
		rc = SQLITE_ERROR
	} else if iLang < int64(0) || iLang > int64(AMATCH_MX_LANGID) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3370, /* "%s: iLang must b..." */
			libc.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, AMATCH_MX_LANGID))
		rc = SQLITE_ERROR
	} else if libc.Xstrcmp(tls, zFrom, ts+584) == 0 && libc.Xstrcmp(tls, zTo, ts+3405) == 0 {
		if (*amatch_vtab)(unsafe.Pointer(p)).FrIns == 0 || (*amatch_vtab)(unsafe.Pointer(p)).FrIns > rCost {
			(*amatch_vtab)(unsafe.Pointer(p)).FrIns = rCost
		}
	} else if libc.Xstrcmp(tls, zFrom, ts+3405) == 0 && libc.Xstrcmp(tls, zTo, ts+584) == 0 {
		if (*amatch_vtab)(unsafe.Pointer(p)).FrDel == 0 || (*amatch_vtab)(unsafe.Pointer(p)).FrDel > rCost {
			(*amatch_vtab)(unsafe.Pointer(p)).FrDel = rCost
		}
	} else {
		pRule = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(amatch_rule{}))+uint64(nFrom)+uint64(nTo)))
		if pRule == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pRule, 0, uint64(unsafe.Sizeof(amatch_rule{})))
			(*amatch_rule)(unsafe.Pointer(pRule)).FzFrom = pRule + 26 + uintptr(nTo+1)
			(*amatch_rule)(unsafe.Pointer(pRule)).FnFrom = amatch_len(nFrom)
			libc.Xmemcpy(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, uint64(nFrom+1))
			libc.Xmemcpy(tls, pRule+26, zTo, uint64(nTo+1))
			(*amatch_rule)(unsafe.Pointer(pRule)).FnTo = amatch_len(nTo)
			(*amatch_rule)(unsafe.Pointer(pRule)).FrCost = rCost
			(*amatch_rule)(unsafe.Pointer(pRule)).FiLang = int32(iLang)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

// Free all the content in the edit-cost-table
func amatchFreeRules(tls *libc.TLS, p uintptr) { /* amatch.c:644:13: */
	for (*amatch_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*amatch_vtab)(unsafe.Pointer(p)).FpRule
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	(*amatch_vtab)(unsafe.Pointer(p)).FpRule = uintptr(0)
}

// Load the content of the amatch data table into memory.
func amatchLoadRules(tls *libc.TLS, db uintptr, p uintptr, pzErr uintptr) int32 { /* amatch.c:656:12: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	var rc int32 = SQLITE_OK // Return code
	var zSql uintptr         // SELECT used to read from rules table
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+3407 /* "SELECT * FROM %Q..." */, libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzDb, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab))
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var rc2 int32 // finalize() return code
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56 /* &pStmt */, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3427 /* "%s: %s" */, libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3434, /* "%s: %s has %d co..." */
				libc.VaList(bp+32, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))))
			rc = SQLITE_ERROR
		} else {
			for rc == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) {
				*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)) = uintptr(0)
				rc = amatchLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)), bp+64 /* &pRule */, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 64)) != 0 {
					(*amatch_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	// All rules are now in a singly linked list starting at pHead. This
	// block sorts them by cost and then sets amatch_vtab.pRule to point to
	// point to the head of the sorted list.
	if rc == SQLITE_OK {
		var i uint32
		var pX uintptr
		// var a [15]uintptr at bp+72, 120

		for i = uint32(0); uint64(i) < uint64(unsafe.Sizeof([15]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
		}
		for libc.AssignUintptr(&pX, pHead) != uintptr(0) {
			pHead = (*amatch_rule)(unsafe.Pointer(pX)).FpNext
			(*amatch_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) != 0 && uint64(i) < uint64(unsafe.Sizeof([15]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0)))-uint64(1); i++ {
				pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */))
		i = uint32(1)
		for ; uint64(i) < uint64(unsafe.Sizeof([15]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
			pX = amatchMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = amatchMergeRules(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		// An error has occurred. Setting p->pRule to point to the head of the
		// allocated list ensures that the list will be cleaned up in this case.

		(*amatch_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func amatchDequote(tls *libc.TLS, zIn uintptr) uintptr { /* amatch.c:740:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+int64(1)))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn)) // Quote character (if any )

		if int32(q) != '[' && int32(q) != '\'' && int32(q) != '"' && int32(q) != '`' {
			libc.Xmemcpy(tls, zOut, zIn, size_t(nIn+int64(1)))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

// Deallocate the pVCheck prepared statement.
func amatchVCheckClear(tls *libc.TLS, p uintptr) { /* amatch.c:769:13: */
	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
		(*amatch_vtab)(unsafe.Pointer(p)).FpVCheck = uintptr(0)
	}
}

// Deallocate an amatch_vtab object
func amatchFree(tls *libc.TLS, p uintptr) { /* amatch.c:779:13: */
	if p != 0 {
		amatchFreeRules(tls, p)
		amatchVCheckClear(tls, p)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzClassName)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzCostTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang)
		sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf)
		libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(amatch_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// xDisconnect/xDestroy method for the amatch module.
func amatchDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* amatch.c:798:12: */
	var p uintptr = pVtab

	amatchFree(tls, p)
	return SQLITE_OK
}

// Check to see if the argument is of the form:
//
//       KEY = VALUE
//
// If it is, return a pointer to the first character of VALUE.
// If not, return NULL.  Spaces around the = are ignored.
func amatchValueOfKey(tls *libc.TLS, zKey uintptr, zStr uintptr) uintptr { /* amatch.c:813:19: */
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var nStr int32 = int32(libc.Xstrlen(tls, zStr))
	var i int32
	if nStr < nKey+1 {
		return uintptr(0)
	}
	if libc.Xmemcmp(tls, zStr, zKey, uint64(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint64(X_CTYPE_S)) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint64(X_CTYPE_S)) != 0 {
		i++
	}
	return zStr + uintptr(i)
}

// xConnect/xCreate method for the amatch module. Arguments are:
//
//   argv[0]    -> module name  ("approximate_match")
//   argv[1]    -> database name
//   argv[2]    -> table name
//   argv[3...] -> arguments
func amatchConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* amatch.c:834:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32     // Return code
	var pNew uintptr // New virtual table
	var zModule uintptr
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = SQLITE_OK
	pNew = uintptr(0)
	zModule = *(*uintptr)(unsafe.Pointer(argv))
	zDb = *(*uintptr)(unsafe.Pointer(argv + 1*8))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return SQLITE_NOMEM
__1:
	;
	rc = SQLITE_NOMEM
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(amatch_vtab{})))
	(*amatch_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zModule))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzClassName == uintptr(0)) {
		goto __2
	}
	goto amatchConnectError
__2:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zDb))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __3
	}
	goto amatchConnectError
__3:
	;
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __4
	}
	goto amatchConnectError
__4:
	;
	i = 3
__5:
	if !(i < argc) {
		goto __7
	}
	zVal = amatchValueOfKey(tls, ts+3468 /* "vocabulary_table" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __8
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabTab == uintptr(0)) {
		goto __9
	}
	goto amatchConnectError
__9:
	;
	goto __6
__8:
	;
	zVal = amatchValueOfKey(tls, ts+3485 /* "vocabulary_word" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __10
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabWord == uintptr(0)) {
		goto __11
	}
	goto amatchConnectError
__11:
	;
	goto __6
__10:
	;
	zVal = amatchValueOfKey(tls, ts+3501 /* "vocabulary_langu..." */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzVocabLang == uintptr(0)) {
		goto __13
	}
	goto amatchConnectError
__13:
	;
	goto __6
__12:
	;
	zVal = amatchValueOfKey(tls, ts+3521 /* "edit_distances" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __14
	}
	sqlite3.Xsqlite3_free(tls, (*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab)
	(*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab = amatchDequote(tls, zVal)
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __15
	}
	goto amatchConnectError
__15:
	;
	goto __6
__14:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3536 /* "unrecognized arg..." */, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	amatchFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return SQLITE_ERROR
	goto __6
__6:
	i++
	goto __5
	goto __7
__7:
	;
	rc = SQLITE_OK
	if !((*amatch_vtab)(unsafe.Pointer(pNew)).FzCostTab == uintptr(0)) {
		goto __16
	}
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3565 /* "no edit_distance..." */, 0)
	rc = SQLITE_ERROR
	goto __17
__16:
	rc = amatchLoadRules(tls, db, pNew, pzErr)
__17:
	;
	if !(rc == SQLITE_OK) {
		goto __18
	}
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,

		ts+3599 /* "CREATE TABLE x(w..." */)
__18:
	;
	if !(rc != SQLITE_OK) {
		goto __19
	}
	amatchFree(tls, pNew)
__19:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc

amatchConnectError:
	amatchFree(tls, pNew)
	return rc
}

// Open a new amatch cursor.
func amatchOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* amatch.c:928:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(amatch_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(amatch_cursor{})))
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	(*amatch_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func amatchClearCursor(tls *libc.TLS, pCur uintptr) { /* amatch.c:944:13: */
	var pWord uintptr
	var pNextWord uintptr
	for pWord = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords; pWord != 0; pWord = pNextWord {
		pNextWord = (*amatch_word)(unsafe.Pointer(pWord)).FpNext
		sqlite3.Xsqlite3_free(tls, pWord)
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCost = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpWord = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = 1000000
	(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = 0
	(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord = 0
}

// Close a amatch cursor.
func amatchClose(tls *libc.TLS, cur uintptr) int32 { /* amatch.c:967:12: */
	var pCur uintptr = cur
	amatchClearCursor(tls, pCur)
	(*amatch_vtab)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Render a 24-bit unsigned integer as a 4-byte base-64 number.
func amatchEncodeInt(tls *libc.TLS, x int32, z uintptr) { /* amatch.c:978:13: */
	*(*int8)(unsafe.Pointer(z)) = a[x>>18&0x3f]
	*(*int8)(unsafe.Pointer(z + 1)) = a[x>>12&0x3f]
	*(*int8)(unsafe.Pointer(z + 2)) = a[x>>6&0x3f]
	*(*int8)(unsafe.Pointer(z + 3)) = a[x&0x3f]
}

var a = *(*[65]int8)(unsafe.Pointer(ts + 3666 /* "0123456789ABCDEF..." */)) /* amatch.c:979:21 */

// Write the zCost[] field for a amatch_word object
func amatchWriteCost(tls *libc.TLS, pWord uintptr) { /* amatch.c:996:13: */
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, pWord+112)
	amatchEncodeInt(tls, (*amatch_word)(unsafe.Pointer(pWord)).FiSeq, pWord+112+uintptr(4))
	*(*int8)(unsafe.Pointer(pWord + 112 + 8)) = int8(0)
}

// Circumvent compiler warnings about the use of strcpy() by supplying
// our own implementation.
func amatchStrcpy(tls *libc.TLS, dest uintptr, src uintptr) { /* amatch.c:1005:13: */
	for int32(libc.AssignPtrInt8(libc.PostIncUintptr(&dest, 1), *(*int8)(unsafe.Pointer(libc.PostIncUintptr(&src, 1))))) != 0 {
	}
}

func amatchStrcat(tls *libc.TLS, dest uintptr, src uintptr) { /* amatch.c:1008:13: */
	for *(*int8)(unsafe.Pointer(dest)) != 0 {
		dest++
	}
	amatchStrcpy(tls, dest, src)
}

// Add a new amatch_word object to the queue.
//
// If a prior amatch_word object with the same zWord, and nMatch
// already exists, update its rCost (if the new rCost is less) but
// otherwise leave it unchanged.  Do not add a duplicate.
//
// Do nothing if the cost exceeds threshold.
func amatchAddWord(tls *libc.TLS, pCur uintptr, rCost amatch_cost, nMatch int32, zWordBase uintptr, zWordTail uintptr) { /* amatch.c:1022:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pWord uintptr
	var pNode uintptr
	var pOther uintptr
	_ = pOther
	var nBase int32
	var nTail int32
	// var zBuf [4]int8 at bp, 4

	if rCost > (*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit {
		return
	}
	nBase = int32(libc.Xstrlen(tls, zWordBase))
	nTail = int32(libc.Xstrlen(tls, zWordTail))
	if nBase+nTail+3 > (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = nBase + nTail + 100
		(*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf = sqlite3.Xsqlite3_realloc(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, (*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf)
		if (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf == uintptr(0) {
			(*amatch_cursor)(unsafe.Pointer(pCur)).FnBuf = 0
			return
		}
	}
	amatchEncodeInt(tls, nMatch, bp /* &zBuf[0] */)
	libc.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf, bp+uintptr(2), uint64(2))
	libc.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf+uintptr(2), zWordBase, uint64(nBase))
	libc.Xmemcpy(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf+uintptr(2)+uintptr(nBase), zWordTail, uint64(nTail+1))
	pNode = amatchAvlSearch(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpWord, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	if pNode != 0 {
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		if (*amatch_word)(unsafe.Pointer(pWord)).FrCost > rCost {
			amatchAvlRemove(tls, pCur+80, pWord+8)
			(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
			amatchWriteCost(tls, pWord)
			pOther = amatchAvlInsert(tls, pCur+80, pWord+8)
			_ = pOther
		}
		return
	}
	pWord = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(amatch_word{}))+uint64(nBase)+uint64(nTail)-uint64(1)))
	if pWord == uintptr(0) {
		return
	}
	libc.Xmemset(tls, pWord, 0, uint64(unsafe.Sizeof(amatch_word{})))
	(*amatch_word)(unsafe.Pointer(pWord)).FrCost = rCost
	(*amatch_word)(unsafe.Pointer(pWord)).FiSeq = libc.PostIncInt32(&(*amatch_cursor)(unsafe.Pointer(pCur)).FnWord, 1)
	amatchWriteCost(tls, pWord)
	(*amatch_word)(unsafe.Pointer(pWord)).FnMatch = int16(nMatch)
	(*amatch_word)(unsafe.Pointer(pWord)).FpNext = (*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpAllWords = pWord
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FzKey = pWord + 112 /* &.zCost */
	(*amatch_word)(unsafe.Pointer(pWord)).FsCost.FpWord = pWord
	pOther = amatchAvlInsert(tls, pCur+80, pWord+8)
	_ = pOther
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FzKey = pWord + 124 /* &.zWord */
	(*amatch_word)(unsafe.Pointer(pWord)).FsWord.FpWord = pWord
	amatchStrcpy(tls, pWord+124, (*amatch_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pOther = amatchAvlInsert(tls, pCur+88, pWord+56)
	_ = pOther
}

// Advance a cursor to its next row of output
func amatchNext(tls *libc.TLS, cur uintptr) int32 { /* amatch.c:1102:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var pCur uintptr = cur
	var pWord uintptr = uintptr(0)
	var pNode uintptr
	var isMatch int32 = 0
	var p uintptr = (*amatch_cursor)(unsafe.Pointer(pCur)).FpVtab
	var nWord int32
	var rc int32
	var i int32
	var zW uintptr
	var pRule uintptr
	var zBuf uintptr = uintptr(0)
	var nBuf int8 = int8(0)
	// var zNext [8]int8 at bp+64, 8

	// var zNextIn [8]int8 at bp+72, 8

	var nNextIn int32

	if (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck == uintptr(0) {
		var zSql uintptr
		if (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang != 0 && *(*int8)(unsafe.Pointer((*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang)) != 0 {
			zSql = sqlite3.Xsqlite3_mprintf(tls,
				ts+3731, /* "SELECT \"%w\" FROM..." */

				libc.VaList(bp, ts+3753, /* " WHERE \"%w\">=?1 ..." */
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabLang))
		} else {
			zSql = sqlite3.Xsqlite3_mprintf(tls,

				ts+3792, /* "SELECT \"%w\" FROM..." */
				libc.VaList(bp+40, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord, (*amatch_vtab)(unsafe.Pointer(p)).FzVocabTab,
					(*amatch_vtab)(unsafe.Pointer(p)).FzVocabWord))
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*amatch_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, p+112, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			return rc
		}
	}
	sqlite3.Xsqlite3_bind_int(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 2, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)

	for ok := true; ok; ok = !(isMatch != 0) {
		pNode = amatchAvlFirst(tls, (*amatch_cursor)(unsafe.Pointer(pCur)).FpCost)
		if pNode == uintptr(0) {
			pWord = uintptr(0)
			break
		}
		pWord = (*amatch_avl)(unsafe.Pointer(pNode)).FpWord
		amatchAvlRemove(tls, pCur+80, pWord+8)

		nWord = int32(libc.Xstrlen(tls, pWord+124+uintptr(2)))
		if nWord+20 > int32(nBuf) {
			nBuf = int8(nWord + 100)
			zBuf = sqlite3.Xsqlite3_realloc(tls, zBuf, int32(nBuf))
			if zBuf == uintptr(0) {
				return SQLITE_NOMEM
			}
		}
		amatchStrcpy(tls, zBuf, pWord+124+uintptr(2))
		*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */)) = int8(0)
		*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */)) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)))
		if *(*int8)(unsafe.Pointer(bp + 72)) != 0 {
			for i = 1; i <= 4 && int32(*(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr(int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+i))))&0xc0 == 0x80; i++ {
				*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FzInput + uintptr(int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+i)))
			}
			*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */ + uintptr(i))) = int8(0)
			nNextIn = i
		} else {
			nNextIn = 0
		}

		if *(*int8)(unsafe.Pointer(bp + 72)) != 0 && int32(*(*int8)(unsafe.Pointer(bp + 72))) != '*' {
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			amatchStrcat(tls, zBuf, bp+72 /* &zNextIn[0] */)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, nWord+nNextIn, uintptr(0))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc == SQLITE_ROW {
				zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
				if libc.Xstrncmp(tls, zBuf, zW, uint64(nWord+nNextIn)) == 0 {
					amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+nNextIn, zBuf, ts+584 /* "" */)
				}
			}
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
		}

		for 1 != 0 {
			amatchStrcpy(tls, zBuf+uintptr(nWord), bp+64 /* &zNext[0] */)
			sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			sqlite3.Xsqlite3_bind_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 1, zBuf, -1, libc.UintptrFromInt32(-1))
			rc = sqlite3.Xsqlite3_step(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)
			if rc != SQLITE_ROW {
				break
			}
			zW = sqlite3.Xsqlite3_column_text(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck, 0)
			amatchStrcpy(tls, zBuf+uintptr(nWord), bp+64 /* &zNext[0] */)
			if libc.Xstrncmp(tls, zW, zBuf, uint64(nWord)) != 0 {
				break
			}
			if int32(*(*int8)(unsafe.Pointer(bp + 72))) == '*' && int32(*(*int8)(unsafe.Pointer(bp + 72 + 1))) == 0 ||
				int32(*(*int8)(unsafe.Pointer(bp + 72))) == 0 && int32(*(*int8)(unsafe.Pointer(zW + uintptr(nWord)))) == 0 {
				isMatch = 1
				*(*int8)(unsafe.Pointer(bp + 72 /* &zNextIn[0] */)) = int8(0)
				nNextIn = 0
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */)) = *(*int8)(unsafe.Pointer(zW + uintptr(nWord)))
			for i = 1; i <= 4 && int32(*(*int8)(unsafe.Pointer(zW + uintptr(nWord+i))))&0xc0 == 0x80; i++ {
				*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer(zW + uintptr(nWord+i)))
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(i))) = int8(0)
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			if (*amatch_vtab)(unsafe.Pointer(p)).FrIns > 0 {
				amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_vtab)(unsafe.Pointer(p)).FrIns, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch),
					zBuf, bp+64 /* &zNext[0] */)
			}
			if (*amatch_vtab)(unsafe.Pointer(p)).FrSub > 0 {
				amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_vtab)(unsafe.Pointer(p)).FrSub, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+nNextIn,
					zBuf, bp+64 /* &zNext[0] */)
			}
			if (*amatch_vtab)(unsafe.Pointer(p)).FrIns < 0 && (*amatch_vtab)(unsafe.Pointer(p)).FrSub < 0 {
				break
			}
			*(*int8)(unsafe.Pointer(bp + 64 /* &zNext[0] */ + uintptr(i-1)))++ // FIX ME
		}
		sqlite3.Xsqlite3_reset(tls, (*amatch_vtab)(unsafe.Pointer(p)).FpVCheck)

		if (*amatch_vtab)(unsafe.Pointer(p)).FrDel > 0 {
			*(*int8)(unsafe.Pointer(zBuf + uintptr(nWord))) = int8(0)
			amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_vtab)(unsafe.Pointer(p)).FrDel, int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+nNextIn,
				zBuf, ts+584 /* "" */)
		}

		for pRule = (*amatch_vtab)(unsafe.Pointer(p)).FpRule; pRule != 0; pRule = (*amatch_rule)(unsafe.Pointer(pRule)).FpNext {
			if (*amatch_rule)(unsafe.Pointer(pRule)).FiLang != (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang {
				continue
			}
			if libc.Xstrncmp(tls, (*amatch_rule)(unsafe.Pointer(pRule)).FzFrom, (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput+uintptr((*amatch_word)(unsafe.Pointer(pWord)).FnMatch), uint64((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0 {
				amatchAddWord(tls, pCur, (*amatch_word)(unsafe.Pointer(pWord)).FrCost+(*amatch_rule)(unsafe.Pointer(pRule)).FrCost,
					int32((*amatch_word)(unsafe.Pointer(pWord)).FnMatch)+int32((*amatch_rule)(unsafe.Pointer(pRule)).FnFrom), pWord+124+uintptr(2), pRule+26)
			}
		}
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent = pWord
	sqlite3.Xsqlite3_free(tls, zBuf)
	return SQLITE_OK
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any amatchColumn, amatchRowid, or amatchEof call.
func amatchFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* amatch.c:1251:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 3840 /* "*" */
	var idx int32

	amatchClearCursor(tls, pCur)
	idx = 0
	if idxNum&1 != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		idx++
	}
	if idxNum&2 != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	if idxNum&4 != 0 {
		(*amatch_cursor)(unsafe.Pointer(pCur)).FiLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	(*amatch_cursor)(unsafe.Pointer(pCur)).FzInput = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zWord))
	if (*amatch_cursor)(unsafe.Pointer(pCur)).FzInput == uintptr(0) {
		return SQLITE_NOMEM
	}
	amatchAddWord(tls, pCur, 0, 0, ts+584 /* "" */, ts+584 /* "" */)
	amatchNext(tls, pVtabCursor)

	return SQLITE_OK
}

// Only the word and distance columns have values.  All other columns
// return NULL
func amatchColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* amatch.c:1286:12: */
	var pCur uintptr = cur
	switch i {
	case AMATCH_COL_WORD:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent+124+uintptr(2), -1, uintptr(0))
			break

		}
	case AMATCH_COL_DISTANCE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_word)(unsafe.Pointer((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FrCost)
			break

		}
	case AMATCH_COL_LANGUAGE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FiLang)
			break

		}
	case AMATCH_COL_NWORD:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*amatch_cursor)(unsafe.Pointer(pCur)).FnWord)
			break

		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	}
	return SQLITE_OK
}

// The rowid.
func amatchRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* amatch.c:1316:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*amatch_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// EOF indicator
func amatchEof(tls *libc.TLS, cur uintptr) int32 { /* amatch.c:1325:12: */
	var pCur uintptr = cur
	return libc.Bool32((*amatch_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0))
}

// Search for terms of these forms:
//
//   (A)    word MATCH $str
//   (B1)   distance < $value
//   (B2)   distance <= $value
//   (C)    language == $language
//
// The distance< and distance<= are both treated as distance<=.
// The query plan number is a bit vector:
//
//   bit 1:   Term of the form (A) found
//   bit 2:   Term like (B1) or (B2) found
//   bit 3:   Term like (C) found
//
// If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
// then $value is in filter.argv[0] if bit-1 is clear and is in
// filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
// in filter.argv[0] if bit-1 and bit-2 are both zero, is in
// filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
// filter.argv[2] if both bit-1 and bit-2 are set.
func amatchBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* amatch.c:1352:12: */
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iLangTerm int32 = -1
	var i int32
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if iPlan&1 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			iPlan = iPlan | 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if iPlan&2 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1 &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE) {
			iPlan = iPlan | 2
			iDistTerm = i
		}
		if iPlan&4 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | 4
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iLangTerm = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if iPlan&2 != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = 1 + libc.Bool32(iPlan&1 != 0)
	}
	if iPlan&4 != 0 {
		var idx int32 = 1
		if iPlan&1 != 0 {
			idx++
		}
		if iPlan&2 != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == 1 &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10000)

	return SQLITE_OK
}

// The xUpdate() method.
//
// This implementation disallows DELETE and UPDATE.  The only thing
// allowed is INSERT into the "command" column.
func amatchUpdate(tls *libc.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* amatch.c:1418:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr = pVTab
	var zCmd uintptr
	_ = pRowid
	if argc == 1 {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3842, /* "DELETE from %s i..." */
			libc.VaList(bp, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_NULL {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+3872, /* "UPDATE of %s is ..." */
			libc.VaList(bp+8, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))) != SQLITE_NULL ||
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8))) != SQLITE_NULL ||
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8))) != SQLITE_NULL {
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+3900 /* "INSERT INTO %s a..." */, libc.VaList(bp+16, (*amatch_vtab)(unsafe.Pointer(p)).FzSelf))
		return SQLITE_ERROR
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)))
	if zCmd == uintptr(0) {
		return SQLITE_OK
	}

	return SQLITE_OK
}

// A virtual table module that implements the "approximate_match".
var amatchModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xShadowName
} /* amatch.c:1454:23 */

// Register the amatch virtual table
func sqlite3_amatch_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* amatch.c:1489:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Not used
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+3949 /* "approximate_matc..." */, uintptr(unsafe.Pointer(&amatchModule)), uintptr(0))
	return rc
}

// Allowed values for the mFlags parameter to sqlite3_carray_bind().
// Must exactly match the definitions in carray.h.

// Names of allowed datatypes
var azType = [4]uintptr{ts + 3967 /* "int32" */, ts + 3973 /* "int64" */, ts + 2562 /* "double" */, ts + 3979 /* "char*" */} /* carray.c:83:19 */

// Structure used to hold the sqlite3_carray_bind() information
type carray_bind1 = struct {
	FaData  uintptr
	FnData  int32
	FmFlags int32
	FxDel   uintptr
} /* carray.c:88:9 */

// Structure used to hold the sqlite3_carray_bind() information
type carray_bind = carray_bind1 /* carray.c:88:28 */

// carray_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type carray_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiRowid      sqlite3_int64
	FpPtr        uintptr
	FiCnt        sqlite3_int64
	FeType       uint8
	F__ccgo_pad1 [7]byte
} /* carray.c:101:9 */

// carray_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type carray_cursor = carray_cursor1 /* carray.c:101:30 */

// The carrayConnect() method is invoked to create a new
// carray_vtab that describes the carray virtual table.
//
// Think of this routine as the constructor for carray_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the carray_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against carray will look like.
func carrayConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* carray.c:123:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+3985 /* "CREATE TABLE x(v..." */)
	if rc == SQLITE_OK {
		pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(sqlite3_vtab{})))
	}
	return rc
}

// This method is the destructor for carray_cursor objects.
func carrayDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* carray.c:152:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new carray_cursor object.
func carrayOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* carray.c:160:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(carray_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(carray_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Destructor for a carray_cursor.
func carrayClose(tls *libc.TLS, cur uintptr) int32 { /* carray.c:172:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Advance a carray_cursor to its next row of output.
func carrayNext(tls *libc.TLS, cur uintptr) int32 { /* carray.c:181:12: */
	var pCur uintptr = cur
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

// Return values of columns for the row at which the carray_cursor
// is currently pointing.
func carrayColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* carray.c:191:12: */
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case CARRAY_COLUMN_POINTER:
		return SQLITE_OK
	case CARRAY_COLUMN_COUNT:
		x = (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt
		break
	case CARRAY_COLUMN_CTYPE:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, azType[(*carray_cursor)(unsafe.Pointer(pCur)).FeType], -1, uintptr(0))
			return SQLITE_OK

		}
	default:
		{
			switch int32((*carray_cursor)(unsafe.Pointer(pCur)).FeType) {
			case CARRAY_INT32:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*4)))
					return SQLITE_OK

				}
			case CARRAY_INT64:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*8)))
					return SQLITE_OK

				}
			case CARRAY_DOUBLE:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_double(tls, ctx, *(*float64)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*8)))
					return SQLITE_OK

				}
			case CARRAY_TEXT:
				{
					var p uintptr = (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr
					sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer(p + uintptr((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid-int64(1))*8)), -1, libc.UintptrFromInt32(-1))
					return SQLITE_OK

				}
			}

		}
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return SQLITE_OK
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func carrayRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* carray.c:238:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*carray_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func carrayEof(tls *libc.TLS, cur uintptr) int32 { /* carray.c:248:12: */
	var pCur uintptr = cur
	return libc.Bool32((*carray_cursor)(unsafe.Pointer(pCur)).FiRowid > (*carray_cursor)(unsafe.Pointer(pCur)).FiCnt)
}

// This method is called to "rewind" the carray_cursor object back
// to the first row of output.
func carrayFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* carray.c:257:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = uintptr(0)
	(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = int64(0)
	switch idxNum {
	case 1:
		{
			var pBind uintptr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv)), ts+4048 /* "carray-bind" */)
			if pBind == uintptr(0) {
				break
			}
			(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = (*carray_bind)(unsafe.Pointer(pBind)).FaData
			(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = sqlite3_int64((*carray_bind)(unsafe.Pointer(pBind)).FnData)
			(*carray_cursor)(unsafe.Pointer(pCur)).FeType = uint8((*carray_bind)(unsafe.Pointer(pBind)).FmFlags & 0x03)
			break

		}
	case 2:
		fallthrough
	case 3:
		{
			(*carray_cursor)(unsafe.Pointer(pCur)).FpPtr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv)), ts+4060 /* "carray" */)
			(*carray_cursor)(unsafe.Pointer(pCur)).FiCnt = func() int64 {
				if (*carray_cursor)(unsafe.Pointer(pCur)).FpPtr != 0 {
					return sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
				}
				return int64(0)
			}()
			if idxNum < 3 {
				(*carray_cursor)(unsafe.Pointer(pCur)).FeType = uint8(CARRAY_INT32)
			} else {
				var i uint8
				var zType uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
				for i = uint8(0); uint64(i) < uint64(unsafe.Sizeof(azType))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
					if sqlite3.Xsqlite3_stricmp(tls, zType, azType[i]) == 0 {
						break
					}
				}
				if uint64(i) >= uint64(unsafe.Sizeof(azType))/uint64(unsafe.Sizeof(uintptr(0))) {
					(*sqlite3_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
						ts+4067 /* "unknown datatype..." */, libc.VaList(bp, zType))
					return SQLITE_ERROR
				} else {
					(*carray_cursor)(unsafe.Pointer(pCur)).FeType = i
				}
			}
			break

		}
	}
	(*carray_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the carray virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// idxNum is:
//
//    1    If only the pointer= constraint exists.  In this case, the
//         parameter must be bound using sqlite3_carray_bind().
//
//    2    if the pointer= and count= constraints exist.
//
//    3    if the ctype= constraint also exists.
//
// idxNum is 0 otherwise and carray becomes an empty table.
func carrayBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* carray.c:321:12: */
	var i int32             // Loop over constraints
	var ptrIdx int32 = -1   // Index of the pointer= constraint, or -1 if none
	var cntIdx int32 = -1   // Index of the count= constraint, or -1 if none
	var ctypeIdx int32 = -1 // Index of the ctype= constraint, or -1 if none

	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case CARRAY_COLUMN_POINTER:
			ptrIdx = i
			break
		case CARRAY_COLUMN_COUNT:
			cntIdx = i
			break
		case CARRAY_COLUMN_CTYPE:
			ctypeIdx = i
			break
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if ptrIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ptrIdx)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(100)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
		if cntIdx >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).FargvIndex = 2
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(cntIdx)*8)).Fomit = uint8(1)
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
			if ctypeIdx >= 0 {
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).FargvIndex = 3
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ctypeIdx)*8)).Fomit = uint8(1)
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 3
			}
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
	}
	return SQLITE_OK
}

// This following structure defines all the methods for the
// carray virtual table.
var carrayModule = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* carray.c:375:23 */

// Destructor for the carray_bind object
func carrayBindDel(tls *libc.TLS, pPtr uintptr) { /* carray.c:401:13: */
	var p uintptr = pPtr
	if (*carray_bind)(unsafe.Pointer(p)).FxDel != uintptr(0) {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*carray_bind)(unsafe.Pointer(p)).FxDel})).f(tls, (*carray_bind)(unsafe.Pointer(p)).FaData)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

// Invoke this interface in order to bind to the single-argument
// version of CARRAY().
func sqlite3_carray_bind(tls *libc.TLS, pStmt uintptr, idx int32, aData uintptr, nData int32, mFlags int32, xDestroy uintptr) int32 { /* carray.c:413:16: */
	var pNew uintptr
	var i int32
	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(carray_bind{})))
	if pNew == uintptr(0) {
		if xDestroy != uintptr(0) && xDestroy != libc.UintptrFromInt32(-1) {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{xDestroy})).f(tls, aData)
		}
		return SQLITE_NOMEM
	}
	(*carray_bind)(unsafe.Pointer(pNew)).FnData = nData
	(*carray_bind)(unsafe.Pointer(pNew)).FmFlags = mFlags
	if xDestroy == libc.UintptrFromInt32(-1) {
		var sz sqlite3_int64 = sqlite3_int64(nData)
		switch mFlags & 0x03 {
		case CARRAY_INT32:
			sz = sz * int64(4)
			break
			fallthrough
		case CARRAY_INT64:
			sz = sz * int64(8)
			break
			fallthrough
		case CARRAY_DOUBLE:
			sz = sz * int64(8)
			break
			fallthrough
		case CARRAY_TEXT:
			sz = int64(uint64(sz) * uint64(unsafe.Sizeof(uintptr(0))))
			break
		}
		if mFlags&0x03 == CARRAY_TEXT {
			for i = 0; i < nData; i++ {
				var z uintptr = *(*uintptr)(unsafe.Pointer(aData + uintptr(i)*8))
				if z != 0 {
					sz = sqlite3_int64(uint64(sz) + uint64(libc.Xstrlen(tls, z)+uint64(1)))
				}
			}
		}
		(*carray_bind)(unsafe.Pointer(pNew)).FaData = sqlite3.Xsqlite3_malloc64(tls, uint64(sz))
		if (*carray_bind)(unsafe.Pointer(pNew)).FaData == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, pNew)
			return SQLITE_NOMEM
		}
		if mFlags&0x03 == CARRAY_TEXT {
			var az uintptr = (*carray_bind)(unsafe.Pointer(pNew)).FaData
			var z uintptr = az + uintptr(nData)*8
			for i = 0; i < nData; i++ {
				var zData uintptr = *(*uintptr)(unsafe.Pointer(aData + uintptr(i)*8))
				var n sqlite3_int64
				if zData == uintptr(0) {
					*(*uintptr)(unsafe.Pointer(az + uintptr(i)*8)) = uintptr(0)
					continue
				}
				*(*uintptr)(unsafe.Pointer(az + uintptr(i)*8)) = z
				n = sqlite3_int64(libc.Xstrlen(tls, zData))
				libc.Xmemcpy(tls, z, zData, uint64(n+int64(1)))
				z += uintptr(n + int64(1))
			}
		} else {
			libc.Xmemcpy(tls, (*carray_bind)(unsafe.Pointer(pNew)).FaData, aData, uint64(sz))
		}
		(*carray_bind)(unsafe.Pointer(pNew)).FxDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))
	} else {
		(*carray_bind)(unsafe.Pointer(pNew)).FaData = aData
		(*carray_bind)(unsafe.Pointer(pNew)).FxDel = xDestroy
	}
	return sqlite3.Xsqlite3_bind_pointer(tls, pStmt, idx, pNew, ts+4048 /* "carray-bind" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{carrayBindDel})))
}

// For testing purpose in the TCL test harness, we need a method for
// setting the pointer value.  The inttoptr(X) SQL function accomplishes
// this.  Tcl script will bind an integer to X and the inttoptr() SQL
// function will use sqlite3_result_pointer() to convert that integer into
// a pointer.
//
// This is for testing on TCL only.
func inttoptrFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* carray.c:488:13: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var p uintptr at bp, 8

	// var i64 sqlite3_int64 at bp+8, 8

	*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* i64 */)) = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if uint64(unsafe.Sizeof(sqlite3_int64(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp /* &p */, bp+8 /* &i64 */, uint64(unsafe.Sizeof(uintptr(0))))
	} else {
		*(*int32)(unsafe.Pointer(bp + 16 /* i32 */)) = int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 8)) & int64(0xffffffff))
		libc.Xmemcpy(tls, bp /* &p */, bp+16 /* &i32 */, uint64(unsafe.Sizeof(uintptr(0))))
	}
	sqlite3.Xsqlite3_result_pointer(tls, context, *(*uintptr)(unsafe.Pointer(bp /* p */)), ts+4060 /* "carray" */, uintptr(0))
}

func sqlite3_carray_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* carray.c:508:16: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4060 /* "carray" */, uintptr(unsafe.Pointer(&carrayModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4088 /* "inttoptr" */, 1, SQLITE_UTF8, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{inttoptrFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Forward declaration of objects used by this utility
type CksmVfs = sqlite3_vfs1 /* cksumvfs.c:176:28 */
type CksmFile1 = struct {
	Fbase        sqlite3_file
	FzFName      uintptr
	FcomputeCksm int8
	FverifyCksm  int8
	FisWal       int8
	FinCkpt      int8
	F__ccgo_pad1 [4]byte
	FpPartner    uintptr
} /* cksumvfs.c:177:9 */

type CksmFile = CksmFile1 /* cksumvfs.c:177:25 */

// Useful datatype abbreviations
type u8 = uint8 /* cksumvfs.c:183:25 */

var cksm_vfs = sqlite3_vfs{
	FiVersion:          3,         // szOsFile (set when registered)
	FmxPathname:        1024,      // pNext
	FzName:             ts + 4097, /* "cksmvfs" */ /* pAppData (set when registered) */
	FxOpen:             0,         // xOpen
	FxDelete:           0,         // xDelete
	FxAccess:           0,         // xAccess
	FxFullPathname:     0,         // xFullPathname
	FxDlOpen:           0,         // xDlOpen
	FxDlError:          0,         // xDlError
	FxDlSym:            0,         // xDlSym
	FxDlClose:          0,         // xDlClose
	FxRandomness:       0,         // xRandomness
	FxSleep:            0,         // xSleep
	FxCurrentTime:      0,         // xCurrentTime
	FxGetLastError:     0,         // xGetLastError
	FxCurrentTimeInt64: 0,         // xCurrentTimeInt64
	FxSetSystemCall:    0,         // xSetSystemCall
	FxGetSystemCall:    0,         // xGetSystemCall
	FxNextSystemCall:   0,         // xNextSystemCall
} /* cksumvfs.c:247:20 */

var cksm_io_methods = sqlite3_io_methods{
	FiVersion:               3, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
	FxFetch:                 0, // xFetch
	FxUnfetch:               0, // xUnfetch
} /* cksumvfs.c:272:33 */

// Do byte swapping on a unsigned 32-bit integer

// Compute a checksum on a buffer
func cksmCompute(tls *libc.TLS, a uintptr, nByte int32, aOut uintptr) { /* cksumvfs.c:301:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) = u32(0)
	*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) = u32(0)
	var aData uintptr = a
	var aEnd uintptr = a + uintptr(nByte)
	*(*u32)(unsafe.Pointer(bp /* x */)) = u32(1)

	if 1 == int32(*(*u8)(unsafe.Pointer(bp))) {
		// Little-endian
		for ok := true; ok; ok = aData < aEnd {
			*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) += *(*u32)(unsafe.Pointer(libc.PostIncUintptr(&aData, 4))) + *(*u32)(unsafe.Pointer(bp + 8))
			*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) += *(*u32)(unsafe.Pointer(libc.PostIncUintptr(&aData, 4))) + *(*u32)(unsafe.Pointer(bp + 4))
		}
	} else {
		// Big-endian
		for ok1 := true; ok1; ok1 = aData < aEnd {
			*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) += *(*u32)(unsafe.Pointer(aData))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(aData))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(aData))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(aData))&0xFF000000>>24 + *(*u32)(unsafe.Pointer(bp + 8))
			*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) += *(*u32)(unsafe.Pointer(aData + 1*4))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(aData + 1*4))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(aData + 1*4))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(aData + 1*4))&0xFF000000>>24 + *(*u32)(unsafe.Pointer(bp + 4))
			aData += 4 * uintptr(2)
		}
		*(*u32)(unsafe.Pointer(bp + 4 /* s1 */)) = *(*u32)(unsafe.Pointer(bp + 4))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(bp + 4))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(bp + 4))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(bp + 4))&0xFF000000>>24
		*(*u32)(unsafe.Pointer(bp + 8 /* s2 */)) = *(*u32)(unsafe.Pointer(bp + 8))&u32(0x000000FF)<<24 + *(*u32)(unsafe.Pointer(bp + 8))&u32(0x0000FF00)<<8 + *(*u32)(unsafe.Pointer(bp + 8))&u32(0x00FF0000)>>8 + *(*u32)(unsafe.Pointer(bp + 8))&0xFF000000>>24
	}
	libc.Xmemcpy(tls, aOut, bp+4 /* &s1 */, uint64(4))
	libc.Xmemcpy(tls, aOut+uintptr(4), bp+8 /* &s2 */, uint64(4))
}

// SQL function:    verify_checksum(BLOB)
//
// Return 0 or 1 if the checksum is invalid or valid.  Or return
// NULL if the input is not a BLOB that is the right size for a
// database page.
func cksmVerifyFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* cksumvfs.c:342:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var nByte int32
	var data uintptr
	// var cksum [8]u8 at bp, 8

	data = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if data == uintptr(0) {
		return
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_BLOB {
		return
	}
	nByte = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if nByte < 512 || nByte > 65536 || nByte&(nByte-1) != 0 {
		return
	}
	cksmCompute(tls, data, nByte-8, bp /* &cksum[0] */)
	sqlite3.Xsqlite3_result_int(tls, context, libc.Bool32(libc.Xmemcmp(tls, data+uintptr(nByte)-uintptr(8), bp, uint64(8)) == 0))
}

// Close a cksm-file.
func cksmClose(tls *libc.TLS, pFile uintptr) int32 { /* cksumvfs.c:397:12: */
	var p uintptr = pFile
	if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {

		(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FpPartner = uintptr(0)
		(*CksmFile)(unsafe.Pointer(p)).FpPartner = uintptr(0)
	}
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxClose})).f(tls, pFile)
}

// Set the computeCkSm and verifyCksm flags, if they need to be
// changed.
func cksmSetFlags(tls *libc.TLS, p uintptr, hasCorrectReserveSize int32) { /* cksumvfs.c:412:13: */
	if hasCorrectReserveSize != int32((*CksmFile)(unsafe.Pointer(p)).FcomputeCksm) {
		(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = libc.AssignPtrInt8(p+17, int8(hasCorrectReserveSize))
		if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FverifyCksm = int8(hasCorrectReserveSize)
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FcomputeCksm = int8(hasCorrectReserveSize)
		}
	}
}

// Read data from a cksm-file.
func cksmRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* cksumvfs.c:425:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*32
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxRead})).f(tls, pFile, zBuf, iAmt, iOfst)
	if rc == SQLITE_OK {
		if iOfst == int64(0) && iAmt >= 100 && (libc.Xmemcmp(tls, zBuf, ts+3288, uint64(16)) == 0 || libc.Xmemcmp(tls, zBuf, ts+4105, uint64(3)) == 0) {
			var d uintptr = zBuf
			var hasCorrectReserveSize int8 = int8(libc.Bool32(int32(*(*u8)(unsafe.Pointer(d + 20))) == 8))
			cksmSetFlags(tls, p, int32(hasCorrectReserveSize))
		}
		// Verify the checksum if
		//    (1) the size indicates that we are dealing with a complete
		//        database page
		//    (2) checksum verification is enabled
		//    (3) we are not in the middle of checkpoint
		if iAmt >= 512 &&
			(*CksmFile)(unsafe.Pointer(p)).FverifyCksm != 0 &&
			!(int32((*CksmFile)(unsafe.Pointer(p)).FinCkpt) != 0) {
			// var cksum [8]u8 at bp+16, 8

			cksmCompute(tls, zBuf, iAmt-8, bp+16 /* &cksum[0] */)
			if libc.Xmemcmp(tls, zBuf+uintptr(iAmt)-uintptr(8), bp+16, uint64(8)) != 0 {
				sqlite3.Xsqlite3_log(tls, SQLITE_IOERR|int32(32)<<8,
					ts+4109, /* "checksum fault o..." */
					libc.VaList(bp, iOfst, (*CksmFile)(unsafe.Pointer(p)).FzFName))
				rc = SQLITE_IOERR | int32(32)<<8
			}
		}
	}
	return rc
}

// Write data to a cksm-file.
func cksmWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* cksumvfs.c:469:12: */
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*32
	if iOfst == int64(0) && iAmt >= 100 && (libc.Xmemcmp(tls, zBuf, ts+3288, uint64(16)) == 0 || libc.Xmemcmp(tls, zBuf, ts+4105, uint64(3)) == 0) {
		var d uintptr = zBuf
		var hasCorrectReserveSize int8 = int8(libc.Bool32(int32(*(*u8)(unsafe.Pointer(d + 20))) == 8))
		cksmSetFlags(tls, p, int32(hasCorrectReserveSize))
	}
	// If the write size is appropriate for a database page and if
	// checksums where ever enabled, then it will be safe to compute
	// the checksums.  The reserve byte size might have increased, but
	// it will never decrease.  And because it cannot decrease, the
	// checksum will not overwrite anything.
	if iAmt >= 512 &&
		(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0 &&
		!(int32((*CksmFile)(unsafe.Pointer(p)).FinCkpt) != 0) {
		cksmCompute(tls, zBuf, iAmt-8, zBuf+uintptr(iAmt)-uintptr(8))
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxWrite})).f(tls, pFile, zBuf, iAmt, iOfst)
}

// Truncate a cksm-file.
func cksmTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* cksumvfs.c:502:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxTruncate})).f(tls, pFile, size)
}

// Sync a cksm-file.
func cksmSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* cksumvfs.c:510:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSync})).f(tls, pFile, flags)
}

// Return the current file-size of a cksm-file.
func cksmFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* cksumvfs.c:518:12: */
	var p uintptr = pFile
	pFile = p + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFileSize})).f(tls, pFile, pSize)
}

// Lock a cksm-file.
func cksmLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* cksumvfs.c:527:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxLock})).f(tls, pFile, eLock)
}

// Unlock a cksm-file.
func cksmUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* cksumvfs.c:535:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnlock})).f(tls, pFile, eLock)
}

// Check if another file-handle holds a RESERVED lock on a cksm-file.
func cksmCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* cksumvfs.c:543:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxCheckReservedLock})).f(tls, pFile, pResOut)
}

// File control method. For custom operations on a cksm-file.
func cksmFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* cksumvfs.c:551:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	var p uintptr = pFile
	pFile = pFile + uintptr(1)*32
	if op == SQLITE_FCNTL_PRAGMA {
		var azArg uintptr = pArg

		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(azArg + 1*8)), ts+4144) == 0 {
			var zArg uintptr = *(*uintptr)(unsafe.Pointer(azArg + 2*8))
			if zArg != uintptr(0) {
				if int32(*(*int8)(unsafe.Pointer(zArg))) >= '1' && int32(*(*int8)(unsafe.Pointer(zArg))) <= '9' ||
					sqlite3.Xsqlite3_strlike(tls, ts+4166, zArg, uint32(0)) == 0 ||
					sqlite3.Xsqlite3_stricmp(tls, ts+4174, zArg) == 0 ||
					sqlite3.Xsqlite3_stricmp(tls, ts+4178, zArg) == 0 {
					(*CksmFile)(unsafe.Pointer(p)).FverifyCksm = (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm
				} else {
					(*CksmFile)(unsafe.Pointer(p)).FverifyCksm = int8(0)
				}
				if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
					(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FverifyCksm = (*CksmFile)(unsafe.Pointer(p)).FverifyCksm
				}
			}
			*(*uintptr)(unsafe.Pointer(azArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+1333 /* "%d" */, libc.VaList(bp, int32((*CksmFile)(unsafe.Pointer(p)).FverifyCksm)))
			return SQLITE_OK
		} else if (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0 && *(*uintptr)(unsafe.Pointer(azArg + 2*8)) != uintptr(0) &&
			sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(azArg + 1*8)), ts+4181) == 0 {
			// Do not allow page size changes on a checksum database
			return SQLITE_OK
		}
	} else if op == SQLITE_FCNTL_CKPT_START || op == SQLITE_FCNTL_CKPT_DONE {
		(*CksmFile)(unsafe.Pointer(p)).FinCkpt = int8(libc.Bool32(op == SQLITE_FCNTL_CKPT_START))
		if (*CksmFile)(unsafe.Pointer(p)).FpPartner != 0 {
			(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FinCkpt = (*CksmFile)(unsafe.Pointer(p)).FinCkpt
		}
	} else if op == SQLITE_FCNTL_CKSM_FILE {
		// This VFS needs to obtain a pointer to the corresponding database
		// file handle from within xOpen() calls to open wal files. To do this,
		// it uses the sqlite3_database_file_object() API to obtain a pointer
		// to the file-handle used by SQLite to access the db file. This is
		// fine if cksmvfs happens to be the top-level VFS, but not if there
		// are one or more wrapper VFS. To handle this case, this file-control
		// is used to extract the cksmvfs file-handle from any wrapper file
		// handle.
		var ppFile uintptr = pArg
		*(*uintptr)(unsafe.Pointer(ppFile)) = p
		return SQLITE_OK
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFileControl})).f(tls, pFile, op, pArg)
	if rc == SQLITE_OK && op == SQLITE_FCNTL_VFSNAME {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+4191 /* "cksm/%z" */, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Return the sector-size in bytes for a cksm-file.
func cksmSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* cksumvfs.c:605:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxSectorSize})).f(tls, pFile)
}

// Return the device characteristic flags supported by a cksm-file.
func cksmDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* cksumvfs.c:613:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxDeviceCharacteristics})).f(tls, pFile)
}

// Create a shared memory file mapping
func cksmShmMap(tls *libc.TLS, pFile uintptr, iPg int32, pgsz int32, bExtend int32, pp uintptr) int32 { /* cksumvfs.c:619:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmMap})).f(tls, pFile, iPg, pgsz, bExtend, pp)
}

// Perform locking on a shared-memory segment
func cksmShmLock(tls *libc.TLS, pFile uintptr, offset int32, n int32, flags int32) int32 { /* cksumvfs.c:631:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmLock})).f(tls, pFile, offset, n, flags)
}

// Memory barrier operation on shared memory
func cksmShmBarrier(tls *libc.TLS, pFile uintptr) { /* cksumvfs.c:637:13: */
	pFile = pFile + uintptr(1)*32
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmBarrier})).f(tls, pFile)
}

// Unmap a shared memory segment
func cksmShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* cksumvfs.c:643:12: */
	pFile = pFile + uintptr(1)*32
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxShmUnmap})).f(tls, pFile, deleteFlag)
}

// Fetch a page of a memory-mapped file
func cksmFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 { /* cksumvfs.c:649:12: */
	var p uintptr = pFile
	if (*CksmFile)(unsafe.Pointer(p)).FcomputeCksm != 0 {
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		return SQLITE_OK
	}
	pFile = pFile + uintptr(1)*32
	if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FiVersion > 2 && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFetch != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxFetch})).f(tls, pFile, iOfst, iAmt, pp)
	}
	*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
	return SQLITE_OK
}

// Release a memory-mapped page
func cksmUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, pPage uintptr) int32 { /* cksumvfs.c:669:12: */
	pFile = pFile + uintptr(1)*32
	if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FiVersion > 2 && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnfetch != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)).FxUnfetch})).f(tls, pFile, iOfst, pPage)
	}
	return SQLITE_OK
}

// Open a cksm file handle.
func cksmOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* cksumvfs.c:680:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var pSubFile uintptr
	var pSubVfs uintptr
	var rc int32
	// var pDb uintptr at bp, 8

	pSubVfs = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if !(flags&(SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_WAL) == 0) {
		goto __1
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pSubVfs)).FxOpen})).f(tls, pSubVfs, zName, pFile, flags, pOutFlags)
__1:
	;
	p = pFile
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(CksmFile{})))
	pSubFile = pFile + uintptr(1)*32
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&cksm_io_methods))
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pSubVfs)).FxOpen})).f(tls, pSubVfs, zName, pSubFile, flags, pOutFlags)
	if !(rc != 0) {
		goto __2
	}
	goto cksm_open_done
__2:
	;
	if !(flags&SQLITE_OPEN_WAL != 0) {
		goto __3
	}
	*(*uintptr)(unsafe.Pointer(bp /* pDb */)) = sqlite3.Xsqlite3_database_file_object(tls, zName)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* pDb */)))).FpMethods)).FxFileControl})).f(tls, *(*uintptr)(unsafe.Pointer(bp /* pDb */)), SQLITE_FCNTL_CKSM_FILE, bp /* &pDb */)

	(*CksmFile)(unsafe.Pointer(p)).FpPartner = *(*uintptr)(unsafe.Pointer(bp /* pDb */))

	(*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FpPartner = p
	(*CksmFile)(unsafe.Pointer(p)).FisWal = int8(1)
	(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = (*CksmFile)(unsafe.Pointer((*CksmFile)(unsafe.Pointer(p)).FpPartner)).FcomputeCksm
	goto __4
__3:
	(*CksmFile)(unsafe.Pointer(p)).FisWal = int8(0)
	(*CksmFile)(unsafe.Pointer(p)).FcomputeCksm = int8(0)
__4:
	;
	(*CksmFile)(unsafe.Pointer(p)).FzFName = zName
cksm_open_done:
	if !(rc != 0) {
		goto __5
	}
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
__5:
	;
	return rc
}

// All other VFS methods are pass-thrus.
func cksmDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* cksumvfs.c:723:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDelete})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, dirSync)
}

func cksmAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* cksumvfs.c:726:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxAccess})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, flags, pResOut)
}

func cksmFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* cksumvfs.c:734:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxFullPathname})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath, nOut, zOut)
}

func cksmDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* cksumvfs.c:742:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlOpen})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zPath)
}

func cksmDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* cksumvfs.c:745:13: */
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zErrMsg)
}

func cksmDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* cksumvfs.c:748:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlSym})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, p, zSym)
}

func cksmDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* cksumvfs.c:751:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxDlClose})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pHandle)
}

func cksmRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* cksumvfs.c:754:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxRandomness})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nByte, zBufOut)
}

func cksmSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* cksumvfs.c:757:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSleep})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, nMicro)
}

func cksmCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* cksumvfs.c:760:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxCurrentTime})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, pTimeOut)
}

func cksmGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* cksumvfs.c:763:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetLastError})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, a, b)
}

func cksmCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 { /* cksumvfs.c:766:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pOrig uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	var rc int32

	if (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FxCurrentTimeInt64 != 0 {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrig)).FxCurrentTimeInt64})).f(tls, pOrig, p)
	} else {
		// var r float64 at bp, 8

		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrig)).FxCurrentTime})).f(tls, pOrig, bp /* &r */)
		*(*sqlite3_int64)(unsafe.Pointer(p)) = libc.Int64FromFloat64(*(*float64)(unsafe.Pointer(bp)) * 86400000.0)
	}
	return rc
}

func cksmSetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr, pCall sqlite3_syscall_ptr) int32 { /* cksumvfs.c:779:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxSetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName, pCall)
}

func cksmGetSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) sqlite3_syscall_ptr { /* cksumvfs.c:786:28: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxGetSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

func cksmNextSystemCall(tls *libc.TLS, pVfs uintptr, zName uintptr) uintptr { /* cksumvfs.c:792:19: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FxNextSystemCall})).f(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData, zName)
}

// Register the verify_checksum() SQL function.
func cksmRegisterFunc(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* cksumvfs.c:798:12: */
	var rc int32
	if db == uintptr(0) {
		return SQLITE_OK
	}
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4199 /* "verify_checksum" */, 1,
		SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{cksmVerifyFunc})), uintptr(0), uintptr(0))
	return rc
}

// Register the cksum VFS as the default VFS for the system.
// Also make arrangements to automatically register the "verify_checksum()"
// SQL function on each new database connection.
func cksmRegisterVfs(tls *libc.TLS) int32 { /* cksumvfs.c:821:12: */
	var rc int32 = SQLITE_OK
	var pOrig uintptr
	if sqlite3.Xsqlite3_vfs_find(tls, ts+4097) != uintptr(0) {
		return SQLITE_OK
	}
	pOrig = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if pOrig == uintptr(0) {
		return SQLITE_ERROR
	}
	cksm_vfs.FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pOrig)).FiVersion
	cksm_vfs.FpAppData = pOrig
	cksm_vfs.FszOsFile = int32(uint64((*sqlite3_vfs)(unsafe.Pointer(pOrig)).FszOsFile) + uint64(unsafe.Sizeof(CksmFile{})))
	rc = sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&cksm_vfs)), 1)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{cksmRegisterFunc})))
	}
	return rc
}

// This variant of the initializer runs when the extension is
// statically linked.
func sqlite3_register_cksumvfs(tls *libc.TLS, NotUsed uintptr) int32 { /* cksumvfs.c:841:5: */
	_ = NotUsed
	return cksmRegisterVfs(tls)
}

func sqlite3_unregister_cksumvfs(tls *libc.TLS) int32 { /* cksumvfs.c:845:5: */
	if sqlite3.Xsqlite3_vfs_find(tls, ts+4097) != 0 {
		sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&cksm_vfs)))
		sqlite3.Xsqlite3_cancel_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{cksmRegisterFunc})))
	}
	return SQLITE_OK
}

// POSIX.1-2001 specifies _tolower() and _toupper() to be macros equivalent to
// tolower() and toupper() respectively, minus extra checking to ensure that
// the argument is a lower or uppercase letter respectively.  We've chosen to
// implement these macros with the same error checking as tolower() and
// toupper() since this doesn't violate the specification itself, only its
// intent.  We purposely leave _tolower() and _toupper() undocumented to
// discourage their use.
//
// XXX isascii() and toascii() should similarly be undocumented.

// Forward declaration of objects used by this implementation
type closure_vtab1 = struct {
	Fbase          sqlite3_vtab
	FzDb           uintptr
	FzSelf         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	Fdb            uintptr
	FnCursor       int32
	F__ccgo_pad1   [4]byte
} /* closure.c:156:9 */

// POSIX.1-2001 specifies _tolower() and _toupper() to be macros equivalent to
// tolower() and toupper() respectively, minus extra checking to ensure that
// the argument is a lower or uppercase letter respectively.  We've chosen to
// implement these macros with the same error checking as tolower() and
// toupper() since this doesn't violate the specification itself, only its
// intent.  We purposely leave _tolower() and _toupper() undocumented to
// discourage their use.
//
// XXX isascii() and toascii() should similarly be undocumented.

// Forward declaration of objects used by this implementation
type closure_vtab = closure_vtab1 /* closure.c:156:29 */
type closure_cursor1 = struct {
	Fbase          sqlite3_vtab_cursor
	FpVtab         uintptr
	FzTableName    uintptr
	FzIdColumn     uintptr
	FzParentColumn uintptr
	FpCurrent      uintptr
	FpClosure      uintptr
} /* closure.c:157:9 */

type closure_cursor = closure_cursor1 /* closure.c:157:31 */
type closure_queue1 = struct {
	FpFirst uintptr
	FpLast  uintptr
} /* closure.c:158:9 */

type closure_queue = closure_queue1 /* closure.c:158:30 */
type closure_avl1 = struct {
	Fid          sqlite3_int64
	FiGeneration int32
	F__ccgo_pad1 [4]byte
	FpList       uintptr
	FpBefore     uintptr
	FpAfter      uintptr
	FpUp         uintptr
	Fheight      int16
	Fimbalance   int16
	F__ccgo_pad2 [4]byte
} /* closure.c:157:9 */

type closure_avl = closure_avl1 /* closure.c:159:28 */

// Recompute the closure_avl.height and closure_avl.imbalance fields for p.
// Assume that the children of p have correct heights.
func closureAvlRecomputeHeight(tls *libc.TLS, p uintptr) { /* closure.c:182:13: */
	var hBefore int16
	if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
		hBefore = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpBefore)).Fheight
	} else {
		hBefore = int16(0)
	}
	var hAfter int16
	if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
		hAfter = (*closure_avl)(unsafe.Pointer((*closure_avl)(unsafe.Pointer(p)).FpAfter)).Fheight
	} else {
		hAfter = int16(0)
	}
	(*closure_avl)(unsafe.Pointer(p)).Fimbalance = int16(int32(hBefore) - int32(hAfter)) // -: pAfter higher.  +: pBefore higher
	(*closure_avl)(unsafe.Pointer(p)).Fheight = int16(func() int32 {
		if int32(hBefore) > int32(hAfter) {
			return int32(hBefore)
		}
		return int32(hAfter)
	}() + 1)
}

//     P                B
//    / \              / **   B   Z    ==>     X   P
//  / \                  / ** X   Y                Y   Z
//
func closureAvlRotateBefore(tls *libc.TLS, pP uintptr) uintptr { /* closure.c:197:20: */
	var pB uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpBefore
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pB)).FpAfter
	(*closure_avl)(unsafe.Pointer(pB)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pB)).FpAfter = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pB
	(*closure_avl)(unsafe.Pointer(pP)).FpBefore = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pB)
	return pB
}

//     P                A
//    / \              / **   X   A    ==>     P   Z
//      / \          / **     Y   Z        X   Y
//
func closureAvlRotateAfter(tls *libc.TLS, pP uintptr) uintptr { /* closure.c:218:20: */
	var pA uintptr = (*closure_avl)(unsafe.Pointer(pP)).FpAfter
	var pY uintptr = (*closure_avl)(unsafe.Pointer(pA)).FpBefore
	(*closure_avl)(unsafe.Pointer(pA)).FpUp = (*closure_avl)(unsafe.Pointer(pP)).FpUp
	(*closure_avl)(unsafe.Pointer(pA)).FpBefore = pP
	(*closure_avl)(unsafe.Pointer(pP)).FpUp = pA
	(*closure_avl)(unsafe.Pointer(pP)).FpAfter = pY
	if pY != 0 {
		(*closure_avl)(unsafe.Pointer(pY)).FpUp = pP
	}
	closureAvlRecomputeHeight(tls, pP)
	closureAvlRecomputeHeight(tls, pA)
	return pA
}

// Return a pointer to the pBefore or pAfter pointer in the parent
// of p that points to p.  Or if p is the root node, return pp.
func closureAvlFromPtr(tls *libc.TLS, p uintptr, pp uintptr) uintptr { /* closure.c:235:20: */
	var pUp uintptr = (*closure_avl)(unsafe.Pointer(p)).FpUp
	if pUp == uintptr(0) {
		return pp
	}
	if (*closure_avl)(unsafe.Pointer(pUp)).FpAfter == p {
		return pUp + 32
	}
	return pUp + 24
}

// Rebalance all nodes starting with p and working up to the root.
// Return the new root.
func closureAvlBalance(tls *libc.TLS, p uintptr) uintptr { /* closure.c:246:20: */
	bp := tls.Alloc(8)
	defer tls.Free(8)
	*(*uintptr)(unsafe.Pointer(bp)) = p

	var pTop uintptr = *(*uintptr)(unsafe.Pointer(bp /* p */))
	var pp uintptr
	for *(*uintptr)(unsafe.Pointer(bp)) != 0 {
		closureAvlRecomputeHeight(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)))
		if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) >= 2 {
			var pB uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore
			if int32((*closure_avl)(unsafe.Pointer(pB)).Fimbalance) < 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpBefore = closureAvlRotateAfter(tls, pB)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, closureAvlRotateBefore(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		} else if int32((*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fimbalance) <= -2 {
			var pA uintptr = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter
			if int32((*closure_avl)(unsafe.Pointer(pA)).Fimbalance) > 0 {
				(*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpAfter = closureAvlRotateBefore(tls, pA)
			}
			pp = closureAvlFromPtr(tls, *(*uintptr)(unsafe.Pointer(bp /* p */)), bp /* &p */)
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = libc.AssignPtrUintptr(pp, closureAvlRotateAfter(tls, *(*uintptr)(unsafe.Pointer(bp /* p */))))
		}
		pTop = *(*uintptr)(unsafe.Pointer(bp /* p */))
		*(*uintptr)(unsafe.Pointer(bp /* p */)) = (*closure_avl)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* p */)))).FpUp
	}
	return pTop
}

// Search the tree rooted at p for an entry with id.  Return a pointer
// to the entry or return NULL.
func closureAvlSearch(tls *libc.TLS, p uintptr, id sqlite3_int64) uintptr { /* closure.c:271:20: */
	for p != 0 && id != (*closure_avl)(unsafe.Pointer(p)).Fid {
		if id < (*closure_avl)(unsafe.Pointer(p)).Fid {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		} else {
			p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
		}
	}
	return p
}

// Find the first node (the one with the smallest key).
func closureAvlFirst(tls *libc.TLS, p uintptr) uintptr { /* closure.c:280:20: */
	if p != 0 {
		for (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
			p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
		}
	}
	return p
}

// Return the node with the next larger key after p.
func closureAvlNext(tls *libc.TLS, p uintptr) uintptr { /* closure.c:287:13: */
	var pPrev uintptr = uintptr(0)
	for p != 0 && (*closure_avl)(unsafe.Pointer(p)).FpAfter == pPrev {
		pPrev = p
		p = (*closure_avl)(unsafe.Pointer(p)).FpUp
	}
	if p != 0 && pPrev == uintptr(0) {
		p = closureAvlFirst(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter)
	}
	return p
}

// Insert a new node pNew.  Return NULL on success.  If the key is not
// unique, then do not perform the insert but instead leave pNew unchanged
// and return a pointer to an existing node with the same key.
func closureAvlInsert(tls *libc.TLS, ppHead uintptr, pNew uintptr) uintptr { /* closure.c:303:20: */
	var p uintptr = *(*uintptr)(unsafe.Pointer(ppHead))
	if p == uintptr(0) {
		p = pNew
		(*closure_avl)(unsafe.Pointer(pNew)).FpUp = uintptr(0)
	} else {
		for p != 0 {
			if (*closure_avl)(unsafe.Pointer(pNew)).Fid < (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpBefore != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpBefore
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpBefore = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else if (*closure_avl)(unsafe.Pointer(pNew)).Fid > (*closure_avl)(unsafe.Pointer(p)).Fid {
				if (*closure_avl)(unsafe.Pointer(p)).FpAfter != 0 {
					p = (*closure_avl)(unsafe.Pointer(p)).FpAfter
				} else {
					(*closure_avl)(unsafe.Pointer(p)).FpAfter = pNew
					(*closure_avl)(unsafe.Pointer(pNew)).FpUp = p
					break
				}
			} else {
				return p
			}
		}
	}
	(*closure_avl)(unsafe.Pointer(pNew)).FpBefore = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).FpAfter = uintptr(0)
	(*closure_avl)(unsafe.Pointer(pNew)).Fheight = int16(1)
	(*closure_avl)(unsafe.Pointer(pNew)).Fimbalance = int16(0)
	*(*uintptr)(unsafe.Pointer(ppHead)) = closureAvlBalance(tls, p)
	return uintptr(0)
}

// Walk the tree can call xDestroy on each node
func closureAvlDestroy(tls *libc.TLS, p uintptr, xDestroy uintptr) { /* closure.c:344:13: */
	if p != 0 {
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpBefore, xDestroy)
		closureAvlDestroy(tls, (*closure_avl)(unsafe.Pointer(p)).FpAfter, xDestroy)
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{xDestroy})).f(tls, p)
	}
}

// Add a node to the end of the queue
func queuePush(tls *libc.TLS, pQueue uintptr, pNode uintptr) { /* closure.c:389:13: */
	(*closure_avl)(unsafe.Pointer(pNode)).FpList = uintptr(0)
	if (*closure_queue)(unsafe.Pointer(pQueue)).FpLast != 0 {
		(*closure_avl)(unsafe.Pointer((*closure_queue)(unsafe.Pointer(pQueue)).FpLast)).FpList = pNode
	} else {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = pNode
	}
	(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = pNode
}

// Extract the oldest element (the front element) from the queue.
func queuePull(tls *libc.TLS, pQueue uintptr) uintptr { /* closure.c:402:20: */
	var p uintptr = (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst
	if p != 0 {
		(*closure_queue)(unsafe.Pointer(pQueue)).FpFirst = (*closure_avl)(unsafe.Pointer(p)).FpList
		if (*closure_queue)(unsafe.Pointer(pQueue)).FpFirst == uintptr(0) {
			(*closure_queue)(unsafe.Pointer(pQueue)).FpLast = uintptr(0)
		}
	}
	return p
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func closureDequote(tls *libc.TLS, zIn uintptr) uintptr { /* closure.c:424:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+int64(1)))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn)) // Quote character (if any )

		if int32(q) != '[' && int32(q) != '\'' && int32(q) != '"' && int32(q) != '`' {
			libc.Xmemcpy(tls, zOut, zIn, size_t(nIn+int64(1)))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

// Deallocate an closure_vtab object
func closureFree(tls *libc.TLS, p uintptr) { /* closure.c:453:13: */
	if p != 0 {
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzDb)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzSelf)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzTableName)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzIdColumn)
		sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(p)).FzParentColumn)
		libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(closure_vtab{})))
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// xDisconnect/xDestroy method for the closure module.
func closureDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* closure.c:468:12: */
	var p uintptr = pVtab

	closureFree(tls, p)
	return SQLITE_OK
}

// Check to see if the argument is of the form:
//
//       KEY = VALUE
//
// If it is, return a pointer to the first character of VALUE.
// If not, return NULL.  Spaces around the = are ignored.
func closureValueOfKey(tls *libc.TLS, zKey uintptr, zStr uintptr) uintptr { /* closure.c:483:19: */
	var nKey int32 = int32(libc.Xstrlen(tls, zKey))
	var nStr int32 = int32(libc.Xstrlen(tls, zStr))
	var i int32
	if nStr < nKey+1 {
		return uintptr(0)
	}
	if libc.Xmemcmp(tls, zStr, zKey, uint64(nKey)) != 0 {
		return uintptr(0)
	}
	for i = nKey; __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint64(X_CTYPE_S)) != 0; i++ {
	}
	if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) != '=' {
		return uintptr(0)
	}
	i++
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zStr + uintptr(i))))), uint64(X_CTYPE_S)) != 0 {
		i++
	}
	return zStr + uintptr(i)
}

// xConnect/xCreate method for the closure module. Arguments are:
//
//   argv[0]    -> module name  ("transitive_closure")
//   argv[1]    -> database name
//   argv[2]    -> table name
//   argv[3...] -> arguments
func closureConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* closure.c:504:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32     // Return code
	var pNew uintptr // New virtual table
	var zDb uintptr
	var zVal uintptr
	var i int32
	rc = SQLITE_OK
	pNew = uintptr(0)
	zDb = *(*uintptr)(unsafe.Pointer(argv + 1*8))

	_ = pAux
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_vtab{})))
	if !(pNew == uintptr(0)) {
		goto __1
	}
	return SQLITE_NOMEM
__1:
	;
	rc = SQLITE_NOMEM
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(closure_vtab{})))
	(*closure_vtab)(unsafe.Pointer(pNew)).Fdb = db
	(*closure_vtab)(unsafe.Pointer(pNew)).FzDb = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zDb))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzDb == uintptr(0)) {
		goto __2
	}
	goto closureConnectError
__2:
	;
	(*closure_vtab)(unsafe.Pointer(pNew)).FzSelf = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzSelf == uintptr(0)) {
		goto __3
	}
	goto closureConnectError
__3:
	;
	i = 3
__4:
	if !(i < argc) {
		goto __6
	}
	zVal = closureValueOfKey(tls, ts+4215 /* "tablename" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __7
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzTableName)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzTableName = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0)) {
		goto __8
	}
	goto closureConnectError
__8:
	;
	goto __5
__7:
	;
	zVal = closureValueOfKey(tls, ts+4225 /* "idcolumn" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __9
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzIdColumn == uintptr(0)) {
		goto __10
	}
	goto closureConnectError
__10:
	;
	goto __5
__9:
	;
	zVal = closureValueOfKey(tls, ts+4234 /* "parentcolumn" */, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	if !(zVal != 0) {
		goto __11
	}
	sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn)
	(*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn = closureDequote(tls, zVal)
	if !((*closure_vtab)(unsafe.Pointer(pNew)).FzParentColumn == uintptr(0)) {
		goto __12
	}
	goto closureConnectError
__12:
	;
	goto __5
__11:
	;
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3536 /* "unrecognized arg..." */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	closureFree(tls, pNew)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	return SQLITE_ERROR
	goto __5
__5:
	i++
	goto __4
	goto __6
__6:
	;
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,

		ts+4247 /* "CREATE TABLE x(i..." */)
	if !(rc != SQLITE_OK) {
		goto __13
	}
	closureFree(tls, pNew)
__13:
	;
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc

closureConnectError:
	closureFree(tls, pNew)
	return rc
}

// Open a new closure cursor.
func closureOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* closure.c:579:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(closure_cursor{})))
	(*closure_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	(*closure_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func closureClearCursor(tls *libc.TLS, pCur uintptr) { /* closure.c:595:13: */
	closureAvlDestroy(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn)
	sqlite3.Xsqlite3_free(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = uintptr(0)
	(*closure_cursor)(unsafe.Pointer(pCur)).FpClosure = uintptr(0)
}

// Close a closure cursor.
func closureClose(tls *libc.TLS, cur uintptr) int32 { /* closure.c:610:12: */
	var pCur uintptr = cur
	closureClearCursor(tls, pCur)
	(*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Advance a cursor to its next row of output
func closureNext(tls *libc.TLS, cur uintptr) int32 { /* closure.c:621:12: */
	var pCur uintptr = cur
	(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlNext(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)
	return SQLITE_OK
}

// Allocate and insert a node
func closureInsertNode(tls *libc.TLS, pQueue uintptr, pCur uintptr, id sqlite3_int64, iGeneration int32) int32 { /* closure.c:630:12: */
	var pNew uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(closure_avl{})))
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(closure_avl{})))
	(*closure_avl)(unsafe.Pointer(pNew)).Fid = id
	(*closure_avl)(unsafe.Pointer(pNew)).FiGeneration = iGeneration
	closureAvlInsert(tls, pCur+48, pNew)
	queuePush(tls, pQueue, pNew)
	return SQLITE_OK
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any closureColumn, closureRowid, or closureEof call.
//
// This routine actually computes the closure.
//
// See the comment at the beginning of closureBestIndex() for a
// description of the meaning of idxNum.  The idxStr parameter is
// not used.
func closureFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* closure.c:657:12: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*closure_cursor)(unsafe.Pointer(pCur)).FpVtab
	var iRoot sqlite3_int64
	var mxGen int32 = 999999999
	var zSql uintptr
	// var pStmt uintptr at bp+88, 8

	var pAvl uintptr
	var rc int32 = SQLITE_OK
	var zTableName uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName
	var zIdColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn
	var zParentColumn uintptr = (*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn
	// var sQueue closure_queue at bp+72, 16

	_ = idxStr // Unused parameter
	_ = argc   // Unused parameter
	closureClearCursor(tls, pCur)
	libc.Xmemset(tls, bp+72 /* &sQueue */, 0, uint64(unsafe.Sizeof(closure_queue{})))
	if idxNum&1 == 0 {
		// No root=$root in the WHERE clause.  Return an empty set
		return SQLITE_OK
	}
	iRoot = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if idxNum&0x000f0 != 0 {
		mxGen = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>4&0x0f)*8)))
		if idxNum&0x00002 != 0 {
			mxGen--
		}
	}
	if idxNum&0x00f00 != 0 {
		zTableName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>8&0x0f)*8)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zTableName))
	}
	if idxNum&0x0f000 != 0 {
		zIdColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>12&0x0f)*8)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zIdColumn))
	}
	if idxNum&0x0f0000 != 0 {
		zParentColumn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idxNum>>16&0x0f)*8)))
		(*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, zParentColumn))
	}

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+4337, /* "SELECT \"%w\".\"%w\"..." */
		libc.VaList(bp+24, zTableName, zIdColumn, zTableName, zTableName, zParentColumn))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, bp+88 /* &pStmt */, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != 0 {
			sqlite3.Xsqlite3_free(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg)
			(*closure_vtab)(unsafe.Pointer(pVtab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+64, sqlite3.Xsqlite3_errmsg(tls, (*closure_vtab)(unsafe.Pointer(pVtab)).Fdb)))
			return rc
		}
	}
	if rc == SQLITE_OK {
		rc = closureInsertNode(tls, bp+72 /* &sQueue */, pCur, iRoot, 0)
	}
	for libc.AssignUintptr(&pAvl, queuePull(tls, bp+72)) != uintptr(0) {
		if (*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration >= mxGen {
			continue
		}
		sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)), 1, (*closure_avl)(unsafe.Pointer(pAvl)).Fid)
		for rc == SQLITE_OK && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 88))) == SQLITE_ROW {
			if sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 88)), 0) == SQLITE_INTEGER {
				var iNew sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)), 0)
				if closureAvlSearch(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure, iNew) == uintptr(0) {
					rc = closureInsertNode(tls, bp+72 /* &sQueue */, pCur, iNew, (*closure_avl)(unsafe.Pointer(pAvl)).FiGeneration+1)
				}
			}
		}
		sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)))
	}
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)))
	if rc == SQLITE_OK {
		(*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent = closureAvlFirst(tls, (*closure_cursor)(unsafe.Pointer(pCur)).FpClosure)
	}

	return rc
}

// Only the word and distance columns have values.  All other columns
// return NULL
func closureColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* closure.c:743:12: */
	var pCur uintptr = cur
	switch i {
	case CLOSURE_COL_ID:
		{
			sqlite3.Xsqlite3_result_int64(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid)
			break

		}
	case CLOSURE_COL_DEPTH:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).FiGeneration)
			break

		}
	case CLOSURE_COL_ROOT:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	case CLOSURE_COL_TABLENAME:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzTableName
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzTableName
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	case CLOSURE_COL_IDCOLUMN:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzIdColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzIdColumn
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	case CLOSURE_COL_PARENTCOLUMN:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx,
				func() uintptr {
					if (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn != 0 {
						return (*closure_cursor)(unsafe.Pointer(pCur)).FzParentColumn
					}
					return (*closure_vtab)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpVtab)).FzParentColumn
				}(),
				-1, libc.UintptrFromInt32(-1))
			break

		}
	}
	return SQLITE_OK
}

// The rowid.  For the closure table, this is the same as the "id" column.
func closureRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* closure.c:783:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*closure_avl)(unsafe.Pointer((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent)).Fid
	return SQLITE_OK
}

// EOF indicator
func closureEof(tls *libc.TLS, cur uintptr) int32 { /* closure.c:792:12: */
	var pCur uintptr = cur
	return libc.Bool32((*closure_cursor)(unsafe.Pointer(pCur)).FpCurrent == uintptr(0))
}

// Search for terms of these forms:
//
//   (A)    root = $root
//   (B1)   depth < $depth
//   (B2)   depth <= $depth
//   (B3)   depth = $depth
//   (C)    tablename = $tablename
//   (D)    idcolumn = $idcolumn
//   (E)    parentcolumn = $parentcolumn
//
//
//
//   idxNum       meaning
//   ----------   ------------------------------------------------------
//   0x00000001   Term of the form (A) found
//   0x00000002   The term of bit-2 is like (B1)
//   0x000000f0   Index in filter.argv[] of $depth.  0 if not used.
//   0x00000f00   Index in filter.argv[] of $tablename.  0 if not used.
//   0x0000f000   Index in filter.argv[] of $idcolumn.  0 if not used
//   0x000f0000   Index in filter.argv[] of $parentcolumn.  0 if not used.
//
// There must be a term of type (A).  If there is not, then the index type
// is 0 and the query will return an empty set.
func closureBestIndex(tls *libc.TLS, pTab uintptr, pIdxInfo uintptr) int32 { /* closure.c:822:12: */
	var iPlan int32 = 0
	var i int32
	var idx int32 = 1
	var pConstraint uintptr
	var pVtab uintptr = pTab
	var rCost float64 = 10000000.0

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if iPlan&1 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_ROOT &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / 100.0
		}
		if iPlan&0x0000f0 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_DEPTH &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			iPlan = iPlan | idx<<4
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
				iPlan = iPlan | 0x000002
			}
			rCost = rCost / 5.0
		}
		if iPlan&0x000f00 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_TABLENAME &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | idx<<8
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / 5.0
		}
		if iPlan&0x00f000 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_IDCOLUMN &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | idx<<12
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}
		if iPlan&0x0f0000 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == CLOSURE_COL_PARENTCOLUMN &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | idx<<16
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = libc.PreIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if (*closure_vtab)(unsafe.Pointer(pVtab)).FzTableName == uintptr(0) && iPlan&0x000f00 == 0 ||
		(*closure_vtab)(unsafe.Pointer(pVtab)).FzIdColumn == uintptr(0) && iPlan&0x00f000 == 0 ||
		(*closure_vtab)(unsafe.Pointer(pVtab)).FzParentColumn == uintptr(0) && iPlan&0x0f0000 == 0 {
		// All of tablename, idcolumn, and parentcolumn must be specified
		// in either the CREATE VIRTUAL TABLE or in the WHERE clause constraints
		// or else the result is an empty set.
		iPlan = 0
	}
	if iPlan&1 == 0 {
		// If there is no usable "root=?" term, then set the index-type to 0.
		// Also clear any argvIndex variables already set. This is necessary
		// to prevent the core from throwing an "xBestIndex malfunction error"
		// error (because the argvIndex values are not contiguously assigned
		// starting from 1).
		rCost = rCost * 1e30
		i = 0
	__4:
		if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
			goto __6
		}
		{
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 0

		}
		goto __5
	__5:
		i++
		pConstraint += 12
		goto __4
		goto __6
	__6:
		;
		iPlan = 0
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == CLOSURE_COL_ID &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return SQLITE_OK
}

// A virtual table module that implements the "transitive_closure".
var closureModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* closure.c:918:23 */

// Register the closure virtual table
func sqlite3_closure_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* closure.c:953:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4383 /* "transitive_closu..." */, uintptr(unsafe.Pointer(&closureModule)), uintptr(0))
	return rc
}

// See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
// B.8.2.7 for the rationale behind the *_unlocked() macros.

// A macro to hint to the compiler that a function should not be
// inlined.

// Max size of the error message in a CsvReader

// Size of the CsvReader input buffer

// A context object used when read a CSV file.
type CsvReader1 = struct {
	Fin          uintptr
	Fz           uintptr
	Fn           int32
	FnAlloc      int32
	FnLine       int32
	FbNotFirst   int32
	FcTerm       int32
	F__ccgo_pad1 [4]byte
	FiIn         size_t
	FnIn         size_t
	FzIn         uintptr
	FzErr        [200]int8
} /* csv.c:73:9 */

// See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
// B.8.2.7 for the rationale behind the *_unlocked() macros.

// A macro to hint to the compiler that a function should not be
// inlined.

// Max size of the error message in a CsvReader

// Size of the CsvReader input buffer

// A context object used when read a CSV file.
type CsvReader = CsvReader1 /* csv.c:73:26 */

// Initialize a CsvReader object
func csv_reader_init(tls *libc.TLS, p uintptr) { /* csv.c:89:13: */
	(*CsvReader)(unsafe.Pointer(p)).Fin = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fz = uintptr(0)
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	(*CsvReader)(unsafe.Pointer(p)).FnAlloc = 0
	(*CsvReader)(unsafe.Pointer(p)).FnLine = 0
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 0
	(*CsvReader)(unsafe.Pointer(p)).FnIn = uint64(0)
	(*CsvReader)(unsafe.Pointer(p)).FzIn = uintptr(0)
	*(*int8)(unsafe.Pointer(p + 64)) = int8(0)
}

// Close and reset a CsvReader object
func csv_reader_reset(tls *libc.TLS, p uintptr) { /* csv.c:102:13: */
	if (*CsvReader)(unsafe.Pointer(p)).Fin != 0 {
		libc.Xfclose(tls, (*CsvReader)(unsafe.Pointer(p)).Fin)
		sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
	}
	sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).Fz)
	csv_reader_init(tls, p)
}

// Report an error on a CsvReader
func csv_errmsg(tls *libc.TLS, p uintptr, zFormat uintptr, va uintptr) { /* csv.c:112:13: */
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_vsnprintf(tls, CSV_MXERR, p+64, zFormat, ap)
	_ = ap
}

// Open the file associated with a CsvReader
// Return the number of errors.
func csv_reader_open(tls *libc.TLS, p uintptr, zFilename uintptr, zData uintptr) int32 { /* csv.c:122:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if zFilename != 0 {
		(*CsvReader)(unsafe.Pointer(p)).FzIn = sqlite3.Xsqlite3_malloc(tls, CSV_INBUFSZ)
		if (*CsvReader)(unsafe.Pointer(p)).FzIn == uintptr(0) {
			csv_errmsg(tls, p, ts+2069 /* "out of memory" */, 0)
			return 1
		}
		(*CsvReader)(unsafe.Pointer(p)).Fin = libc.Xfopen(tls, zFilename, ts+4402 /* "rb" */)
		if (*CsvReader)(unsafe.Pointer(p)).Fin == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn)
			csv_reader_reset(tls, p)
			csv_errmsg(tls, p, ts+4405 /* "cannot open '%s'..." */, libc.VaList(bp, zFilename))
			return 1
		}
	} else {

		(*CsvReader)(unsafe.Pointer(p)).FzIn = zData
		(*CsvReader)(unsafe.Pointer(p)).FnIn = libc.Xstrlen(tls, zData)
	}
	return 0
}

// The input buffer has overflowed.  Refill the input buffer, then
// return the next character
func csv_getc_refill(tls *libc.TLS, p uintptr) int32 { /* csv.c:151:25: */
	var got size_t

	// Only called on an empty input buffer
	// Only called if reading froma file

	got = libc.Xfread(tls, (*CsvReader)(unsafe.Pointer(p)).FzIn, uint64(1), uint64(CSV_INBUFSZ), (*CsvReader)(unsafe.Pointer(p)).Fin)
	if got == uint64(0) {
		return -1
	}
	(*CsvReader)(unsafe.Pointer(p)).FnIn = got
	(*CsvReader)(unsafe.Pointer(p)).FiIn = uint64(1)
	return int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).FzIn)))
}

// Return the next character of input.  Return EOF at end of input.
func csv_getc(tls *libc.TLS, p uintptr) int32 { /* csv.c:165:12: */
	if (*CsvReader)(unsafe.Pointer(p)).FiIn >= (*CsvReader)(unsafe.Pointer(p)).FnIn {
		if (*CsvReader)(unsafe.Pointer(p)).Fin != uintptr(0) {
			return csv_getc_refill(tls, p)
		}
		return -1
	}
	return int32(*(*uint8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).FzIn + uintptr(libc.PostIncUint64(&(*CsvReader)(unsafe.Pointer(p)).FiIn, 1)))))
}

// Increase the size of p->z and append character c to the end.
// Return 0 on success and non-zero if there is an OOM error
func csv_resize_and_append(tls *libc.TLS, p uintptr, c int8) int32 { /* csv.c:175:25: */
	var zNew uintptr
	var nNew int32 = (*CsvReader)(unsafe.Pointer(p)).FnAlloc*2 + 100
	zNew = sqlite3.Xsqlite3_realloc64(tls, (*CsvReader)(unsafe.Pointer(p)).Fz, uint64(nNew))
	if zNew != 0 {
		(*CsvReader)(unsafe.Pointer(p)).Fz = zNew
		(*CsvReader)(unsafe.Pointer(p)).FnAlloc = nNew
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
		return 0
	} else {
		csv_errmsg(tls, p, ts+2069 /* "out of memory" */, 0)
		return 1
	}
	return int32(0)
}

// Append a single character to the CsvReader.z[] array.
// Return 0 on success and non-zero if there is an OOM error
func csv_append(tls *libc.TLS, p uintptr, c int8) int32 { /* csv.c:192:12: */
	if (*CsvReader)(unsafe.Pointer(p)).Fn >= (*CsvReader)(unsafe.Pointer(p)).FnAlloc-1 {
		return csv_resize_and_append(tls, p, c)
	}
	*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*CsvReader)(unsafe.Pointer(p)).Fn, 1)))) = c
	return 0
}

// Read a single field of CSV text.  Compatible with rfc4180 and extended
// with the option of having a separator other than ",".
//
//   +  Input comes from p->in.
//   +  Store results in p->z of length p->n.  Space to hold p->z comes
//      from sqlite3_malloc64().
//   +  Keep track of the line number in p->nLine.
//   +  Store the character that terminates the field in p->cTerm.  Store
//      EOF on end-of-file.
//
// Return 0 at EOF or on OOM.  On EOF, the p->cTerm character will have
// been set to EOF.
func csv_read_one_field(tls *libc.TLS, p uintptr) uintptr { /* csv.c:211:13: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var c int32
	(*CsvReader)(unsafe.Pointer(p)).Fn = 0
	c = csv_getc(tls, p)
	if c == -1 {
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = -1
		return uintptr(0)
	}
	if c == '"' {
		var pc int32
		var ppc int32
		var startLine int32 = (*CsvReader)(unsafe.Pointer(p)).FnLine
		pc = libc.AssignInt32(&ppc, 0)
		for 1 != 0 {
			c = csv_getc(tls, p)
			if c <= '"' || pc == '"' {
				if c == '\n' {
					(*CsvReader)(unsafe.Pointer(p)).FnLine++
				}
				if c == '"' {
					if pc == '"' {
						pc = 0
						continue
					}
				}
				if c == ',' && pc == '"' ||
					c == '\n' && pc == '"' ||
					c == '\n' && pc == '\r' && ppc == '"' ||
					c == -1 && pc == '"' {
					for ok := true; ok; ok = int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn)))) != '"' {
						(*CsvReader)(unsafe.Pointer(p)).Fn--
					}
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
				if pc == '"' && c != '\r' {
					csv_errmsg(tls, p, ts+4434 /* "line %d: unescap..." */, libc.VaList(bp, (*CsvReader)(unsafe.Pointer(p)).FnLine, '"'))
					break
				}
				if c == -1 {
					csv_errmsg(tls, p, ts+4466, /* "line %d: untermi..." */
						libc.VaList(bp+16, startLine, '"'))
					(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
					break
				}
			}
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			ppc = pc
			pc = c
		}
	} else {
		// If this is the first field being parsed and it begins with the
		// UTF-8 BOM  (0xEF BB BF) then skip the BOM
		if c&0xff == 0xef && (*CsvReader)(unsafe.Pointer(p)).FbNotFirst == 0 {
			csv_append(tls, p, int8(c))
			c = csv_getc(tls, p)
			if c&0xff == 0xbb {
				csv_append(tls, p, int8(c))
				c = csv_getc(tls, p)
				if c&0xff == 0xbf {
					(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
					(*CsvReader)(unsafe.Pointer(p)).Fn = 0
					return csv_read_one_field(tls, p)
				}
			}
		}
		for c > ',' || c != -1 && c != ',' && c != '\n' {
			if csv_append(tls, p, int8(c)) != 0 {
				return uintptr(0)
			}
			c = csv_getc(tls, p)
		}
		if c == '\n' {
			(*CsvReader)(unsafe.Pointer(p)).FnLine++
			if (*CsvReader)(unsafe.Pointer(p)).Fn > 0 && int32(*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn-1)))) == '\r' {
				(*CsvReader)(unsafe.Pointer(p)).Fn--
			}
		}
		(*CsvReader)(unsafe.Pointer(p)).FcTerm = int32(int8(c))
	}
	if (*CsvReader)(unsafe.Pointer(p)).Fz != 0 {
		*(*int8)(unsafe.Pointer((*CsvReader)(unsafe.Pointer(p)).Fz + uintptr((*CsvReader)(unsafe.Pointer(p)).Fn))) = int8(0)
	}
	(*CsvReader)(unsafe.Pointer(p)).FbNotFirst = 1
	return (*CsvReader)(unsafe.Pointer(p)).Fz
}

// An instance of the CSV virtual table
type CsvTable1 = struct {
	Fbase      sqlite3_vtab
	FzFilename uintptr
	FzData     uintptr
	FiStart    int64
	FnCol      int32
	FtstFlags  uint32
} /* csv.c:307:9 */

// An instance of the CSV virtual table
type CsvTable = CsvTable1 /* csv.c:314:3 */

// Allowed values for tstFlags

// A cursor for the CSV virtual table
type CsvCursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	Frdr    CsvReader
	FazVal  uintptr
	FaLen   uintptr
	FiRowid sqlite3_int64
} /* csv.c:320:9 */

// Allowed values for tstFlags

// A cursor for the CSV virtual table
type CsvCursor = CsvCursor1 /* csv.c:326:3 */

// Transfer error message text from a reader into a CsvTable
func csv_xfer_error(tls *libc.TLS, pTab uintptr, pRdr uintptr) { /* csv.c:329:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg)
	(*CsvTable)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, pRdr+64))
}

// This method is the destructor fo a CsvTable object.
func csvtabDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* csv.c:337:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzFilename)
	sqlite3.Xsqlite3_free(tls, (*CsvTable)(unsafe.Pointer(p)).FzData)
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Skip leading whitespace.  Return a pointer to the first non-whitespace
// character, or to the zero terminator if the string has only whitespace
func csv_skip_whitespace(tls *libc.TLS, z uintptr) uintptr { /* csv.c:347:19: */
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(z)))), uint64(X_CTYPE_S)) != 0 {
		z++
	}
	return z
}

// Remove trailing whitespace from the end of string z[]
func csv_trim_whitespace(tls *libc.TLS, z uintptr) { /* csv.c:353:13: */
	var n size_t = libc.Xstrlen(tls, z)
	for n > uint64(0) && __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(z + uintptr(n))))), uint64(X_CTYPE_S)) != 0 {
		n--
	}
	*(*int8)(unsafe.Pointer(z + uintptr(n))) = int8(0)
}

// Dequote the string
func csv_dequote(tls *libc.TLS, z uintptr) { /* csv.c:360:13: */
	var j int32
	var cQuote int8 = *(*int8)(unsafe.Pointer(z))
	var i size_t
	var n size_t

	if int32(cQuote) != '\'' && int32(cQuote) != '"' {
		return
	}
	n = libc.Xstrlen(tls, z)
	if n < uint64(2) || int32(*(*int8)(unsafe.Pointer(z + uintptr(n-uint64(1))))) != int32(*(*int8)(unsafe.Pointer(z))) {
		return
	}
	i = uint64(1)
	j = 0
	for ; i < n-uint64(1); i++ {
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == int32(cQuote) && int32(*(*int8)(unsafe.Pointer(z + uintptr(i+uint64(1))))) == int32(cQuote) {
			i++
		}
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
}

// Check to see if the string is of the form:  "TAG = VALUE" with optional
// whitespace before and around tokens.  If it is, return a pointer to the
// first character of VALUE.  If it is not, return NULL.
func csv_parameter(tls *libc.TLS, zTag uintptr, nTag int32, z uintptr) uintptr { /* csv.c:379:19: */
	z = csv_skip_whitespace(tls, z)
	if libc.Xstrncmp(tls, zTag, z, uint64(nTag)) != 0 {
		return uintptr(0)
	}
	z = csv_skip_whitespace(tls, z+uintptr(nTag))
	if int32(*(*int8)(unsafe.Pointer(z))) != '=' {
		return uintptr(0)
	}
	return csv_skip_whitespace(tls, z+uintptr(1))
}

// Decode a parameter that requires a dequoted string.
//
// Return 1 if the parameter is seen, or 0 if not.  1 is returned
// even if there is an error.  If an error occurs, then an error message
// is left in p->zErr.  If there are no errors, p->zErr[0]==0.
func csv_string_parameter(tls *libc.TLS, p uintptr, zParam uintptr, zArg uintptr, pzVal uintptr) int32 { /* csv.c:393:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zValue uintptr
	zValue = csv_parameter(tls, zParam, int32(libc.Xstrlen(tls, zParam)), zArg)
	if zValue == uintptr(0) {
		return 0
	}
	*(*int8)(unsafe.Pointer(p + 64)) = int8(0)
	if *(*uintptr)(unsafe.Pointer(pzVal)) != 0 {
		csv_errmsg(tls, p, ts+4505 /* "more than one '%..." */, libc.VaList(bp, zParam))
		return 1
	}
	*(*uintptr)(unsafe.Pointer(pzVal)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zValue))
	if *(*uintptr)(unsafe.Pointer(pzVal)) == uintptr(0) {
		csv_errmsg(tls, p, ts+2069 /* "out of memory" */, 0)
		return 1
	}
	csv_trim_whitespace(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	csv_dequote(tls, *(*uintptr)(unsafe.Pointer(pzVal)))
	return 1
}

// Return 0 if the argument is false and 1 if it is true.  Return -1 if
// we cannot really tell.
func csv_boolean(tls *libc.TLS, z uintptr) int32 { /* csv.c:421:12: */
	if sqlite3.Xsqlite3_stricmp(tls, ts+4174, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4178, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4534, z) == 0 ||
		int32(*(*int8)(unsafe.Pointer(z))) == '1' && int32(*(*int8)(unsafe.Pointer(z + 1))) == 0 {
		return 1
	}
	if sqlite3.Xsqlite3_stricmp(tls, ts+4539, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4542, z) == 0 ||
		sqlite3.Xsqlite3_stricmp(tls, ts+4546, z) == 0 ||
		int32(*(*int8)(unsafe.Pointer(z))) == '0' && int32(*(*int8)(unsafe.Pointer(z + 1))) == 0 {
		return 0
	}
	return -1
}

// Check to see if the string is of the form:  "TAG = BOOLEAN" or just "TAG".
// If it is, set *pValue to be the value of the boolean ("true" if there is
// not "= BOOLEAN" component) and return non-zero.  If the input string
// does not begin with TAG, return zero.
func csv_boolean_parameter(tls *libc.TLS, zTag uintptr, nTag int32, z uintptr, pValue uintptr) int32 { /* csv.c:444:12: */
	var b int32
	z = csv_skip_whitespace(tls, z)
	if libc.Xstrncmp(tls, zTag, z, uint64(nTag)) != 0 {
		return 0
	}
	z = csv_skip_whitespace(tls, z+uintptr(nTag))
	if int32(*(*int8)(unsafe.Pointer(z))) == 0 {
		*(*int32)(unsafe.Pointer(pValue)) = 1
		return 1
	}
	if int32(*(*int8)(unsafe.Pointer(z))) != '=' {
		return 0
	}
	z = csv_skip_whitespace(tls, z+uintptr(1))
	b = csv_boolean(tls, z)
	if b >= 0 {
		*(*int32)(unsafe.Pointer(pValue)) = b
		return 1
	}
	return 0
}

// Parameters:
//    filename=FILENAME          Name of file containing CSV content
//    data=TEXT                  Direct CSV content.
//    schema=SCHEMA              Alternative CSV schema.
//    header=YES|NO              First row of CSV defines the names of
//                               columns if "yes".  Default "no".
//    columns=N                  Assume the CSV file contains N columns.
//
// Only available if compiled with SQLITE_TEST:
//
//    testflags=N                Bitmask of test flags.  Optional
//
// If schema= is omitted, then the columns are named "c0", "c1", "c2",
// and so forth.  If columns=N is omitted, then the file is opened and
// the number of columns in the first row is counted to determine the
// column count.  If header=YES, then the first row is skipped.
func csvtabConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* csv.c:486:12: */
	bp := tls.Alloc(372)
	defer tls.Free(372)

	var pNew uintptr  // The CsvTable object to construct
	var bHeader int32 // header= flags.  -1 means not seen yet
	var rc int32      // Result code from this routine
	var i int32
	var j int32        // Loop counters
	var tstFlags int32 // Value for testflags=N parameter
	// var b int32 at bp+368, 4
	// Value of a boolean parameter
	var nCol int32 // Value of the columns= parameter
	// var sRdr CsvReader at bp+80, 264

	// var azPValue [3]uintptr at bp+344, 24

	var z uintptr
	var zValue uintptr
	var z1 uintptr
	var pStr uintptr
	var zSep uintptr
	var iCol int32
	pNew = uintptr(0)
	bHeader = -1
	rc = SQLITE_OK
	tstFlags = 0
	nCol = -99 // Parameter values

	libc.Xmemset(tls, bp+80 /* &sRdr */, 0, uint64(unsafe.Sizeof(CsvReader{})))
	libc.Xmemset(tls, bp+344 /* &azPValue[0] */, 0, uint64(unsafe.Sizeof([3]uintptr{})))
	i = 3
__1:
	if !(i < argc) {
		goto __3
	}
	z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
	j = 0
__4:
	if !(uint64(j) < uint64(unsafe.Sizeof(azParam))/uint64(unsafe.Sizeof(uintptr(0)))) {
		goto __6
	}
	if !(csv_string_parameter(tls, bp+80, azParam[j], z, bp+344+uintptr(j)*8) != 0) {
		goto __7
	}
	goto __6
__7:
	;
	goto __5
__5:
	j++
	goto __4
	goto __6
__6:
	;
	if !(uint64(j) < uint64(unsafe.Sizeof(azParam))/uint64(unsafe.Sizeof(uintptr(0)))) {
		goto __8
	}
	if !(*(*int8)(unsafe.Pointer(bp + 80 + 64)) != 0) {
		goto __10
	}
	goto csvtab_connect_error
__10:
	;
	goto __9
__8:
	if !(csv_boolean_parameter(tls, ts+4552, 6, z, bp+368) != 0) {
		goto __11
	}
	if !(bHeader >= 0) {
		goto __13
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4559 /* "more than one 'h..." */, 0)
	goto csvtab_connect_error
__13:
	;
	bHeader = *(*int32)(unsafe.Pointer(bp + 368 /* b */))
	goto __12
__11:
	if !(libc.AssignUintptr(&zValue, csv_parameter(tls, ts+4592, 9, z)) != uintptr(0)) {
		goto __14
	}
	tstFlags = int32(uint32(libc.Xatoi(tls, zValue)))
	goto __15
__14:
	if !(libc.AssignUintptr(&zValue, csv_parameter(tls, ts+4602, 7, z)) != uintptr(0)) {
		goto __16
	}
	if !(nCol > 0) {
		goto __18
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4610 /* "more than one 'c..." */, 0)
	goto csvtab_connect_error
__18:
	;
	nCol = libc.Xatoi(tls, zValue)
	if !(nCol <= 0) {
		goto __19
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4644 /* "column= value mu..." */, 0)
	goto csvtab_connect_error
__19:
	;
	goto __17
__16:

	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4675 /* "bad parameter: '..." */, libc.VaList(bp, z))
	goto csvtab_connect_error
__17:
	;
__15:
	;
__12:
	;
__9:
	;
	goto __2
__2:
	i++
	goto __1
	goto __3
__3:
	;
	if !(libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 344)) == uintptr(0)) == libc.Bool32(*(*uintptr)(unsafe.Pointer(bp + 344 + 1*8)) == uintptr(0))) {
		goto __20
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4695 /* "must specify eit..." */, 0)
	goto csvtab_connect_error
__20:
	;

	if !((nCol <= 0 || bHeader == 1) &&
		csv_reader_open(tls, bp+80, *(*uintptr)(unsafe.Pointer(bp + 344)), *(*uintptr)(unsafe.Pointer(bp + 344 + 1*8))) != 0) {
		goto __21
	}
	goto csvtab_connect_error
__21:
	;
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CsvTable{})))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	if !(pNew == uintptr(0)) {
		goto __22
	}
	goto csvtab_connect_oom
__22:
	;
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(CsvTable{})))
	if !(*(*uintptr)(unsafe.Pointer(bp + 344 + 2*8)) == uintptr(0)) {
		goto __23
	}
	pStr = sqlite3.Xsqlite3_str_new(tls, uintptr(0))
	zSep = ts + 584 /* "" */
	iCol = 0
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+979 /* "CREATE TABLE x(" */, 0)
	if !(nCol < 0 && bHeader < 1) {
		goto __25
	}
	nCol = 0
__26:
	csv_read_one_field(tls, bp+80 /* &sRdr */)
	nCol++
	goto __27
__27:
	if (*CsvReader)(unsafe.Pointer(bp+80)).FcTerm == ',' {
		goto __26
	}
	goto __28
__28:
	;
__25:
	;
	if !(nCol > 0 && bHeader < 1) {
		goto __29
	}
	iCol = 0
__31:
	if !(iCol < nCol) {
		goto __33
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4747 /* "%sc%d TEXT" */, libc.VaList(bp+8, zSep, iCol))
	zSep = ts + 4758 /* "," */
	goto __32
__32:
	iCol++
	goto __31
	goto __33
__33:
	;
	goto __30
__29:
__34:
	z1 = csv_read_one_field(tls, bp+80 /* &sRdr */)
	if !(nCol > 0 && iCol < nCol || nCol < 0 && bHeader != 0) {
		goto __37
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4760 /* "%s\"%w\" TEXT" */, libc.VaList(bp+24, zSep, z1))
	zSep = ts + 4758 /* "," */
	iCol++
__37:
	;
	goto __35
__35:
	if (*CsvReader)(unsafe.Pointer(bp+80)).FcTerm == ',' {
		goto __34
	}
	goto __36
__36:
	;
	if !(nCol < 0) {
		goto __38
	}
	nCol = iCol
	goto __39
__38:
__40:
	if !(iCol < nCol) {
		goto __41
	}
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+4747 /* "%sc%d TEXT" */, libc.VaList(bp+40, zSep, libc.PreIncInt32(&iCol, 1)))
	zSep = ts + 4758 /* "," */
	goto __40
__41:
	;
__39:
	;
__30:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
	sqlite3.Xsqlite3_str_appendf(tls, pStr, ts+585 /* ")" */, 0)
	*(*uintptr)(unsafe.Pointer(bp + 344 + 2*8)) = sqlite3.Xsqlite3_str_finish(tls, pStr)
	if !(*(*uintptr)(unsafe.Pointer(bp + 344 + 2*8)) == uintptr(0)) {
		goto __42
	}
	goto csvtab_connect_oom
__42:
	;
	goto __24
__23:
	if !(nCol < 0) {
		goto __43
	}
__45:
	csv_read_one_field(tls, bp+80 /* &sRdr */)
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol++
	goto __46
__46:
	if (*CsvReader)(unsafe.Pointer(bp+80)).FcTerm == ',' {
		goto __45
	}
	goto __47
__47:
	;
	goto __44
__43:
	(*CsvTable)(unsafe.Pointer(pNew)).FnCol = nCol
__44:
	;
__24:
	;
	(*CsvTable)(unsafe.Pointer(pNew)).FzFilename = *(*uintptr)(unsafe.Pointer(bp + 344))
	*(*uintptr)(unsafe.Pointer(bp + 344)) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FzData = *(*uintptr)(unsafe.Pointer(bp + 344 + 1*8))
	*(*uintptr)(unsafe.Pointer(bp + 344 + 1*8)) = uintptr(0)
	(*CsvTable)(unsafe.Pointer(pNew)).FtstFlags = uint32(tstFlags)
	if !(bHeader != 1) {
		goto __48
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int64(0)
	goto __49
__48:
	if !((*CsvTable)(unsafe.Pointer(pNew)).FzData != 0) {
		goto __50
	}
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int64(int32((*CsvReader)(unsafe.Pointer(bp + 80 /* &sRdr */)).FiIn))
	goto __51
__50:
	(*CsvTable)(unsafe.Pointer(pNew)).FiStart = int64(int32(size_t(libc.Xftell(tls, (*CsvReader)(unsafe.Pointer(bp+80)).Fin)) - (*CsvReader)(unsafe.Pointer(bp+80)).FnIn + (*CsvReader)(unsafe.Pointer(bp+80)).FiIn))
__51:
	;
__49:
	;
	csv_reader_reset(tls, bp+80 /* &sRdr */)
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, *(*uintptr)(unsafe.Pointer(bp + 344 + 2*8)))
	if !(rc != 0) {
		goto __52
	}
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+4772 /* "bad schema: '%s'..." */, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(bp + 344 + 2*8)), sqlite3.Xsqlite3_errmsg(tls, db)))
	goto csvtab_connect_error
__52:
	;
	i = 0
__53:
	if !(uint64(i) < uint64(unsafe.Sizeof([3]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0)))) {
		goto __55
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(i)*8)))
	goto __54
__54:
	i++
	goto __53
	goto __55
__55:
	;
	// Rationale for DIRECTONLY:
	// An attacker who controls a database schema could use this vtab
	// to exfiltrate sensitive data from other files in the filesystem.
	// And, recommended practice is to put all CSV virtual tables in the
	// TEMP namespace, so they should still be usable from within TEMP
	// views, so there shouldn't be a serious loss of functionality by
	// prohibiting the use of this vtab from persistent triggers and views.
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	return SQLITE_OK

csvtab_connect_oom:
	rc = SQLITE_NOMEM
	csv_errmsg(tls, bp+80 /* &sRdr */, ts+2069 /* "out of memory" */, 0)

csvtab_connect_error:
	if !(pNew != 0) {
		goto __56
	}
	csvtabDisconnect(tls, pNew)
__56:
	;
	i = 0
__57:
	if !(uint64(i) < uint64(unsafe.Sizeof([3]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0)))) {
		goto __59
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 344 /* &azPValue[0] */ + uintptr(i)*8)))
	goto __58
__58:
	i++
	goto __57
	goto __59
__59:
	;
	if !(*(*int8)(unsafe.Pointer(bp + 80 + 64)) != 0) {
		goto __60
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(pzErr)))
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+72, bp+80+64))
__60:
	;
	csv_reader_reset(tls, bp+80 /* &sRdr */)
	if !(rc == SQLITE_OK) {
		goto __61
	}
	rc = SQLITE_ERROR
__61:
	;
	return rc
}

var azParam = [3]uintptr{
	ts + 4794 /* "filename" */, ts + 4803 /* "data" */, ts + 4808, /* "schema" */
} /* csv.c:504:21 */

// Reset the current row content held by a CsvCursor.
func csvtabCursorRowReset(tls *libc.TLS, pCur uintptr) { /* csv.c:667:13: */
	var pTab uintptr = (*CsvCursor)(unsafe.Pointer(pCur)).Fbase.FpVtab
	var i int32
	for i = 0; i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)))
		*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) = uintptr(0)
		*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
	}
}

// The xConnect and xCreate methods do the same thing, but they must be
// different so that the virtual table is not an eponymous virtual table.
func csvtabCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* csv.c:681:12: */
	return csvtabConnect(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

// Destructor for a CsvCursor.
func csvtabClose(tls *libc.TLS, cur uintptr) int32 { /* csv.c:694:12: */
	var pCur uintptr = cur
	csvtabCursorRowReset(tls, pCur)
	csv_reader_reset(tls, pCur+8)
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Constructor for a new CsvTable cursor object.
func csvtabOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* csv.c:705:12: */
	var pTab uintptr = p
	var pCur uintptr
	var nByte size_t
	nByte = uint64(unsafe.Sizeof(CsvCursor{})) + (uint64(unsafe.Sizeof(uintptr(0)))+uint64(unsafe.Sizeof(int32(0))))*uint64((*CsvTable)(unsafe.Pointer(pTab)).FnCol)
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, nByte)
	(*CsvCursor)(unsafe.Pointer(pCur)).FazVal = pCur + 1*296
	(*CsvCursor)(unsafe.Pointer(pCur)).FaLen = (*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr((*CsvTable)(unsafe.Pointer(pTab)).FnCol)*8
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	if csv_reader_open(tls, pCur+8, (*CsvTable)(unsafe.Pointer(pTab)).FzFilename, (*CsvTable)(unsafe.Pointer(pTab)).FzData) != 0 {
		csv_xfer_error(tls, pTab, pCur+8)
		return SQLITE_ERROR
	}
	return SQLITE_OK
}

// Advance a CsvCursor to its next row of input.
// Set the EOF marker if we reach the end of input.
func csvtabNext(tls *libc.TLS, cur uintptr) int32 { /* csv.c:728:12: */
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var i int32 = 0
	var z uintptr
	for ok := true; ok; ok = (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FcTerm == ',' {
		z = csv_read_one_field(tls, pCur+8)
		if z == uintptr(0) {
			break
		}
		if i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			if *(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) < (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn+1 {
				var zNew uintptr = sqlite3.Xsqlite3_realloc64(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)), uint64((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn+1))
				if zNew == uintptr(0) {
					csv_errmsg(tls, pCur+8, ts+2069 /* "out of memory" */, 0)
					csv_xfer_error(tls, pTab, pCur+8)
					break
				}
				*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) = zNew
				*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn + 1
			}
			libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)), z, uint64((*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fn+1))
			i++
		}
	}
	if z == uintptr(0) || (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FcTerm == -1 && i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(-1)
	} else {
		(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid++
		for i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol {
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)))
			*(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) = uintptr(0)
			*(*int32)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FaLen + uintptr(i)*4)) = 0
			i++
		}
	}
	return SQLITE_OK
}

// Return values of columns for the row at which the CsvCursor
// is currently pointing.
func csvtabColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* csv.c:771:12: */
	var pCur uintptr = cur
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if i >= 0 && i < (*CsvTable)(unsafe.Pointer(pTab)).FnCol && *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)) != uintptr(0) {
		sqlite3.Xsqlite3_result_text(tls, ctx, *(*uintptr)(unsafe.Pointer((*CsvCursor)(unsafe.Pointer(pCur)).FazVal + uintptr(i)*8)), -1, libc.UintptrFromInt32(-1))
	}
	return SQLITE_OK
}

// Return the rowid for the current row.
func csvtabRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* csv.c:787:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*CsvCursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func csvtabEof(tls *libc.TLS, cur uintptr) int32 { /* csv.c:797:12: */
	var pCur uintptr = cur
	return libc.Bool32((*CsvCursor)(unsafe.Pointer(pCur)).FiRowid < int64(0))
}

// Only a full table scan is supported.  So xFilter simply rewinds to
// the beginning.
func csvtabFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* csv.c:806:12: */
	var pCur uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	(*CsvCursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	if (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin == uintptr(0) {

		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = size_t((*CsvTable)(unsafe.Pointer(pTab)).FiStart)
	} else {
		libc.Xfseek(tls, (*CsvCursor)(unsafe.Pointer(pCur)).Frdr.Fin, (*CsvTable)(unsafe.Pointer(pTab)).FiStart, SEEK_SET)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FiIn = uint64(0)
		(*CsvCursor)(unsafe.Pointer(pCur)).Frdr.FnIn = uint64(0)
	}
	return csvtabNext(tls, pVtabCursor)
}

// Only a forward full table scan is supported.  xBestIndex is mostly
// a no-op.  If CSVTEST_FIDX is set, then the presence of equality
// constraints lowers the estimated cost, which is fiction, but is useful
// for testing certain kinds of virtual table behavior.
func csvtabBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* csv.c:833:12: */
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000)
	if (*CsvTable)(unsafe.Pointer(tab)).FtstFlags&uint32(CSVTEST_FIDX) != uint32(0) {
		// The usual (and sensible) case is to always do a full table scan.
		// The code in this branch only runs when testflags=1.  This code
		// generates an artifical and unrealistic plan which is useful
		// for testing virtual table logic but is not helpful to real applications.
		//
		// Any ==, LIKE, or GLOB constraint is marked as usable by the virtual
		// table (even though it is not) and the cost of running the virtual table
		// is reduced from 1 million to just 10.  The constraints are *not* marked
		// as omittable, however, so the query planner should still generate a
		// plan that gives a correct answer, even if they plan is not optimal.
		var i int32
		var nConst int32 = 0
		for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
			var op uint8
			if int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(i)*12)).Fusable) == 0 {
				continue
			}
			op = (*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12)).Fop
			if int32(op) == SQLITE_INDEX_CONSTRAINT_EQ ||
				int32(op) == SQLITE_INDEX_CONSTRAINT_LIKE ||
				int32(op) == SQLITE_INDEX_CONSTRAINT_GLOB {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(nConst)*8)).FargvIndex = nConst + 1
				nConst++
			}
		}
	}
	return SQLITE_OK
}

var CsvModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* csv.c:872:23 */

// For virtual table testing, make a version of the CSV virtual table
// available that has an xUpdate function.  But the xUpdate always returns
// SQLITE_READONLY since the CSV file is not really writable.
func csvtabUpdate(tls *libc.TLS, p uintptr, n int32, v uintptr, x uintptr) int32 { /* csv.c:901:12: */
	return SQLITE_READONLY
}

var CsvModuleFauxWrite = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xRename
} /* csv.c:904:23 */

// This routine is called when the extension is loaded.  The new
// CSV virtual table module is registered with the calling database
// connection.
func sqlite3_csv_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* csv.c:939:5: */
	var rc int32
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4815 /* "csv" */, uintptr(unsafe.Pointer(&CsvModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4819 /* "csv_wr" */, uintptr(unsafe.Pointer(&CsvModuleFauxWrite)), uintptr(0))
	}
	return rc
}

// Mark a function parameter as unused, to suppress nuisance compiler
// warnings.

// A decimal object
type Decimal1 = struct {
	Fsign        int8
	Foom         int8
	FisNull      int8
	FisInit      int8
	FnDigit      int32
	FnFrac       int32
	F__ccgo_pad1 [4]byte
	Fa           uintptr
} /* decimal.c:32:9 */

// Mark a function parameter as unused, to suppress nuisance compiler
// warnings.

// A decimal object
type Decimal = Decimal1 /* decimal.c:32:24 */

// Release memory held by a Decimal, but do not free the object itself.
func decimal_clear(tls *libc.TLS, p uintptr) { /* decimal.c:46:13: */
	sqlite3.Xsqlite3_free(tls, (*Decimal)(unsafe.Pointer(p)).Fa)
}

// Destroy a Decimal object
func decimal_free(tls *libc.TLS, p uintptr) { /* decimal.c:53:13: */
	if p != 0 {
		decimal_clear(tls, p)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Allocate a new Decimal object.  Initialize it to the number given
// by the input string.
func decimal_new(tls *libc.TLS, pCtx uintptr, pIn uintptr, nAlt int32, zAlt uintptr) uintptr { /* decimal.c:64:16: */
	var p uintptr
	var n int32
	var i int32
	var zIn uintptr
	var iExp int32
	var j int32
	var neg int32
	var c int8
	var nExtra int32
	iExp = 0
	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Decimal{})))
	if !(p == uintptr(0)) {
		goto __1
	}
	goto new_no_mem
__1:
	;
	(*Decimal)(unsafe.Pointer(p)).Fsign = int8(0)
	(*Decimal)(unsafe.Pointer(p)).Foom = int8(0)
	(*Decimal)(unsafe.Pointer(p)).FisInit = int8(1)
	(*Decimal)(unsafe.Pointer(p)).FisNull = int8(0)
	(*Decimal)(unsafe.Pointer(p)).FnDigit = 0
	(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
	if !(zAlt != 0) {
		goto __2
	}
	n = nAlt
	zIn = zAlt
	goto __3
__2:
	if !(sqlite3.Xsqlite3_value_type(tls, pIn) == SQLITE_NULL) {
		goto __4
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = uintptr(0)
	(*Decimal)(unsafe.Pointer(p)).FisNull = int8(1)
	return p
__4:
	;
	n = sqlite3.Xsqlite3_value_bytes(tls, pIn)
	zIn = sqlite3.Xsqlite3_value_text(tls, pIn)
__3:
	;
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_malloc64(tls, uint64(n+1))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __5
	}
	goto new_no_mem
__5:
	;
	i = 0
__6:
	if !(__sbistype(tls, int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))), uint64(X_CTYPE_S)) != 0) {
		goto __8
	}
	goto __7
__7:
	i++
	goto __6
	goto __8
__8:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '-') {
		goto __9
	}
	(*Decimal)(unsafe.Pointer(p)).Fsign = int8(1)
	i++
	goto __10
__9:
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '+') {
		goto __11
	}
	i++
__11:
	;
__10:
	;
__12:
	if !(i < n && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i)))) == '0') {
		goto __13
	}
	i++
	goto __12
__13:
	;
__14:
	if !(i < n) {
		goto __15
	}
	c = int8(*(*uint8)(unsafe.Pointer(zIn + uintptr(i))))
	if !(int32(c) >= '0' && int32(c) <= '9') {
		goto __16
	}
	*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(libc.PostIncInt32(&(*Decimal)(unsafe.Pointer(p)).FnDigit, 1)))) = int8(int32(c) - '0')
	goto __17
__16:
	if !(int32(c) == '.') {
		goto __18
	}
	(*Decimal)(unsafe.Pointer(p)).FnFrac = (*Decimal)(unsafe.Pointer(p)).FnDigit + 1
	goto __19
__18:
	if !(int32(c) == 'e' || int32(c) == 'E') {
		goto __20
	}
	j = i + 1
	neg = 0
	if !(j >= n) {
		goto __21
	}
	goto __15
__21:
	;
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) == '-') {
		goto __22
	}
	neg = 1
	j++
	goto __23
__22:
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) == '+') {
		goto __24
	}
	j++
__24:
	;
__23:
	;
__25:
	if !(j < n && iExp < 1000000) {
		goto __26
	}
	if !(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) >= '0' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) <= '9') {
		goto __27
	}
	iExp = iExp*10 + int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(j)))) - '0'
__27:
	;
	j++
	goto __25
__26:
	;
	if !(neg != 0) {
		goto __28
	}
	iExp = -iExp
__28:
	;
	goto __15
__20:
	;
__19:
	;
__17:
	;
	i++
	goto __14
__15:
	;
	if !((*Decimal)(unsafe.Pointer(p)).FnFrac != 0) {
		goto __29
	}
	(*Decimal)(unsafe.Pointer(p)).FnFrac = (*Decimal)(unsafe.Pointer(p)).FnDigit - ((*Decimal)(unsafe.Pointer(p)).FnFrac - 1)
__29:
	;
	if !(iExp > 0) {
		goto __30
	}
	if !((*Decimal)(unsafe.Pointer(p)).FnFrac > 0) {
		goto __32
	}
	if !(iExp <= (*Decimal)(unsafe.Pointer(p)).FnFrac) {
		goto __33
	}
	*(*int32)(unsafe.Pointer(p + 8)) -= iExp
	iExp = 0
	goto __34
__33:
	iExp = iExp - (*Decimal)(unsafe.Pointer(p)).FnFrac
	(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
__34:
	;
__32:
	;
	if !(iExp > 0) {
		goto __35
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, uint64((*Decimal)(unsafe.Pointer(p)).FnDigit+iExp+1))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __36
	}
	goto new_no_mem
__36:
	;
	libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr((*Decimal)(unsafe.Pointer(p)).FnDigit), 0, uint64(iExp))
	*(*int32)(unsafe.Pointer(p + 4)) += iExp
__35:
	;
	goto __31
__30:
	if !(iExp < 0) {
		goto __37
	}
	iExp = -iExp
	nExtra = (*Decimal)(unsafe.Pointer(p)).FnDigit - (*Decimal)(unsafe.Pointer(p)).FnFrac - 1
	if !(nExtra != 0) {
		goto __38
	}
	if !(nExtra >= iExp) {
		goto __39
	}
	*(*int32)(unsafe.Pointer(p + 8)) += iExp
	iExp = 0
	goto __40
__39:
	iExp = iExp - nExtra
	(*Decimal)(unsafe.Pointer(p)).FnFrac = (*Decimal)(unsafe.Pointer(p)).FnDigit - 1
__40:
	;
__38:
	;
	if !(iExp > 0) {
		goto __41
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, uint64((*Decimal)(unsafe.Pointer(p)).FnDigit+iExp+1))
	if !((*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0)) {
		goto __42
	}
	goto new_no_mem
__42:
	;
	libc.Xmemmove(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr(iExp), (*Decimal)(unsafe.Pointer(p)).Fa, uint64((*Decimal)(unsafe.Pointer(p)).FnDigit))
	libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa, 0, uint64(iExp))
	*(*int32)(unsafe.Pointer(p + 4)) += iExp
	*(*int32)(unsafe.Pointer(p + 8)) += iExp
__41:
	;
__37:
	;
__31:
	;
	return p

new_no_mem:
	if !(pCtx != 0) {
		goto __43
	}
	sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
__43:
	;
	sqlite3.Xsqlite3_free(tls, p)
	return uintptr(0)
}

// Make the given Decimal the result.
func decimal_result(tls *libc.TLS, pCtx uintptr, p uintptr) { /* decimal.c:183:13: */
	var z uintptr
	var i int32
	var j int32
	var n int32
	if p == uintptr(0) || (*Decimal)(unsafe.Pointer(p)).Foom != 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return
	}
	if (*Decimal)(unsafe.Pointer(p)).FisNull != 0 {
		sqlite3.Xsqlite3_result_null(tls, pCtx)
		return
	}
	z = sqlite3.Xsqlite3_malloc(tls, (*Decimal)(unsafe.Pointer(p)).FnDigit+4)
	if z == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		return
	}
	i = 0
	if (*Decimal)(unsafe.Pointer(p)).FnDigit == 0 || (*Decimal)(unsafe.Pointer(p)).FnDigit == 1 && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa))) == 0 {
		(*Decimal)(unsafe.Pointer(p)).Fsign = int8(0)
	}
	if (*Decimal)(unsafe.Pointer(p)).Fsign != 0 {
		*(*int8)(unsafe.Pointer(z)) = int8('-')
		i = 1
	}
	n = (*Decimal)(unsafe.Pointer(p)).FnDigit - (*Decimal)(unsafe.Pointer(p)).FnFrac
	if n <= 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8('0')
	}
	j = 0
	for n > 1 && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) == 0 {
		j++
		n--
	}
	for n > 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8(int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) + '0')
		j++
		n--
	}
	if (*Decimal)(unsafe.Pointer(p)).FnFrac != 0 {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8('.')
		for ok := true; ok; ok = j < (*Decimal)(unsafe.Pointer(p)).FnDigit {
			*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))) = int8(int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa + uintptr(j)))) + '0')
			j++
		}
	}
	*(*int8)(unsafe.Pointer(z + uintptr(i))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, pCtx, z, i, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
}

// SQL Function:   decimal(X)
//
// Convert input X into decimal and then back into text
func decimalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:238:13: */
	var p uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	_ = argc
	decimal_result(tls, context, p)
	decimal_free(tls, p)
}

// Compare to Decimal objects.  Return negative, 0, or positive if the
// first object is less than, equal to, or greater than the second.
//
// Preconditions for this routine:
//
//    pA!=0
//    pA->isNull==0
//    pB!=0
//    pB->isNull==0
func decimal_cmp(tls *libc.TLS, pA uintptr, pB uintptr) int32 { /* decimal.c:260:12: */
	var nASig int32
	var nBSig int32
	var rc int32
	var n int32
	if int32((*Decimal)(unsafe.Pointer(pA)).Fsign) != int32((*Decimal)(unsafe.Pointer(pB)).Fsign) {
		if (*Decimal)(unsafe.Pointer(pA)).Fsign != 0 {
			return -1
		}
		return +1
	}
	if (*Decimal)(unsafe.Pointer(pA)).Fsign != 0 {
		var pTemp uintptr = pA
		pA = pB
		pB = pTemp
	}
	nASig = (*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pA)).FnFrac
	nBSig = (*Decimal)(unsafe.Pointer(pB)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnFrac
	if nASig != nBSig {
		return nASig - nBSig
	}
	n = (*Decimal)(unsafe.Pointer(pA)).FnDigit
	if n > (*Decimal)(unsafe.Pointer(pB)).FnDigit {
		n = (*Decimal)(unsafe.Pointer(pB)).FnDigit
	}
	rc = libc.Xmemcmp(tls, (*Decimal)(unsafe.Pointer(pA)).Fa, (*Decimal)(unsafe.Pointer(pB)).Fa, uint64(n))
	if rc == 0 {
		rc = (*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnDigit
	}
	return rc
}

// SQL Function:   decimal_cmp(X, Y)
//
// Return negative, zero, or positive if X is less then, equal to, or
// greater than Y.
func decimalCmpFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:290:13: */
	var pA uintptr
	var pB uintptr
	var rc int32
	pA = uintptr(0)
	pB = uintptr(0)

	_ = argc
	pA = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	if !(pA == uintptr(0) || (*Decimal)(unsafe.Pointer(pA)).FisNull != 0) {
		goto __1
	}
	goto cmp_done
__1:
	;
	pB = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*8)), 0, uintptr(0))
	if !(pB == uintptr(0) || (*Decimal)(unsafe.Pointer(pB)).FisNull != 0) {
		goto __2
	}
	goto cmp_done
__2:
	;
	rc = decimal_cmp(tls, pA, pB)
	if !(rc < 0) {
		goto __3
	}
	rc = -1
	goto __4
__3:
	if !(rc > 0) {
		goto __5
	}
	rc = +1
__5:
	;
__4:
	;
	sqlite3.Xsqlite3_result_int(tls, context, rc)
cmp_done:
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

// Expand the Decimal so that it has a least nDigit digits and nFrac
// digits to the right of the decimal point.
func decimal_expand(tls *libc.TLS, p uintptr, nDigit int32, nFrac int32) { /* decimal.c:316:13: */
	var nAddSig int32
	var nAddFrac int32
	if p == uintptr(0) {
		return
	}
	nAddFrac = nFrac - (*Decimal)(unsafe.Pointer(p)).FnFrac
	nAddSig = nDigit - (*Decimal)(unsafe.Pointer(p)).FnDigit - nAddFrac
	if nAddFrac == 0 && nAddSig == 0 {
		return
	}
	(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_realloc64(tls, (*Decimal)(unsafe.Pointer(p)).Fa, uint64(nDigit+1))
	if (*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0) {
		(*Decimal)(unsafe.Pointer(p)).Foom = int8(1)
		return
	}
	if nAddSig != 0 {
		libc.Xmemmove(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr(nAddSig), (*Decimal)(unsafe.Pointer(p)).Fa, uint64((*Decimal)(unsafe.Pointer(p)).FnDigit))
		libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa, 0, uint64(nAddSig))
		*(*int32)(unsafe.Pointer(p + 4)) += nAddSig
	}
	if nAddFrac != 0 {
		libc.Xmemset(tls, (*Decimal)(unsafe.Pointer(p)).Fa+uintptr((*Decimal)(unsafe.Pointer(p)).FnDigit), 0, uint64(nAddFrac))
		*(*int32)(unsafe.Pointer(p + 4)) += nAddFrac
		*(*int32)(unsafe.Pointer(p + 8)) += nAddFrac
	}
}

// Add the value pB into pA.
//
// Both pA and pB might become denormalized by this routine.
func decimal_add(tls *libc.TLS, pA uintptr, pB uintptr) { /* decimal.c:345:13: */
	var nSig int32
	var nFrac int32
	var nDigit int32
	var i int32
	var rc int32
	if pA == uintptr(0) {
		return
	}
	if (*Decimal)(unsafe.Pointer(pA)).Foom != 0 || pB == uintptr(0) || (*Decimal)(unsafe.Pointer(pB)).Foom != 0 {
		(*Decimal)(unsafe.Pointer(pA)).Foom = int8(1)
		return
	}
	if (*Decimal)(unsafe.Pointer(pA)).FisNull != 0 || (*Decimal)(unsafe.Pointer(pB)).FisNull != 0 {
		(*Decimal)(unsafe.Pointer(pA)).FisNull = int8(1)
		return
	}
	nSig = (*Decimal)(unsafe.Pointer(pA)).FnDigit - (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if nSig != 0 && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa))) == 0 {
		nSig--
	}
	if nSig < (*Decimal)(unsafe.Pointer(pB)).FnDigit-(*Decimal)(unsafe.Pointer(pB)).FnFrac {
		nSig = (*Decimal)(unsafe.Pointer(pB)).FnDigit - (*Decimal)(unsafe.Pointer(pB)).FnFrac
	}
	nFrac = (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if nFrac < (*Decimal)(unsafe.Pointer(pB)).FnFrac {
		nFrac = (*Decimal)(unsafe.Pointer(pB)).FnFrac
	}
	nDigit = nSig + nFrac + 1
	decimal_expand(tls, pA, nDigit, nFrac)
	decimal_expand(tls, pB, nDigit, nFrac)
	if (*Decimal)(unsafe.Pointer(pA)).Foom != 0 || (*Decimal)(unsafe.Pointer(pB)).Foom != 0 {
		(*Decimal)(unsafe.Pointer(pA)).Foom = int8(1)
	} else {
		if int32((*Decimal)(unsafe.Pointer(pA)).Fsign) == int32((*Decimal)(unsafe.Pointer(pB)).Fsign) {
			var carry int32 = 0
			for i = nDigit - 1; i >= 0; i-- {
				var x int32 = int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i)))) + int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pB)).Fa + uintptr(i)))) + carry
				if x >= 10 {
					carry = 1
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x - 10)
				} else {
					carry = 0
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x)
				}
			}
		} else {
			var aA uintptr
			var aB uintptr
			var borrow int32 = 0
			rc = libc.Xmemcmp(tls, (*Decimal)(unsafe.Pointer(pA)).Fa, (*Decimal)(unsafe.Pointer(pB)).Fa, uint64(nDigit))
			if rc < 0 {
				aA = (*Decimal)(unsafe.Pointer(pB)).Fa
				aB = (*Decimal)(unsafe.Pointer(pA)).Fa
				(*Decimal)(unsafe.Pointer(pA)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pA)).Fsign != 0))
			} else {
				aA = (*Decimal)(unsafe.Pointer(pA)).Fa
				aB = (*Decimal)(unsafe.Pointer(pB)).Fa
			}
			for i = nDigit - 1; i >= 0; i-- {
				var x int32 = int32(*(*int8)(unsafe.Pointer(aA + uintptr(i)))) - int32(*(*int8)(unsafe.Pointer(aB + uintptr(i)))) - borrow
				if x < 0 {
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x + 10)
					borrow = 1
				} else {
					*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i))) = int8(x)
					borrow = 0
				}
			}
		}
	}
}

// Compare text in decimal order.
func decimalCollFunc(tls *libc.TLS, notUsed uintptr, nKey1 int32, pKey1 uintptr, nKey2 int32, pKey2 uintptr) int32 { /* decimal.c:413:12: */
	var zA uintptr = pKey1
	var zB uintptr = pKey2
	var pA uintptr = decimal_new(tls, uintptr(0), uintptr(0), nKey1, zA)
	var pB uintptr = decimal_new(tls, uintptr(0), uintptr(0), nKey2, zB)
	var rc int32
	_ = notUsed
	if pA == uintptr(0) || pB == uintptr(0) {
		rc = 0
	} else {
		rc = decimal_cmp(tls, pA, pB)
	}
	decimal_free(tls, pA)
	decimal_free(tls, pB)
	return rc
}

// SQL Function:   decimal_add(X, Y)
//                 decimal_sub(X, Y)
//
// Return the sum or difference of X and Y.
func decimalAddFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:441:13: */
	var pA uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	var pB uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*8)), 0, uintptr(0))
	_ = argc
	decimal_add(tls, pA, pB)
	decimal_result(tls, context, pA)
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func decimalSubFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:454:13: */
	var pA uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	var pB uintptr = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*8)), 0, uintptr(0))
	_ = argc
	if pB != 0 {
		(*Decimal)(unsafe.Pointer(pB)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pB)).Fsign != 0))
		decimal_add(tls, pA, pB)
		decimal_result(tls, context, pA)
	}
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

// Aggregate funcion:   decimal_sum(X)
//
// Works like sum() except that it uses decimal arithmetic for unlimited
// precision.
func decimalSumStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:476:13: */
	var p uintptr
	var pArg uintptr
	_ = argc
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(Decimal{})))
	if p == uintptr(0) {
		return
	}
	if !(int32((*Decimal)(unsafe.Pointer(p)).FisInit) != 0) {
		(*Decimal)(unsafe.Pointer(p)).FisInit = int8(1)
		(*Decimal)(unsafe.Pointer(p)).Fa = sqlite3.Xsqlite3_malloc(tls, 2)
		if (*Decimal)(unsafe.Pointer(p)).Fa == uintptr(0) {
			(*Decimal)(unsafe.Pointer(p)).Foom = int8(1)
		} else {
			*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(p)).Fa)) = int8(0)
		}
		(*Decimal)(unsafe.Pointer(p)).FnDigit = 1
		(*Decimal)(unsafe.Pointer(p)).FnFrac = 0
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	pArg = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	decimal_add(tls, p, pArg)
	decimal_free(tls, pArg)
}

func decimalSumInverse(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:502:13: */
	var p uintptr
	var pArg uintptr
	_ = argc
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(Decimal{})))
	if p == uintptr(0) {
		return
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	pArg = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	if pArg != 0 {
		(*Decimal)(unsafe.Pointer(pArg)).Fsign = libc.BoolInt8(!((*Decimal)(unsafe.Pointer(pArg)).Fsign != 0))
	}
	decimal_add(tls, p, pArg)
	decimal_free(tls, pArg)
}

func decimalSumValue(tls *libc.TLS, context uintptr) { /* decimal.c:518:13: */
	var p uintptr = sqlite3.Xsqlite3_aggregate_context(tls, context, 0)
	if p == uintptr(0) {
		return
	}
	decimal_result(tls, context, p)
}

func decimalSumFinalize(tls *libc.TLS, context uintptr) { /* decimal.c:523:13: */
	var p uintptr = sqlite3.Xsqlite3_aggregate_context(tls, context, 0)
	if p == uintptr(0) {
		return
	}
	decimal_result(tls, context, p)
	decimal_clear(tls, p)
}

// SQL Function:   decimal_mul(X, Y)
//
// Return the product of X and Y.
//
// All significant digits after the decimal point are retained.
// Trailing zeros after the decimal point are omitted as long as
// the number of digits after the decimal point is no less than
// either the number of digits in either input.
func decimalMulFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* decimal.c:540:13: */
	var pA uintptr
	var pB uintptr
	var acc uintptr
	var i int32
	var j int32
	var k int32
	var minFrac int32
	var f int8
	var carry int32
	var x int32
	pA = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv)), 0, uintptr(0))
	pB = decimal_new(tls, context, *(*uintptr)(unsafe.Pointer(argv + 1*8)), 0, uintptr(0))
	acc = uintptr(0)
	_ = argc
	if !(pA == uintptr(0) || (*Decimal)(unsafe.Pointer(pA)).Foom != 0 || (*Decimal)(unsafe.Pointer(pA)).FisNull != 0 ||
		pB == uintptr(0) || (*Decimal)(unsafe.Pointer(pB)).Foom != 0 || (*Decimal)(unsafe.Pointer(pB)).FisNull != 0) {
		goto __1
	}
	goto mul_end
__1:
	;
	acc = sqlite3.Xsqlite3_malloc64(tls, uint64((*Decimal)(unsafe.Pointer(pA)).FnDigit+(*Decimal)(unsafe.Pointer(pB)).FnDigit+2))
	if !(acc == uintptr(0)) {
		goto __2
	}
	sqlite3.Xsqlite3_result_error_nomem(tls, context)
	goto mul_end
__2:
	;
	libc.Xmemset(tls, acc, 0, uint64((*Decimal)(unsafe.Pointer(pA)).FnDigit+(*Decimal)(unsafe.Pointer(pB)).FnDigit+2))
	minFrac = (*Decimal)(unsafe.Pointer(pA)).FnFrac
	if !((*Decimal)(unsafe.Pointer(pB)).FnFrac < minFrac) {
		goto __3
	}
	minFrac = (*Decimal)(unsafe.Pointer(pB)).FnFrac
__3:
	;
	i = (*Decimal)(unsafe.Pointer(pA)).FnDigit - 1
__4:
	if !(i >= 0) {
		goto __6
	}
	f = *(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr(i)))
	carry = 0
	j = (*Decimal)(unsafe.Pointer(pB)).FnDigit - 1
	k = i + j + 3
__7:
	if !(j >= 0) {
		goto __9
	}
	x = int32(*(*int8)(unsafe.Pointer(acc + uintptr(k)))) + int32(f)*int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pB)).Fa + uintptr(j)))) + carry
	*(*int8)(unsafe.Pointer(acc + uintptr(k))) = int8(x % 10)
	carry = x / 10
	goto __8
__8:
	j--
	k--
	goto __7
	goto __9
__9:
	;
	x = int32(*(*int8)(unsafe.Pointer(acc + uintptr(k)))) + carry
	*(*int8)(unsafe.Pointer(acc + uintptr(k))) = int8(x % 10)
	*(*int8)(unsafe.Pointer(acc + uintptr(k-1))) += int8(x / 10)
	goto __5
__5:
	i--
	goto __4
	goto __6
__6:
	;
	sqlite3.Xsqlite3_free(tls, (*Decimal)(unsafe.Pointer(pA)).Fa)
	(*Decimal)(unsafe.Pointer(pA)).Fa = acc
	acc = uintptr(0)
	*(*int32)(unsafe.Pointer(pA + 4)) += (*Decimal)(unsafe.Pointer(pB)).FnDigit + 2
	*(*int32)(unsafe.Pointer(pA + 8)) += (*Decimal)(unsafe.Pointer(pB)).FnFrac
	*(*int8)(unsafe.Pointer(pA)) ^= int8(int32((*Decimal)(unsafe.Pointer(pB)).Fsign))
__10:
	if !((*Decimal)(unsafe.Pointer(pA)).FnFrac > minFrac && int32(*(*int8)(unsafe.Pointer((*Decimal)(unsafe.Pointer(pA)).Fa + uintptr((*Decimal)(unsafe.Pointer(pA)).FnDigit-1)))) == 0) {
		goto __11
	}
	(*Decimal)(unsafe.Pointer(pA)).FnFrac--
	(*Decimal)(unsafe.Pointer(pA)).FnDigit--
	goto __10
__11:
	;
	decimal_result(tls, context, pA)

mul_end:
	sqlite3.Xsqlite3_free(tls, acc)
	decimal_free(tls, pA)
	decimal_free(tls, pB)
}

func sqlite3_decimal_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* decimal.c:597:5: */
	var rc int32 = SQLITE_OK
	var i uint32
	_ = pzErrMsg // Unused parameter

	_ = pApi

	for i = uint32(0); uint64(i) < uint64(unsafe.Sizeof(aFunc))/uint64(unsafe.Sizeof(struct {
		FzFuncName   uintptr
		FnArg        int32
		F__ccgo_pad1 [4]byte
		FxFunc       uintptr
	}{})) && rc == SQLITE_OK; i++ {
		rc = sqlite3.Xsqlite3_create_function(tls, db, aFunc[i].FzFuncName, aFunc[i].FnArg,
			SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC,
			uintptr(0), aFunc[i].FxFunc, uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_window_function(tls, db, ts+4826 /* "decimal_sum" */, 1,
			SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{decimalSumStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{decimalSumFinalize})),
			*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{decimalSumValue})), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{decimalSumInverse})), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_collation(tls, db, ts+4838 /* "decimal" */, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{decimalCollFunc})))
	}
	return rc
}

var aFunc = [5]struct {
	FzFuncName   uintptr
	FnArg        int32
	F__ccgo_pad1 [4]byte
	FxFunc       uintptr
}{
	{FzFuncName: ts + 4838 /* "decimal" */, FnArg: 1, FxFunc: 0},
	{FzFuncName: ts + 4846 /* "decimal_cmp" */, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 4858 /* "decimal_add" */, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 4870 /* "decimal_sub" */, FnArg: 2, FxFunc: 0},
	{FzFuncName: ts + 4882 /* "decimal_mul" */, FnArg: 2, FxFunc: 0},
} /* decimal.c:607:5 */

// Structure used to accumulate the output
type EvalResult = struct {
	Fz           uintptr
	FzSep        uintptr
	FszSep       int32
	F__ccgo_pad1 [4]byte
	FnAlloc      sqlite3_int64
	FnUsed       sqlite3_int64
} /* eval.c:23:1 */

// Callback from sqlite_exec() for the eval() function.
func callback(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr, colnames uintptr) int32 { /* eval.c:34:12: */
	var p uintptr = pCtx
	var i int32
	if argv == uintptr(0) {
		return 0
	}
	for i = 0; i < argc; i++ {
		var z uintptr
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) != 0 {
			z = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
		} else {
			z = ts + 584 /* "" */
		}
		var sz size_t = libc.Xstrlen(tls, z)
		if sqlite3_int64(sz)+(*EvalResult)(unsafe.Pointer(p)).FnUsed+sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep)+int64(1) > (*EvalResult)(unsafe.Pointer(p)).FnAlloc {
			var zNew uintptr
			(*EvalResult)(unsafe.Pointer(p)).FnAlloc = sqlite3_int64(uint64((*EvalResult)(unsafe.Pointer(p)).FnAlloc*int64(2)) + uint64(sz) + uint64((*EvalResult)(unsafe.Pointer(p)).FszSep) + uint64(1))
			// Using sqlite3_realloc64() would be better, but it is a recent
			// addition and will cause a segfault if loaded by an older version
			// of SQLite.
			if (*EvalResult)(unsafe.Pointer(p)).FnAlloc <= int64(0x7fffffff) {
				zNew = sqlite3.Xsqlite3_realloc64(tls, (*EvalResult)(unsafe.Pointer(p)).Fz, uint64((*EvalResult)(unsafe.Pointer(p)).FnAlloc))
			} else {
				zNew = uintptr(0)
			}
			if zNew == uintptr(0) {
				sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(p)).Fz)
				libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(EvalResult{})))
				return 1
			}
			(*EvalResult)(unsafe.Pointer(p)).Fz = zNew
		}
		if (*EvalResult)(unsafe.Pointer(p)).FnUsed > int64(0) {
			libc.Xmemcpy(tls, (*EvalResult)(unsafe.Pointer(p)).Fz+uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed), (*EvalResult)(unsafe.Pointer(p)).FzSep, uint64((*EvalResult)(unsafe.Pointer(p)).FszSep))
			*(*sqlite3_int64)(unsafe.Pointer(p + 32)) += sqlite3_int64((*EvalResult)(unsafe.Pointer(p)).FszSep)
		}
		libc.Xmemcpy(tls, (*EvalResult)(unsafe.Pointer(p)).Fz+uintptr((*EvalResult)(unsafe.Pointer(p)).FnUsed), z, sz)
		*(*sqlite3_int64)(unsafe.Pointer(p + 32)) += sqlite3_int64(uint64(sz))
	}
	return 0
}

// Implementation of the eval(X) and eval(X,Y) SQL functions.
//
// Evaluate the SQL text in X.  Return the results, using string
// Y as the separator.  If Y is omitted, use a single space character.
func sqlEvalFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* eval.c:71:13: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zSql uintptr
	var db uintptr
	*(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)) = uintptr(0)
	var rc int32
	// var x EvalResult at bp, 40

	libc.Xmemset(tls, bp /* &x */, 0, uint64(unsafe.Sizeof(EvalResult{})))
	(*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep = ts + 4894 /* " " */
	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zSql == uintptr(0) {
		return
	}
	if argc > 1 {
		(*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		if (*EvalResult)(unsafe.Pointer(bp)).FzSep == uintptr(0) {
			return
		}
	}
	(*EvalResult)(unsafe.Pointer(bp /* &x */)).FszSep = int32(libc.Xstrlen(tls, (*EvalResult)(unsafe.Pointer(bp /* &x */)).FzSep))
	db = sqlite3.Xsqlite3_context_db_handle(tls, context)
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{callback})), bp /* &x */, bp+40 /* &zErr */)
	if rc != SQLITE_OK {
		sqlite3.Xsqlite3_result_error(tls, context, *(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)), -1)
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)))
	} else if (*EvalResult)(unsafe.Pointer(bp)).FzSep == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		sqlite3.Xsqlite3_free(tls, (*EvalResult)(unsafe.Pointer(bp /* &x */)).Fz)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, (*EvalResult)(unsafe.Pointer(bp /* &x */)).Fz, int32((*EvalResult)(unsafe.Pointer(bp /* &x */)).FnUsed), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

func sqlite3_eval_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* eval.c:108:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4896 /* "eval" */, 1,
		SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sqlEvalFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+4896 /* "eval" */, 2,
			SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{sqlEvalFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// explain_vtab is a subclass of sqlite3_vtab which will
// serve as the underlying representation of a explain virtual table
type explain_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
} /* explain.c:38:9 */

// explain_vtab is a subclass of sqlite3_vtab which will
// serve as the underlying representation of a explain virtual table
type explain_vtab = explain_vtab1 /* explain.c:38:29 */

// explain_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result from an EXPLAIN operation.
type explain_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	Fdb          uintptr
	FzSql        uintptr
	FpExplain    uintptr
	Frc          int32
	F__ccgo_pad1 [4]byte
} /* explain.c:48:9 */

// explain_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result from an EXPLAIN operation.
type explain_cursor = explain_cursor1 /* explain.c:48:31 */

// The explainConnect() method is invoked to create a new
// explain_vtab that describes the explain virtual table.
//
// Think of this routine as the constructor for explain_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the explain_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against explain will look like.
func explainConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* explain.c:70:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+4901 /* "CREATE TABLE x(a..." */)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(explain_vtab{})))
		(*explain_vtab)(unsafe.Pointer(pNew)).Fdb = db
	}
	return rc
}

// This method is the destructor for explain_cursor objects.
func explainDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* explain.c:107:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new explain_cursor object.
func explainOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* explain.c:115:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(explain_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(explain_cursor{})))
	(*explain_cursor)(unsafe.Pointer(pCur)).Fdb = (*explain_vtab)(unsafe.Pointer(p)).Fdb
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Destructor for a explain_cursor.
func explainClose(tls *libc.TLS, cur uintptr) int32 { /* explain.c:128:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Advance a explain_cursor to its next row of output.
func explainNext(tls *libc.TLS, cur uintptr) int32 { /* explain.c:140:12: */
	var pCur uintptr = cur
	(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	if (*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_DONE && (*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_ROW {
		return (*explain_cursor)(unsafe.Pointer(pCur)).Frc
	}
	return SQLITE_OK
}

// Return values of columns for the row at which the explain_cursor
// is currently pointing.
func explainColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* explain.c:151:12: */
	var pCur uintptr = cur
	if i == EXPLN_COLUMN_SQL {
		sqlite3.Xsqlite3_result_text(tls, ctx, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql, -1, libc.UintptrFromInt32(-1))
	} else {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, i))
	}
	return SQLITE_OK
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func explainRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* explain.c:169:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain, 0)
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func explainEof(tls *libc.TLS, cur uintptr) int32 { /* explain.c:179:12: */
	var pCur uintptr = cur
	return libc.Bool32((*explain_cursor)(unsafe.Pointer(pCur)).Frc != SQLITE_ROW)
}

// This method is called to "rewind" the explain_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to explainColumn() or explainRowid() or
// explainEof().
//
// The argv[0] is the SQL statement that is to be explained.
func explainFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* explain.c:192:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pCur uintptr = pVtabCursor
	var zSql uintptr = uintptr(0)
	var rc int32
	sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
	(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) != SQLITE_TEXT {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = SQLITE_DONE
		return SQLITE_OK
	}
	sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
	(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))))
	if (*explain_cursor)(unsafe.Pointer(pCur)).FzSql != 0 {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+4963 /* "EXPLAIN %s" */, libc.VaList(bp+8, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql))
	}
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*explain_cursor)(unsafe.Pointer(pCur)).Fdb, zSql, -1, pCur+24, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if rc != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		(*explain_cursor)(unsafe.Pointer(pCur)).FpExplain = uintptr(0)
		sqlite3.Xsqlite3_free(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FzSql)
		(*explain_cursor)(unsafe.Pointer(pCur)).FzSql = uintptr(0)
	} else {
		(*explain_cursor)(unsafe.Pointer(pCur)).Frc = sqlite3.Xsqlite3_step(tls, (*explain_cursor)(unsafe.Pointer(pCur)).FpExplain)
		if (*explain_cursor)(unsafe.Pointer(pCur)).Frc == SQLITE_DONE || (*explain_cursor)(unsafe.Pointer(pCur)).Frc == SQLITE_ROW {
			rc = SQLITE_OK
		} else {
			rc = (*explain_cursor)(unsafe.Pointer(pCur)).Frc
		}
	}
	return rc
}

// SQLite will invoke this method one or more times while planning a query
// that uses the explain virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
func explainBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* explain.c:235:12: */
	var i int32            // Loop counter
	var idx int32 = -1     // Index of a usable == constraint against SQL
	var unusable int32 = 0 // True if there are unusable constraints on SQL

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(500)
	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != EXPLN_COLUMN_SQL {
			continue
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			unusable = 1
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idx = i
		}
	}
	if idx >= 0 {
		// There exists a usable == constraint against the SQL column
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).Fomit = uint8(1)
	} else if unusable != 0 {
		// There are unusable constraints against the SQL column.  Do not allow
		// this plan to continue forward.
		return SQLITE_CONSTRAINT
	}
	return SQLITE_OK
}

// This following structure defines all the methods for the
// explain virtual table.
var explainModule = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* explain.c:271:23 */

func sqlite3ExplainVtabInit(tls *libc.TLS, db uintptr) int32 { /* explain.c:300:5: */
	var rc int32 = SQLITE_OK
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+4974 /* "explain" */, uintptr(unsafe.Pointer(&explainModule)), uintptr(0))
	return rc
}

func sqlite3_explain_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* explain.c:311:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3ExplainVtabInit(tls, db)
	return rc
}

type pthread_once = struct {
	Fstate       int32
	F__ccgo_pad1 [4]byte
	Fmutex       pthread_mutex_t
} /* _pthreadtypes.h:52:1 */

// Primitive system data type definitions required by P1003.1c.
//
// Note that P1003.1c specifies that there are no defined comparison
// or assignment operators for the types pthread_attr_t, pthread_cond_t,
// pthread_condattr_t, pthread_mutex_t, pthread_mutexattr_t.
type pthread_t = uintptr             /* _pthreadtypes.h:67:26 */
type pthread_attr_t = uintptr        /* _pthreadtypes.h:70:30 */
type pthread_mutex_t = uintptr       /* _pthreadtypes.h:71:31 */
type pthread_mutexattr_t = uintptr   /* _pthreadtypes.h:72:35 */
type pthread_cond_t = uintptr        /* _pthreadtypes.h:73:30 */
type pthread_condattr_t = uintptr    /* _pthreadtypes.h:74:34 */
type pthread_key_t = int32           /* _pthreadtypes.h:75:20 */
type pthread_once_t = pthread_once   /* _pthreadtypes.h:76:30 */
type pthread_rwlock_t = uintptr      /* _pthreadtypes.h:77:32 */
type pthread_rwlockattr_t = uintptr  /* _pthreadtypes.h:78:35 */
type pthread_barrier_t = uintptr     /* _pthreadtypes.h:79:33 */
type pthread_barrierattr_t = uintptr /* _pthreadtypes.h:80:36 */
type pthread_spinlock_t = uintptr    /* _pthreadtypes.h:81:33 */

// Additional type definitions:
//
// Note that P1003.1c reserves the prefixes pthread_ and PTHREAD_ for
// use in header symbols.
type pthread_addr_t = uintptr         /* _pthreadtypes.h:89:14 */
type pthread_startroutine_t = uintptr /* _pthreadtypes.h:90:14 */

type u_char = uint8   /* types.h:52:23 */
type u_short = uint16 /* types.h:53:24 */
type u_int = uint32   /* types.h:54:22 */
type u_long = uint64  /* types.h:55:23 */
type ushort = uint16  /* types.h:57:24 */ // Sys V compatibility
type uint = uint32    /* types.h:58:22 */ // Sys V compatibility

// XXX POSIX sized integrals that should appear only in <sys/stdint.h>.
// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2011 David E. O'Brien <obrien@FreeBSD.org>
// Copyright (c) 2001 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type int8_t = int8 /* _stdint.h:36:19 */

type int16_t = int16 /* _stdint.h:41:20 */

type int32_t = int32 /* _stdint.h:46:20 */

type int64_t = int64 /* _stdint.h:51:20 */

type uint8_t = uint8 /* _stdint.h:56:20 */

type uint16_t = uint16 /* _stdint.h:61:21 */

type uint32_t = uint32 /* _stdint.h:66:21 */

type uint64_t = uint64 /* _stdint.h:71:21 */

type intptr_t = int64   /* _stdint.h:76:21 */
type uintptr_t = uint64 /* _stdint.h:80:22 */
type intmax_t = int64   /* _stdint.h:84:21 */
type uintmax_t = uint64 /* _stdint.h:88:22 */

type u_int8_t = uint8   /* types.h:67:19 */ // unsigned integrals (deprecated)
type u_int16_t = uint16 /* types.h:68:20 */
type u_int32_t = uint32 /* types.h:69:20 */
type u_int64_t = uint64 /* types.h:70:20 */

type u_quad_t = uint64 /* types.h:72:20 */ // quads (deprecated)
type quad_t = int64    /* types.h:73:19 */
type qaddr_t = uintptr /* types.h:74:16 */

type caddr_t = uintptr   /* types.h:76:14 */ // core address
type c_caddr_t = uintptr /* types.h:77:20 */ // core address, pointer to const

type blksize_t = int32 /* types.h:80:21 */

type cpuwhich_t = int32 /* types.h:84:22 */
type cpulevel_t = int32 /* types.h:85:22 */
type cpusetid_t = int32 /* types.h:86:22 */

type blkcnt_t = int64 /* types.h:89:20 */

type clock_t = int32 /* types.h:94:19 */

type clockid_t = int32 /* types.h:99:21 */

type critical_t = int64 /* types.h:103:22 */ // Critical section value
type daddr_t = int64    /* types.h:104:19 */ // disk address

type dev_t = uint64 /* types.h:107:18 */ // device number or struct cdev

type fflags_t = uint32 /* types.h:112:20 */ // file flags

type fixpt_t = uint32 /* types.h:116:19 */ // fixed point number

type fsblkcnt_t = uint64 /* types.h:119:22 */
type fsfilcnt_t = uint64 /* types.h:120:22 */

type gid_t = uint32 /* types.h:125:18 */ // group id

type in_addr_t = uint32 /* types.h:130:20 */ // base type for internet address

type in_port_t = uint16 /* types.h:135:20 */

type id_t = int64 /* types.h:140:17 */ // can hold a uid_t or pid_t

type ino_t = uint64 /* types.h:145:18 */ // inode number

type key_t = int64 /* types.h:150:18 */ // IPC key (for Sys V IPC)

type lwpid_t = int32 /* types.h:155:19 */ // Thread ID (a.k.a. LWP)

type mode_t = uint16 /* types.h:160:18 */ // permissions

type accmode_t = int32 /* types.h:165:21 */ // access permissions

type nlink_t = uint64 /* types.h:170:19 */ // link count

type pid_t = int32 /* types.h:185:18 */ // process id

type register_t = int64 /* types.h:189:22 */

type rlim_t = int64 /* types.h:192:18 */ // resource limit

type sbintime_t = int64 /* types.h:196:19 */

type segsz_t = int64 /* types.h:198:19 */ // segment size (in pages)

type suseconds_t = int64 /* types.h:211:23 */ // microseconds (signed)

type time_t = int64 /* types.h:216:18 */

type timer_t = uintptr /* types.h:221:19 */

type mqd_t = uintptr /* types.h:226:17 */

type u_register_t = uint64 /* types.h:230:24 */

type uid_t = uint32 /* types.h:233:18 */ // user id

type useconds_t = uint32 /* types.h:238:22 */ // microseconds (unsigned)

type cap_ioctl_t = uint64 /* types.h:244:23 */

// Types suitable for exporting physical addresses, virtual addresses
// (pointers), and memory object sizes from the kernel independent of native
// word size.  These should be used in place of vm_paddr_t, (u)intptr_t, and
// size_t in structs which contain such types that are shared with userspace.
type kpaddr_t = uint64 /* types.h:260:20 */
type kvaddr_t = uint64 /* types.h:261:20 */
type ksize_t = uint64  /* types.h:262:20 */
type kssize_t = int64  /* types.h:263:19 */

type vm_offset_t = uint64  /* types.h:265:23 */
type vm_ooffset_t = uint64 /* types.h:266:20 */
type vm_paddr_t = uint64   /* types.h:267:22 */
type vm_pindex_t = uint64  /* types.h:268:20 */
type vm_size_t = uint64    /* types.h:269:21 */

type rman_res_t = uint64 /* types.h:271:25 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.4 (Berkeley) 5/4/95
// $FreeBSD$

// sigset_t macros.

type __sigset = struct{ F__bits [4]uint32 } /* _sigset.h:53:9 */

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Structure returned by gettimeofday(2) system call, and used in other calls.
type timeval = struct {
	Ftv_sec  time_t
	Ftv_usec suseconds_t
} /* _timeval.h:49:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

type timespec = struct {
	Ftv_sec  time_t
	Ftv_nsec int64
} /* _timespec.h:46:1 */

// Structure defined by POSIX.1b to be like a itimerval, but with
// timespecs. Used in the timer_*() system calls.
type itimerspec = struct {
	Fit_interval struct {
		Ftv_sec  time_t
		Ftv_nsec int64
	}
	Fit_value struct {
		Ftv_sec  time_t
		Ftv_nsec int64
	}
} /* timespec.h:60:1 */

type fd_mask = uint64 /* select.h:46:19 */

type sigset_t = __sigset /* select.h:51:20 */

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).
// FD_SETSIZE may be defined by the user, but the default here should
// be enough for most uses.

type fd_set1 = struct{ F__fds_bits [16]uint64 } /* select.h:73:9 */

// Select uses bit masks of file descriptors in longs.  These macros
// manipulate such bit fields (the filesystem macros use chars).
// FD_SETSIZE may be defined by the user, but the default here should
// be enough for most uses.

type fd_set = fd_set1 /* select.h:75:3 */

// These declarations belong elsewhere, but are repeated here and in
// <stdio.h> to give broken programs a better chance of working with
// 64-bit off_t's.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stat.h	8.12 (Berkeley) 6/16/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// XXX We get miscellaneous namespace pollution with this.
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1991, 1993, 1994
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)types.h	8.6 (Berkeley) 2/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

type timezone = struct {
	Ftz_minuteswest int32
	Ftz_dsttime     int32
} /* time.h:42:1 */

type bintime = struct {
	Fsec  time_t
	Ffrac uint64_t
} /* time.h:55:1 */

// Decimal<->sbt conversions.  Multiplying or dividing by SBT_1NS results in
// large roundoff errors which sbttons() and nstosbt() avoid.  Millisecond and
// microsecond functions are also provided for completeness.
//
// These functions return the smallest sbt larger or equal to the
// number of seconds requested so that sbttoX(Xtosbt(y)) == y.  Unlike
// top of second computations below, which require that we tick at the
// top of second, these need to be rounded up so we do whatever for at
// least as long as requested.
//
// The naive computation we'd do is this
//	((unit * 2^64 / SIFACTOR) + 2^32-1) >> 32
// However, that overflows. Instead, we compute
//	((unit * 2^63 / SIFACTOR) + 2^31-1) >> 32
// and use pre-computed constants that are the ceil of the 2^63 / SIFACTOR
// term to ensure we are using exactly the right constant. We use the lesser
// evil of ull rather than a uint64_t cast to ensure we have well defined
// right shift semantics. With these changes, we get all the ns, us and ms
// conversions back and forth right.
// Note: This file is used for both kernel and userland includes, so we can't
// rely on KASSERT being defined, nor can we pollute the namespace by including
// assert.h.
func sbttons(tls *libc.TLS, _sbt sbintime_t) int64_t { /* time.h:185:1: */
	var ns uint64_t

	ns = uint64_t(_sbt)
	if ns >= uint64(sbintime_t(int64(1))<<32) {
		ns = ns >> 32 * uint64(1000000000)
	} else {
		ns = uint64(0)
	}

	return int64_t(ns + uint64_t(int64(1000000000)*(_sbt&int64(0xffffffff))>>32))
}

func nstosbt(tls *libc.TLS, _ns int64_t) sbintime_t { /* time.h:202:1: */
	var sb sbintime_t = int64(0)

	if _ns >= sbintime_t(int64(1))<<32 {
		sb = _ns / int64(1000000000) * (sbintime_t(int64(1)) << 32)
		_ns = _ns % int64(1000000000)
	}
	// 9223372037 = ceil(2^63 / 1000000000)
	sb = sbintime_t(uint64(sb) + (uint64(_ns)*9223372037+uint64(0x7fffffff))>>31)
	return sb
}

func sbttous(tls *libc.TLS, _sbt sbintime_t) int64_t { /* time.h:219:1: */

	return int64(1000000) * _sbt >> 32
}

func ustosbt(tls *libc.TLS, _us int64_t) sbintime_t { /* time.h:226:1: */
	var sb sbintime_t = int64(0)

	if _us >= sbintime_t(int64(1))<<32 {
		sb = _us / int64(1000000) * (sbintime_t(int64(1)) << 32)
		_us = _us % int64(1000000)
	}
	// 9223372036855 = ceil(2^63 / 1000000)
	sb = sbintime_t(uint64(sb) + (uint64(_us)*9223372036855+uint64(0x7fffffff))>>31)
	return sb
}

// Operations on timespecs

// Names of the interval timers, and structure
// defining a timer setting.

type itimerval = struct {
	Fit_interval struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
	Fit_value struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
} /* time.h:447:1 */

// Getkerninfo clock information structure
type clockinfo = struct {
	Fhz     int32
	Ftick   int32
	Fspare  int32
	Fstathz int32
	Fprofhz int32
} /* time.h:455:1 */

// These macros are also in time.h.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.3 (Berkeley) 1/21/94

// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2003 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Frequency of the clock ticks reported by times().  Deprecated - use
// sysconf(_SC_CLK_TCK) instead.  (Removed in 1003.1-2001.)

// Frequency of the clock ticks reported by clock().

// New in POSIX 1003.1b-1993.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)time.h	8.5 (Berkeley) 5/4/95
// from: FreeBSD: src/sys/sys/time.h,v 1.43 2000/03/20 14:09:05 phk Exp
//	$FreeBSD$

// These macros are also in sys/time.h.

type tm = struct {
	Ftm_sec      int32
	Ftm_min      int32
	Ftm_hour     int32
	Ftm_mday     int32
	Ftm_mon      int32
	Ftm_year     int32
	Ftm_wday     int32
	Ftm_yday     int32
	Ftm_isdst    int32
	F__ccgo_pad1 [4]byte
	Ftm_gmtoff   int64
	Ftm_zone     uintptr
} /* time.h:129:1 */

type sigevent = struct {
	Fsigev_notify int32
	Fsigev_signo  int32
	Fsigev_value  struct {
		F__ccgo_pad1 [0]uint64
		Fsival_int   int32
		F__ccgo_pad2 [4]byte
	}
	F_sigev_un struct {
		F__ccgo_pad1 [0]uint64
		F_threadid   int32
		F__ccgo_pad2 [60]byte
	}
} /* signal.h:195:1 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1983, 1990, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)fcntl.h	8.3 (Berkeley) 1/21/94
// $FreeBSD$

// This file includes the definitions for open and fcntl
// described by POSIX for <fcntl.h>; it also includes
// related kernel definitions.

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// File status flags: these are used by open(2), fcntl(2).
// They are also used (indirectly) in the kernel file structure f_flags,
// which is a superset of the open/fcntl flags.  Open flags and f_flags
// are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
// Open/fcntl flags begin with O_; kernel-internal flags begin with F.
// open-only flags

// Kernel encoding of open mode; separate read and write bits that are
// independently testable: 1 greater than the above.
//
// XXX
// FREAD and FWRITE are excluded from the #ifdef _KERNEL so that TIOCFLUSH,
// which was documented to use FREAD/FWRITE, continues to work.

// Defined by POSIX 1003.1; BSD default, but must be distinct from O_RDONLY.

// Attempt to bypass buffer cache

// Defined by POSIX 1003.1-2008; BSD default, but reserve for future use.

/* #define O_UNUSED1	0x00400000   */ // Was O_BENEATH

// XXX missing O_RSYNC.

// The O_* flags used to have only F* names, which were used in the kernel
// and by fcntl.  We retain the F* names for the kernel f_flag field
// and for backward compatibility for fcntl.  These flags are deprecated.

// Historically, we ran out of bits in f_flag (which was once a short).
// However, the flag bits not set in FMASK are only meaningful in the
// initial open syscall.  Those bits were thus given a
// different meaning for fcntl(2).
// Read ahead

// Magic value that specify the use of the current working directory
// to determine the target of relative file paths in the openat() and
// similar syscalls.

// Miscellaneous flags for the *at() syscalls.
/* #define AT_UNUSED1		0x1000 */ // Was AT_BENEATH

// Constants used for fcntl(2)

// command values

// Seals (F_ADD_SEALS, F_GET_SEALS).

// file descriptor flags (F_GETFD, F_SETFD)

// record locking flags (F_GETLK, F_SETLK, F_SETLKW)

// Advisory file segment locking data type -
// information passed to system by user
type flock = struct {
	Fl_start     off_t
	Fl_len       off_t
	Fl_pid       pid_t
	Fl_type      int16
	Fl_whence    int16
	Fl_sysid     int32
	F__ccgo_pad1 [4]byte
} /* fcntl.h:294:1 */

// Old advisory file segment locking data type,
// before adding l_sysid.
type __oflock = struct {
	Fl_start  off_t
	Fl_len    off_t
	Fl_pid    pid_t
	Fl_type   int16
	Fl_whence int16
} /* fcntl.h:308:1 */

// select(2)

type crypt_data = struct {
	Finitialized int32
	F__buf       [256]int8
} /* unistd.h:489:1 */

// getopt(3) external variable

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)dirent.h	8.2 (Berkeley) 7/28/94
// $FreeBSD$

// The kernel defines the format of directory entries returned by
// the getdirentries(2) system call.
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1989, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)dirent.h	8.3 (Berkeley) 8/10/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// The dirent structure defines the format of directory entries returned by
// the getdirentries(2) system call.
//
// A directory entry has a struct dirent at the front of it, containing its
// inode number, the length of the entry, and the length of the name
// contained in the entry.  These are followed by the name padded to an 8
// byte boundary with null bytes.  All names are guaranteed null terminated.
// The maximum length of a name in a directory is MAXNAMLEN.
//
// Explicit padding between the last member of the header (d_namlen) and
// d_name avoids ABI padding at the end of dirent on LP64 architectures.
// There is code depending on d_name being last.

type dirent = struct {
	Fd_fileno ino_t
	Fd_off    off_t
	Fd_reclen uint16
	Fd_type   uint8
	Fd_pad0   uint8
	Fd_namlen uint16
	Fd_pad1   uint16
	Fd_name   [256]int8
} /* dirent.h:66:1 */

// 11 was EAGAIN

// math software

// non-blocking and interrupt i/o

// ipc/network software -- argument errors

// ipc/network software -- operational errors

// should be rearranged

// quotas & mush

// Network File System

// ISO/IEC 9899:2011 K.3.2.2

// Structure of the fsdir() table-valued function
//    0    1    2     3    4           5

// Set the result stored by context ctx to a blob containing the
// contents of file zName.  Or, leave the result unchanged (NULL)
// if the file does not exist or is unreadable.
//
// If the file exceeds the SQLite blob size limit, through an
// SQLITE_TOOBIG error.
//
// Throw an SQLITE_IOERR if there are difficulties pulling the file
// off of disk.
func readFileContents(tls *libc.TLS, ctx uintptr, zName uintptr) { /* fileio.c:138:13: */
	var in uintptr
	var nIn sqlite3_int64
	var pBuf uintptr
	var db uintptr
	var mxBlob int32

	in = libc.Xfopen(tls, zName, ts+4402 /* "rb" */)
	if in == uintptr(0) {
		// File does not exist or is unreadable. Leave the result set to NULL.
		return
	}
	libc.Xfseek(tls, in, int64(0), SEEK_END)
	nIn = sqlite3_int64(libc.Xftell(tls, in))
	libc.Xrewind(tls, in)
	db = sqlite3.Xsqlite3_context_db_handle(tls, ctx)
	mxBlob = sqlite3.Xsqlite3_limit(tls, db, SQLITE_LIMIT_LENGTH, -1)
	if nIn > sqlite3_int64(mxBlob) {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, SQLITE_TOOBIG)
		libc.Xfclose(tls, in)
		return
	}
	pBuf = sqlite3.Xsqlite3_malloc64(tls, func() uint64 {
		if nIn != 0 {
			return uint64(nIn)
		}
		return uint64(1)
	}())
	if pBuf == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
		libc.Xfclose(tls, in)
		return
	}
	if nIn == sqlite3_int64(libc.Xfread(tls, pBuf, uint64(1), size_t(nIn), in)) {
		sqlite3.Xsqlite3_result_blob64(tls, ctx, pBuf, uint64(nIn), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		sqlite3.Xsqlite3_result_error_code(tls, ctx, SQLITE_IOERR)
		sqlite3.Xsqlite3_free(tls, pBuf)
	}
	libc.Xfclose(tls, in)
}

// Implementation of the "readfile(X)" SQL function.  The entire content
// of the file named X is read and returned as a BLOB.  NULL is returned
// if the file does not exist or is unreadable.
func readfileFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:180:13: */
	var zName uintptr
	_ = argc // Unused parameter
	zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zName == uintptr(0) {
		return
	}
	readFileContents(tls, context, zName)
}

// Set the error message contained in context ctx to the results of
// vprintf(zFmt, ...).
func ctxErrorMsg(tls *libc.TLS, ctx uintptr, zFmt uintptr, va uintptr) { /* fileio.c:196:13: */
	var zMsg uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	sqlite3.Xsqlite3_result_error(tls, ctx, zMsg, -1)
	sqlite3.Xsqlite3_free(tls, zMsg)
	_ = ap
}

// This function is used in place of stat().  On Windows, special handling
// is required in order for the included time to be returned as UTC.  On all
// other systems, this function simply calls stat().
func fileStat(tls *libc.TLS, zPath uintptr, pStatBuf uintptr) int32 { /* fileio.c:282:12: */
	return libc.Xstat(tls, zPath, pStatBuf)
}

// This function is used in place of lstat().  On Windows, special handling
// is required in order for the included time to be returned as UTC.  On all
// other systems, this function simply calls lstat().
func fileLinkStat(tls *libc.TLS, zPath uintptr, pStatBuf uintptr) int32 { /* fileio.c:300:12: */
	return libc.Xlstat(tls, zPath, pStatBuf)
}

// Argument zFile is the name of a file that will be created and/or written
// by SQL function writefile(). This function ensures that the directory
// zFile will be written to exists, creating it if required. The permissions
// for any path components created by this function are set in accordance
// with the current umask.
//
// If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
// SQLITE_OK is returned if the directory is successfully created, or
// SQLITE_ERROR otherwise.
func makeDirectory(tls *libc.TLS, zFile uintptr) int32 { /* fileio.c:324:12: */
	bp := tls.Alloc(232)
	defer tls.Free(232)

	var zCopy uintptr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zFile))
	var rc int32 = SQLITE_OK

	if zCopy == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var nCopy int32 = int32(libc.Xstrlen(tls, zCopy))
		var i int32 = 1

		for rc == SQLITE_OK {
			// var sStat stat at bp+8, 224

			var rc2 int32

			for ; int32(*(*int8)(unsafe.Pointer(zCopy + uintptr(i)))) != '/' && i < nCopy; i++ {
			}
			if i == nCopy {
				break
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8(0)

			rc2 = fileStat(tls, zCopy, bp+8 /* &sStat */)
			if rc2 != 0 {
				if libc.Xmkdir(tls, zCopy, uint16(0777)) != 0 {
					rc = SQLITE_ERROR
				}
			} else {
				if !(int32((*stat)(unsafe.Pointer(bp+8)).Fst_mode)&0170000 == 0040000) {
					rc = SQLITE_ERROR
				}
			}
			*(*int8)(unsafe.Pointer(zCopy + uintptr(i))) = int8('/')
			i++
		}

		sqlite3.Xsqlite3_free(tls, zCopy)
	}

	return rc
}

// This function does the work for the writefile() UDF. Refer to
// header comments at the top of this file for details.
func writeFile(tls *libc.TLS, pCtx uintptr, zFile uintptr, pData uintptr, mode mode_t, mtime sqlite3_int64) int32 { /* fileio.c:364:12: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	if int32(mode)&0170000 == 0120000 {
		var zTo uintptr = sqlite3.Xsqlite3_value_text(tls, pData)
		if libc.Xsymlink(tls, zTo, zFile) < 0 {
			return 1
		}
	} else {
		if int32(mode)&0170000 == 0040000 {
			if libc.Xmkdir(tls, zFile, mode) != 0 {
				// The mkdir() call to create the directory failed. This might not
				// be an error though - if there is already a directory at the same
				// path and either the permissions already match or can be changed
				// to do so using chmod(), it is not an error.
				// var sStat stat at bp, 224

				if *(*int32)(unsafe.Pointer(libc.X__error(tls))) != EEXIST ||
					0 != fileStat(tls, zFile, bp) ||
					!(int32((*stat)(unsafe.Pointer(bp)).Fst_mode)&0170000 == 0040000) ||
					int32((*stat)(unsafe.Pointer(bp)).Fst_mode)&0777 != int32(mode)&0777 && 0 != libc.Xchmod(tls, zFile, uint16(int32(mode)&0777)) {
					return 1
				}
			}
		} else {
			var nWrite sqlite3_int64 = int64(0)
			var z uintptr
			var rc int32 = 0
			var out uintptr = libc.Xfopen(tls, zFile, ts+4982 /* "wb" */)
			if out == uintptr(0) {
				return 1
			}
			z = sqlite3.Xsqlite3_value_blob(tls, pData)
			if z != 0 {
				var n sqlite3_int64 = sqlite3_int64(libc.Xfwrite(tls, z, uint64(1), uint64(sqlite3.Xsqlite3_value_bytes(tls, pData)), out))
				nWrite = sqlite3_int64(sqlite3.Xsqlite3_value_bytes(tls, pData))
				if nWrite != n {
					rc = 1
				}
			}
			libc.Xfclose(tls, out)
			if rc == 0 && mode != 0 && libc.Xchmod(tls, zFile, uint16(int32(mode)&0777)) != 0 {
				rc = 1
			}
			if rc != 0 {
				return 2
			}
			sqlite3.Xsqlite3_result_int64(tls, pCtx, nWrite)
		}
	}

	if mtime >= int64(0) {
		// Legacy unix
		// var times [2]timeval at bp+224, 32

		(*timeval)(unsafe.Pointer(bp + 224 /* &times */)).Ftv_usec = libc.AssignPtrInt64(bp+224+1*16+8, int64(0))
		(*timeval)(unsafe.Pointer(bp + 224 /* &times */)).Ftv_sec = libc.Xtime(tls, uintptr(0))
		(*timeval)(unsafe.Pointer(bp + 224 /* &times */ + 1*16)).Ftv_sec = time_t(mtime)
		if libc.Xutimes(tls, zFile, bp+224) != 0 {
			return 1
		}
	}

	return 0
}

// Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.
// Refer to header comments at the top of this file for details.
func writefileFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:478:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zFile uintptr
	var mode mode_t = mode_t(0)
	var res int32
	var mtime sqlite3_int64 = int64(-1)

	if argc < 2 || argc > 4 {
		sqlite3.Xsqlite3_result_error(tls, context,
			ts+4985 /* "wrong number of ..." */, -1)
		return
	}

	zFile = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zFile == uintptr(0) {
		return
	}
	if argc >= 3 {
		mode = mode_t(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	}
	if argc == 4 {
		mtime = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))
	}

	res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + 1*8)), mode, mtime)
	if res == 1 && *(*int32)(unsafe.Pointer(libc.X__error(tls))) == ENOENT {
		if makeDirectory(tls, zFile) == SQLITE_OK {
			res = writeFile(tls, context, zFile, *(*uintptr)(unsafe.Pointer(argv + 1*8)), mode, mtime)
		}
	}

	if argc > 2 && res != 0 {
		if int32(mode)&0170000 == 0120000 {
			ctxErrorMsg(tls, context, ts+5035 /* "failed to create..." */, libc.VaList(bp, zFile))
		} else if int32(mode)&0170000 == 0040000 {
			ctxErrorMsg(tls, context, ts+5064 /* "failed to create..." */, libc.VaList(bp+8, zFile))
		} else {
			ctxErrorMsg(tls, context, ts+5095 /* "failed to write ..." */, libc.VaList(bp+16, zFile))
		}
	}
}

// SQL function:   lsmode(MODE)
//
// Given a numberic st_mode from stat(), convert it into a human-readable
// text string in the style of "ls -l".
func lsModeFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* fileio.c:528:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var i int32
	var iMode int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	// var z [16]int8 at bp, 16

	_ = argc
	if iMode&0170000 == 0120000 {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('l')
	} else if iMode&0170000 == 0100000 {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('-')
	} else if iMode&0170000 == 0040000 {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('d')
	} else {
		*(*int8)(unsafe.Pointer(bp /* &z[0] */)) = int8('?')
	}
	for i = 0; i < 3; i++ {
		var m int32 = iMode >> ((2 - i) * 3)
		var a uintptr = bp + uintptr(1+i*3)
		*(*int8)(unsafe.Pointer(a)) = func() int8 {
			if m&0x4 != 0 {
				return int8('r')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + 1)) = func() int8 {
			if m&0x2 != 0 {
				return int8('w')
			}
			return int8('-')
		}()
		*(*int8)(unsafe.Pointer(a + 2)) = func() int8 {
			if m&0x1 != 0 {
				return int8('x')
			}
			return int8('-')
		}()
	}
	*(*int8)(unsafe.Pointer(bp /* &z[0] */ + 10)) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp /* &z[0] */, -1, libc.UintptrFromInt32(-1))
}

// Cursor type for recursively iterating through a directory structure.
type fsdir_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FnLvl        int32
	FiLvl        int32
	FaLvl        uintptr
	FzBase       uintptr
	FnBase       int32
	F__ccgo_pad1 [4]byte
	FsStat       struct {
		Fst_dev      dev_t
		Fst_ino      ino_t
		Fst_nlink    nlink_t
		Fst_mode     mode_t
		Fst_padding0 int16
		Fst_uid      uid_t
		Fst_gid      gid_t
		Fst_padding1 int32
		Fst_rdev     dev_t
		Fst_atim     struct {
			Ftv_sec  time_t
			Ftv_nsec int64
		}
		Fst_mtim struct {
			Ftv_sec  time_t
			Ftv_nsec int64
		}
		Fst_ctim struct {
			Ftv_sec  time_t
			Ftv_nsec int64
		}
		Fst_birthtim struct {
			Ftv_sec  time_t
			Ftv_nsec int64
		}
		Fst_size    off_t
		Fst_blocks  blkcnt_t
		Fst_blksize blksize_t
		Fst_flags   fflags_t
		Fst_gen     uint64
		Fst_spare   [10]uint64
	}
	FzPath  uintptr
	FiRowid sqlite3_int64
} /* fileio.c:562:9 */

// Cursor type for recursively iterating through a directory structure.
type fsdir_cursor = fsdir_cursor1 /* fileio.c:562:29 */
type FsdirLevel1 = struct {
	FpDir uintptr
	FzDir uintptr
} /* fileio.c:562:9 */

type FsdirLevel = FsdirLevel1 /* fileio.c:563:27 */

type fsdir_tab1 = struct{ Fbase sqlite3_vtab } /* fileio.c:585:9 */

type fsdir_tab = fsdir_tab1 /* fileio.c:585:26 */

// Construct a new fsdir virtual table object.
func fsdirConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fileio.c:593:12: */
	var pNew uintptr = uintptr(0)
	var rc int32
	_ = pAux
	_ = argc
	_ = argv
	_ = pzErr
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+5120 /* "CREATE TABLE x(n..." */)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_tab{})))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(fsdir_tab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// This method is the destructor for fsdir vtab objects.
func fsdirDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* fileio.c:620:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new fsdir_cursor object.
func fsdirOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* fileio.c:628:12: */
	var pCur uintptr
	_ = p
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fsdir_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(fsdir_cursor{})))
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Reset a cursor back to the state it was in when first returned
// by fsdirOpen().
func fsdirResetCursor(tls *libc.TLS, pCur uintptr) { /* fileio.c:643:13: */
	var i int32
	for i = 0; i <= (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl; i++ {
		var pLvl uintptr = (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(i)*16
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir != 0 {
			libc.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		}
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
	}
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = uintptr(0)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = 0
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = -1
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
}

// Destructor for an fsdir_cursor.
func fsdirClose(tls *libc.TLS, cur uintptr) int32 { /* fileio.c:664:12: */
	var pCur uintptr = cur

	fsdirResetCursor(tls, pCur)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Set the error message for the virtual table associated with cursor
// pCur to the results of vprintf(zFmt, ...).
func fsdirSetErrmsg(tls *libc.TLS, pCur uintptr, zFmt uintptr, va uintptr) { /* fileio.c:676:13: */
	var ap va_list
	_ = ap
	ap = va
	(*sqlite3_vtab)(unsafe.Pointer((*fsdir_cursor)(unsafe.Pointer(pCur)).Fbase.FpVtab)).FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

// Advance an fsdir_cursor to its next row of output.
func fsdirNext(tls *libc.TLS, cur uintptr) int32 { /* fileio.c:687:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pCur uintptr = cur
	var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode

	(*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid++
	if int32(m)&0170000 == 0040000 {
		// Descend into this directory
		var iNew int32 = (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl + 1
		var pLvl uintptr
		if iNew >= (*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl {
			var nNew int32 = iNew + 1
			var nByte sqlite3_int64 = sqlite3_int64(uint64(nNew) * uint64(unsafe.Sizeof(FsdirLevel{})))
			var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl, uint64(nByte))
			if aNew == uintptr(0) {
				return SQLITE_NOMEM
			}
			libc.Xmemset(tls, aNew+uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl)*16, 0, uint64(unsafe.Sizeof(FsdirLevel{}))*uint64(nNew-(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl))
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl = aNew
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FnLvl = nNew
		}
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl = iNew
		pLvl = (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr(iNew)*16

		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = libc.Xopendir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		if (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir == uintptr(0) {
			fsdirSetErrmsg(tls, pCur, ts+5180 /* "cannot read dire..." */, libc.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
			return SQLITE_ERROR
		}
	}

	for (*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl >= 0 {
		var pLvl uintptr = (*fsdir_cursor)(unsafe.Pointer(pCur)).FaLvl + uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl)*16
		var pEntry uintptr = libc.Xreaddir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		if pEntry != 0 {
			if int32(*(*int8)(unsafe.Pointer(pEntry + 24))) == '.' {
				if int32(*(*int8)(unsafe.Pointer(pEntry + 24 + 1))) == '.' && int32(*(*int8)(unsafe.Pointer(pEntry + 24 + 2))) == 0 {
					continue
				}
				if int32(*(*int8)(unsafe.Pointer(pEntry + 24 + 1))) == 0 {
					continue
				}
			}
			sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+5206 /* "%s/%s" */, libc.VaList(bp+8, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir, pEntry+24))
			if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
				return SQLITE_NOMEM
			}
			if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, pCur+40) != 0 {
				fsdirSetErrmsg(tls, pCur, ts+5212 /* "cannot stat file..." */, libc.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
				return SQLITE_ERROR
			}
			return SQLITE_OK
		}
		libc.Xclosedir(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir)
		sqlite3.Xsqlite3_free(tls, (*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FpDir = uintptr(0)
		(*FsdirLevel)(unsafe.Pointer(pLvl)).FzDir = uintptr(0)
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FiLvl--
	}

	// EOF
	sqlite3.Xsqlite3_free(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
	(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = uintptr(0)
	return SQLITE_OK
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func fsdirColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* fileio.c:751:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pCur uintptr = cur
	switch i {
	case FSDIR_COLUMN_NAME:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath+uintptr((*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase), -1, libc.UintptrFromInt32(-1))
			break

		}

	case FSDIR_COLUMN_MODE:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode))
		break

	case FSDIR_COLUMN_MTIME:
		sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mtim.Ftv_sec))
		break

	case FSDIR_COLUMN_DATA:
		{
			var m mode_t = (*fsdir_cursor)(unsafe.Pointer(pCur)).FsStat.Fst_mode
			if int32(m)&0170000 == 0040000 {
				sqlite3.Xsqlite3_result_null(tls, ctx)
			} else if int32(m)&0170000 == 0120000 {
				// var aStatic [64]int8 at bp, 64

				var aBuf uintptr = bp /* aStatic */
				var nBuf sqlite3_int64 = int64(64)
				var n int32

				for 1 != 0 {
					n = int32(libc.Xreadlink(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, aBuf, uint64(nBuf)))
					if sqlite3_int64(n) < nBuf {
						break
					}
					if aBuf != bp {
						sqlite3.Xsqlite3_free(tls, aBuf)
					}
					nBuf = nBuf * int64(2)
					aBuf = sqlite3.Xsqlite3_malloc64(tls, uint64(nBuf))
					if aBuf == uintptr(0) {
						sqlite3.Xsqlite3_result_error_nomem(tls, ctx)
						return SQLITE_NOMEM
					}
				}

				sqlite3.Xsqlite3_result_text(tls, ctx, aBuf, n, libc.UintptrFromInt32(-1))
				if aBuf != bp {
					sqlite3.Xsqlite3_free(tls, aBuf)
				}
			} else {
				readFileContents(tls, ctx, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath)
			}

		}
		fallthrough
	case FSDIR_COLUMN_PATH:
		fallthrough
	default:
		{
			// The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
			// always return their values as NULL
			break

		}
	}
	return SQLITE_OK
}

// Return the rowid for the current row. In this implementation, the
// first row returned is assigned rowid value 1, and each subsequent
// row a value 1 more than that of the previous.
func fsdirRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* fileio.c:816:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fsdir_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func fsdirEof(tls *libc.TLS, cur uintptr) int32 { /* fileio.c:826:12: */
	var pCur uintptr = cur
	return libc.Bool32((*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0))
}

// xFilter callback.
//
// idxNum==1   PATH parameter only
// idxNum==2   Both PATH and DIR supplied
func fsdirFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* fileio.c:837:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zDir uintptr = uintptr(0)
	var pCur uintptr = cur
	_ = idxStr
	fsdirResetCursor(tls, pCur)

	if idxNum == 0 {
		fsdirSetErrmsg(tls, pCur, ts+5233 /* "table function f..." */, 0)
		return SQLITE_ERROR
	}

	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zDir == uintptr(0) {
		fsdirSetErrmsg(tls, pCur, ts+5275 /* "table function f..." */, 0)
		return SQLITE_ERROR
	}
	if argc == 2 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	}
	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase != 0 {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FnBase = int32(libc.Xstrlen(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase)) + 1
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts+5206 /* "%s/%s" */, libc.VaList(bp, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzBase, zDir))
	} else {
		(*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, zDir))
	}

	if (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath == uintptr(0) {
		return SQLITE_NOMEM
	}
	if fileLinkStat(tls, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath, pCur+40) != 0 {
		fsdirSetErrmsg(tls, pCur, ts+5212 /* "cannot stat file..." */, libc.VaList(bp+24, (*fsdir_cursor)(unsafe.Pointer(pCur)).FzPath))
		return SQLITE_ERROR
	}

	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the generate_series virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// The query plan is represented by values of idxNum:
//
//  (1)  The path value is supplied by argv[0]
//  (2)  Path is in argv[0] and dir is in argv[1]
func fsdirBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* fileio.c:893:12: */
	var i int32            // Loop over constraints
	var idxPath int32 = -1 // Index in pIdxInfo->aConstraint of PATH=
	var idxDir int32 = -1  // Index in pIdxInfo->aConstraint of DIR=
	var seenPath int32 = 0 // True if an unusable PATH= constraint is seen
	var seenDir int32 = 0  // True if an unusable DIR= constraint is seen
	var pConstraint uintptr

	_ = tab
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		switch (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn {
		case FSDIR_COLUMN_PATH:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxPath = i
					seenPath = 0
				} else if idxPath < 0 {
					seenPath = 1
				}
				break

			}
		case FSDIR_COLUMN_DIR:
			{
				if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable != 0 {
					idxDir = i
					seenDir = 0
				} else if idxDir < 0 {
					seenDir = 1
				}
				break

			}
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if seenPath != 0 || seenDir != 0 {
		// If input parameters are unusable, disallow this plan
		return SQLITE_CONSTRAINT
	}

	if idxPath < 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
		// The pIdxInfo->estimatedCost should have been initialized to a huge
		// number.  Leave it unchanged.
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(0x7fffffff)
	} else {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).Fomit = uint8(1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxPath)*8)).FargvIndex = 1
		if idxDir >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idxDir)*8)).FargvIndex = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 2
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
		} else {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100.0
		}
	}

	return SQLITE_OK
}

// Register the "fsdir" virtual table.
func fsdirRegister(tls *libc.TLS, db uintptr) int32 { /* fileio.c:959:12: */

	var rc int32 = sqlite3.Xsqlite3_create_module(tls, db, ts+5325 /* "fsdir" */, uintptr(unsafe.Pointer(&fsdirModule1)), uintptr(0))
	return rc
}

var fsdirModule1 = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* fileio.c:960:25 */

func sqlite3_fileio_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* fileio.c:997:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5331 /* "readfile" */, 1,
		SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{readfileFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5340 /* "writefile" */, -1,
			SQLITE_UTF8|SQLITE_DIRECTONLY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{writefileFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5350 /* "lsmode" */, 1, SQLITE_UTF8, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{lsModeFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = fsdirRegister(tls, db)
	}
	return rc
}

// See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
// B.8.2.7 for the rationale behind the *_unlocked() macros.

// Forward declaration of objects used by this implementation
type fuzzer_vtab1 = struct {
	Fbase        sqlite3_vtab
	FzClassName  uintptr
	FpRule       uintptr
	FnCursor     int32
	F__ccgo_pad1 [4]byte
} /* fuzzer.c:162:9 */

// See ISO/IEC 9945-1 ANSI/IEEE Std 1003.1 Second Edition 1996-07-12
// B.8.2.7 for the rationale behind the *_unlocked() macros.

// Forward declaration of objects used by this implementation
type fuzzer_vtab = fuzzer_vtab1 /* fuzzer.c:162:28 */
type fuzzer_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiRowid      sqlite3_int64
	FpVtab       uintptr
	FrLimit      fuzzer_cost
	F__ccgo_pad1 [4]byte
	FpStem       uintptr
	FpDone       uintptr
	FaQueue      [20]uintptr
	FmxQueue     int32
	F__ccgo_pad2 [4]byte
	FzBuf        uintptr
	FnBuf        int32
	FnStem       int32
	FiRuleset    int32
	F__ccgo_pad3 [4]byte
	FnullRule    fuzzer_rule
	FapHash      [4001]uintptr
} /* fuzzer.c:163:9 */

type fuzzer_cursor = fuzzer_cursor1 /* fuzzer.c:163:30 */
type fuzzer_rule1 = struct {
	FpNext       uintptr
	FzFrom       uintptr
	FrCost       fuzzer_cost
	FnFrom       fuzzer_len
	FnTo         fuzzer_len
	F__ccgo_pad1 [2]byte
	FiRuleset    fuzzer_ruleid
	FzTo         [4]int8
} /* fuzzer.c:162:9 */

type fuzzer_rule = fuzzer_rule1 /* fuzzer.c:164:28 */
type fuzzer_stem1 = struct {
	FzBasis      uintptr
	FpRule       uintptr
	FpNext       uintptr
	FpHash       uintptr
	FrBaseCost   fuzzer_cost
	FrCostX      fuzzer_cost
	FnBasis      fuzzer_len
	Fn           fuzzer_len
	F__ccgo_pad1 [6]byte
} /* fuzzer.c:163:9 */

type fuzzer_stem = fuzzer_stem1 /* fuzzer.c:166:28 */

// Various types.
//
// fuzzer_cost is the "cost" of an edit operation.
//
// fuzzer_len is the length of a matching string.
//
// fuzzer_ruleid is an ruleset identifier.
type fuzzer_cost = int32   /* fuzzer.c:177:13 */
type fuzzer_len = int8     /* fuzzer.c:178:21 */
type fuzzer_ruleid = int32 /* fuzzer.c:179:13 */

// The two input rule lists are both sorted in order of increasing
// cost.  Merge them together into a single list, sorted by cost, and
// return a pointer to the head of that list.
func fuzzerMergeRules(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* fuzzer.c:261:20: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var head fuzzer_rule at bp, 32

	var pTail uintptr

	pTail = bp /* &head */
	for pA != 0 && pB != 0 {
		if (*fuzzer_rule)(unsafe.Pointer(pA)).FrCost <= (*fuzzer_rule)(unsafe.Pointer(pB)).FrCost {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_rule)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_rule)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_rule)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_rule)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Statement pStmt currently points to a row in the fuzzer data table. This
// function allocates and populates a fuzzer_rule structure according to
// the content of the row.
//
// If successful, *ppRule is set to point to the new object and SQLITE_OK
// is returned. Otherwise, *ppRule is zeroed, *pzErr may be set to point
// to an error message and an SQLite error code returned.
func fuzzerLoadOneRule(tls *libc.TLS, p uintptr, pStmt uintptr, ppRule uintptr, pzErr uintptr) int32 { /* fuzzer.c:294:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var iRuleset sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
	var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 2)
	var nCost int32 = sqlite3.Xsqlite3_column_int(tls, pStmt, 3)

	var rc int32 = SQLITE_OK       // Return code
	var nFrom int32                // Size of string zFrom, in bytes
	var nTo int32                  // Size of string zTo, in bytes
	var pRule uintptr = uintptr(0) // New rule object to return

	if zFrom == uintptr(0) {
		zFrom = ts + 584 /* "" */
	}
	if zTo == uintptr(0) {
		zTo = ts + 584 /* "" */
	}
	nFrom = int32(libc.Xstrlen(tls, zFrom))
	nTo = int32(libc.Xstrlen(tls, zTo))

	// Silently ignore null transformations
	if libc.Xstrcmp(tls, zFrom, zTo) == 0 {
		*(*uintptr)(unsafe.Pointer(ppRule)) = uintptr(0)
		return SQLITE_OK
	}

	if nCost <= 0 || nCost > FUZZER_MX_COST {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3304, /* "%s: cost must be..." */
			libc.VaList(bp, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_COST))
		rc = SQLITE_ERROR
	} else if nFrom > FUZZER_MX_LENGTH || nTo > FUZZER_MX_LENGTH {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3338, /* "%s: maximum stri..." */
			libc.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_LENGTH))
		rc = SQLITE_ERROR
	} else if iRuleset < int64(0) || iRuleset > int64(FUZZER_MX_RULEID) {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+5357, /* "%s: ruleset must..." */
			libc.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, FUZZER_MX_RULEID))
		rc = SQLITE_ERROR
	} else {

		pRule = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(fuzzer_rule{}))+uint64(nFrom)+uint64(nTo)))
		if pRule == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pRule, 0, uint64(unsafe.Sizeof(fuzzer_rule{})))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom = pRule + 28 /* &.zTo */
			*(*uintptr)(unsafe.Pointer(pRule + 8)) += uintptr(nTo + 1)
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom = fuzzer_len(nFrom)
			libc.Xmemcpy(tls, (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, zFrom, uint64(nFrom+1))
			libc.Xmemcpy(tls, pRule+28, zTo, uint64(nTo+1))
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo = fuzzer_len(nTo)
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FrCost = nCost
			(*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset = int32(iRuleset)
		}
	}

	*(*uintptr)(unsafe.Pointer(ppRule)) = pRule
	return rc
}

// Load the content of the fuzzer data table into memory.
func fuzzerLoadRules(tls *libc.TLS, db uintptr, p uintptr, zDb uintptr, zData uintptr, pzErr uintptr) int32 { /* fuzzer.c:363:12: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	var rc int32 = SQLITE_OK // Return code
	var zSql uintptr         // SELECT used to read from rules table
	var pHead uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+3407 /* "SELECT * FROM %Q..." */, libc.VaList(bp, zDb, zData))
	if zSql == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var rc2 int32 // finalize() return code
		*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+56 /* &pStmt */, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3427 /* "%s: %s" */, libc.VaList(bp+16, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, sqlite3.Xsqlite3_errmsg(tls, db)))
		} else if sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) != 4 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+3434, /* "%s: %s has %d co..." */
				libc.VaList(bp+32, (*fuzzer_vtab)(unsafe.Pointer(p)).FzClassName, zData, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))))
			rc = SQLITE_ERROR
		} else {
			for rc == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 56))) {
				*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)) = uintptr(0)
				rc = fuzzerLoadOneRule(tls, p, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)), bp+64 /* &pRule */, pzErr)
				if *(*uintptr)(unsafe.Pointer(bp + 64)) != 0 {
					(*fuzzer_rule)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */)))).FpNext = pHead
					pHead = *(*uintptr)(unsafe.Pointer(bp + 64 /* pRule */))
				}
			}
		}
		rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	// All rules are now in a singly linked list starting at pHead. This
	// block sorts them by cost and then sets fuzzer_vtab.pRule to point to
	// point to the head of the sorted list.
	if rc == SQLITE_OK {
		var i uint32
		var pX uintptr
		// var a [15]uintptr at bp+72, 120

		for i = uint32(0); uint64(i) < uint64(unsafe.Sizeof([15]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
		}
		for libc.AssignUintptr(&pX, pHead) != uintptr(0) {
			pHead = (*fuzzer_rule)(unsafe.Pointer(pX)).FpNext
			(*fuzzer_rule)(unsafe.Pointer(pX)).FpNext = uintptr(0)
			for i = uint32(0); *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) != 0 && uint64(i) < uint64(unsafe.Sizeof([15]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0)))-uint64(1); i++ {
				pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
				*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = uintptr(0)
			}
			*(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)) = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		pX = *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */))
		i = uint32(1)
		for ; uint64(i) < uint64(unsafe.Sizeof([15]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
			pX = fuzzerMergeRules(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* &a[0] */ + uintptr(i)*8)), pX)
		}
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = fuzzerMergeRules(tls, (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule, pX)
	} else {
		// An error has occurred. Setting p->pRule to point to the head of the
		// allocated list ensures that the list will be cleaned up in this case.

		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = pHead
	}

	return rc
}

// This function converts an SQL quoted string into an unquoted string
// and returns a pointer to a buffer allocated using sqlite3_malloc()
// containing the result. The caller should eventually free this buffer
// using sqlite3_free.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func fuzzerDequote(tls *libc.TLS, zIn uintptr) uintptr { /* fuzzer.c:449:13: */
	var nIn sqlite3_int64 // Size of input string, in bytes
	var zOut uintptr      // Output (dequoted) string

	nIn = sqlite3_int64(libc.Xstrlen(tls, zIn))
	zOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+int64(1)))
	if zOut != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(zIn)) // Quote character (if any )

		if int32(q) != '[' && int32(q) != '\'' && int32(q) != '"' && int32(q) != '`' {
			libc.Xmemcpy(tls, zOut, zIn, size_t(nIn+int64(1)))
		} else {
			var iOut int32 = 0 // Index of next byte to write to output
			var iIn int32      // Index of next byte to read from input

			if int32(q) == '[' {
				q = int8(']')
			}
			for iIn = 1; sqlite3_int64(iIn) < nIn; iIn++ {
				if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))) == int32(q) {
					iIn++
				}
				*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(zIn + uintptr(iIn)))
			}
		}

	}
	return zOut
}

// xDisconnect/xDestroy method for the fuzzer module.
func fuzzerDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* fuzzer.c:478:12: */
	var p uintptr = pVtab

	for (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule != 0 {
		var pRule uintptr = (*fuzzer_vtab)(unsafe.Pointer(p)).FpRule
		(*fuzzer_vtab)(unsafe.Pointer(p)).FpRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		sqlite3.Xsqlite3_free(tls, pRule)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// xConnect/xCreate method for the fuzzer module. Arguments are:
//
//   argv[0]   -> module name  ("fuzzer")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3]   -> fuzzer rule table name
func fuzzerConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* fuzzer.c:498:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK      // Return code
	var pNew uintptr = uintptr(0) // New virtual table
	var zModule uintptr = *(*uintptr)(unsafe.Pointer(argv))
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*8))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+5394 /* "%s: wrong number..." */, libc.VaList(bp, zModule))
		rc = SQLITE_ERROR
	} else {
		var nModule sqlite3_int64 // Length of zModule, in bytes

		nModule = sqlite3_int64(libc.Xstrlen(tls, zModule))
		pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(fuzzer_vtab{}))+uint64(nModule)+uint64(1))
		if pNew == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			var zTab uintptr // Dequoted name of fuzzer data table

			libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(fuzzer_vtab{})))
			(*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName = pNew + 1*48
			libc.Xmemcpy(tls, (*fuzzer_vtab)(unsafe.Pointer(pNew)).FzClassName, zModule, size_t(nModule+int64(1)))

			zTab = fuzzerDequote(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))
			if zTab == uintptr(0) {
				rc = SQLITE_NOMEM
			} else {
				rc = fuzzerLoadRules(tls, db, pNew, zDb, zTab, pzErr)
				sqlite3.Xsqlite3_free(tls, zTab)
			}

			if rc == SQLITE_OK {
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+5445 /* "CREATE TABLE x(w..." */)
			}
			if rc != SQLITE_OK {
				fuzzerDisconnect(tls, pNew)
				pNew = uintptr(0)
			} else {
				sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
			}
		}
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// Open a new fuzzer cursor.
func fuzzerOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* fuzzer.c:556:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(fuzzer_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(fuzzer_cursor{})))
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	(*fuzzer_vtab)(unsafe.Pointer(p)).FnCursor++
	return SQLITE_OK
}

// Free all stems in a list.
func fuzzerClearStemList(tls *libc.TLS, pStem uintptr) { /* fuzzer.c:571:13: */
	for pStem != 0 {
		var pNext uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext
		sqlite3.Xsqlite3_free(tls, pStem)
		pStem = pNext
	}
}

// Free up all the memory allocated by a cursor.  Set it rLimit to 0
// to indicate that it is at EOF.
func fuzzerClearCursor(tls *libc.TLS, pCur uintptr, clearHash int32) { /* fuzzer.c:583:13: */
	var i int32
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
	fuzzerClearStemList(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone)
	for i = 0; i < FUZZER_NQUEUE; i++ {
		fuzzerClearStemList(tls, *(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(i)*8)))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	if clearHash != 0 && (*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = 0
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = uintptr(0)
		libc.Xmemset(tls, pCur+48, 0, uint64(unsafe.Sizeof([20]uintptr{})))
		libc.Xmemset(tls, pCur+272, 0, uint64(unsafe.Sizeof([4001]uintptr{})))
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem = 0
}

// Close a fuzzer cursor.
func fuzzerClose(tls *libc.TLS, cur uintptr) int32 { /* fuzzer.c:602:12: */
	var pCur uintptr = cur
	fuzzerClearCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	(*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FnCursor--
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Compute the current output term for a fuzzer_stem.
func fuzzerRender(tls *libc.TLS, pStem uintptr, pzBuf uintptr, pnBuf uintptr) int32 { /* fuzzer.c:614:12: */
	var pRule uintptr = (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule
	var n int32   // Size of output term without nul-term
	var z uintptr // Buffer to assemble output term in

	n = int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis) + int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo) - int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)
	if *(*int32)(unsafe.Pointer(pnBuf)) < n+1 {
		*(*uintptr)(unsafe.Pointer(pzBuf)) = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(pzBuf)), n+100)
		if *(*uintptr)(unsafe.Pointer(pzBuf)) == uintptr(0) {
			return SQLITE_NOMEM
		}
		*(*int32)(unsafe.Pointer(pnBuf)) = n + 100
	}
	n = int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn)
	z = *(*uintptr)(unsafe.Pointer(pzBuf))
	if n < 0 {
		libc.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, uint64(int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)+1))
	} else {
		libc.Xmemcpy(tls, z, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis, uint64(n))
		libc.Xmemcpy(tls, z+uintptr(n), pRule+28, uint64((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo))
		libc.Xmemcpy(tls, z+uintptr(n+int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)), (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis+uintptr(n+int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)),
			uint64(int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)-n-int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)+1))
	}

	return SQLITE_OK
}

// Compute a hash on zBasis.
func fuzzerHash(tls *libc.TLS, z uintptr) uint32 { /* fuzzer.c:647:21: */
	var h uint32 = uint32(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		h = h<<3 ^ h>>29 ^ uint32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
	}
	return h % uint32(FUZZER_HASH)
}

// Current cost of a stem
func fuzzerCost(tls *libc.TLS, pStem uintptr) fuzzer_cost { /* fuzzer.c:656:20: */
	return libc.AssignPtrInt32(pStem+36, (*fuzzer_stem)(unsafe.Pointer(pStem)).FrBaseCost+(*fuzzer_rule)(unsafe.Pointer((*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule)).FrCost)
}

// Return 1 if the string to which the cursor is point has already
// been emitted.  Return 0 if not.  Return -1 on a memory allocation
// failures.
func fuzzerSeen(tls *libc.TLS, pCur uintptr, pStem uintptr) int32 { /* fuzzer.c:694:12: */
	var h uint32
	var pLookup uintptr

	if fuzzerRender(tls, pStem, pCur+216, pCur+224) == SQLITE_NOMEM {
		return -1
	}
	h = fuzzerHash(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf)
	pLookup = *(*uintptr)(unsafe.Pointer(pCur + 272 + uintptr(h)*8))
	for pLookup != 0 && libc.Xstrcmp(tls, (*fuzzer_stem)(unsafe.Pointer(pLookup)).FzBasis, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf) != 0 {
		pLookup = (*fuzzer_stem)(unsafe.Pointer(pLookup)).FpHash
	}
	return libc.Bool32(pLookup != uintptr(0))
}

// If argument pRule is NULL, this function returns false.
//
// Otherwise, it returns true if rule pRule should be skipped. A rule
// should be skipped if it does not belong to rule-set iRuleset, or if
// applying it to stem pStem would create a string longer than
// FUZZER_MX_OUTPUT_LENGTH bytes.
func fuzzerSkipRule(tls *libc.TLS, pRule uintptr, pStem uintptr, iRuleset int32) int32 { /* fuzzer.c:717:12: */
	return libc.Bool32(pRule != 0 && ((*fuzzer_rule)(unsafe.Pointer(pRule)).FiRuleset != iRuleset ||
		int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)+int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnTo)-int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) > FUZZER_MX_OUTPUT_LENGTH))
}

// Advance a fuzzer_stem to its next value.   Return 0 if there are
// no more values that can be generated by this fuzzer_stem.  Return
// -1 on a memory allocation failure.
func fuzzerAdvance(tls *libc.TLS, pCur uintptr, pStem uintptr) int32 { /* fuzzer.c:733:12: */
	var pRule uintptr
	for libc.AssignUintptr(&pRule, (*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule) != uintptr(0) {

		for int32((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn) < int32((*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis)-int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn++
			if int32((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom) == 0 ||
				libc.Xmemcmp(tls, (*fuzzer_stem)(unsafe.Pointer(pStem)).FzBasis+uintptr((*fuzzer_stem)(unsafe.Pointer(pStem)).Fn), (*fuzzer_rule)(unsafe.Pointer(pRule)).FzFrom, uint64((*fuzzer_rule)(unsafe.Pointer(pRule)).FnFrom)) == 0 {
				// Found a rewrite case.  Make sure it is not a duplicate
				var rc int32 = fuzzerSeen(tls, pCur, pStem)
				if rc < 0 {
					return -1
				}
				if rc == 0 {
					fuzzerCost(tls, pStem)
					return 1
				}
			}
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = int8(-1)
		for ok := true; ok; ok = fuzzerSkipRule(tls, pRule, pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
			pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = pRule
		if pRule != 0 && fuzzerCost(tls, pStem) > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit {
			(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = uintptr(0)
		}
	}
	return 0
}

// The two input stem lists are both sorted in order of increasing
// rCostX.  Merge them together into a single list, sorted by rCostX, and
// return a pointer to the head of that new list.
func fuzzerMergeStems(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* fuzzer.c:766:20: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var head fuzzer_stem at bp, 48

	var pTail uintptr

	pTail = bp /* &head */
	for pA != 0 && pB != 0 {
		if (*fuzzer_stem)(unsafe.Pointer(pA)).FrCostX <= (*fuzzer_stem)(unsafe.Pointer(pB)).FrCostX {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
			pTail = pA
			pA = (*fuzzer_stem)(unsafe.Pointer(pA)).FpNext
		} else {
			(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
			pTail = pB
			pB = (*fuzzer_stem)(unsafe.Pointer(pB)).FpNext
		}
	}
	if pA == uintptr(0) {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pB
	} else {
		(*fuzzer_stem)(unsafe.Pointer(pTail)).FpNext = pA
	}
	return (*fuzzer_stem)(unsafe.Pointer(bp /* &head */)).FpNext
}

// Load pCur->pStem with the lowest-cost stem.  Return a pointer
// to the lowest-cost stem.
func fuzzerLowestCostStem(tls *libc.TLS, pCur uintptr) uintptr { /* fuzzer.c:794:20: */
	var pBest uintptr
	var pX uintptr
	var iBest int32
	var i int32

	if (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem == uintptr(0) {
		iBest = -1
		pBest = uintptr(0)
		for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
			pX = *(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(i)*8))
			if pX == uintptr(0) {
				continue
			}
			if pBest == uintptr(0) || (*fuzzer_stem)(unsafe.Pointer(pBest)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX {
				pBest = pX
				iBest = i
			}
		}
		if pBest != 0 {
			*(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(iBest)*8)) = (*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext
			(*fuzzer_stem)(unsafe.Pointer(pBest)).FpNext = uintptr(0)
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pBest
		}
	}
	return (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
}

// Insert pNew into queue of pending stems.  Then find the stem
// with the lowest rCostX and move it into pCur->pStem.
// list.  The insert is done such the pNew is in the correct order
// according to fuzzer_stem.zBaseCost+fuzzer_stem.pRule->rCost.
func fuzzerInsert(tls *libc.TLS, pCur uintptr, pNew uintptr) uintptr { /* fuzzer.c:825:20: */
	var pX uintptr
	var i int32

	// If pCur->pStem exists and is greater than pNew, then make pNew
	// the new pCur->pStem and insert the old pCur->pStem instead.
	if libc.AssignUintptr(&pX, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem) != uintptr(0) && (*fuzzer_stem)(unsafe.Pointer(pX)).FrCostX > (*fuzzer_stem)(unsafe.Pointer(pNew)).FrCostX {
		(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = pNew
		pNew = pX
	}

	// Insert the new value
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = uintptr(0)
	pX = pNew
	for i = 0; i <= (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue; i++ {
		if *(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(i)*8)) != 0 {
			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(i)*8)))
			*(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(i)*8)) = uintptr(0)
		} else {
			*(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(i)*8)) = pX
			break
		}
	}
	if i > (*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue {
		if i < FUZZER_NQUEUE {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FmxQueue = i
			*(*uintptr)(unsafe.Pointer(pCur + 48 + uintptr(i)*8)) = pX
		} else {

			pX = fuzzerMergeStems(tls, pX, *(*uintptr)(unsafe.Pointer(pCur + 48 + 19*8)))
			*(*uintptr)(unsafe.Pointer(pCur + 48 + 19*8)) = pX
		}
	}

	return fuzzerLowestCostStem(tls, pCur)
}

// Allocate a new fuzzer_stem.  Add it to the hash table but do not
// link it into either the pCur->pStem or pCur->pDone lists.
func fuzzerNewStem(tls *libc.TLS, pCur uintptr, zWord uintptr, rBaseCost fuzzer_cost) uintptr { /* fuzzer.c:868:20: */
	var pNew uintptr
	var pRule uintptr
	var h uint32

	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(fuzzer_stem{}))+libc.Xstrlen(tls, zWord)+uint64(1)))
	if pNew == uintptr(0) {
		return uintptr(0)
	}
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(fuzzer_stem{})))
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis = pNew + 1*48
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis = fuzzer_len(libc.Xstrlen(tls, zWord))
	libc.Xmemcpy(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis, zWord, uint64(int32((*fuzzer_stem)(unsafe.Pointer(pNew)).FnBasis)+1))
	pRule = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	for fuzzerSkipRule(tls, pRule, pNew, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset) != 0 {
		pRule = (*fuzzer_rule)(unsafe.Pointer(pRule)).FpNext
	}
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpRule = pRule
	(*fuzzer_stem)(unsafe.Pointer(pNew)).Fn = int8(-1)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FrBaseCost = libc.AssignPtrInt32(pNew+36, rBaseCost)
	h = fuzzerHash(tls, (*fuzzer_stem)(unsafe.Pointer(pNew)).FzBasis)
	(*fuzzer_stem)(unsafe.Pointer(pNew)).FpHash = *(*uintptr)(unsafe.Pointer(pCur + 272 + uintptr(h)*8))
	*(*uintptr)(unsafe.Pointer(pCur + 272 + uintptr(h)*8)) = pNew
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnStem++
	return pNew
}

// Advance a cursor to its next row of output
func fuzzerNext(tls *libc.TLS, cur uintptr) int32 { /* fuzzer.c:901:12: */
	var pCur uintptr = cur
	var rc int32
	var pStem uintptr
	var pNew uintptr

	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid++

	// Use the element the cursor is currently point to to create
	// a new stem and insert the new stem into the priority queue.
	pStem = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem
	if (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX > 0 {
		rc = fuzzerRender(tls, pStem, pCur+216, pCur+224)
		if rc == SQLITE_NOMEM {
			return SQLITE_NOMEM
		}
		pNew = fuzzerNewStem(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, (*fuzzer_stem)(unsafe.Pointer(pStem)).FrCostX)
		if pNew != 0 {
			if fuzzerAdvance(tls, pCur, pNew) == 0 {
				(*fuzzer_stem)(unsafe.Pointer(pNew)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
				(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pNew
			} else {
				if fuzzerInsert(tls, pCur, pNew) == pNew {
					return SQLITE_OK
				}
			}
		} else {
			return SQLITE_NOMEM
		}
	}

	// Adjust the priority queue so that the first element of the
	// stem list is the next lowest cost word.
	for libc.AssignUintptr(&pStem, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem) != uintptr(0) {
		var res int32 = fuzzerAdvance(tls, pCur, pStem)
		if res < 0 {
			return SQLITE_NOMEM
		} else if res > 0 {
			(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
			pStem = fuzzerInsert(tls, pCur, pStem)
			if libc.AssignInt32(&rc, fuzzerSeen(tls, pCur, pStem)) != 0 {
				if rc < 0 {
					return SQLITE_NOMEM
				}
				continue
			}
			return SQLITE_OK // New word found
		}
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = uintptr(0)
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpNext = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpDone = pStem
		if fuzzerLowestCostStem(tls, pCur) != 0 {
			rc = fuzzerSeen(tls, pCur, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)
			if rc < 0 {
				return SQLITE_NOMEM
			}
			if rc == 0 {
				return SQLITE_OK
			}
		}
	}

	// Reach this point only if queue has been exhausted and there is
	// nothing left to be output.
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	return SQLITE_OK
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any fuzzerColumn, fuzzerRowid, or fuzzerEof call.
func fuzzerFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* fuzzer.c:969:12: */
	var pCur uintptr = pVtabCursor
	var zWord uintptr = ts + 584 /* "" */
	var pStem uintptr
	var idx int32

	fuzzerClearCursor(tls, pCur, 1)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 2147483647
	idx = 0
	if idxNum&1 != 0 {
		zWord = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		idx++
	}
	if idxNum&2 != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	if idxNum&4 != 0 {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRuleset = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(idx)*8)))
		idx++
	}
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FpNext = (*fuzzer_vtab)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpVtab)).FpRule
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FrCost = 0
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnFrom = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FnTo = int8(0)
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FnullRule.FzFrom = ts + 584 /* "" */
	(*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)

	// If the query term is longer than FUZZER_MX_OUTPUT_LENGTH bytes, this
	// query will return zero rows.
	if int32(libc.Xstrlen(tls, zWord)) < FUZZER_MX_OUTPUT_LENGTH {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem = libc.AssignUintptr(&pStem, fuzzerNewStem(tls, pCur, zWord, 0))
		if pStem == uintptr(0) {
			return SQLITE_NOMEM
		}
		(*fuzzer_stem)(unsafe.Pointer(pStem)).FpRule = pCur + 240
		(*fuzzer_stem)(unsafe.Pointer(pStem)).Fn = (*fuzzer_stem)(unsafe.Pointer(pStem)).FnBasis
	} else {
		(*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit = 0
	}

	return SQLITE_OK
}

// Only the word and distance columns have values.  All other columns
// return NULL
func fuzzerColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* fuzzer.c:1020:12: */
	var pCur uintptr = cur
	if i == 0 {
		// the "word" column
		if fuzzerRender(tls, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem, pCur+216, pCur+224) == SQLITE_NOMEM {
			return SQLITE_NOMEM
		}
		sqlite3.Xsqlite3_result_text(tls, ctx, (*fuzzer_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, libc.UintptrFromInt32(-1))
	} else if i == 1 {
		// the "distance" column
		sqlite3.Xsqlite3_result_int(tls, ctx, (*fuzzer_stem)(unsafe.Pointer((*fuzzer_cursor)(unsafe.Pointer(pCur)).FpStem)).FrCostX)
	} else {
		// All other columns are NULL
		sqlite3.Xsqlite3_result_null(tls, ctx)
	}
	return SQLITE_OK
}

// The rowid.
func fuzzerRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* fuzzer.c:1041:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*fuzzer_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// When the fuzzer_cursor.rLimit value is 0 or less, that is a signal
// that the cursor has nothing more to output.
func fuzzerEof(tls *libc.TLS, cur uintptr) int32 { /* fuzzer.c:1051:12: */
	var pCur uintptr = cur
	return libc.Bool32((*fuzzer_cursor)(unsafe.Pointer(pCur)).FrLimit <= 0)
}

// Search for terms of these forms:
//
//   (A)    word MATCH $str
//   (B1)   distance < $value
//   (B2)   distance <= $value
//   (C)    ruleid == $ruleid
//
// The distance< and distance<= are both treated as distance<=.
// The query plan number is a bit vector:
//
//   bit 1:   Term of the form (A) found
//   bit 2:   Term like (B1) or (B2) found
//   bit 3:   Term like (C) found
//
// If bit-1 is set, $str is always in filter.argv[0].  If bit-2 is set
// then $value is in filter.argv[0] if bit-1 is clear and is in
// filter.argv[1] if bit-1 is set.  If bit-3 is set, then $ruleid is
// in filter.argv[0] if bit-1 and bit-2 are both zero, is in
// filter.argv[1] if exactly one of bit-1 and bit-2 are set, and is in
// filter.argv[2] if both bit-1 and bit-2 are set.
func fuzzerBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* fuzzer.c:1078:12: */
	var iPlan int32 = 0
	var iDistTerm int32 = -1
	var iRulesetTerm int32 = -1
	var i int32
	var seenMatch int32 = 0
	var pConstraint uintptr
	var rCost float64 = 1e12

	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			seenMatch = 1
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if iPlan&1 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			iPlan = iPlan | 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			rCost = rCost / 1e6
		}
		if iPlan&2 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 1 &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE) {
			iPlan = iPlan | 2
			iDistTerm = i
			rCost = rCost / 10.0
		}
		if iPlan&4 == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == 2 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | 4
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
			iRulesetTerm = i
			rCost = rCost / 10.0
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if iPlan&2 != 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = 1 + libc.Bool32(iPlan&1 != 0)
	}
	if iPlan&4 != 0 {
		var idx int32 = 1
		if iPlan&1 != 0 {
			idx++
		}
		if iPlan&2 != 0 {
			idx++
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRulesetTerm)*8)).FargvIndex = idx
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == 1 &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if seenMatch != 0 && iPlan&1 == 0 {
		rCost = 1e99
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = rCost

	return SQLITE_OK
}

// A virtual table module that implements the "fuzzer".
var fuzzerModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* fuzzer.c:1147:23 */

func sqlite3_fuzzer_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* fuzzer.c:1176:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+5483 /* "fuzzer" */, uintptr(unsafe.Pointer(&fuzzerModule)), uintptr(0))
	return rc
}

// Mark a function parameter as unused, to suppress nuisance compiler
// warnings.

// Implementation of the ieee754() function
func ieee754func(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* ieee754.c:102:13: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	if argc == 1 {
		var m sqlite3_int64
		// var a sqlite3_int64 at bp+32, 8

		// var r float64 at bp+16, 8

		var e int32
		var isNeg int32
		// var zResult [100]int8 at bp+40, 100

		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB &&
			uint64(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))) == uint64(unsafe.Sizeof(float64(0))) {
			var x uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var i uint32
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 24 /* v */)) = uint64(0)
			for i = uint32(0); uint64(i) < uint64(unsafe.Sizeof(float64(0))); i++ {
				*(*sqlite3_uint64)(unsafe.Pointer(bp + 24 /* v */)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 24))<<8 | sqlite3_uint64(*(*uint8)(unsafe.Pointer(x + uintptr(i))))
			}
			libc.Xmemcpy(tls, bp+16 /* &r */, bp+24 /* &v */, uint64(unsafe.Sizeof(float64(0))))
		} else {
			*(*float64)(unsafe.Pointer(bp + 16 /* r */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
		}
		if *(*float64)(unsafe.Pointer(bp + 16)) < 0.0 {
			isNeg = 1
			*(*float64)(unsafe.Pointer(bp + 16 /* r */)) = -*(*float64)(unsafe.Pointer(bp + 16 /* r */))
		} else {
			isNeg = 0
		}
		libc.Xmemcpy(tls, bp+32 /* &a */, bp+16 /* &r */, uint64(unsafe.Sizeof(sqlite3_int64(0))))
		if *(*sqlite3_int64)(unsafe.Pointer(bp + 32)) == int64(0) {
			e = 0
			m = int64(0)
		} else {
			e = int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 32)) >> 52)
			m = *(*sqlite3_int64)(unsafe.Pointer(bp + 32)) & (sqlite3_int64(int64(1))<<52 - int64(1))
			if e == 0 {
				m <<= 1
			} else {
				m = m | sqlite3_int64(int64(1))<<52
			}
			for e < 1075 && m > int64(0) && m&int64(1) == int64(0) {
				m >>= 1
				e++
			}
			if isNeg != 0 {
				m = -m
			}
		}
		switch *(*int32)(unsafe.Pointer(sqlite3.Xsqlite3_user_data(tls, context))) {
		case 0:
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zResult[0] */, ts+5490, /* "ieee754(%lld,%d)" */
				libc.VaList(bp, m, e-1075))
			sqlite3.Xsqlite3_result_text(tls, context, bp+40 /* &zResult[0] */, -1, libc.UintptrFromInt32(-1))
			break
			fallthrough
		case 1:
			sqlite3.Xsqlite3_result_int64(tls, context, m)
			break
			fallthrough
		case 2:
			sqlite3.Xsqlite3_result_int(tls, context, e-1075)
			break
		}
	} else {
		var m sqlite3_int64
		var e sqlite3_int64
		// var a sqlite3_int64 at bp+152, 8

		// var r float64 at bp+144, 8

		var isNeg int32 = 0
		m = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
		e = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))

		// Limit the range of e.  Ticket 22dea1cfdb9151e4 2021-03-02
		if e > int64(10000) {
			e = int64(10000)
		} else if e < int64(-10000) {
			e = int64(-10000)
		}

		if m < int64(0) {
			isNeg = 1
			m = -m
			if m < int64(0) {
				return
			}
		} else if m == int64(0) && e > int64(-1000) && e < int64(1000) {
			sqlite3.Xsqlite3_result_double(tls, context, 0.0)
			return
		}
		for m>>32&int64(0xffe00000) != 0 {
			m >>= 1
			e++
		}
		for m != int64(0) && m>>32&int64(0xfff00000) == int64(0) {
			m <<= 1
			e--
		}
		e = e + int64(1075)
		if e <= int64(0) {
			// Subnormal
			if int64(1)-e >= int64(64) {
				m = int64(0)
			} else {
				m >>= int64(1) - e
			}
			e = int64(0)
		} else if e > int64(0x7ff) {
			e = int64(0x7ff)
		}
		*(*sqlite3_int64)(unsafe.Pointer(bp + 152 /* a */)) = m & (sqlite3_int64(int64(1))<<52 - int64(1))
		*(*sqlite3_int64)(unsafe.Pointer(bp + 152 /* a */)) |= e << 52
		if isNeg != 0 {
			*(*sqlite3_int64)(unsafe.Pointer(bp + 152 /* a */)) |= libc.Int64FromUint64(sqlite3_uint64(uint64(1)) << 63)
		}
		libc.Xmemcpy(tls, bp+144 /* &r */, bp+152 /* &a */, uint64(unsafe.Sizeof(float64(0))))
		sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 144 /* r */)))
	}
}

// Functions to convert between blobs and floats.
func ieee754func_from_blob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* ieee754.c:217:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	_ = argc
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB &&
		uint64(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))) == uint64(unsafe.Sizeof(float64(0))) {
		// var r float64 at bp, 8

		var x uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var i uint32
		*(*sqlite3_uint64)(unsafe.Pointer(bp + 8 /* v */)) = uint64(0)
		for i = uint32(0); uint64(i) < uint64(unsafe.Sizeof(float64(0))); i++ {
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 8 /* v */)) = *(*sqlite3_uint64)(unsafe.Pointer(bp + 8))<<8 | sqlite3_uint64(*(*uint8)(unsafe.Pointer(x + uintptr(i))))
		}
		libc.Xmemcpy(tls, bp /* &r */, bp+8 /* &v */, uint64(unsafe.Sizeof(float64(0))))
		sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp /* r */)))
	}
}

func ieee754func_to_blob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* ieee754.c:237:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_FLOAT ||
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_INTEGER {
		*(*float64)(unsafe.Pointer(bp + 8 /* r */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
		// var v sqlite3_uint64 at bp, 8

		// var a [8]uint8 at bp+16, 8

		var i uint32
		libc.Xmemcpy(tls, bp /* &v */, bp+8 /* &r */, uint64(unsafe.Sizeof(float64(0))))
		for i = uint32(1); uint64(i) <= uint64(unsafe.Sizeof(float64(0))); i++ {
			*(*uint8)(unsafe.Pointer(bp + 16 /* &a[0] */ + uintptr(uint64(unsafe.Sizeof(float64(0)))-uint64(i)))) = uint8(*(*sqlite3_uint64)(unsafe.Pointer(bp)) & uint64(0xff))
			*(*sqlite3_uint64)(unsafe.Pointer(bp /* v */)) >>= 8
		}
		sqlite3.Xsqlite3_result_blob(tls, context, bp+16 /* &a[0] */, int32(unsafe.Sizeof(float64(0))), libc.UintptrFromInt32(-1))
	}
}

func sqlite3_ieee_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* ieee754.c:263:5: */
	var i uint32
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	for i = uint32(0); uint64(i) < uint64(unsafe.Sizeof(aFunc1))/uint64(unsafe.Sizeof(struct {
		FzFName uintptr
		FnArg   int32
		FiAux   int32
		FxFunc  uintptr
	}{})) && rc == SQLITE_OK; i++ {
		rc = sqlite3.Xsqlite3_create_function(tls, db, aFunc1[i].FzFName, aFunc1[i].FnArg,
			SQLITE_UTF8|SQLITE_INNOCUOUS,
			uintptr(unsafe.Pointer(&aFunc1))+uintptr(i)*24+12,
			aFunc1[i].FxFunc, uintptr(0), uintptr(0))
	}
	return rc
}

var aFunc1 = [6]struct {
	FzFName uintptr
	FnArg   int32
	FiAux   int32
	FxFunc  uintptr
}{
	{FzFName: ts + 5507 /* "ieee754" */, FnArg: 1, FxFunc: 0},
	{FzFName: ts + 5507 /* "ieee754" */, FnArg: 2, FxFunc: 0},
	{FzFName: ts + 5515 /* "ieee754_mantissa" */, FnArg: 1, FiAux: 1, FxFunc: 0},
	{FzFName: ts + 5532 /* "ieee754_exponent" */, FnArg: 1, FiAux: 2, FxFunc: 0},
	{FzFName: ts + 5549 /* "ieee754_to_blob" */, FnArg: 1, FxFunc: 0},
	{FzFName: ts + 5565 /* "ieee754_from_blo..." */, FnArg: 1, FxFunc: 0},
} /* ieee754.c:273:5 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// This function is used to touch each page of a mapping of a memory
// mapped SQLite database. Assuming that the system has sufficient free
// memory and supports sufficiently large mappings, this causes the OS
// to cache the entire database in main memory, making subsequent
// database accesses faster.
//
// If the second parameter to this function is not NULL, it is the name of
// the specific database to operate on (i.e. "main" or the name of an
// attached database).
//
// SQLITE_OK is returned if successful, or an SQLite error code otherwise.
// It is not considered an error if the file is not memory-mapped, or if
// the mapping does not span the entire file. If an error does occur, a
// transaction may be left open on the database file.
//
// It is illegal to call this function when the database handle has an
// open transaction. SQLITE_MISUSE is returned in this case.
func sqlite3_mmap_warm(tls *libc.TLS, db uintptr, zDb uintptr) int32 { /* mmapwarm.c:37:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	var rc int32 = SQLITE_OK
	var zSql uintptr = uintptr(0)
	var pgsz int32 = 0
	var nTotal int32 = 0

	if 0 == sqlite3.Xsqlite3_get_autocommit(tls, db) {
		return SQLITE_MISUSE
	}

	// Open a read-only transaction on the file in question
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5583, /* "BEGIN; SELECT * ..." */
		libc.VaList(bp, func() uintptr {
			if zDb != 0 {
				return ts + 5624 /* "'" */
			}
			return ts + 584 /* "" */
		}(), func() uintptr {
			if zDb != 0 {
				return zDb
			}
			return ts + 584
		}(), func() uintptr {
			if zDb != 0 {
				return ts + 5626 /* "'." */
			}
			return ts + 584 /* "" */
		}()))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	// Find the SQLite page size of the file
	if rc == SQLITE_OK {
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+5629, /* "PRAGMA %s%q%spag..." */
			libc.VaList(bp+24, func() uintptr {
				if zDb != 0 {
					return ts + 5624 /* "'" */
				}
				return ts + 584 /* "" */
			}(), func() uintptr {
				if zDb != 0 {
					return zDb
				}
				return ts + 584
			}(), func() uintptr {
				if zDb != 0 {
					return ts + 5626 /* "'." */
				}
				return ts + 584 /* "" */
			}()))
		if zSql == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			*(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)) = uintptr(0)
			rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+64 /* &pPgsz */, uintptr(0))
			sqlite3.Xsqlite3_free(tls, zSql)
			if rc == SQLITE_OK {
				if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 64))) == SQLITE_ROW {
					pgsz = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)), 0)
				}
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pPgsz */)))
			}
			if rc == SQLITE_OK && pgsz == 0 {
				rc = SQLITE_ERROR
			}
		}
	}

	// Touch each mmap'd page of the file
	if rc == SQLITE_OK {
		var rc2 int32
		*(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, db, zDb, SQLITE_FCNTL_FILE_POINTER, bp+72 /* &pFd */)
		if rc == SQLITE_OK && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)))).FpMethods)).FiVersion >= 3 {
			var iPg sqlite3_int64 = int64(1)
			var p uintptr = (*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)))).FpMethods
			for 1 != 0 {
				// var pMap uintptr at bp+80, 8

				rc = (*struct {
					f func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods)(unsafe.Pointer(p)).FxFetch})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)), sqlite3_int64(pgsz)*iPg, pgsz, bp+80 /* &pMap */)
				if rc != SQLITE_OK || *(*uintptr)(unsafe.Pointer(bp + 80)) == uintptr(0) {
					break
				}

				nTotal = nTotal + int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)))))
				nTotal = nTotal + int32(*(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80)) + uintptr(pgsz-1))))

				rc = (*struct {
					f func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods)(unsafe.Pointer(p)).FxUnfetch})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pFd */)), sqlite3_int64(pgsz)*iPg, *(*uintptr)(unsafe.Pointer(bp + 80 /* pMap */)))
				if rc != SQLITE_OK {
					break
				}
				iPg++
			}
			sqlite3.Xsqlite3_log(tls, SQLITE_OK,
				ts+5652 /* "sqlite3_mmap_war..." */, libc.VaList(bp+48, func() int64 {
					if iPg == int64(1) {
						return int64(0)
					}
					return iPg
				}(),
					sqlite3.Xsqlite3_db_filename(tls, db, zDb)))
		}

		rc2 = sqlite3.Xsqlite3_exec(tls, db, ts+5702 /* "END" */, uintptr(0), uintptr(0), uintptr(0))
		if rc == SQLITE_OK {
			rc = rc2
		}
	}

	return rc
}

// A structure to hold context of the next_char() computation across
// nested function calls.
type nextCharContext1 = struct {
	Fdb           uintptr
	FpStmt        uintptr
	FzPrefix      uintptr
	FnPrefix      int32
	FnAlloc       int32
	FnUsed        int32
	F__ccgo_pad1  [4]byte
	FaResult      uintptr
	FmallocFailed int32
	FotherError   int32
} /* nextchar.c:63:9 */

// A structure to hold context of the next_char() computation across
// nested function calls.
type nextCharContext = nextCharContext1 /* nextchar.c:63:32 */

// Append a result character if the character is not already in the
// result.
func nextCharAppend(tls *libc.TLS, p uintptr, c uint32) { /* nextchar.c:80:13: */
	var i int32
	for i = 0; i < (*nextCharContext)(unsafe.Pointer(p)).FnUsed; i++ {
		if *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(i)*4)) == c {
			return
		}
	}
	if (*nextCharContext)(unsafe.Pointer(p)).FnUsed+1 > (*nextCharContext)(unsafe.Pointer(p)).FnAlloc {
		var aNew uintptr
		var n int32 = (*nextCharContext)(unsafe.Pointer(p)).FnAlloc*2 + 30
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*nextCharContext)(unsafe.Pointer(p)).FaResult, uint64(uint64(n)*uint64(unsafe.Sizeof(uint32(0)))))
		if aNew == uintptr(0) {
			(*nextCharContext)(unsafe.Pointer(p)).FmallocFailed = 1
			return
		} else {
			(*nextCharContext)(unsafe.Pointer(p)).FaResult = aNew
			(*nextCharContext)(unsafe.Pointer(p)).FnAlloc = n
		}
	}
	*(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(p)).FaResult + uintptr(libc.PostIncInt32(&(*nextCharContext)(unsafe.Pointer(p)).FnUsed, 1))*4)) = c
}

// Write a character into z[] as UTF8.  Return the number of bytes needed
// to hold the character
func writeUtf8(tls *libc.TLS, z uintptr, c uint32) int32 { /* nextchar.c:104:12: */
	if c < uint32(0x00080) {
		*(*uint8)(unsafe.Pointer(z)) = uint8(c & uint32(0xff))
		return 1
	}
	if c < uint32(0x00800) {
		*(*uint8)(unsafe.Pointer(z)) = uint8(0xC0 + int32(uint8(c>>6&uint32(0x1F))))
		*(*uint8)(unsafe.Pointer(z + 1)) = uint8(0x80 + int32(uint8(c&uint32(0x3F))))
		return 2
	}
	if c < uint32(0x10000) {
		*(*uint8)(unsafe.Pointer(z)) = uint8(0xE0 + int32(uint8(c>>12&uint32(0x0F))))
		*(*uint8)(unsafe.Pointer(z + 1)) = uint8(0x80 + int32(uint8(c>>6&uint32(0x3F))))
		*(*uint8)(unsafe.Pointer(z + 2)) = uint8(0x80 + int32(uint8(c&uint32(0x3F))))
		return 3
	}
	*(*uint8)(unsafe.Pointer(z)) = uint8(0xF0 + int32(uint8(c>>18&uint32(0x07))))
	*(*uint8)(unsafe.Pointer(z + 1)) = uint8(0x80 + int32(uint8(c>>12&uint32(0x3F))))
	*(*uint8)(unsafe.Pointer(z + 2)) = uint8(0x80 + int32(uint8(c>>6&uint32(0x3F))))
	*(*uint8)(unsafe.Pointer(z + 3)) = uint8(0x80 + int32(uint8(c&uint32(0x3F))))
	return 4
}

// Read a UTF8 character out of z[] and write it into *pOut.  Return
// the number of bytes in z[] that were used to construct the character.
func readUtf8(tls *libc.TLS, z uintptr, pOut uintptr) int32 { /* nextchar.c:131:12: */
	var c uint32 = uint32(*(*uint8)(unsafe.Pointer(z)))
	if c < uint32(0xc0) {
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return 1
	} else {
		var n int32 = 1
		c = uint32(validBits[c-uint32(0xc0)])
		for int32(*(*uint8)(unsafe.Pointer(z + uintptr(n))))&0xc0 == 0x80 {
			c = c<<6 + uint32(0x3f&int32(*(*uint8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&n, 1))))))
		}
		if c < uint32(0x80) || c&0xFFFFF800 == uint32(0xD800) || c&0xFFFFFFFE == uint32(0xFFFE) {
			c = uint32(0xFFFD)
		}
		*(*uint32)(unsafe.Pointer(pOut)) = c
		return n
	}
	return int32(0)
}

var validBits = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
} /* nextchar.c:132:30 */

// The nextCharContext structure has been set up.  Add all "next" characters
// to the result set.
func findNextChars(tls *libc.TLS, p uintptr) { /* nextchar.c:164:13: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var cPrev uint32 = uint32(0)
	// var zPrev [8]uint8 at bp, 8

	var n int32
	var rc int32

	for {
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 1, (*nextCharContext)(unsafe.Pointer(p)).FzPrefix, (*nextCharContext)(unsafe.Pointer(p)).FnPrefix,
			uintptr(0))
		n = writeUtf8(tls, bp /* &zPrev[0] */, cPrev+uint32(1))
		sqlite3.Xsqlite3_bind_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 2, bp /* zPrev */, n, uintptr(0))
		rc = sqlite3.Xsqlite3_step(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
		if rc == SQLITE_DONE {
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			return
		} else if rc != SQLITE_ROW {
			(*nextCharContext)(unsafe.Pointer(p)).FotherError = rc
			return
		} else {
			var zOut uintptr = sqlite3.Xsqlite3_column_text(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt, 0)
			// var cNext uint32 at bp+8, 4

			n = readUtf8(tls, zOut+uintptr((*nextCharContext)(unsafe.Pointer(p)).FnPrefix), bp+8 /* &cNext */)
			sqlite3.Xsqlite3_reset(tls, (*nextCharContext)(unsafe.Pointer(p)).FpStmt)
			nextCharAppend(tls, p, *(*uint32)(unsafe.Pointer(bp + 8 /* cNext */)))
			cPrev = *(*uint32)(unsafe.Pointer(bp + 8 /* cNext */))
			if (*nextCharContext)(unsafe.Pointer(p)).FmallocFailed != 0 {
				return
			}
		}
	}
}

// next_character(A,T,F,W)
//
// Return a string composted of all next possible characters after
// A for elements of T.F.  If W is supplied, then it is an SQL expression
// that limits the elements in T.F that are considered.
func nextCharFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* nextchar.c:201:13: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	// var c nextCharContext at bp+80, 56

	var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	var zField uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	var zWhere uintptr
	var zCollName uintptr
	var zWhereClause uintptr = uintptr(0)
	var zColl uintptr = uintptr(0)
	var zSql uintptr
	var rc int32

	libc.Xmemset(tls, bp+80 /* &c */, 0, uint64(unsafe.Sizeof(nextCharContext{})))
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).Fdb = sqlite3.Xsqlite3_context_db_handle(tls, context)
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).FzPrefix = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	(*nextCharContext)(unsafe.Pointer(bp + 80 /* &c */)).FnPrefix = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zTable == uintptr(0) || zField == uintptr(0) || (*nextCharContext)(unsafe.Pointer(bp+80)).FzPrefix == uintptr(0) {
		return
	}
	if argc >= 4 &&
		libc.AssignUintptr(&zWhere, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))) != uintptr(0) &&
		int32(*(*uint8)(unsafe.Pointer(zWhere))) != 0 {
		zWhereClause = sqlite3.Xsqlite3_mprintf(tls, ts+5706 /* "AND (%s)" */, libc.VaList(bp, zWhere))
		if zWhereClause == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
	} else {
		zWhereClause = ts + 584 /* "" */
	}
	if argc >= 5 &&
		libc.AssignUintptr(&zCollName, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)))) != uintptr(0) &&
		int32(*(*uint8)(unsafe.Pointer(zCollName))) != 0 {
		zColl = sqlite3.Xsqlite3_mprintf(tls, ts+5715 /* "collate \"%w\"" */, libc.VaList(bp+8, zCollName))
		if zColl == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			if *(*int8)(unsafe.Pointer(zWhereClause)) != 0 {
				sqlite3.Xsqlite3_free(tls, zWhereClause)
			}
			return
		}
	} else {
		zColl = ts + 584 /* "" */
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,

		// 1114111 == 0x10ffff

		ts+5728, /* "SELECT %s FROM %..." */
		libc.VaList(bp+16, zField, zTable, zField, zColl, zField, zColl, zWhereClause, zColl))
	if *(*int8)(unsafe.Pointer(zWhereClause)) != 0 {
		sqlite3.Xsqlite3_free(tls, zWhereClause)
	}
	if *(*int8)(unsafe.Pointer(zColl)) != 0 {
		sqlite3.Xsqlite3_free(tls, zColl)
	}
	if zSql == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
		return
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).Fdb, zSql, -1, bp+80+8, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, context, sqlite3.Xsqlite3_errmsg(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).Fdb), -1)
		return
	}
	findNextChars(tls, bp+80 /* &c */)
	if (*nextCharContext)(unsafe.Pointer(bp+80)).FmallocFailed != 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		var pRes uintptr
		pRes = sqlite3.Xsqlite3_malloc64(tls, uint64((*nextCharContext)(unsafe.Pointer(bp+80)).FnUsed*4+1))
		if pRes == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			var i int32
			var n int32 = 0
			for i = 0; i < (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FnUsed; i++ {
				n = n + writeUtf8(tls, pRes+uintptr(n), *(*uint32)(unsafe.Pointer((*nextCharContext)(unsafe.Pointer(bp+80)).FaResult + uintptr(i)*4)))
			}
			*(*uint8)(unsafe.Pointer(pRes + uintptr(n))) = uint8(0)
			sqlite3.Xsqlite3_result_text(tls, context, pRes, n, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		}
	}
	sqlite3.Xsqlite3_finalize(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*nextCharContext)(unsafe.Pointer(bp+80 /* &c */)).FaResult)
}

func sqlite3_nextchar_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* nextchar.c:292:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5836 /* "next_char" */, 3,
		SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{nextCharFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5836 /* "next_char" */, 4,
			SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+5836 /* "next_char" */, 5,
			SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nextCharFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Implementation note:
//
// Much of the tokenizer logic is copied out of the tokenize.c source file
// of SQLite.  That logic could be simplified for this particular application,
// but that would impose a risk of introducing subtle errors.  It is best to
// keep the code as close to the original as possible.
//
// The tokenize code is in sync with the SQLite core as of 2018-01-08.
// Any future changes to the core tokenizer might require corresponding
// adjustments to the tokenizer logic in this module.

// Character classes for tokenizing
//
// In the sqlite3GetToken() function, a switch() on aiClass[c] is implemented
// using a lookup table, whereas a switch() directly on c uses a binary search.
// The lookup table is much faster.  To maximize speed, and to ensure that
// a lookup table is used, all of the classes need to be small integers and
// all of them need to be used within the switch.

var aiClass = [256]uint8{
	//         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf
	/* 0x */ uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(7), uint8(7), uint8(27), uint8(7), uint8(7), uint8(27), uint8(27),
	/* 1x */ uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27), uint8(27),
	/* 2x */ uint8(7), uint8(15), uint8(8), uint8(5), uint8(4), uint8(22), uint8(24), uint8(8), uint8(17), uint8(18), uint8(21), uint8(20), uint8(23), uint8(11), uint8(26), uint8(16),
	/* 3x */ uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(3), uint8(5), uint8(19), uint8(12), uint8(14), uint8(13), uint8(6),
	/* 4x */ uint8(5), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	/* 5x */ uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(9), uint8(27), uint8(27), uint8(27), uint8(1),
	/* 6x */ uint8(8), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1),
	/* 7x */ uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(1), uint8(0), uint8(1), uint8(1), uint8(27), uint8(10), uint8(27), uint8(25), uint8(27),
	/* 8x */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* 9x */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Ax */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Bx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Cx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Dx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Ex */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
	/* Fx */ uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2), uint8(2),
} /* normalize.c:106:28 */

// An array to map all upper-case characters into their corresponding
// lower-case character.
//
// SQLite only considers US-ASCII (or EBCDIC) characters.  We do not
// handle case conversions for the UTF character set since the tables
// involved are nearly as big or bigger than SQLite itself.
var sqlite3UpperToLower = [256]uint8{
	uint8(0), uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(17),
	uint8(18), uint8(19), uint8(20), uint8(21), uint8(22), uint8(23), uint8(24), uint8(25), uint8(26), uint8(27), uint8(28), uint8(29), uint8(30), uint8(31), uint8(32), uint8(33), uint8(34), uint8(35),
	uint8(36), uint8(37), uint8(38), uint8(39), uint8(40), uint8(41), uint8(42), uint8(43), uint8(44), uint8(45), uint8(46), uint8(47), uint8(48), uint8(49), uint8(50), uint8(51), uint8(52), uint8(53),
	uint8(54), uint8(55), uint8(56), uint8(57), uint8(58), uint8(59), uint8(60), uint8(61), uint8(62), uint8(63), uint8(64), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103),
	uint8(104), uint8(105), uint8(106), uint8(107), uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121),
	uint8(122), uint8(91), uint8(92), uint8(93), uint8(94), uint8(95), uint8(96), uint8(97), uint8(98), uint8(99), uint8(100), uint8(101), uint8(102), uint8(103), uint8(104), uint8(105), uint8(106), uint8(107),
	uint8(108), uint8(109), uint8(110), uint8(111), uint8(112), uint8(113), uint8(114), uint8(115), uint8(116), uint8(117), uint8(118), uint8(119), uint8(120), uint8(121), uint8(122), uint8(123), uint8(124), uint8(125),
	uint8(126), uint8(127), uint8(128), uint8(129), uint8(130), uint8(131), uint8(132), uint8(133), uint8(134), uint8(135), uint8(136), uint8(137), uint8(138), uint8(139), uint8(140), uint8(141), uint8(142), uint8(143),
	uint8(144), uint8(145), uint8(146), uint8(147), uint8(148), uint8(149), uint8(150), uint8(151), uint8(152), uint8(153), uint8(154), uint8(155), uint8(156), uint8(157), uint8(158), uint8(159), uint8(160), uint8(161),
	uint8(162), uint8(163), uint8(164), uint8(165), uint8(166), uint8(167), uint8(168), uint8(169), uint8(170), uint8(171), uint8(172), uint8(173), uint8(174), uint8(175), uint8(176), uint8(177), uint8(178), uint8(179),
	uint8(180), uint8(181), uint8(182), uint8(183), uint8(184), uint8(185), uint8(186), uint8(187), uint8(188), uint8(189), uint8(190), uint8(191), uint8(192), uint8(193), uint8(194), uint8(195), uint8(196), uint8(197),
	uint8(198), uint8(199), uint8(200), uint8(201), uint8(202), uint8(203), uint8(204), uint8(205), uint8(206), uint8(207), uint8(208), uint8(209), uint8(210), uint8(211), uint8(212), uint8(213), uint8(214), uint8(215),
	uint8(216), uint8(217), uint8(218), uint8(219), uint8(220), uint8(221), uint8(222), uint8(223), uint8(224), uint8(225), uint8(226), uint8(227), uint8(228), uint8(229), uint8(230), uint8(231), uint8(232), uint8(233),
	uint8(234), uint8(235), uint8(236), uint8(237), uint8(238), uint8(239), uint8(240), uint8(241), uint8(242), uint8(243), uint8(244), uint8(245), uint8(246), uint8(247), uint8(248), uint8(249), uint8(250), uint8(251),
	uint8(252), uint8(253), uint8(254), uint8(255),
} /* normalize.c:133:28 */

// The following 256 byte lookup table is used to support SQLites built-in
// equivalents to the following standard library functions:
//
//   isspace()                        0x01
//   isalpha()                        0x02
//   isdigit()                        0x04
//   isalnum()                        0x06
//   isxdigit()                       0x08
//   toupper()                        0x20
//   SQLite identifier character      0x40
//   Quote character                  0x80
//
// Bit 0x20 is set if the mapped character requires translation to upper
// case. i.e. if the character is a lower-case ASCII character.
// If x is a lower-case ASCII character, then its upper-case equivalent
// is (x - 0x20). Therefore toupper() can be implemented as:
//
//   (x & ~(map[x]&0x20))
//
// The equivalent of tolower() is implemented using the sqlite3UpperToLower[]
// array. tolower() is used more often than toupper() by SQLite.
//
// Bit 0x40 is set if the character is non-alphanumeric and can be used in an
// SQLite identifier.  Identifiers are alphanumerics, "_", "$", and any
// non-ASCII UTF character. Hence the test for whether or not a character is
// part of an identifier is 0x46.
var sqlite3CtypeMap = [256]uint8{
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 00..07    ........
	uint8(0x00), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x01), uint8(0x00), uint8(0x00), // 08..0f    ........
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 10..17    ........
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 18..1f    ........
	uint8(0x01), uint8(0x00), uint8(0x80), uint8(0x00), uint8(0x40), uint8(0x00), uint8(0x00), uint8(0x80), // 20..27     !"#$%&'
	uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 28..2f    ()*+,-./
	uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), uint8(0x0c), // 30..37    01234567
	uint8(0x0c), uint8(0x0c), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 38..3f    89:;<=>?

	uint8(0x00), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x0a), uint8(0x02), // 40..47    @ABCDEFG
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), // 48..4f    HIJKLMNO
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x02), // 50..57    PQRSTUVW
	uint8(0x02), uint8(0x02), uint8(0x02), uint8(0x80), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x40), // 58..5f    XYZ[\]^_
	uint8(0x80), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x2a), uint8(0x22), // 60..67    `abcdefg
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), // 68..6f    hijklmno
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x22), // 70..77    pqrstuvw
	uint8(0x22), uint8(0x22), uint8(0x22), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), uint8(0x00), // 78..7f    xyz{|}~.

	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 80..87    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 88..8f    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 90..97    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // 98..9f    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // a0..a7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // a8..af    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // b0..b7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // b8..bf    ........

	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // c0..c7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // c8..cf    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // d0..d7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // d8..df    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // e0..e7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // e8..ef    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // f0..f7    ........
	uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), uint8(0x40), // f8..ff    ........
} /* normalize.c:179:28 */

// If X is a character that can be used in an identifier then
// IdChar(X) will be true.  Otherwise it is false.
//
// For ASCII, any character with the high-order bit set is
// allowed in an identifier.  For 7-bit characters,
// sqlite3IsIdChar[X] must be 1.
//
// For EBCDIC, the rules are more complex but have the same
// end result.
//
// Ticket #1066.  the SQL standard does not allow '$' in the
// middle of identifiers.  But many SQL implementations do.
// SQLite will allow '$' in identifiers for compatibility.
// But the feature is undocumented.

// Ignore testcase() macros

// Token values

// Disable nuisence warnings about case fall-through

// Return the length (in bytes) of the token that begins at z[0].
// Store the token type in *tokenType before returning.
func sqlite3GetToken(tls *libc.TLS, z uintptr, tokenType uintptr) int32 { /* normalize.c:300:12: */
	var i int32
	var c int32
	switch int32(aiClass[*(*uint8)(unsafe.Pointer(z))]) { // Switch on the character-class of the first byte
	// of the token. See the comment on the CC_ defines
	// above.
	case CC_SPACE:
		{
			for i = 1; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x01 != 0; i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
			return i

		}
	case CC_MINUS:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) == '-' {
				for i = 2; libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0 && c != '\n'; i++ {
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
				return i
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_LP:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_RP:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_SEMI:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_PLUS:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_STAR:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_SLASH:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '*' || int32(*(*uint8)(unsafe.Pointer(z + 2))) == 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}
			i = 3
			c = int32(*(*uint8)(unsafe.Pointer(z + 2)))
			for ; (c != '*' || int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '/') && libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
			}
			if c != 0 {
				i++
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_SPACE
			return i

		}
	case CC_PERCENT:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_EQ:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1 + libc.Bool32(int32(*(*uint8)(unsafe.Pointer(z + 1))) == '=')

		}
	case CC_LT:
		{
			if libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + 1)))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '<' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}

		}
		fallthrough
	case CC_GT:
		{
			if libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + 1)))) == '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else if c == '>' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}

		}
		fallthrough
	case CC_BANG:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '=' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			}

		}
		fallthrough
	case CC_PIPE:
		{
			if int32(*(*uint8)(unsafe.Pointer(z + 1))) != '|' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 2
			}

		}
		fallthrough
	case CC_COMMA:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_AND:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_TILDA:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
			return 1

		}
	case CC_QUOTE:
		{
			var delim int32 = int32(*(*uint8)(unsafe.Pointer(z)))

			for i = 1; libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
				if c == delim {
					if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == delim {
						i++
					} else {
						break
					}
				}
			}
			if c == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
				return i + 1
			} else if c != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
				return i + 1
			} else {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				return i
			}

		}
		fallthrough
	case CC_DOT:
		{
			if !(int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + 1))])&0x04 != 0) {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_PUNCT
				return 1
			}
			// If the next character is a digit, this is a floating point
			// number that begins with ".".  Fall thru into the next case
			/* no break */

		}
		fallthrough
	case CC_DIGIT:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			if int32(*(*uint8)(unsafe.Pointer(z))) == '0' && (int32(*(*uint8)(unsafe.Pointer(z + 1))) == 'x' || int32(*(*uint8)(unsafe.Pointer(z + 1))) == 'X') && int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + 2))])&0x08 != 0 {
				for i = 3; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x08 != 0; i++ {
				}
				return i
			}
			for i = 0; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0; i++ {
			}
			if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == '.' {
				i++
				for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			}
			if (int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'e' || int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) == 'E') && (int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))])&0x04 != 0 ||
				(int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == '+' || int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == '-') && int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i+2)))])&0x04 != 0) {
				i = i + 2
				for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0 {
					i++
				}
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			}
			for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x46 != 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
				i++
			}
			return i

		}
	case CC_QUOTE2:
		{
			i = 1
			c = int32(*(*uint8)(unsafe.Pointer(z)))
			for ; c != ']' && libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
			}
			*(*int32)(unsafe.Pointer(tokenType)) = func() int32 {
				if c == ']' {
					return TK_NAME
				}
				return TK_ERROR
			}()
			return i

		}
	case CC_VARNUM:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			for i = 1; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x04 != 0; i++ {
			}
			return i

		}
	case CC_DOLLAR:
		fallthrough
	case CC_VARALPHA:
		{
			var n int32 = 0

			*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
			for i = 1; libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0; i++ {
				if int32(sqlite3CtypeMap[uint8(c)])&0x46 != 0 {
					n++
				} else if c == '(' && n > 0 {
					for ok := true; ok; ok = libc.AssignInt32(&c, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))) != 0 && !(int32(sqlite3CtypeMap[uint8(c)])&0x01 != 0) && c != ')' {
						i++
					}
					if c == ')' {
						i++
					} else {
						*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
					}
					break
				} else if c == ':' && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i+1)))) == ':' {
					i++
				} else {
					break
				}
			}
			if n == 0 {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
			}
			return i

		}
	case CC_KYWD:
		{
			for i = 1; int32(aiClass[*(*uint8)(unsafe.Pointer(z + uintptr(i)))]) <= CC_KYWD; i++ {
			}
			if int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x46 != 0 {
				// This token started out using characters that can appear in keywords,
				// but z[i] is a character not allowed within keywords, so this must
				// be an identifier instead
				i++
				break
			}
			*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
			return i

		}
	case CC_X:
		{

			if int32(*(*uint8)(unsafe.Pointer(z + 1))) == '\'' {
				*(*int32)(unsafe.Pointer(tokenType)) = TK_LITERAL
				for i = 2; int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x08 != 0; i++ {
				}
				if int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'' || i%2 != 0 {
					*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
					for *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) != '\'' {
						i++
					}
				}
				if *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0 {
					i++
				}
				return i
			}
			// If it is not a BLOB literal, then it must be an ID, since no
			// SQL keywords start with the letter 'x'.  Fall through
			/* no break */

		}
		fallthrough
	case CC_ID:
		{
			i = 1
			break

		}
	default:
		{
			*(*int32)(unsafe.Pointer(tokenType)) = TK_ERROR
			return 1

		}
	}
	for int32(sqlite3CtypeMap[*(*uint8)(unsafe.Pointer(z + uintptr(i)))])&0x46 != 0 {
		i++
	}
	*(*int32)(unsafe.Pointer(tokenType)) = TK_NAME
	return i
}

func sqlite3_normalize(tls *libc.TLS, zSql uintptr) uintptr { /* normalize.c:555:6: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var z uintptr          // The output string
	var nZ sqlite3_int64   // Size of the output string in bytes
	var nSql sqlite3_int64 // Size of the input string in bytes
	var i int32            // Next character to read from zSql[]
	var j int32            // Next slot to fill in on z[]
	// var tokenType int32 at bp, 4
	// Type of the next token
	var n int32 // Size of the next token
	var k int32 // Loop counter

	nSql = sqlite3_int64(libc.Xstrlen(tls, zSql))
	nZ = nSql
	z = sqlite3.Xsqlite3_malloc64(tls, uint64(nZ+int64(2)))
	if z == uintptr(0) {
		return uintptr(0)
	}
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; i = i + n {
		n = sqlite3GetToken(tls, zSql+uintptr(i), bp /* &tokenType */)
		switch *(*int32)(unsafe.Pointer(bp /* tokenType */)) {
		case TK_SPACE:
			{
				break

			}
		case TK_ERROR:
			{
				sqlite3.Xsqlite3_free(tls, z)
				return uintptr(0)

			}
		case TK_LITERAL:
			{
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
				break

			}
		case TK_PUNCT:
			fallthrough
		case TK_NAME:
			{
				if n == 4 && sqlite3.Xsqlite3_strnicmp(tls, zSql+uintptr(i), ts+5846, 4) == 0 {
					if j >= 3 && libc.Xstrncmp(tls, z+uintptr(j)-uintptr(2), ts+5851, uint64(2)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(j-3))))])&0x46 != 0) ||
						j >= 4 && libc.Xstrncmp(tls, z+uintptr(j)-uintptr(3), ts+5854, uint64(3)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(j-4))))])&0x46 != 0) {
						// NULL is a keyword in this case, not a literal value
					} else {
						// Here the NULL is a literal value
						*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
						break
					}
				}
				if j > 0 && int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z + uintptr(j-1))))])&0x46 != 0 && int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr(i))))])&0x46 != 0 {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(' ')
				}
				for k = 0; k < n; k++ {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(sqlite3UpperToLower[uint8(*(*int8)(unsafe.Pointer(zSql + uintptr(i+k))))])
				}
				break

			}
		}
	}
	for j > 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(j-1)))) == ' ' {
		j--
	}
	if j > 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(j-1)))) != ';' {
		*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(';')
	}
	*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)

	// Make a second pass converting "in(...)" where the "..." is not a
	// SELECT statement into "in(?,?,?)"
	for i = 0; i < j; i = n {
		var zIn uintptr = libc.Xstrstr(tls, z+uintptr(i), ts+5858 /* "in(" */)
		var nParen int32
		if zIn == uintptr(0) {
			break
		}
		n = int32((int64(zIn)-int64(z))/1) + 3 // Index of first char past "in("
		if n != 0 && int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + libc.UintptrFromInt32(-1))))])&0x46 != 0 {
			continue
		}
		if libc.Xstrncmp(tls, zIn, ts+5862, uint64(9)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + 9)))])&0x46 != 0) {
			continue
		}
		if libc.Xstrncmp(tls, zIn, ts+5872, uint64(7)) == 0 && !(int32(sqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(zIn + 7)))])&0x46 != 0) {
			continue
		}
		nParen = 1
		k = 0
		for ; *(*int8)(unsafe.Pointer(z + uintptr(n+k))) != 0; k++ {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n+k)))) == '(' {
				nParen++
			}
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(n+k)))) == ')' {
				nParen--
				if nParen == 0 {
					break
				}
			}
		}
		// k is the number of bytes in the "..." within "in(...)"
		if k < 5 {
			z = sqlite3.Xsqlite3_realloc64(tls, z, uint64(j+(5-k)+1))
			if z == uintptr(0) {
				return uintptr(0)
			}
			libc.Xmemmove(tls, z+uintptr(n)+uintptr(5), z+uintptr(n)+uintptr(k), uint64(j-(n+k)))
		} else if k > 5 {
			libc.Xmemmove(tls, z+uintptr(n)+uintptr(5), z+uintptr(n)+uintptr(k), uint64(j-(n+k)))
		}
		j = j - k + 5
		*(*int8)(unsafe.Pointer(z + uintptr(j))) = int8(0)
		libc.Xmemcpy(tls, z+uintptr(n), ts+5880 /* "?,?,?" */, uint64(5))
	}
	return z
}

// For testing purposes, or to build a stand-alone SQL normalizer program,
// compile this one source file with the -DSQLITE_NORMALIZE_CLI and link
// it against any SQLite library.  The resulting command-line program will
// run sqlite3_normalize() over the text of all files named on the command-
// line and show the result on standard output.

// The following object is the session context for a single percentile()
// function.  We have to remember all input Y values until the very end.
// Those values are accumulated in the Percentile.a[] array.
type Percentile1 = struct {
	FnAlloc uint32
	FnUsed  uint32
	FrPct   float64
	Fa      uintptr
} /* percentile.c:71:9 */

// The following object is the session context for a single percentile()
// function.  We have to remember all input Y values until the very end.
// Those values are accumulated in the Percentile.a[] array.
type Percentile = Percentile1 /* percentile.c:71:27 */

// Return TRUE if the input floating-point number is an infinity.
func isInfinity(tls *libc.TLS, r float64) int32 { /* percentile.c:82:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)
	*(*float64)(unsafe.Pointer(bp + 8)) = r

	// var u sqlite3_uint64 at bp, 8

	libc.Xmemcpy(tls, bp /* &u */, bp+8 /* &r */, uint64(unsafe.Sizeof(sqlite3_uint64(0))))
	return libc.Bool32(*(*sqlite3_uint64)(unsafe.Pointer(bp))>>52&uint64(0x7ff) == uint64(0x7ff))
}

// Return TRUE if two doubles differ by 0.001 or less
func sameValue(tls *libc.TLS, a float64, b float64) int32 { /* percentile.c:92:12: */
	a = a - b
	return libc.Bool32(a >= -0.001 && a <= 0.001)
}

// The "step" function for percentile(Y,P) is called once for each
// input row.
func percentStep(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* percentile.c:101:13: */
	var p uintptr
	var rPct float64
	var eType int32
	var y float64

	// Requirement 3:  P must be a number between 0 and 100
	eType = sqlite3.Xsqlite3_value_numeric_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rPct = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if eType != SQLITE_INTEGER && eType != SQLITE_FLOAT ||
		rPct < 0.0 || rPct > 100.0 {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5886 /* "2nd argument to ..." */, -1)
		return
	}

	// Allocate the session context.
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(Percentile{})))
	if p == uintptr(0) {
		return
	}

	// Remember the P value.  Throw an error if the P value is different
	// from any prior row, per Requirement (2).
	if (*Percentile)(unsafe.Pointer(p)).FrPct == 0.0 {
		(*Percentile)(unsafe.Pointer(p)).FrPct = rPct + 1.0
	} else if !(sameValue(tls, (*Percentile)(unsafe.Pointer(p)).FrPct, rPct+1.0) != 0) {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+5953 /* "2nd argument to ..." */, -1)
		return
	}

	// Ignore rows for which Y is NULL
	eType = sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if eType == SQLITE_NULL {
		return
	}

	// If not NULL, then Y must be numeric.  Otherwise throw an error.
	// Requirement 4
	if eType != SQLITE_INTEGER && eType != SQLITE_FLOAT {
		sqlite3.Xsqlite3_result_error(tls, pCtx,
			ts+6017 /* "1st argument to ..." */, -1)
		return
	}

	// Throw an error if the Y value is infinity or NaN
	y = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if isInfinity(tls, y) != 0 {
		sqlite3.Xsqlite3_result_error(tls, pCtx, ts+6061 /* "Inf input to per..." */, -1)
		return
	}

	// Allocate and store the Y
	if (*Percentile)(unsafe.Pointer(p)).FnUsed >= (*Percentile)(unsafe.Pointer(p)).FnAlloc {
		var n uint32 = (*Percentile)(unsafe.Pointer(p)).FnAlloc*uint32(2) + uint32(250)
		var a uintptr = sqlite3.Xsqlite3_realloc64(tls, (*Percentile)(unsafe.Pointer(p)).Fa, uint64(uint64(unsafe.Sizeof(float64(0)))*uint64(n)))
		if a == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
			libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(Percentile{})))
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		(*Percentile)(unsafe.Pointer(p)).FnAlloc = n
		(*Percentile)(unsafe.Pointer(p)).Fa = a
	}
	*(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(libc.PostIncUint32(&(*Percentile)(unsafe.Pointer(p)).FnUsed, 1))*8)) = y
}

// Compare to doubles for sorting using qsort()
func doubleCmp(tls *libc.TLS, pA uintptr, pB uintptr) int32 { /* percentile.c:170:25: */
	var a float64 = *(*float64)(unsafe.Pointer(pA))
	var b float64 = *(*float64)(unsafe.Pointer(pB))
	if a == b {
		return 0
	}
	if a < b {
		return -1
	}
	return +1
}

// Called to compute the final output of percentile() and to clean
// up all allocated memory.
func percentFinal(tls *libc.TLS, pCtx uintptr) { /* percentile.c:182:13: */
	var p uintptr
	var i1 uint32
	var i2 uint32
	var v1 float64
	var v2 float64
	var ix float64
	var vx float64
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, 0)
	if p == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).Fa == uintptr(0) {
		return
	}
	if (*Percentile)(unsafe.Pointer(p)).FnUsed != 0 {
		libc.Xqsort(tls, (*Percentile)(unsafe.Pointer(p)).Fa, uint64((*Percentile)(unsafe.Pointer(p)).FnUsed), uint64(unsafe.Sizeof(float64(0))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		}{doubleCmp})))
		ix = ((*Percentile)(unsafe.Pointer(p)).FrPct - 1.0) * float64((*Percentile)(unsafe.Pointer(p)).FnUsed-uint32(1)) * 0.01
		i1 = uint32(ix)
		if ix == float64(i1) || i1 == (*Percentile)(unsafe.Pointer(p)).FnUsed-uint32(1) {
			i2 = i1
		} else {
			i2 = i1 + uint32(1)
		}
		v1 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i1)*8))
		v2 = *(*float64)(unsafe.Pointer((*Percentile)(unsafe.Pointer(p)).Fa + uintptr(i2)*8))
		vx = v1 + (v2-v1)*(ix-float64(i1))
		sqlite3.Xsqlite3_result_double(tls, pCtx, vx)
	}
	sqlite3.Xsqlite3_free(tls, (*Percentile)(unsafe.Pointer(p)).Fa)
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(Percentile{})))
}

func sqlite3_percentile_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* percentile.c:208:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6087 /* "percentile" */, 2,
		SQLITE_UTF8|SQLITE_INNOCUOUS, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{percentStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{percentFinal})))
	return rc
}

// prefixes_vtab is a subclass of sqlite3_vtab which is
// underlying representation of the virtual table
type prefixes_vtab1 = struct{ Fbase sqlite3_vtab } /* prefixes.c:33:9 */

// prefixes_vtab is a subclass of sqlite3_vtab which is
// underlying representation of the virtual table
type prefixes_vtab = prefixes_vtab1 /* prefixes.c:33:30 */

// prefixes_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type prefixes_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiRowid      sqlite3_int64
	FzStr        uintptr
	FnStr        int32
	F__ccgo_pad1 [4]byte
} /* prefixes.c:43:9 */

// prefixes_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type prefixes_cursor = prefixes_cursor1 /* prefixes.c:43:32 */

// The prefixesConnect() method is invoked to create a new
// template virtual table.
//
// Think of this routine as the constructor for prefixes_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the prefixes_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against the virtual table will look like.
func prefixesConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* prefixes.c:64:12: */
	var pNew uintptr
	var rc int32

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+6098 /* "CREATE TABLE pre..." */)
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_vtab{})))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(prefixes_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	}
	return rc
}

// This method is the destructor for prefixes_vtab objects.
func prefixesDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* prefixes.c:90:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Constructor for a new prefixes_cursor object.
func prefixesOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* prefixes.c:99:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(prefixes_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(prefixes_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Destructor for a prefixes_cursor.
func prefixesClose(tls *libc.TLS, cur uintptr) int32 { /* prefixes.c:111:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Advance a prefixes_cursor to its next row of output.
func prefixesNext(tls *libc.TLS, cur uintptr) int32 { /* prefixes.c:122:12: */
	var pCur uintptr = cur
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

// Return values of columns for the row at which the prefixes_cursor
// is currently pointing.
func prefixesColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* prefixes.c:132:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, (*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr-int32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid),
			uintptr(0))
		break
	default:
		sqlite3.Xsqlite3_result_text(tls, ctx, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr, (*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr, uintptr(0))
		break
	}
	return SQLITE_OK
}

// Return the rowid for the current row.  In this implementation, the
// rowid is the same as the output value.
func prefixesRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* prefixes.c:154:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func prefixesEof(tls *libc.TLS, cur uintptr) int32 { /* prefixes.c:164:12: */
	var pCur uintptr = cur
	return libc.Bool32((*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid > sqlite3_int64((*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr))
}

// This method is called to "rewind" the prefixes_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to prefixesColumn() or prefixesRowid() or
// prefixesEof().
func prefixesFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* prefixes.c:175:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCur uintptr = pVtabCursor
	sqlite3.Xsqlite3_free(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr)
	if argc > 0 {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))))
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = func() int32 {
			if (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr != 0 {
				return int32(libc.Xstrlen(tls, (*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr))
			}
			return 0
		}()
	} else {
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FzStr = uintptr(0)
		(*prefixes_cursor)(unsafe.Pointer(pCur)).FnStr = 0
	}
	(*prefixes_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(0)
	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
func prefixesBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* prefixes.c:199:12: */
	// Search for a usable equality constraint against column 1
	// (original_string) and use it if at all possible
	var i int32
	var p uintptr

	i = 0
	p = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn != 1 {
			goto __2
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) != SQLITE_INDEX_CONSTRAINT_EQ {
			goto __2
		}
		if !(int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable) != 0) {
			goto __2
		}
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(10)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(10)
		return SQLITE_OK

	}
	goto __2
__2:
	i++
	p += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1000000000)
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000000000)
	return SQLITE_OK
}

// This following structure defines all the methods for the
// virtual table.
var prefixesModule = sqlite3_module{
	/* xConnect    */ FxConnect: 0,
	/* xBestIndex  */ FxBestIndex: 0,
	/* xDisconnect */ FxDisconnect: 0,
	/* xOpen       */ FxOpen: 0,
	/* xClose      */ FxClose: 0,
	/* xFilter     */ FxFilter: 0,
	/* xNext       */ FxNext: 0,
	/* xEof        */ FxEof: 0,
	/* xColumn     */ FxColumn: 0,
	/* xRowid      */ FxRowid: 0,
} /* prefixes.c:227:23 */

// This is a copy of the SQLITE_SKIP_UTF8(zIn) macro in sqliteInt.h.
//
// Assuming zIn points to the first byte of a UTF-8 character,
// advance zIn to point to the first byte of the next UTF-8 character.

// Implementation of function prefix_length(). This function accepts two
// strings as arguments and returns the length in characters (not bytes),
// of the longest prefix shared by the two strings. For example:
//
//   prefix_length('abcdxxx', 'abcyy') == 3
//   prefix_length('abcdxxx', 'bcyyy') == 0
//   prefix_length('abcdxxx', 'ab')    == 2
//   prefix_length('ab',      'abcd')  == 2
//
// This function assumes the input is well-formed utf-8. If it is not,
// it is possible for this function to return -1.
func prefixLengthFunc(tls *libc.TLS, ctx uintptr, nVal int32, apVal uintptr) { /* prefixes.c:279:13: */
	var nByte int32    // Number of bytes to compare
	var nRet int32 = 0 // Return value
	var zL uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	var zR uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*8)))
	var nL int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	var nR int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*8)))
	var i int32

	nByte = func() int32 {
		if nL > nR {
			return nL
		}
		return nR
	}()
	for i = 0; i < nByte; i++ {
		if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i)))) != int32(*(*uint8)(unsafe.Pointer(zR + uintptr(i)))) {
			break
		}
		if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i))))&0xC0 != 0x80 {
			nRet++
		}
	}

	if int32(*(*uint8)(unsafe.Pointer(zL + uintptr(i))))&0xC0 == 0x80 {
		nRet--
	}
	sqlite3.Xsqlite3_result_int(tls, ctx, nRet)
}

func sqlite3_prefixes_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* prefixes.c:305:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+6162 /* "prefixes" */, uintptr(unsafe.Pointer(&prefixesModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls,
			db, ts+6171 /* "prefix_length" */, 2, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{prefixLengthFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// The following #defines change the names of some functions implemented in
// this file to prevent name collisions with C-library functions of the
// same name.

// The end-of-input character

// The NFA is implemented as sequence of opcodes taken from the following
// set.  Each opcode has a single integer argument.

// Each opcode is a "state" in the NFA
type ReStateNumber = uint16 /* regexp.c:98:24 */

// Because this is an NFA and not a DFA, multiple states can be active at
// once.  An instance of the following object records all active states in
// the NFA.  The implementation is optimized for the common case where the
// number of actives states is small.
type ReStateSet1 = struct {
	FnState      uint32
	F__ccgo_pad1 [4]byte
	FaState      uintptr
} /* regexp.c:105:9 */

// Because this is an NFA and not a DFA, multiple states can be active at
// once.  An instance of the following object records all active states in
// the NFA.  The implementation is optimized for the common case where the
// number of actives states is small.
type ReStateSet = ReStateSet1 /* regexp.c:108:3 */

// An input string read one character at a time.
type ReInput1 = struct {
	Fz  uintptr
	Fi  int32
	Fmx int32
} /* regexp.c:112:9 */

// An input string read one character at a time.
type ReInput = ReInput1 /* regexp.c:112:24 */

// A compiled NFA (or an NFA that is in the process of being compiled) is
// an instance of the following object.
type ReCompiled1 = struct {
	FsIn       ReInput
	FzErr      uintptr
	FaOp       uintptr
	FaArg      uintptr
	FxNextChar uintptr
	FzInit     [12]uint8
	FnInit     int32
	FnState    uint32
	FnAlloc    uint32
} /* regexp.c:122:9 */

// A compiled NFA (or an NFA that is in the process of being compiled) is
// an instance of the following object.
type ReCompiled = ReCompiled1 /* regexp.c:122:27 */

// Add a state to the given state set if it is not already there
func re_add_state(tls *libc.TLS, pSet uintptr, newState int32) { /* regexp.c:136:13: */
	var i uint32
	for i = uint32(0); i < (*ReStateSet)(unsafe.Pointer(pSet)).FnState; i++ {
		if int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(i)*2))) == newState {
			return
		}
	}
	*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pSet)).FaState + uintptr(libc.PostIncUint32(&(*ReStateSet)(unsafe.Pointer(pSet)).FnState, 1))*2)) = ReStateNumber(newState)
}

// Extract the next unicode character from *pzIn and return it.  Advance
// *pzIn to the first byte past the end of the character returned.  To
// be clear:  this routine converts utf8 to unicode.  This routine is
// optimized for the common case where the next character is a single byte.
func re_next_char(tls *libc.TLS, p uintptr) uint32 { /* regexp.c:147:17: */
	var c uint32
	if (*ReInput)(unsafe.Pointer(p)).Fi >= (*ReInput)(unsafe.Pointer(p)).Fmx {
		return uint32(0)
	}
	c = uint32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1)))))
	if c >= uint32(0x80) {
		if c&uint32(0xe0) == uint32(0xc0) && (*ReInput)(unsafe.Pointer(p)).Fi < (*ReInput)(unsafe.Pointer(p)).Fmx && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0xc0 == 0x80 {
			c = c&uint32(0x1f)<<6 | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*ReInput)(unsafe.Pointer(p)).Fi, 1)))))&0x3f)
			if c < uint32(0x80) {
				c = uint32(0xfffd)
			}
		} else if c&uint32(0xf0) == uint32(0xe0) && (*ReInput)(unsafe.Pointer(p)).Fi+1 < (*ReInput)(unsafe.Pointer(p)).Fmx && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0xc0 == 0x80 &&
			int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0xc0 == 0x80 {
			c = c&uint32(0x0f)<<12 | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0x3f<<6) | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0x3f)
			*(*int32)(unsafe.Pointer(p + 8)) += 2
			if c <= uint32(0x7ff) || c >= uint32(0xd800) && c <= uint32(0xdfff) {
				c = uint32(0xfffd)
			}
		} else if c&uint32(0xf8) == uint32(0xf0) && (*ReInput)(unsafe.Pointer(p)).Fi+3 < (*ReInput)(unsafe.Pointer(p)).Fmx && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0xc0 == 0x80 &&
			int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0xc0 == 0x80 && int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+2))))&0xc0 == 0x80 {
			c = c&uint32(0x07)<<18 | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi))))&0x3f<<12) | uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+1))))&0x3f<<6) |
				uint32(int32(*(*uint8)(unsafe.Pointer((*ReInput)(unsafe.Pointer(p)).Fz + uintptr((*ReInput)(unsafe.Pointer(p)).Fi+2))))&0x3f)
			*(*int32)(unsafe.Pointer(p + 8)) += 3
			if c <= uint32(0xffff) || c > uint32(0x10ffff) {
				c = uint32(0xfffd)
			}
		} else {
			c = uint32(0xfffd)
		}
	}
	return c
}

func re_next_char_nocase(tls *libc.TLS, p uintptr) uint32 { /* regexp.c:172:17: */
	var c uint32 = re_next_char(tls, p)
	if c >= uint32('A') && c <= uint32('Z') {
		c = c + uint32('a'-'A')
	}
	return c
}

// Return true if c is a perl "word" character:  [A-Za-z0-9_]
func re_word_char(tls *libc.TLS, c int32) int32 { /* regexp.c:179:12: */
	return libc.Bool32(c >= '0' && c <= '9' || c >= 'a' && c <= 'z' ||
		c >= 'A' && c <= 'Z' || c == '_')
}

// Return true if c is a "digit" character:  [0-9]
func re_digit_char(tls *libc.TLS, c int32) int32 { /* regexp.c:185:12: */
	return libc.Bool32(c >= '0' && c <= '9')
}

// Return true if c is a perl "space" character:  [ \t\r\n\v\f]
func re_space_char(tls *libc.TLS, c int32) int32 { /* regexp.c:190:12: */
	return libc.Bool32(c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\v' || c == '\f')
}

// Run a compiled regular expression on the zero-terminated input
// string zIn[].  Return true on a match and false if there is no match.
func sqlite3re_match(tls *libc.TLS, pRe uintptr, zIn uintptr, nIn int32) int32 { /* regexp.c:197:12: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	// var aStateSet [2]ReStateSet at bp, 32

	var pThis uintptr
	var pNext uintptr
	// var aSpace [100]ReStateNumber at bp+32, 200

	var pToFree uintptr
	var i uint32
	var iSwap uint32
	var c int32
	var cPrev int32
	var rc int32
	// var in ReInput at bp+232, 16

	var x uint8
	var j int32
	var n int32
	var hit int32
	var x1 int32
	i = uint32(0)
	iSwap = uint32(0)
	c = RE_EOF + 1
	cPrev = 0
	rc = 0

	(*ReInput)(unsafe.Pointer(bp + 232 /* &in */)).Fz = zIn
	(*ReInput)(unsafe.Pointer(bp + 232 /* &in */)).Fi = 0
	(*ReInput)(unsafe.Pointer(bp + 232 /* &in */)).Fmx = func() int32 {
		if nIn >= 0 {
			return nIn
		}
		return int32(libc.Xstrlen(tls, zIn))
	}()

	// Look for the initial prefix match, if there is one.
	if !((*ReCompiled)(unsafe.Pointer(pRe)).FnInit != 0) {
		goto __1
	}
	x = *(*uint8)(unsafe.Pointer(pRe + 48))
__2:
	if !((*ReInput)(unsafe.Pointer(bp+232)).Fi+(*ReCompiled)(unsafe.Pointer(pRe)).FnInit <= (*ReInput)(unsafe.Pointer(bp+232)).Fmx &&
		(int32(*(*uint8)(unsafe.Pointer(zIn + uintptr((*ReInput)(unsafe.Pointer(bp+232)).Fi)))) != int32(x) || libc.Xstrncmp(tls, zIn+uintptr((*ReInput)(unsafe.Pointer(bp+232)).Fi), pRe+48, uint64((*ReCompiled)(unsafe.Pointer(pRe)).FnInit)) != 0)) {
		goto __3
	}
	(*ReInput)(unsafe.Pointer(bp+232 /* &in */)).Fi++
	goto __2
__3:
	;
	if !((*ReInput)(unsafe.Pointer(bp+232)).Fi+(*ReCompiled)(unsafe.Pointer(pRe)).FnInit > (*ReInput)(unsafe.Pointer(bp+232)).Fmx) {
		goto __4
	}
	return 0
__4:
	;
__1:
	;

	if !(uint64((*ReCompiled)(unsafe.Pointer(pRe)).FnState) <= uint64(unsafe.Sizeof([100]ReStateNumber{}))/(uint64(unsafe.Sizeof(ReStateNumber(0)))*uint64(2))) {
		goto __5
	}
	pToFree = uintptr(0)
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */)).FaState = bp + 32 /* &aSpace[0] */
	goto __6
__5:
	pToFree = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(ReStateNumber(0)))*uint64(2)*uint64((*ReCompiled)(unsafe.Pointer(pRe)).FnState)))
	if !(pToFree == uintptr(0)) {
		goto __7
	}
	return -1
__7:
	;
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */)).FaState = pToFree
__6:
	;
	(*ReStateSet)(unsafe.Pointer(bp /* &aStateSet */ + 1*16)).FaState = (*ReStateSet)(unsafe.Pointer(bp)).FaState + uintptr((*ReCompiled)(unsafe.Pointer(pRe)).FnState)*2
	pNext = bp + 1*16
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	re_add_state(tls, pNext, 0)
__8:
	if !(c != RE_EOF && (*ReStateSet)(unsafe.Pointer(pNext)).FnState > uint32(0)) {
		goto __9
	}
	cPrev = c
	c = int32((*struct {
		f func(*libc.TLS, uintptr) uint32
	})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(pRe)).FxNextChar})).f(tls, bp+232 /* &in */))
	pThis = pNext
	pNext = bp + uintptr(iSwap)*16
	iSwap = uint32(1) - iSwap
	(*ReStateSet)(unsafe.Pointer(pNext)).FnState = uint32(0)
	i = uint32(0)
__10:
	if !(i < (*ReStateSet)(unsafe.Pointer(pThis)).FnState) {
		goto __12
	}
	x1 = int32(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pThis)).FaState + uintptr(i)*2)))
	switch int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) {
	case RE_OP_MATCH:
		goto __14
	case RE_OP_ANY:
		goto __15
	case RE_OP_WORD:
		goto __16
	case RE_OP_NOTWORD:
		goto __17
	case RE_OP_DIGIT:
		goto __18
	case RE_OP_NOTDIGIT:
		goto __19
	case RE_OP_SPACE:
		goto __20
	case RE_OP_NOTSPACE:
		goto __21
	case RE_OP_BOUNDARY:
		goto __22
	case RE_OP_ANYSTAR:
		goto __23
	case RE_OP_FORK:
		goto __24
	case RE_OP_GOTO:
		goto __25
	case RE_OP_ACCEPT:
		goto __26
	case RE_OP_CC_EXC:
		goto __27
	case RE_OP_CC_INC:
		goto __28
	}
	goto __13
__14:
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)) == c) {
		goto __29
	}
	re_add_state(tls, pNext, x1+1)
__29:
	;
	goto __13

__15:
	if !(c != 0) {
		goto __30
	}
	re_add_state(tls, pNext, x1+1)
__30:
	;
	goto __13

__16:
	if !(re_word_char(tls, c) != 0) {
		goto __31
	}
	re_add_state(tls, pNext, x1+1)
__31:
	;
	goto __13

__17:
	if !(!(re_word_char(tls, c) != 0) && c != 0) {
		goto __32
	}
	re_add_state(tls, pNext, x1+1)
__32:
	;
	goto __13

__18:
	if !(re_digit_char(tls, c) != 0) {
		goto __33
	}
	re_add_state(tls, pNext, x1+1)
__33:
	;
	goto __13

__19:
	if !(!(re_digit_char(tls, c) != 0) && c != 0) {
		goto __34
	}
	re_add_state(tls, pNext, x1+1)
__34:
	;
	goto __13

__20:
	if !(re_space_char(tls, c) != 0) {
		goto __35
	}
	re_add_state(tls, pNext, x1+1)
__35:
	;
	goto __13

__21:
	if !(!(re_space_char(tls, c) != 0) && c != 0) {
		goto __36
	}
	re_add_state(tls, pNext, x1+1)
__36:
	;
	goto __13

__22:
	if !(re_word_char(tls, c) != re_word_char(tls, cPrev)) {
		goto __37
	}
	re_add_state(tls, pThis, x1+1)
__37:
	;
	goto __13

__23:
	re_add_state(tls, pNext, x1)
	re_add_state(tls, pThis, x1+1)
	goto __13

__24:
	re_add_state(tls, pThis, x1+*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)))
	re_add_state(tls, pThis, x1+1)
	goto __13

__25:
	re_add_state(tls, pThis, x1+*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4)))
	goto __13

__26:
	rc = 1
	goto re_match_end

__27:
	if !(c == 0) {
		goto __38
	}
	goto __13
__38:
	;
	/* fall-through */ goto re_op_cc_inc

__28:
re_op_cc_inc:
	j = 1
	n = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1)*4))
	hit = 0
	j = 1
__39:
	if !(j > 0 && j < n) {
		goto __41
	}
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1+j)))) == RE_OP_CC_VALUE) {
		goto __42
	}
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1+j)*4)) == c) {
		goto __44
	}
	hit = 1
	j = -1
__44:
	;
	goto __43
__42:
	if !(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1+j)*4)) <= c && *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(x1+j+1)*4)) >= c) {
		goto __45
	}
	hit = 1
	j = -1
	goto __46
__45:
	j++
__46:
	;
__43:
	;
	goto __40
__40:
	j++
	goto __39
	goto __41
__41:
	;
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(x1)))) == RE_OP_CC_EXC) {
		goto __47
	}
	hit = libc.BoolInt32(!(hit != 0))
__47:
	;
	if !(hit != 0) {
		goto __48
	}
	re_add_state(tls, pNext, x1+n)
__48:
	;
	goto __13

__13:
	;
	goto __11
__11:
	i++
	goto __10
	goto __12
__12:
	;
	goto __8
__9:
	;
	i = uint32(0)
__49:
	if !(i < (*ReStateSet)(unsafe.Pointer(pNext)).FnState) {
		goto __51
	}
	if !(int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(*(*ReStateNumber)(unsafe.Pointer((*ReStateSet)(unsafe.Pointer(pNext)).FaState + uintptr(i)*2)))))) == RE_OP_ACCEPT) {
		goto __52
	}
	rc = 1
	goto __51
__52:
	;
	goto __50
__50:
	i++
	goto __49
	goto __51
__51:
	;
re_match_end:
	sqlite3.Xsqlite3_free(tls, pToFree)
	return rc
}

// Resize the opcode and argument arrays for an RE under construction.
func re_resize(tls *libc.TLS, p uintptr, N int32) int32 { /* regexp.c:340:12: */
	var aOp uintptr
	var aArg uintptr
	aOp = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaOp, uint64(uint64(N)*uint64(unsafe.Sizeof(int8(0)))))
	if aOp == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaOp = aOp
	aArg = sqlite3.Xsqlite3_realloc64(tls, (*ReCompiled)(unsafe.Pointer(p)).FaArg, uint64(uint64(N)*uint64(unsafe.Sizeof(int32(0)))))
	if aArg == uintptr(0) {
		return 1
	}
	(*ReCompiled)(unsafe.Pointer(p)).FaArg = aArg
	(*ReCompiled)(unsafe.Pointer(p)).FnAlloc = uint32(N)
	return 0
}

// Insert a new opcode and argument into an RE under construction.  The
// insertion point is just prior to existing opcode iBefore.
func re_insert(tls *libc.TLS, p uintptr, iBefore int32, op int32, arg int32) int32 { /* regexp.c:356:12: */
	var i int32
	if (*ReCompiled)(unsafe.Pointer(p)).FnAlloc <= (*ReCompiled)(unsafe.Pointer(p)).FnState && re_resize(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2))) != 0 {
		return 0
	}
	for i = int32((*ReCompiled)(unsafe.Pointer(p)).FnState); i > iBefore; i-- {
		*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(i))) = *(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(i-1)))
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(i)*4)) = *(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(i-1)*4))
	}
	(*ReCompiled)(unsafe.Pointer(p)).FnState++
	*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaOp + uintptr(iBefore))) = int8(op)
	*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iBefore)*4)) = arg
	return iBefore
}

// Append a new opcode and argument to the end of the RE under construction.
func re_append(tls *libc.TLS, p uintptr, op int32, arg int32) int32 { /* regexp.c:371:12: */
	return re_insert(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnState), op, arg)
}

// Make a copy of N opcodes starting at iStart onto the end of the RE
// under construction.
func re_copy(tls *libc.TLS, p uintptr, iStart int32, N int32) { /* regexp.c:378:13: */
	if (*ReCompiled)(unsafe.Pointer(p)).FnState+uint32(N) >= (*ReCompiled)(unsafe.Pointer(p)).FnAlloc && re_resize(tls, p, int32((*ReCompiled)(unsafe.Pointer(p)).FnAlloc*uint32(2)+uint32(N))) != 0 {
		return
	}
	libc.Xmemcpy(tls, (*ReCompiled)(unsafe.Pointer(p)).FaOp+uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState), (*ReCompiled)(unsafe.Pointer(p)).FaOp+uintptr(iStart), uint64(N)*uint64(unsafe.Sizeof(int8(0))))
	libc.Xmemcpy(tls, (*ReCompiled)(unsafe.Pointer(p)).FaArg+uintptr((*ReCompiled)(unsafe.Pointer(p)).FnState)*4, (*ReCompiled)(unsafe.Pointer(p)).FaArg+uintptr(iStart)*4, uint64(N)*uint64(unsafe.Sizeof(int32(0))))
	*(*uint32)(unsafe.Pointer(p + 64)) += uint32(N)
}

// Return true if c is a hexadecimal digit character:  [0-9a-fA-F]
// If c is a hex digit, also set *pV = (*pV)*16 + valueof(c).  If
// c is not a hex digit *pV is unchanged.
func re_hex(tls *libc.TLS, c int32, pV uintptr) int32 { /* regexp.c:389:12: */
	if c >= '0' && c <= '9' {
		c = c - '0'
	} else if c >= 'a' && c <= 'f' {
		c = c - ('a' - 10)
	} else if c >= 'A' && c <= 'F' {
		c = c - ('A' - 10)
	} else {
		return 0
	}
	*(*int32)(unsafe.Pointer(pV)) = *(*int32)(unsafe.Pointer(pV))*16 + c&0xff
	return 1
}

// A backslash character has been seen, read the next character and
// return its interpretation.
func re_esc_char(tls *libc.TLS, p uintptr) uint32 { /* regexp.c:406:17: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	*(*int32)(unsafe.Pointer(bp /* v */)) = 0
	var c int8
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return uint32(0)
	}
	c = int8(*(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi))))
	if int32(c) == 'u' && (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi+4 < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		var zIn uintptr = (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)
		if re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 1))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 2))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 3))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 4))), bp) != 0 {
			*(*int32)(unsafe.Pointer(p + 8)) += 5
			return uint32(*(*int32)(unsafe.Pointer(bp /* v */)))
		}
	}
	if int32(c) == 'x' && (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi+2 < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		var zIn uintptr = (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)
		if re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 1))), bp) != 0 &&
			re_hex(tls, int32(*(*uint8)(unsafe.Pointer(zIn + 2))), bp) != 0 {
			*(*int32)(unsafe.Pointer(p + 8)) += 3
			return uint32(*(*int32)(unsafe.Pointer(bp /* v */)))
		}
	}
	for i = 0; zEsc[i] != 0 && int32(zEsc[i]) != int32(c); i++ {
	}
	if zEsc[i] != 0 {
		if i < 6 {
			c = zTrans[i]
		}
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
	} else {
		(*ReCompiled)(unsafe.Pointer(p)).FzErr = ts + 6185 /* "unknown \\ escape" */
	}
	return uint32(c)
}

var zEsc = *(*[21]int8)(unsafe.Pointer(ts + 6202 /* "afnrtv\\()*.+?[$^..." */)) /* regexp.c:407:21 */
var zTrans = *(*[7]int8)(unsafe.Pointer(ts + 6223 /* "\a\f\n\r\t\v" */))        /* regexp.c:408:21 */

// Peek at the next byte of input
func rePeek(tls *libc.TLS, p uintptr) uint8 { /* regexp.c:447:22: */
	if (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi < (*ReCompiled)(unsafe.Pointer(p)).FsIn.Fmx {
		return *(*uint8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fz + uintptr((*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi)))
	}
	return uint8(0)
}

// Compile RE text into a sequence of opcodes.  Continue up to the
// first unmatched ")" character, then return.  If an error is found,
// return a pointer to the error message string.
func re_subcompile_re(tls *libc.TLS, p uintptr) uintptr { /* regexp.c:455:19: */
	var zErr uintptr
	var iStart int32
	var iEnd int32
	var iGoto int32
	iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
	zErr = re_subcompile_string(tls, p)
	if zErr != 0 {
		return zErr
	}
	for int32(rePeek(tls, p)) == '|' {
		iEnd = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		re_insert(tls, p, iStart, RE_OP_FORK, iEnd+2-iStart)
		iGoto = re_append(tls, p, RE_OP_GOTO, 0)
		(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
		zErr = re_subcompile_string(tls, p)
		if zErr != 0 {
			return zErr
		}
		*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iGoto)*4)) = int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iGoto))
	}
	return uintptr(0)
}

// Compile an element of regular expression text (anything that can be
// an operand to the "|" operator).  Return NULL on success or a pointer
// to the error message if there is a problem.
func re_subcompile_string(tls *libc.TLS, p uintptr) uintptr { /* regexp.c:477:19: */
	var iPrev int32 = -1
	var iStart int32
	var c uint32
	var zErr uintptr
	for libc.AssignUint32(&c, (*struct {
		f func(*libc.TLS, uintptr) uint32
	})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(p)).FxNextChar})).f(tls, p)) != uint32(0) {
		iStart = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
		switch c {
		case uint32('|'):
			fallthrough
		case uint32('$'):
			fallthrough
		case uint32(')'):
			{
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi--
				return uintptr(0)

			}
		case uint32('('):
			{
				zErr = re_subcompile_re(tls, p)
				if zErr != 0 {
					return zErr
				}
				if int32(rePeek(tls, p)) != ')' {
					return ts + 6230 /* "unmatched '('" */
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				break

			}
		case uint32('.'):
			{
				if int32(rePeek(tls, p)) == '*' {
					re_append(tls, p, RE_OP_ANYSTAR, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, RE_OP_ANY, 0)
				}
				break

			}
		case uint32('*'):
			{
				if iPrev < 0 {
					return ts + 6244 /* "'*' without oper..." */
				}
				re_insert(tls, p, iPrev, RE_OP_GOTO, int32((*ReCompiled)(unsafe.Pointer(p)).FnState-uint32(iPrev)+uint32(1)))
				re_append(tls, p, RE_OP_FORK, int32(uint32(iPrev)-(*ReCompiled)(unsafe.Pointer(p)).FnState+uint32(1)))
				break

			}
		case uint32('+'):
			{
				if iPrev < 0 {
					return ts + 6264 /* "'+' without oper..." */
				}
				re_append(tls, p, RE_OP_FORK, int32(uint32(iPrev)-(*ReCompiled)(unsafe.Pointer(p)).FnState))
				break

			}
		case uint32('?'):
			{
				if iPrev < 0 {
					return ts + 6284 /* "'?' without oper..." */
				}
				re_insert(tls, p, iPrev, RE_OP_FORK, int32((*ReCompiled)(unsafe.Pointer(p)).FnState-uint32(iPrev)+uint32(1)))
				break

			}
		case uint32('{'):
			{
				var m int32 = 0
				var n int32 = 0
				var sz int32
				var j int32
				if iPrev < 0 {
					return ts + 6304 /* "'{m,n}' without ..." */
				}
				for libc.AssignUint32(&c, uint32(rePeek(tls, p))) >= uint32('0') && c <= uint32('9') {
					m = int32(uint32(m*10) + c - uint32('0'))
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				}
				n = m
				if c == uint32(',') {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					n = 0
					for libc.AssignUint32(&c, uint32(rePeek(tls, p))) >= uint32('0') && c <= uint32('9') {
						n = int32(uint32(n*10) + c - uint32('0'))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					}
				}
				if c != uint32('}') {
					return ts + 6328 /* "unmatched '{'" */
				}
				if n > 0 && n < m {
					return ts + 6342 /* "n less than m in..." */
				}
				(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				sz = int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iPrev))
				if m == 0 {
					if n == 0 {
						return ts + 6367 /* "both m and n are..." */
					}
					re_insert(tls, p, iPrev, RE_OP_FORK, sz+1)
					n--
				} else {
					for j = 1; j < m; j++ {
						re_copy(tls, p, iPrev, sz)
					}
				}
				for j = m; j < n; j++ {
					re_append(tls, p, RE_OP_FORK, sz+1)
					re_copy(tls, p, iPrev, sz)
				}
				if n == 0 && m > 0 {
					re_append(tls, p, RE_OP_FORK, -sz)
				}
				break

			}
		case uint32('['):
			{
				var iFirst int32 = int32((*ReCompiled)(unsafe.Pointer(p)).FnState)
				if int32(rePeek(tls, p)) == '^' {
					re_append(tls, p, RE_OP_CC_EXC, 0)
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
				} else {
					re_append(tls, p, RE_OP_CC_INC, 0)
				}
				for libc.AssignUint32(&c, (*struct {
					f func(*libc.TLS, uintptr) uint32
				})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(p)).FxNextChar})).f(tls, p)) != uint32(0) {
					if c == uint32('[') && int32(rePeek(tls, p)) == ':' {
						return ts + 6400 /* "POSIX character ..." */
					}
					if c == uint32('\\') {
						c = re_esc_char(tls, p)
					}
					if int32(rePeek(tls, p)) == '-' {
						re_append(tls, p, RE_OP_CC_RANGE, int32(c))
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						c = (*struct {
							f func(*libc.TLS, uintptr) uint32
						})(unsafe.Pointer(&struct{ uintptr }{(*ReCompiled)(unsafe.Pointer(p)).FxNextChar})).f(tls, p /* &.sIn */)
						if c == uint32('\\') {
							c = re_esc_char(tls, p)
						}
						re_append(tls, p, RE_OP_CC_RANGE, int32(c))
					} else {
						re_append(tls, p, RE_OP_CC_VALUE, int32(c))
					}
					if int32(rePeek(tls, p)) == ']' {
						(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
						break
					}
				}
				if c == uint32(0) {
					return ts + 6438 /* "unclosed '['" */
				}
				*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(p)).FaArg + uintptr(iFirst)*4)) = int32((*ReCompiled)(unsafe.Pointer(p)).FnState - uint32(iFirst))
				break

			}
		case uint32('\\'):
			{
				var specialOp int32 = 0
				switch int32(rePeek(tls, p)) {
				case 'b':
					specialOp = RE_OP_BOUNDARY
					break
				case 'd':
					specialOp = RE_OP_DIGIT
					break
				case 'D':
					specialOp = RE_OP_NOTDIGIT
					break
				case 's':
					specialOp = RE_OP_SPACE
					break
				case 'S':
					specialOp = RE_OP_NOTSPACE
					break
				case 'w':
					specialOp = RE_OP_WORD
					break
				case 'W':
					specialOp = RE_OP_NOTWORD
					break
				}
				if specialOp != 0 {
					(*ReCompiled)(unsafe.Pointer(p)).FsIn.Fi++
					re_append(tls, p, specialOp, 0)
				} else {
					c = re_esc_char(tls, p)
					re_append(tls, p, RE_OP_MATCH, int32(c))
				}
				break

			}
		default:
			{
				re_append(tls, p, RE_OP_MATCH, int32(c))
				break

			}
		}
		iPrev = iStart
	}
	return uintptr(0)
}

// Free and reclaim all the memory used by a previously compiled
// regular expression.  Applications should invoke this routine once
// for every call to re_compile() to avoid memory leaks.
func sqlite3re_free(tls *libc.TLS, pRe uintptr) { /* regexp.c:616:13: */
	if pRe != 0 {
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaOp)
		sqlite3.Xsqlite3_free(tls, (*ReCompiled)(unsafe.Pointer(pRe)).FaArg)
		sqlite3.Xsqlite3_free(tls, pRe)
	}
}

// Compile a textual regular expression in zIn[] into a compiled regular
// expression suitable for us by re_match() and return a pointer to the
// compiled regular expression in *ppRe.  Return NULL on success or an
// error message if something goes wrong.
func sqlite3re_compile(tls *libc.TLS, ppRe uintptr, zIn uintptr, noCase int32) uintptr { /* regexp.c:630:19: */
	var pRe uintptr
	var zErr uintptr
	var i int32
	var j int32

	*(*uintptr)(unsafe.Pointer(ppRe)) = uintptr(0)
	pRe = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ReCompiled{})))
	if pRe == uintptr(0) {
		return ts + 2069 /* "out of memory" */
	}
	libc.Xmemset(tls, pRe, 0, uint64(unsafe.Sizeof(ReCompiled{})))
	(*ReCompiled)(unsafe.Pointer(pRe)).FxNextChar = func() uintptr {
		if noCase != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) uint32
			}{re_next_char_nocase}))
		}
		return *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) uint32
		}{re_next_char}))
	}()
	if re_resize(tls, pRe, 30) != 0 {
		sqlite3re_free(tls, pRe)
		return ts + 2069 /* "out of memory" */
	}
	if int32(*(*int8)(unsafe.Pointer(zIn))) == '^' {
		zIn++
	} else {
		re_append(tls, pRe, RE_OP_ANYSTAR, 0)
	}
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fz = zIn
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi = 0
	(*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx = int32(libc.Xstrlen(tls, zIn))
	zErr = re_subcompile_re(tls, pRe)
	if zErr != 0 {
		sqlite3re_free(tls, pRe)
		return zErr
	}
	if int32(rePeek(tls, pRe)) == '$' && (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi+1 >= (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx {
		re_append(tls, pRe, RE_OP_MATCH, RE_EOF)
		re_append(tls, pRe, RE_OP_ACCEPT, 0)
		*(*uintptr)(unsafe.Pointer(ppRe)) = pRe
	} else if (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fi >= (*ReCompiled)(unsafe.Pointer(pRe)).FsIn.Fmx {
		re_append(tls, pRe, RE_OP_ACCEPT, 0)
		*(*uintptr)(unsafe.Pointer(ppRe)) = pRe
	} else {
		sqlite3re_free(tls, pRe)
		return ts + 6451 /* "unrecognized cha..." */
	}

	// The following is a performance optimization.  If the regex begins with
	// ".*" (if the input regex lacks an initial "^") and afterwards there are
	// one or more matching characters, enter those matching characters into
	// zInit[].  The re_match() routine can then search ahead in the input
	// string looking for the initial match without having to run the whole
	// regex engine over the string.  Do not worry able trying to match
	// unicode characters beyond plane 0 - those are very rare and this is
	// just an optimization.
	if int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp))) == RE_OP_ANYSTAR && !(noCase != 0) {
		j = 0
		i = 1
		for ; j < int32(unsafe.Sizeof([12]uint8{}))-2 && int32(*(*int8)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaOp + uintptr(i)))) == RE_OP_MATCH; i++ {
			var x uint32 = uint32(*(*int32)(unsafe.Pointer((*ReCompiled)(unsafe.Pointer(pRe)).FaArg + uintptr(i)*4)))
			if x <= uint32(127) {
				*(*uint8)(unsafe.Pointer(pRe + 48 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(x)
			} else if x <= uint32(0xfff) {
				*(*uint8)(unsafe.Pointer(pRe + 48 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0xc0) | x>>6)
				*(*uint8)(unsafe.Pointer(pRe + 48 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0x80) | x&uint32(0x3f))
			} else if x <= uint32(0xffff) {
				*(*uint8)(unsafe.Pointer(pRe + 48 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0xd0) | x>>12)
				*(*uint8)(unsafe.Pointer(pRe + 48 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0x80) | x>>6&uint32(0x3f))
				*(*uint8)(unsafe.Pointer(pRe + 48 + uintptr(libc.PostIncInt32(&j, 1)))) = uint8(uint32(0x80) | x&uint32(0x3f))
			} else {
				break
			}
		}
		if j > 0 && int32(*(*uint8)(unsafe.Pointer(pRe + 48 + uintptr(j-1)))) == 0 {
			j--
		}
		(*ReCompiled)(unsafe.Pointer(pRe)).FnInit = j
	}
	return (*ReCompiled)(unsafe.Pointer(pRe)).FzErr
}

// Implementation of the regexp() SQL function.  This function implements
// the build-in REGEXP operator.  The first argument to the function is the
// pattern and the second argument is the string.  So, the SQL statements:
//
//       A REGEXP B
//
// is implemented as regexp(B,A).
func re_sql_func(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* regexp.c:710:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pRe uintptr at bp, 8
	// Compiled regular expression
	var zPattern uintptr // The regular expression
	var zStr uintptr     // String being searched
	var zErr uintptr     // Compile error message
	var setAux int32 = 0 // True to invoke sqlite3_set_auxdata()

	_ = argc // Unused
	*(*uintptr)(unsafe.Pointer(bp /* pRe */)) = sqlite3.Xsqlite3_get_auxdata(tls, context, 0)
	if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) {
		zPattern = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		if zPattern == uintptr(0) {
			return
		}
		zErr = sqlite3re_compile(tls, bp /* &pRe */, zPattern, libc.Bool32(sqlite3.Xsqlite3_user_data(tls, context) != uintptr(0)))
		if zErr != 0 {
			sqlite3re_free(tls, *(*uintptr)(unsafe.Pointer(bp /* pRe */)))
			sqlite3.Xsqlite3_result_error(tls, context, zErr, -1)
			return
		}
		if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		setAux = 1
	}
	zStr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if zStr != uintptr(0) {
		sqlite3.Xsqlite3_result_int(tls, context, sqlite3re_match(tls, *(*uintptr)(unsafe.Pointer(bp /* pRe */)), zStr, -1))
	}
	if setAux != 0 {
		sqlite3.Xsqlite3_set_auxdata(tls, context, 0, *(*uintptr)(unsafe.Pointer(bp /* pRe */)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3re_free})))
	}
}

// Invoke this routine to register the regexp() function with the
// SQLite database connection.
func sqlite3_regexp_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* regexp.c:754:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6474 /* "regexp" */, 2, SQLITE_UTF8|SQLITE_INNOCUOUS,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{re_sql_func})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		// The regexpi(PATTERN,STRING) function is a case-insensitive version
		// of regexp(PATTERN,STRING).
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6481 /* "regexpi" */, 2, SQLITE_UTF8|SQLITE_INNOCUOUS,
			db, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{re_sql_func})), uintptr(0), uintptr(0))
	}
	return rc
}

//      remember(V,PTR)
//
// Return the integer value V.  Also save the value of V in a
// C-language variable whose address is PTR.
func rememberFunc(tls *libc.TLS, pCtx uintptr, argc int32, argv uintptr) { /* remember.c:45:13: */
	var v sqlite3_int64
	var ptr uintptr

	v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	ptr = sqlite3.Xsqlite3_value_pointer(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4060 /* "carray" */)
	if ptr != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(ptr)) = v
	}
	sqlite3.Xsqlite3_result_int64(tls, pCtx, v)
}

func sqlite3_remember_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* remember.c:62:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+6489 /* "remember" */, 2, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{rememberFunc})), uintptr(0), uintptr(0))
	return rc
}

// series_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type series_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FisDesc      int32
	F__ccgo_pad1 [4]byte
	FiRowid      sqlite3_int64
	FiValue      sqlite3_int64
	FmnValue     sqlite3_int64
	FmxValue     sqlite3_int64
	FiStep       sqlite3_int64
} /* series.c:83:9 */

// series_cursor is a subclass of sqlite3_vtab_cursor which will
// serve as the underlying representation of a cursor that scans
// over rows of the result
type series_cursor = series_cursor1 /* series.c:83:30 */

// The seriesConnect() method is invoked to create a new
// series_vtab that describes the generate_series virtual table.
//
// Think of this routine as the constructor for series_vtab objects.
//
// All this routine needs to do is:
//
//    (1) Allocate the series_vtab object and initialize all fields.
//
//    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
//        result set of queries against generate_series will look like.
func seriesConnect(tls *libc.TLS, db uintptr, pUnused uintptr, argcUnused int32, argvUnused uintptr, ppVtab uintptr, pzErrUnused uintptr) int32 { /* series.c:107:12: */
	var pNew uintptr
	var rc int32

	// Column numbers

	_ = pUnused
	_ = argcUnused
	_ = argvUnused
	_ = pzErrUnused
	rc = sqlite3.Xsqlite3_declare_vtab(tls, db,
		ts+6498 /* "CREATE TABLE x(v..." */)
	if rc == SQLITE_OK {
		pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(sqlite3_vtab{})))
		sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	}
	return rc
}

// This method is the destructor for series_cursor objects.
func seriesDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* series.c:141:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new series_cursor object.
func seriesOpen(tls *libc.TLS, pUnused uintptr, ppCursor uintptr) int32 { /* series.c:149:12: */
	var pCur uintptr
	_ = pUnused
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(series_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(series_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Destructor for a series_cursor.
func seriesClose(tls *libc.TLS, cur uintptr) int32 { /* series.c:162:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Advance a series_cursor to its next row of output.
func seriesNext(tls *libc.TLS, cur uintptr) int32 { /* series.c:171:12: */
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 24)) -= (*series_cursor)(unsafe.Pointer(pCur)).FiStep
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pCur + 24)) += (*series_cursor)(unsafe.Pointer(pCur)).FiStep
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid++
	return SQLITE_OK
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func seriesColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* series.c:186:12: */
	var pCur uintptr = cur
	var x sqlite3_int64 = int64(0)
	switch i {
	case SERIES_COLUMN_START:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
		break
	case SERIES_COLUMN_STOP:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		break
	case SERIES_COLUMN_STEP:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiStep
		break
	default:
		x = (*series_cursor)(unsafe.Pointer(pCur)).FiValue
		break
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, x)
	return SQLITE_OK
}

// Return the rowid for the current row. In this implementation, the
// first row returned is assigned rowid value 1, and each subsequent
// row a value 1 more than that of the previous.
func seriesRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* series.c:208:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*series_cursor)(unsafe.Pointer(pCur)).FiRowid
	return SQLITE_OK
}

// Return TRUE if the cursor has been moved off of the last
// row of output.
func seriesEof(tls *libc.TLS, cur uintptr) int32 { /* series.c:218:12: */
	var pCur uintptr = cur
	if (*series_cursor)(unsafe.Pointer(pCur)).FisDesc != 0 {
		return libc.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue < (*series_cursor)(unsafe.Pointer(pCur)).FmnValue)
	} else {
		return libc.Bool32((*series_cursor)(unsafe.Pointer(pCur)).FiValue > (*series_cursor)(unsafe.Pointer(pCur)).FmxValue)
	}
	return int32(0)
}

// True to cause run-time checking of the start=, stop=, and/or step=
// parameters.  The only reason to do this is for testing the
// constraint checking logic for virtual tables in the SQLite core.

// This method is called to "rewind" the series_cursor object back
// to the first row of output.  This method is always called at least
// once prior to any call to seriesColumn() or seriesRowid() or
// seriesEof().
//
// The query plan selected by seriesBestIndex is passed in the idxNum
// parameter.  (idxStr is not used in this implementation.)  idxNum
// is a bitmask showing which constraints are available:
//
//    1:    start=VALUE
//    2:    stop=VALUE
//    4:    step=VALUE
//
// Also, if bit 8 is set, that means that the series should be output
// in descending order rather than in ascending order.  If bit 16 is
// set, then output must appear in ascending order.
//
// This routine should initialize the cursor and position it so that it
// is pointing at the first row, or pointing off the end of the table
// (so that seriesEof() will return true) if the table is empty.
func seriesFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStrUnused uintptr, argc int32, argv uintptr) int32 { /* series.c:257:12: */
	var pCur uintptr = pVtabCursor
	var i int32 = 0
	_ = idxStrUnused
	if idxNum&1 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*8)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(0)
	}
	if idxNum&2 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*8)))
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff)
	}
	if idxNum&4 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&i, 1))*8)))
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep == int64(0) {
			(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
		} else if (*series_cursor)(unsafe.Pointer(pCur)).FiStep < int64(0) {
			(*series_cursor)(unsafe.Pointer(pCur)).FiStep = -(*series_cursor)(unsafe.Pointer(pCur)).FiStep
			if idxNum&16 == 0 {
				idxNum = idxNum | 8
			}
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FiStep = int64(1)
	}
	for i = 0; i < argc; i++ {
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) == SQLITE_NULL {
			// If any of the constraints have a NULL value, then return no rows.
			// See ticket https://www.sqlite.org/src/info/fac496b61722daf2
			(*series_cursor)(unsafe.Pointer(pCur)).FmnValue = int64(1)
			(*series_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0)
			break
		}
	}
	if idxNum&8 != 0 {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 1
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmxValue
		if (*series_cursor)(unsafe.Pointer(pCur)).FiStep > int64(0) {
			*(*sqlite3_int64)(unsafe.Pointer(pCur + 24)) -= ((*series_cursor)(unsafe.Pointer(pCur)).FmxValue - (*series_cursor)(unsafe.Pointer(pCur)).FmnValue) % (*series_cursor)(unsafe.Pointer(pCur)).FiStep
		}
	} else {
		(*series_cursor)(unsafe.Pointer(pCur)).FisDesc = 0
		(*series_cursor)(unsafe.Pointer(pCur)).FiValue = (*series_cursor)(unsafe.Pointer(pCur)).FmnValue
	}
	(*series_cursor)(unsafe.Pointer(pCur)).FiRowid = int64(1)
	return SQLITE_OK
}

// SQLite will invoke this method one or more times while planning a query
// that uses the generate_series virtual table.  This routine needs to create
// a query plan for each invocation and compute an estimated cost for that
// plan.
//
// In this implementation idxNum is used to represent the
// query plan.  idxStr is unused.
//
// The query plan is represented by bits in idxNum:
//
//  (1)  start = $value  -- constraint exists
//  (2)  stop = $value   -- constraint exists
//  (4)  step = $value   -- constraint exists
//  (8)  output in descending order
func seriesBestIndex(tls *libc.TLS, pVTab uintptr, pIdxInfo uintptr) int32 { /* series.c:325:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var i int32
	var j int32                // Loop over constraints
	var idxNum int32 = 0       // The query plan bitmask
	var bStartSeen int32 = 0   // EQ constraint seen on the START column
	var unusableMask int32 = 0 // Mask of unusable constraints
	var nArg int32 = 0         // Number of arguments that seriesFilter() expects
	// var aIdx [3]int32 at bp, 12
	// Constraints on start, stop, and step
	var pConstraint uintptr

	// This implementation assumes that the start, stop, and step columns
	// are the last three columns in the virtual table.

	*(*int32)(unsafe.Pointer(bp /* &aIdx[0] */)) = libc.AssignPtrInt32(bp+1*4, libc.AssignPtrInt32(bp+2*4, -1))
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		var iCol int32  // 0 for start, 1 for stop, 2 for step
		var iMask int32 // bitmask for those column
		if (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < SERIES_COLUMN_START {
			goto __2
		}
		iCol = (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn - SERIES_COLUMN_START

		iMask = int32(1) << iCol
		if iCol == 0 {
			bStartSeen = 1
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			unusableMask = unusableMask | iMask
			goto __2
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idxNum = idxNum | iMask
			*(*int32)(unsafe.Pointer(bp /* &aIdx[0] */ + uintptr(iCol)*4)) = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	for i = 0; i < 3; i++ {
		if libc.AssignInt32(&j, *(*int32)(unsafe.Pointer(bp + uintptr(i)*4))) >= 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).FargvIndex = libc.PreIncInt32(&nArg, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(j)*8)).Fomit = libc.BoolUint8(!(1 != 0))
		}
	}
	// The current generate_column() implementation requires at least one
	// argument (the START value).  Legacy versions assumed START=0 if the
	// first argument was omitted.  Compile with -DZERO_ARGUMENT_GENERATE_SERIES
	// to obtain the legacy behavior
	if !(bStartSeen != 0) {
		sqlite3.Xsqlite3_free(tls, (*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg)
		(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+6557 /* "first argument t..." */, 0)
		return SQLITE_ERROR
	}
	if unusableMask & ^idxNum != 0 {
		// The start, stop, and step columns are inputs.  Therefore if there
		// are unusable constraints on any of start, stop, or step then
		// this plan is unusable
		return SQLITE_CONSTRAINT
	}
	if idxNum&3 == 3 {
		// Both start= and stop= boundaries are available.  This is the
		// the preferred case
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(2 - libc.Bool32(idxNum&4 != 0))
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1000)
		if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 {
			if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc != 0 {
				idxNum = idxNum | 8
			} else {
				idxNum = idxNum | 16
			}
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
		}
	} else {
		// If either boundary is missing, we have to generate a huge span
		// of numbers.  Make this case very expensive so that the query
		// planner will work hard to avoid it.
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(2147483647)
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	return SQLITE_OK
}

// This following structure defines all the methods for the
// generate_series virtual table.
var seriesModule = sqlite3_module{ // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* series.c:411:23 */

func sqlite3_series_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* series.c:443:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	if sqlite3.Xsqlite3_libversion_number(tls) < 3008012 && pzErrMsg != uintptr(0) {
		*(*uintptr)(unsafe.Pointer(pzErrMsg)) = sqlite3.Xsqlite3_mprintf(tls,
			ts+6615 /* "generate_series(..." */, 0)
		return SQLITE_ERROR
	}
	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+6665 /* "generate_series" */, uintptr(unsafe.Pointer(&seriesModule)), uintptr(0))
	return rc
}

type u16 = uint16 /* spellfix.c:34:26 */

// POSIX.1-2001 specifies _tolower() and _toupper() to be macros equivalent to
// tolower() and toupper() respectively, minus extra checking to ensure that
// the argument is a lower or uppercase letter respectively.  We've chosen to
// implement these macros with the same error checking as tolower() and
// toupper() since this doesn't violate the specification itself, only its
// intent.  We purposely leave _tolower() and _toupper() undocumented to
// discourage their use.
//
// XXX isascii() and toascii() should similarly be undocumented.

// Character classes for ASCII characters:
//
//   0   ''        Silent letters:   H W
//   1   'A'       Any vowel:   A E I O U (Y)
//   2   'B'       A bilabeal stop or fricative:  B F P V W
//   3   'C'       Other fricatives or back stops:  C G J K Q S X Z
//   4   'D'       Alveolar stops:  D T
//   5   'H'       Letter H at the beginning of a word
//   6   'L'       Glide:  L
//   7   'R'       Semivowel:  R
//   8   'M'       Nasals:  M N
//   9   'Y'       Letter Y at the beginning of a word.
//   10  '9'       Digits: 0 1 2 3 4 5 6 7 8 9
//   11  ' '       White space
//   12  '?'       Other.

// The following table gives the character class for non-initial ASCII
// characters.
var midClass = [128]uint8{
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_SPACE),
	/* ! */ uint8(CCLASS_OTHER) /* " */, uint8(CCLASS_OTHER) /* # */, uint8(CCLASS_OTHER),
	/* $ */ uint8(CCLASS_OTHER) /* % */, uint8(CCLASS_OTHER) /* & */, uint8(CCLASS_OTHER),
	/* ' */ uint8(CCLASS_SILENT) /* ( */, uint8(CCLASS_OTHER) /* ) */, uint8(CCLASS_OTHER),
	/* * */ uint8(CCLASS_OTHER) /* + */, uint8(CCLASS_OTHER) /* , */, uint8(CCLASS_OTHER),
	/* - */ uint8(CCLASS_OTHER) /* . */, uint8(CCLASS_OTHER) /* / */, uint8(CCLASS_OTHER),
	/* 0 */ uint8(CCLASS_DIGIT) /* 1 */, uint8(CCLASS_DIGIT) /* 2 */, uint8(CCLASS_DIGIT),
	/* 3 */ uint8(CCLASS_DIGIT) /* 4 */, uint8(CCLASS_DIGIT) /* 5 */, uint8(CCLASS_DIGIT),
	/* 6 */ uint8(CCLASS_DIGIT) /* 7 */, uint8(CCLASS_DIGIT) /* 8 */, uint8(CCLASS_DIGIT),
	/* 9 */ uint8(CCLASS_DIGIT) /* : */, uint8(CCLASS_OTHER) /* ; */, uint8(CCLASS_OTHER),
	/* < */ uint8(CCLASS_OTHER) /* = */, uint8(CCLASS_OTHER) /* > */, uint8(CCLASS_OTHER),
	/* ? */ uint8(CCLASS_OTHER) /* @ */, uint8(CCLASS_OTHER) /* A */, uint8(CCLASS_VOWEL),
	/* B */ uint8(CCLASS_B) /* C */, uint8(CCLASS_C) /* D */, uint8(CCLASS_D),
	/* E */ uint8(CCLASS_VOWEL) /* F */, uint8(CCLASS_B) /* G */, uint8(CCLASS_C),
	/* H */ uint8(CCLASS_SILENT) /* I */, uint8(CCLASS_VOWEL) /* J */, uint8(CCLASS_C),
	/* K */ uint8(CCLASS_C) /* L */, uint8(CCLASS_L) /* M */, uint8(CCLASS_M),
	/* N */ uint8(CCLASS_M) /* O */, uint8(CCLASS_VOWEL) /* P */, uint8(CCLASS_B),
	/* Q */ uint8(CCLASS_C) /* R */, uint8(CCLASS_R) /* S */, uint8(CCLASS_C),
	/* T */ uint8(CCLASS_D) /* U */, uint8(CCLASS_VOWEL) /* V */, uint8(CCLASS_B),
	/* W */ uint8(CCLASS_B) /* X */, uint8(CCLASS_C) /* Y */, uint8(CCLASS_VOWEL),
	/* Z */ uint8(CCLASS_C) /* [ */, uint8(CCLASS_OTHER) /* \ */, uint8(CCLASS_OTHER),
	/* ] */ uint8(CCLASS_OTHER) /* ^ */, uint8(CCLASS_OTHER) /* _ */, uint8(CCLASS_OTHER),
	/* ` */ uint8(CCLASS_OTHER) /* a */, uint8(CCLASS_VOWEL) /* b */, uint8(CCLASS_B),
	/* c */ uint8(CCLASS_C) /* d */, uint8(CCLASS_D) /* e */, uint8(CCLASS_VOWEL),
	/* f */ uint8(CCLASS_B) /* g */, uint8(CCLASS_C) /* h */, uint8(CCLASS_SILENT),
	/* i */ uint8(CCLASS_VOWEL) /* j */, uint8(CCLASS_C) /* k */, uint8(CCLASS_C),
	/* l */ uint8(CCLASS_L) /* m */, uint8(CCLASS_M) /* n */, uint8(CCLASS_M),
	/* o */ uint8(CCLASS_VOWEL) /* p */, uint8(CCLASS_B) /* q */, uint8(CCLASS_C),
	/* r */ uint8(CCLASS_R) /* s */, uint8(CCLASS_C) /* t */, uint8(CCLASS_D),
	/* u */ uint8(CCLASS_VOWEL) /* v */, uint8(CCLASS_B) /* w */, uint8(CCLASS_B),
	/* x */ uint8(CCLASS_C) /* y */, uint8(CCLASS_VOWEL) /* z */, uint8(CCLASS_C),
	/* { */ uint8(CCLASS_OTHER) /* | */, uint8(CCLASS_OTHER) /* } */, uint8(CCLASS_OTHER),
	/* ~ */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
} /* spellfix.c:75:28 */
// This tables gives the character class for ASCII characters that form the
// initial character of a word.  The only difference from midClass is with
// the letters H, W, and Y.
var initClass = [128]uint8{
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_SPACE) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
	/*   */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_SPACE),
	/* ! */ uint8(CCLASS_OTHER) /* " */, uint8(CCLASS_OTHER) /* # */, uint8(CCLASS_OTHER),
	/* $ */ uint8(CCLASS_OTHER) /* % */, uint8(CCLASS_OTHER) /* & */, uint8(CCLASS_OTHER),
	/* ' */ uint8(CCLASS_OTHER) /* ( */, uint8(CCLASS_OTHER) /* ) */, uint8(CCLASS_OTHER),
	/* * */ uint8(CCLASS_OTHER) /* + */, uint8(CCLASS_OTHER) /* , */, uint8(CCLASS_OTHER),
	/* - */ uint8(CCLASS_OTHER) /* . */, uint8(CCLASS_OTHER) /* / */, uint8(CCLASS_OTHER),
	/* 0 */ uint8(CCLASS_DIGIT) /* 1 */, uint8(CCLASS_DIGIT) /* 2 */, uint8(CCLASS_DIGIT),
	/* 3 */ uint8(CCLASS_DIGIT) /* 4 */, uint8(CCLASS_DIGIT) /* 5 */, uint8(CCLASS_DIGIT),
	/* 6 */ uint8(CCLASS_DIGIT) /* 7 */, uint8(CCLASS_DIGIT) /* 8 */, uint8(CCLASS_DIGIT),
	/* 9 */ uint8(CCLASS_DIGIT) /* : */, uint8(CCLASS_OTHER) /* ; */, uint8(CCLASS_OTHER),
	/* < */ uint8(CCLASS_OTHER) /* = */, uint8(CCLASS_OTHER) /* > */, uint8(CCLASS_OTHER),
	/* ? */ uint8(CCLASS_OTHER) /* @ */, uint8(CCLASS_OTHER) /* A */, uint8(CCLASS_VOWEL),
	/* B */ uint8(CCLASS_B) /* C */, uint8(CCLASS_C) /* D */, uint8(CCLASS_D),
	/* E */ uint8(CCLASS_VOWEL) /* F */, uint8(CCLASS_B) /* G */, uint8(CCLASS_C),
	/* H */ uint8(CCLASS_SILENT) /* I */, uint8(CCLASS_VOWEL) /* J */, uint8(CCLASS_C),
	/* K */ uint8(CCLASS_C) /* L */, uint8(CCLASS_L) /* M */, uint8(CCLASS_M),
	/* N */ uint8(CCLASS_M) /* O */, uint8(CCLASS_VOWEL) /* P */, uint8(CCLASS_B),
	/* Q */ uint8(CCLASS_C) /* R */, uint8(CCLASS_R) /* S */, uint8(CCLASS_C),
	/* T */ uint8(CCLASS_D) /* U */, uint8(CCLASS_VOWEL) /* V */, uint8(CCLASS_B),
	/* W */ uint8(CCLASS_B) /* X */, uint8(CCLASS_C) /* Y */, uint8(CCLASS_Y),
	/* Z */ uint8(CCLASS_C) /* [ */, uint8(CCLASS_OTHER) /* \ */, uint8(CCLASS_OTHER),
	/* ] */ uint8(CCLASS_OTHER) /* ^ */, uint8(CCLASS_OTHER) /* _ */, uint8(CCLASS_OTHER),
	/* ` */ uint8(CCLASS_OTHER) /* a */, uint8(CCLASS_VOWEL) /* b */, uint8(CCLASS_B),
	/* c */ uint8(CCLASS_C) /* d */, uint8(CCLASS_D) /* e */, uint8(CCLASS_VOWEL),
	/* f */ uint8(CCLASS_B) /* g */, uint8(CCLASS_C) /* h */, uint8(CCLASS_SILENT),
	/* i */ uint8(CCLASS_VOWEL) /* j */, uint8(CCLASS_C) /* k */, uint8(CCLASS_C),
	/* l */ uint8(CCLASS_L) /* m */, uint8(CCLASS_M) /* n */, uint8(CCLASS_M),
	/* o */ uint8(CCLASS_VOWEL) /* p */, uint8(CCLASS_B) /* q */, uint8(CCLASS_C),
	/* r */ uint8(CCLASS_R) /* s */, uint8(CCLASS_C) /* t */, uint8(CCLASS_D),
	/* u */ uint8(CCLASS_VOWEL) /* v */, uint8(CCLASS_B) /* w */, uint8(CCLASS_B),
	/* x */ uint8(CCLASS_C) /* y */, uint8(CCLASS_Y) /* z */, uint8(CCLASS_C),
	/* { */ uint8(CCLASS_OTHER) /* | */, uint8(CCLASS_OTHER) /* } */, uint8(CCLASS_OTHER),
	/* ~ */ uint8(CCLASS_OTHER) /*   */, uint8(CCLASS_OTHER),
} /* spellfix.c:125:28 */

// Mapping from the character class number (0-13) to a symbol for each
// character class.  Note that initClass[] can be used to map the class
// symbol back into the class number.
var className = *(*[14]uint8)(unsafe.Pointer(ts + 6681 /* ".ABCDHLRMY9 ?" */)) /* spellfix.c:176:28 */

// Generate a "phonetic hash" from a string of ASCII characters
// in zIn[0..nIn-1].
//
//   * Map characters by character class as defined above.
//   * Omit double-letters
//   * Omit vowels beside R and L
//   * Omit T when followed by CH
//   * Omit W when followed by R
//   * Omit D when followed by J or G
//   * Omit K in KN or G in GN at the beginning of a word
//
// Space to hold the result is obtained from sqlite3_malloc()
//
// Return NULL if memory allocation fails.
func phoneticHash(tls *libc.TLS, zIn uintptr, nIn int32) uintptr { /* spellfix.c:194:22: */
	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn+1))
	var i int32
	var nOut int32 = 0
	var cPrev int8 = int8(0x77)
	var cPrevX int8 = int8(0x77)
	var aClass uintptr = uintptr(unsafe.Pointer(&initClass))

	if zOut == uintptr(0) {
		return uintptr(0)
	}
	if nIn > 2 {
		switch int32(*(*uint8)(unsafe.Pointer(zIn))) {
		case 'g':
			fallthrough
		case 'k':
			{
				if int32(*(*uint8)(unsafe.Pointer(zIn + 1))) == 'n' {
					zIn++
					nIn--
				}
				break

			}
		}
	}
	for i = 0; i < nIn; i++ {
		var c uint8 = *(*uint8)(unsafe.Pointer(zIn + uintptr(i)))
		if i+1 < nIn {
			if int32(c) == 'w' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'r' {
				continue
			}
			if int32(c) == 'd' && (int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'j' || int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'g') {
				continue
			}
			if i+2 < nIn {
				if int32(c) == 't' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+1)))) == 'c' && int32(*(*uint8)(unsafe.Pointer(zIn + uintptr(i+2)))) == 'h' {
					continue
				}
			}
		}
		c = *(*uint8)(unsafe.Pointer(aClass + uintptr(int32(c)&0x7f)))
		if int32(c) == CCLASS_SPACE {
			continue
		}
		if int32(c) == CCLASS_OTHER && int32(cPrev) != CCLASS_DIGIT {
			continue
		}
		aClass = uintptr(unsafe.Pointer(&midClass))
		if int32(c) == CCLASS_VOWEL && (int32(cPrevX) == CCLASS_R || int32(cPrevX) == CCLASS_L) {
			continue /* No vowels beside L or R */
		}
		if (int32(c) == CCLASS_R || int32(c) == CCLASS_L) && int32(cPrevX) == CCLASS_VOWEL {
			nOut-- // No vowels beside L or R
		}
		cPrev = int8(c)
		if int32(c) == CCLASS_SILENT {
			continue
		}
		cPrevX = int8(c)
		c = className[c]

		if nOut == 0 || int32(c) != int32(*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut-1)))) {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = c
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

// This is an SQL function wrapper around phoneticHash().  See
// the description of phoneticHash() for additional information.
func phoneticHashSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:246:13: */
	var zIn uintptr
	var zOut uintptr

	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if zIn == uintptr(0) {
		return
	}
	zOut = phoneticHash(tls, zIn, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv))))
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// Return the character class number for a character given its
// context.
func characterClass(tls *libc.TLS, cPrev int8, c int8) int8 { /* spellfix.c:268:13: */
	if int32(cPrev) == 0 {
		return int8(initClass[int32(c)&0x7f])
	}
	return int8(midClass[int32(c)&0x7f])
}

// Return the cost of inserting or deleting character c immediately
// following character cPrev.  If cPrev==0, that means c is the first
// character of the word.
func insertOrDeleteCost(tls *libc.TLS, cPrev int8, c int8, cNext int8) int32 { /* spellfix.c:277:12: */
	var classC int8 = characterClass(tls, cPrev, c)
	var classCprev int8

	if int32(classC) == CCLASS_SILENT {
		// Insert or delete "silent" characters such as H or W
		return 1
	}
	if int32(cPrev) == int32(c) {
		// Repeated characters, or miss a repeat
		return 10
	}
	if int32(classC) == CCLASS_VOWEL && (int32(cPrev) == 'r' || int32(cNext) == 'r') {
		return 20 // Insert a vowel before or after 'r'
	}
	classCprev = characterClass(tls, cPrev, cPrev)
	if int32(classC) == int32(classCprev) {
		if int32(classC) == CCLASS_VOWEL {
			// Remove or add a new vowel to a vowel cluster
			return 15
		} else {
			// Remove or add a consonant not in the same class
			return 50
		}
	}

	// any other character insertion or deletion
	return 100
}

// Divide the insertion cost by this factor when appending to the
// end of the word.

// Return the cost of substituting cTo in place of cFrom assuming
// the previous character is cPrev.  If cPrev==0 then cTo is the first
// character of the word.
func substituteCost(tls *libc.TLS, cPrev int8, cFrom int8, cTo int8) int32 { /* spellfix.c:318:12: */
	var classFrom int8
	var classTo int8
	if int32(cFrom) == int32(cTo) {
		// Exact match
		return 0
	}
	if int32(cFrom) == int32(cTo)^0x20 && (int32(cTo) >= 'A' && int32(cTo) <= 'Z' || int32(cTo) >= 'a' && int32(cTo) <= 'z') {
		// differ only in case
		return 0
	}
	classFrom = characterClass(tls, cPrev, cFrom)
	classTo = characterClass(tls, cPrev, cTo)
	if int32(classFrom) == int32(classTo) {
		// Same character class
		return 40
	}
	if int32(classFrom) >= CCLASS_B && int32(classFrom) <= CCLASS_Y &&
		int32(classTo) >= CCLASS_B && int32(classTo) <= CCLASS_Y {
		// Convert from one consonant to another, but in a different class
		return 75
	}
	// Any other subsitution
	return 100
}

// Given two strings zA and zB which are pure ASCII, return the cost
// of transforming zA into zB.  If zA ends with '*' assume that it is
// a prefix of zB and give only minimal penalty for extra characters
// on the end of zB.
//
// Smaller numbers mean a closer match.
//
// Negative values indicate an error:
//    -1  One of the inputs is NULL
//    -2  Non-ASCII characters on input
//    -3  Unable to allocate memory
//
// If pnMatch is not NULL, then *pnMatch is set to the number of bytes
// of zB that matched the pattern in zA. If zA does not end with a '*',
// then this value is always the number of bytes in zB (i.e. strlen(zB)).
// If zA does end in a '*', then it is the number of bytes in the prefix
// of zB that was deemed to match zA.
func editdist1(tls *libc.TLS, zA uintptr, zB uintptr, pnMatch uintptr) int32 { /* spellfix.c:362:12: */
	bp := tls.Alloc(300)
	defer tls.Free(300)

	var nA int32
	var nB int32 // Number of characters in zA[] and zB[]
	var xA int32
	var xB int32 // Loop counters for zA[] and zB[]
	var cA int8 = int8(0)
	var cB int8 // Current character of zA and zB
	var cAprev int8
	var cBprev int8 // Previous character of zA and zB
	var cAnext int8
	var cBnext int8                 // Next character in zA and zB
	var d int32                     // North-west cost value
	var dc int32 = 0                // North-west character value
	var res int32                   // Final result
	var m uintptr                   // The cost matrix
	var cx uintptr                  // Corresponding character values
	var toFree uintptr = uintptr(0) // Malloced space
	var nMatch int32 = 0
	// var mStack [75]int32 at bp, 300
	// Stack space to use if not too much is needed

	// Early out if either input is NULL
	if zA == uintptr(0) || zB == uintptr(0) {
		return -1
	}

	// Skip any common prefix
	for *(*int8)(unsafe.Pointer(zA)) != 0 && int32(*(*int8)(unsafe.Pointer(zA))) == int32(*(*int8)(unsafe.Pointer(zB))) {
		dc = int32(*(*int8)(unsafe.Pointer(zA)))
		zA++
		zB++
		nMatch++
	}
	if pnMatch != 0 {
		*(*int32)(unsafe.Pointer(pnMatch)) = nMatch
	}
	if int32(*(*int8)(unsafe.Pointer(zA))) == 0 && int32(*(*int8)(unsafe.Pointer(zB))) == 0 {
		return 0
	}

	// Verify input strings and measure their lengths
	for nA = 0; *(*int8)(unsafe.Pointer(zA + uintptr(nA))) != 0; nA++ {
		if int32(*(*int8)(unsafe.Pointer(zA + uintptr(nA))))&0x80 != 0 {
			return -2
		}
	}
	for nB = 0; *(*int8)(unsafe.Pointer(zB + uintptr(nB))) != 0; nB++ {
		if int32(*(*int8)(unsafe.Pointer(zB + uintptr(nB))))&0x80 != 0 {
			return -2
		}
	}

	// Special processing if either string is empty
	if nA == 0 {
		cBprev = int8(dc)
		for xB = libc.AssignInt32(&res, 0); int32(libc.AssignInt8(&cB, *(*int8)(unsafe.Pointer(zB + uintptr(xB))))) != 0; xB++ {
			res = res + insertOrDeleteCost(tls, cBprev, cB, *(*int8)(unsafe.Pointer(zB + uintptr(xB+1))))/FINAL_INS_COST_DIV
			cBprev = cB
		}
		return res
	}
	if nB == 0 {
		cAprev = int8(dc)
		for xA = libc.AssignInt32(&res, 0); int32(libc.AssignInt8(&cA, *(*int8)(unsafe.Pointer(zA + uintptr(xA))))) != 0; xA++ {
			res = res + insertOrDeleteCost(tls, cAprev, cA, *(*int8)(unsafe.Pointer(zA + uintptr(xA+1))))
			cAprev = cA
		}
		return res
	}

	// A is a prefix of B
	if int32(*(*int8)(unsafe.Pointer(zA))) == '*' && int32(*(*int8)(unsafe.Pointer(zA + 1))) == 0 {
		return 0
	}

	// Allocate and initialize the Wagner matrix
	if uint64(nB) < uint64(unsafe.Sizeof([75]int32{}))*uint64(4)/(uint64(unsafe.Sizeof(int32(0)))*uint64(5)) {
		m = bp /* &mStack[0] */
	} else {
		m = libc.AssignUintptr(&toFree, sqlite3.Xsqlite3_malloc64(tls, uint64(uint64((nB+1)*5)*uint64(unsafe.Sizeof(int32(0)))/uint64(4))))
		if m == uintptr(0) {
			return -3
		}
	}
	cx = m + uintptr(nB+1)*4

	// Compute the Wagner edit distance
	*(*int32)(unsafe.Pointer(m)) = 0
	*(*int8)(unsafe.Pointer(cx)) = int8(dc)
	cBprev = int8(dc)
	for xB = 1; xB <= nB; xB++ {
		cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))
		cB = *(*int8)(unsafe.Pointer(zB + uintptr(xB-1)))
		*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = cB
		*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = *(*int32)(unsafe.Pointer(m + uintptr(xB-1)*4)) + insertOrDeleteCost(tls, cBprev, cB, cBnext)
		cBprev = cB
	}
	cAprev = int8(dc)
	for xA = 1; xA <= nA; xA++ {
		var lastA int32 = libc.Bool32(xA == nA)
		cA = *(*int8)(unsafe.Pointer(zA + uintptr(xA-1)))
		cAnext = *(*int8)(unsafe.Pointer(zA + uintptr(xA)))
		if int32(cA) == '*' && lastA != 0 {
			break
		}
		d = *(*int32)(unsafe.Pointer(m))
		dc = int32(*(*int8)(unsafe.Pointer(cx)))
		*(*int32)(unsafe.Pointer(m)) = d + insertOrDeleteCost(tls, cAprev, cA, cAnext)
		cBprev = int8(0)
		for xB = 1; xB <= nB; xB++ {
			var totalCost int32
			var insCost int32
			var delCost int32
			var subCost int32
			var ncx int32
			cB = *(*int8)(unsafe.Pointer(zB + uintptr(xB-1)))
			cBnext = *(*int8)(unsafe.Pointer(zB + uintptr(xB)))

			// Cost to insert cB
			insCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB-1))), cB, cBnext)
			if lastA != 0 {
				insCost = insCost / FINAL_INS_COST_DIV
			}

			// Cost to delete cA
			delCost = insertOrDeleteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB))), cA, cBnext)

			// Cost to substitute cA->cB
			subCost = substituteCost(tls, *(*int8)(unsafe.Pointer(cx + uintptr(xB-1))), cA, cB)

			// Best cost
			totalCost = insCost + *(*int32)(unsafe.Pointer(m + uintptr(xB-1)*4))
			ncx = int32(cB)
			if delCost+*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) < totalCost {
				totalCost = delCost + *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
				ncx = int32(cA)
			}
			if subCost+d < totalCost {
				totalCost = subCost + d
			}

			// Update the matrix
			d = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
			dc = int32(*(*int8)(unsafe.Pointer(cx + uintptr(xB))))
			*(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) = totalCost
			*(*int8)(unsafe.Pointer(cx + uintptr(xB))) = int8(ncx)
			cBprev = cB
		}
		cAprev = cA
	}

	// Free the wagner matrix and return the result
	if int32(cA) == '*' {
		res = *(*int32)(unsafe.Pointer(m + 1*4))
		for xB = 1; xB <= nB; xB++ {
			if *(*int32)(unsafe.Pointer(m + uintptr(xB)*4)) < res {
				res = *(*int32)(unsafe.Pointer(m + uintptr(xB)*4))
				if pnMatch != 0 {
					*(*int32)(unsafe.Pointer(pnMatch)) = xB + nMatch
				}
			}
		}
	} else {
		res = *(*int32)(unsafe.Pointer(m + uintptr(nB)*4))
		// In the current implementation, pnMatch is always NULL if zA does
		// not end in "*"

	}
	sqlite3.Xsqlite3_free(tls, toFree)
	return res
}

// Function:    editdist(A,B)
//
// Return the cost of transforming string A into string B.  Both strings
// must be pure ASCII text.  If A ends with '*' then it is assumed to be
// a prefix of B and extra characters on the end of B have minimal additional
// cost.
func editdistSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:518:13: */
	var res int32 = editdist1(tls,
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))),
		uintptr(0))
	if res < 0 {
		if res == -3 {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else if res == -2 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+6695 /* "non-ASCII input ..." */, -1)
		} else {
			sqlite3.Xsqlite3_result_error(tls, context, ts+6725 /* "NULL input to ed..." */, -1)
		}
	} else {
		sqlite3.Xsqlite3_result_int(tls, context, res)
	}
}

// End of the fixed-cost edit distance implementation
//
//
// Begin: Configurable cost unicode edit distance routines
// Forward declaration of structures
type EditDist3Cost1 = struct {
	FpNext uintptr
	FnFrom u8
	FnTo   u8
	FiCost u16
	Fa     [4]int8
} /* spellfix.c:546:9 */

// End of the fixed-cost edit distance implementation
//
//
// Begin: Configurable cost unicode edit distance routines
// Forward declaration of structures
type EditDist3Cost = EditDist3Cost1 /* spellfix.c:546:30 */
type EditDist3Config1 = struct {
	FnLang       int32
	F__ccgo_pad1 [4]byte
	Fa           uintptr
} /* spellfix.c:547:9 */

type EditDist3Config = EditDist3Config1 /* spellfix.c:547:32 */
type EditDist3From1 = struct {
	FnSubst      int32
	FnDel        int32
	FnByte       int32
	F__ccgo_pad1 [4]byte
	FapSubst     uintptr
	FapDel       uintptr
} /* spellfix.c:549:9 */

type EditDist3From = EditDist3From1 /* spellfix.c:549:30 */
type EditDist3FromString1 = struct {
	Fz        uintptr
	Fn        int32
	FisPrefix int32
	Fa        uintptr
} /* spellfix.c:550:9 */

type EditDist3FromString = EditDist3FromString1 /* spellfix.c:550:36 */
type EditDist3To1 = struct {
	FnIns  int32
	FnByte int32
	FapIns uintptr
} /* spellfix.c:551:9 */

type EditDist3To = EditDist3To1 /* spellfix.c:551:28 */
type EditDist3ToString1 = struct {
	Fz           uintptr
	Fn           int32
	F__ccgo_pad1 [4]byte
	Fa           uintptr
} /* spellfix.c:552:9 */

type EditDist3ToString = EditDist3ToString1 /* spellfix.c:552:34 */
type EditDist3Lang1 = struct {
	FiLang    int32
	FiInsCost int32
	FiDelCost int32
	FiSubCost int32
	FpCost    uintptr
} /* spellfix.c:547:9 */

type EditDist3Lang = EditDist3Lang1 /* spellfix.c:553:30 */

// The default EditDist3Lang object, with default costs.
var editDist3Lang = EditDist3Lang{FiInsCost: 100, FiDelCost: 100, FiSubCost: 150} /* spellfix.c:583:28 */

// Clear or delete an instance of the object that records all edit-distance
// weights.
func editDist3ConfigClear(tls *libc.TLS, p uintptr) { /* spellfix.c:640:13: */
	var i int32
	if p == uintptr(0) {
		return
	}
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; i++ {
		var pCost uintptr
		var pNext uintptr
		pCost = (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(i)*24)).FpCost
		for pCost != 0 {
			pNext = (*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext
			sqlite3.Xsqlite3_free(tls, pCost)
			pCost = pNext
		}
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa)
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(EditDist3Config{})))
}

func editDist3ConfigDelete(tls *libc.TLS, pIn uintptr) { /* spellfix.c:655:13: */
	var p uintptr = pIn
	editDist3ConfigClear(tls, p)
	sqlite3.Xsqlite3_free(tls, p)
}

// Compare the FROM values of two EditDist3Cost objects, for sorting.
// Return negative, zero, or positive if the A is less than, equal to,
// or greater than B.
func editDist3CostCompare(tls *libc.TLS, pA uintptr, pB uintptr) int32 { /* spellfix.c:665:12: */
	var n int32 = int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom)
	var rc int32
	if n > int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom) {
		n = int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom)
	}
	rc = libc.Xstrncmp(tls, pA+12, pB+12, uint64(n))
	if rc == 0 {
		rc = int32((*EditDist3Cost)(unsafe.Pointer(pA)).FnFrom) - int32((*EditDist3Cost)(unsafe.Pointer(pB)).FnFrom)
	}
	return rc
}

// Merge together two sorted lists of EditDist3Cost objects, in order
// of increasing FROM.
func editDist3CostMerge(tls *libc.TLS, pA uintptr, pB uintptr) uintptr { /* spellfix.c:678:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(bp /* pHead */)) = uintptr(0)
	var ppTail uintptr = bp /* &pHead */
	var p uintptr
	for pA != 0 && pB != 0 {
		if editDist3CostCompare(tls, pA, pB) <= 0 {
			p = pA
			pA = (*EditDist3Cost)(unsafe.Pointer(pA)).FpNext
		} else {
			p = pB
			pB = (*EditDist3Cost)(unsafe.Pointer(pB)).FpNext
		}
		*(*uintptr)(unsafe.Pointer(ppTail)) = p
		ppTail = p
	}
	if pA != 0 {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pA
	} else {
		*(*uintptr)(unsafe.Pointer(ppTail)) = pB
	}
	return *(*uintptr)(unsafe.Pointer(bp /* pHead */))
}

// Sort a list of EditDist3Cost objects into order of increasing FROM
func editDist3CostSort(tls *libc.TLS, pList uintptr) uintptr { /* spellfix.c:707:22: */
	bp := tls.Alloc(480)
	defer tls.Free(480)

	// var ap [60]uintptr at bp, 480

	var p uintptr
	var i int32
	var mx int32 = 0
	*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + 1*8)) = uintptr(0)
	for pList != 0 {
		p = pList
		pList = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
		(*EditDist3Cost)(unsafe.Pointer(p)).FpNext = uintptr(0)
		for i = 0; *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)) != 0; i++ {
			p = editDist3CostMerge(tls, *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)), p)
			*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)) = uintptr(0)
		}
		*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)) = p
		if i > mx {
			mx = i
			*(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i+1)*8)) = uintptr(0)
		}
	}
	p = uintptr(0)
	for i = 0; i <= mx; i++ {
		if *(*uintptr)(unsafe.Pointer(bp + uintptr(i)*8)) != 0 {
			p = editDist3CostMerge(tls, p, *(*uintptr)(unsafe.Pointer(bp /* &ap[0] */ + uintptr(i)*8)))
		}
	}
	return p
}

// Load all edit-distance weights from a table.
func editDist3ConfigLoad(tls *libc.TLS, p uintptr, db uintptr, zTable uintptr) int32 { /* spellfix.c:737:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pStmt uintptr at bp+8, 8

	var rc int32
	var rc2 int32
	var zSql uintptr
	var iLangPrev int32 = -9999
	var pLang uintptr = uintptr(0)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+6750 /* "SELECT iLang, cF..." */, libc.VaList(bp, zTable))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+8 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc != 0 {
		return rc
	}
	editDist3ConfigClear(tls, p)
	for sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8))) == SQLITE_ROW {
		var iLang int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0)
		var zFrom uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
		var nFrom int32
		if zFrom != 0 {
			nFrom = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 1)
		} else {
			nFrom = 0
		}
		var zTo uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 2)
		var nTo int32
		if zTo != 0 {
			nTo = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 2)
		} else {
			nTo = 0
		}
		var iCost int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 3)

		if nFrom > 100 || nTo > 100 {
			continue
		}
		if iCost < 0 {
			continue
		}
		if iCost >= 10000 {
			continue
		} // Costs above 10K are considered infinite
		if pLang == uintptr(0) || iLang != iLangPrev {
			var pNew uintptr
			pNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3Config)(unsafe.Pointer(p)).Fa, uint64(uint64((*EditDist3Config)(unsafe.Pointer(p)).FnLang+1)*uint64(unsafe.Sizeof(EditDist3Lang{}))))
			if pNew == uintptr(0) {
				rc = SQLITE_NOMEM
				break
			}
			(*EditDist3Config)(unsafe.Pointer(p)).Fa = pNew
			pLang = (*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr((*EditDist3Config)(unsafe.Pointer(p)).FnLang)*24
			(*EditDist3Config)(unsafe.Pointer(p)).FnLang++
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiLang = iLang
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = 100
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = 150
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = uintptr(0)
			iLangPrev = iLang
		}
		if nFrom == 1 && int32(*(*int8)(unsafe.Pointer(zFrom))) == '?' && nTo == 0 {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost = iCost
		} else if nFrom == 0 && nTo == 1 && int32(*(*int8)(unsafe.Pointer(zTo))) == '?' {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost = iCost
		} else if nFrom == 1 && nTo == 1 && int32(*(*int8)(unsafe.Pointer(zFrom))) == '?' && int32(*(*int8)(unsafe.Pointer(zTo))) == '?' {
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost = iCost
		} else {
			var pCost uintptr
			var nExtra int32 = nFrom + nTo - 4
			if nExtra < 0 {
				nExtra = 0
			}
			pCost = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(EditDist3Cost{}))+uint64(nExtra)))
			if pCost == uintptr(0) {
				rc = SQLITE_NOMEM
				break
			}
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnFrom = u8(nFrom)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FnTo = u8(nTo)
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FiCost = u16(iCost)
			libc.Xmemcpy(tls, pCost+12, zFrom, uint64(nFrom))
			libc.Xmemcpy(tls, pCost+12+uintptr(nFrom), zTo, uint64(nTo))
			(*EditDist3Cost)(unsafe.Pointer(pCost)).FpNext = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
			(*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost = pCost
		}
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
	if rc == SQLITE_OK {
		rc = rc2
	}
	if rc == SQLITE_OK {
		var iLang int32
		for iLang = 0; iLang < (*EditDist3Config)(unsafe.Pointer(p)).FnLang; iLang++ {
			(*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa + uintptr(iLang)*24)).FpCost = editDist3CostSort(tls, (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(p)).Fa+uintptr(iLang)*24)).FpCost)
		}
	}
	return rc
}

// Return the length (in bytes) of a utf-8 character.  Or return a maximum
// of N.
func utf8Len(tls *libc.TLS, c uint8, N int32) int32 { /* spellfix.c:818:12: */
	var len int32 = 1
	if int32(c) > 0x7f {
		if int32(c)&0xe0 == 0xc0 {
			len = 2
		} else if int32(c)&0xf0 == 0xe0 {
			len = 3
		} else {
			len = 4
		}
	}
	if len > N {
		len = N
	}
	return len
}

// Return TRUE (non-zero) if the To side of the given cost matches
// the given string.
func matchTo(tls *libc.TLS, p uintptr, z uintptr, n int32) int32 { /* spellfix.c:837:12: */

	if int32(*(*int8)(unsafe.Pointer(p + 12 + uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)))) != int32(*(*int8)(unsafe.Pointer(z))) {
		return 0
	}
	if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) > n {
		return 0
	}
	if libc.Xstrncmp(tls, p+12+uintptr((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom), z, uint64((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)) != 0 {
		return 0
	}
	return 1
}

// Return TRUE (non-zero) if the From side of the given cost matches
// the given string.
func matchFrom(tls *libc.TLS, p uintptr, z uintptr, n int32) int32 { /* spellfix.c:849:12: */

	if (*EditDist3Cost)(unsafe.Pointer(p)).FnFrom != 0 {
		if int32(*(*int8)(unsafe.Pointer(p + 12))) != int32(*(*int8)(unsafe.Pointer(z))) {
			return 0
		}
		if libc.Xstrncmp(tls, p+12, z, uint64((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)) != 0 {
			return 0
		}
	}
	return 1
}

// Return TRUE (non-zero) of the next FROM character and the next TO
// character are the same.
func matchFromTo(tls *libc.TLS, pStr uintptr, n1 int32, z2 uintptr, n2 int32) int32 { /* spellfix.c:862:12: */
	var b1 int32 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n1)*32)).FnByte
	if b1 > n2 {
		return 0
	}

	if int32(*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n1)))) != int32(*(*int8)(unsafe.Pointer(z2))) {
		return 0
	}
	if libc.Xstrncmp(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fz+uintptr(n1), z2, uint64(b1)) != 0 {
		return 0
	}
	return 1
}

// Delete an EditDist3FromString objecct
func editDist3FromStringDelete(tls *libc.TLS, p uintptr) { /* spellfix.c:879:13: */
	var i int32
	if p != 0 {
		for i = 0; i < (*EditDist3FromString)(unsafe.Pointer(p)).Fn; i++ {
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*32)).FapDel)
			sqlite3.Xsqlite3_free(tls, (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(p)).Fa+uintptr(i)*32)).FapSubst)
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Create a EditDist3FromString object.
func editDist3FromStringNew(tls *libc.TLS, pLang uintptr, z uintptr, n int32) uintptr { /* spellfix.c:893:28: */
	var pStr uintptr
	var p uintptr
	var i int32

	if z == uintptr(0) {
		return uintptr(0)
	}
	if n < 0 {
		n = int32(libc.Xstrlen(tls, z))
	}
	pStr = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(EditDist3FromString{}))+uint64(unsafe.Sizeof(EditDist3From{}))*uint64(n)+uint64(n)+uint64(1)))
	if pStr == uintptr(0) {
		return uintptr(0)
	}
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fa = pStr + 1*24
	libc.Xmemset(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa, 0, uint64(unsafe.Sizeof(EditDist3From{}))*uint64(n))
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn = n
	(*EditDist3FromString)(unsafe.Pointer(pStr)).Fz = (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(n)*32
	libc.Xmemcpy(tls, (*EditDist3FromString)(unsafe.Pointer(pStr)).Fz, z, uint64(n+1))
	if n != 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(n-1)))) == '*' {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 1
		n--
		(*EditDist3FromString)(unsafe.Pointer(pStr)).Fn--
		*(*int8)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(pStr)).Fz + uintptr(n))) = int8(0)
	} else {
		(*EditDist3FromString)(unsafe.Pointer(pStr)).FisPrefix = 0
	}

	for i = 0; i < n; i++ {
		var pFrom uintptr = (*EditDist3FromString)(unsafe.Pointer(pStr)).Fa + uintptr(i)*32
		libc.Xmemset(tls, pFrom, 0, uint64(unsafe.Sizeof(EditDist3From{})))
		(*EditDist3From)(unsafe.Pointer(pFrom)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z + uintptr(i)))), n-i)
		for p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost; p != 0; p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext {
			var apNew uintptr
			if i+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom) > n {
				continue
			}
			if matchFrom(tls, p, z+uintptr(i), n-i) == 0 {
				continue
			}
			if int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) == 0 {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapDel,
					uint64(uint64(unsafe.Sizeof(uintptr(0)))*uint64((*EditDist3From)(unsafe.Pointer(pFrom)).FnDel+1)))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapDel = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(libc.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnDel, 1))*8)) = p
			} else {
				apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst,
					uint64(uint64(unsafe.Sizeof(uintptr(0)))*uint64((*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst+1)))
				if apNew == uintptr(0) {
					break
				}
				(*EditDist3From)(unsafe.Pointer(pFrom)).FapSubst = apNew
				*(*uintptr)(unsafe.Pointer(apNew + uintptr(libc.PostIncInt32(&(*EditDist3From)(unsafe.Pointer(pFrom)).FnSubst, 1))*8)) = p
			}
		}
		if p != 0 {
			editDist3FromStringDelete(tls, pStr)
			pStr = uintptr(0)
			break
		}
	}
	return pStr
}

// Update entry m[i] such that it is the minimum of its current value
// and m[j]+iCost.
func updateCost(tls *libc.TLS, m uintptr, i int32, j int32, iCost int32) { /* spellfix.c:955:13: */
	var b uint32

	b = *(*uint32)(unsafe.Pointer(m + uintptr(j)*4)) + uint32(iCost)
	if b < *(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) {
		*(*uint32)(unsafe.Pointer(m + uintptr(i)*4)) = b
	}
}

// How much stack space (int bytes) to use for Wagner matrix in
// editDist3Core().  If more space than this is required, the entire
// matrix is taken from the heap.  To reduce the load on the memory
// allocator, make this value as large as practical for the
// architecture in use.

// Compute the edit distance between two strings.
//
// If an error occurs, return a negative number which is the error code.
//
// If pnMatch is not NULL, then *pnMatch is set to the number of characters
// (not bytes) in z2 that matched the search pattern in *pFrom. If pFrom does
// not contain the pattern for a prefix-search, then this is always the number
// of characters in z2. If pFrom does contain a prefix search pattern, then
// it is the number of characters in the prefix of z2 that was deemed to
// match pFrom.
func editDist3Core(tls *libc.TLS, pFrom uintptr, z2 uintptr, n2 int32, pLang uintptr, pnMatch uintptr) int32 { /* spellfix.c:990:12: */
	bp := tls.Alloc(1048)
	defer tls.Free(1048)

	var k int32
	var n int32
	var i1 int32
	var b1 int32
	var i2 int32
	var b2 int32
	// var f EditDist3FromString at bp+1024, 24

	var a2 uintptr
	var m uintptr
	var pToFree uintptr
	var szRow int32
	var p uintptr
	var res int32
	var nByte sqlite3_uint64
	// var stackSpace [256]uint32 at bp, 1024

	var apNew uintptr
	var cx int32  // Index of current cell
	var cxp int32 // Index of cell immediately to the left
	var cxd int32 // Index of cell to the left and one row above
	var cxu int32
	var rx int32 // Starting index for current row
	var rxp int32
	var b int32
	var nExtra int32
	*(*EditDist3FromString)(unsafe.Pointer(bp + 1024 /* f */)) = *(*EditDist3FromString)(unsafe.Pointer(pFrom))

	// allocate the Wagner matrix and the aTo[] array for the TO string
	n = ((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn + 1) * (n2 + 1)
	n = (n + 1) & libc.CplInt32(1)
	nByte = sqlite3_uint64(uint64(n)*uint64(unsafe.Sizeof(uint32(0))) + uint64(unsafe.Sizeof(EditDist3To{}))*uint64(n2))
	if !(nByte <= sqlite3_uint64(unsafe.Sizeof([256]uint32{}))) {
		goto __1
	}
	m = bp /* &stackSpace[0] */
	pToFree = uintptr(0)
	goto __2
__1:
	m = libc.AssignUintptr(&pToFree, sqlite3.Xsqlite3_malloc64(tls, nByte))
	if !(m == uintptr(0)) {
		goto __3
	}
	return -1
__3:
	; // Out of memory
__2:
	;
	a2 = m + uintptr(n)*4
	libc.Xmemset(tls, a2, 0, uint64(unsafe.Sizeof(EditDist3To{}))*uint64(n2))

	// Fill in the a1[] matrix for all characters of the TO string
	i2 = 0
__4:
	if !(i2 < n2) {
		goto __6
	}
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*16)).FnByte = utf8Len(tls, uint8(*(*int8)(unsafe.Pointer(z2 + uintptr(i2)))), n2-i2)
	p = (*EditDist3Lang)(unsafe.Pointer(pLang)).FpCost
__7:
	if !(p != 0) {
		goto __9
	}
	if !(int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom) > 0) {
		goto __10
	}
	goto __9
__10:
	;
	if !(i2+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo) > n2) {
		goto __11
	}
	goto __8
__11:
	;
	if !(int32(*(*int8)(unsafe.Pointer(p + 12))) > int32(*(*int8)(unsafe.Pointer(z2 + uintptr(i2))))) {
		goto __12
	}
	goto __9
__12:
	;
	if !(matchTo(tls, p, z2+uintptr(i2), n2-i2) == 0) {
		goto __13
	}
	goto __8
__13:
	;
	(*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns++
	apNew = sqlite3.Xsqlite3_realloc64(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns, uint64(uint64(unsafe.Sizeof(uintptr(0)))*uint64((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns)))
	if !(apNew == uintptr(0)) {
		goto __14
	}
	res = -1 // Out of memory
	goto editDist3Abort
__14:
	;
	(*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*16)).FapIns = apNew
	*(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns + uintptr((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns-1)*8)) = p
	goto __8
__8:
	p = (*EditDist3Cost)(unsafe.Pointer(p)).FpNext
	goto __7
	goto __9
__9:
	;
	goto __5
__5:
	i2++
	goto __4
	goto __6
__6:
	;

	// Prepare to compute the minimum edit distance
	szRow = (*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn + 1
	libc.Xmemset(tls, m, 0x01, uint64((n2+1)*szRow)*uint64(unsafe.Sizeof(uint32(0))))
	*(*uint32)(unsafe.Pointer(m)) = uint32(0)

	// First fill in the top-row of the matrix with FROM deletion costs
	i1 = 0
__15:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn) {
		goto __17
	}
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa + uintptr(i1)*32)).FnByte
	updateCost(tls, m, i1+b1, i1, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__18:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*32)).FnDel) {
		goto __20
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FapDel + uintptr(k)*8))
	updateCost(tls, m, i1+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom), i1, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __19
__19:
	k++
	goto __18
	goto __20
__20:
	;
	goto __16
__16:
	i1 = i1 + b1
	goto __15
	goto __17
__17:
	;

	// Fill in all subsequent rows, top-to-bottom, left-to-right
	i2 = 0
__21:
	if !(i2 < n2) {
		goto __23
	} // Starting index for previous row
	b2 = (*EditDist3To)(unsafe.Pointer(a2 + uintptr(i2)*16)).FnByte
	rx = szRow * (i2 + b2)
	rxp = szRow * i2
	updateCost(tls, m, rx, rxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	k = 0
__24:
	if !(k < (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FnIns) {
		goto __26
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns + uintptr(k)*8))
	updateCost(tls, m, szRow*(i2+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo)), rxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __25
__25:
	k++
	goto __24
	goto __26
__26:
	;
	i1 = 0
__27:
	if !(i1 < (*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fn) {
		goto __29
	} // Index of cell immediately above
	b1 = (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa + uintptr(i1)*32)).FnByte
	cxp = rx + i1
	cx = cxp + b1
	cxd = rxp + i1
	cxu = cxd + b1
	updateCost(tls, m, cx, cxp, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiDelCost)
	k = 0
__30:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*32)).FnDel) {
		goto __32
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FapDel + uintptr(k)*8))
	updateCost(tls, m, cxp+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom), cxp, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
	goto __31
__31:
	k++
	goto __30
	goto __32
__32:
	;
	updateCost(tls, m, cx, cxu, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiInsCost)
	if !(matchFromTo(tls, bp+1024, i1, z2+uintptr(i2), n2-i2) != 0) {
		goto __33
	}
	updateCost(tls, m, cx, cxd, 0)
__33:
	;
	updateCost(tls, m, cx, cxd, (*EditDist3Lang)(unsafe.Pointer(pLang)).FiSubCost)
	k = 0
__34:
	if !(k < (*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024)).Fa+uintptr(i1)*32)).FnSubst) {
		goto __36
	}
	p = *(*uintptr)(unsafe.Pointer((*EditDist3From)(unsafe.Pointer((*EditDist3FromString)(unsafe.Pointer(bp+1024 /* &f */)).Fa+uintptr(i1)*32)).FapSubst + uintptr(k)*8))
	if !(matchTo(tls, p, z2+uintptr(i2), n2-i2) != 0) {
		goto __37
	}
	updateCost(tls, m, cxd+int32((*EditDist3Cost)(unsafe.Pointer(p)).FnFrom)+szRow*int32((*EditDist3Cost)(unsafe.Pointer(p)).FnTo), cxd, int32((*EditDist3Cost)(unsafe.Pointer(p)).FiCost))
__37:
	;
	goto __35
__35:
	k++
	goto __34
	goto __36
__36:
	;
	goto __28
__28:
	i1 = i1 + b1
	goto __27
	goto __29
__29:
	;
	goto __22
__22:
	i2 = i2 + b2
	goto __21
	goto __23
__23:
	;

	// Free memory allocations and return the result
	res = int32(*(*uint32)(unsafe.Pointer(m + uintptr(szRow*(n2+1)-1)*4)))
	n = n2
	if !((*EditDist3FromString)(unsafe.Pointer(bp+1024)).FisPrefix != 0) {
		goto __38
	}
	i2 = 1
__39:
	if !(i2 <= n2) {
		goto __41
	}
	b = int32(*(*uint32)(unsafe.Pointer(m + uintptr(szRow*i2-1)*4)))
	if !(b <= res) {
		goto __42
	}
	res = b
	n = i2 - 1
__42:
	;
	goto __40
__40:
	i2++
	goto __39
	goto __41
__41:
	;
__38:
	;
	if !(pnMatch != 0) {
		goto __43
	}
	nExtra = 0
	k = 0
__44:
	if !(k < n) {
		goto __46
	}
	if !(int32(*(*int8)(unsafe.Pointer(z2 + uintptr(k))))&0xc0 == 0x80) {
		goto __47
	}
	nExtra++
__47:
	;
	goto __45
__45:
	k++
	goto __44
	goto __46
__46:
	;
	*(*int32)(unsafe.Pointer(pnMatch)) = n - nExtra
__43:
	;

editDist3Abort:
	i2 = 0
__48:
	if !(i2 < n2) {
		goto __50
	}
	sqlite3.Xsqlite3_free(tls, (*EditDist3To)(unsafe.Pointer(a2+uintptr(i2)*16)).FapIns)
	goto __49
__49:
	i2++
	goto __48
	goto __50
__50:
	;
	sqlite3.Xsqlite3_free(tls, pToFree)
	return res
}

// Get an appropriate EditDist3Lang object.
func editDist3FindLang(tls *libc.TLS, pConfig uintptr, iLang int32) uintptr { /* spellfix.c:1150:28: */
	var i int32
	for i = 0; i < (*EditDist3Config)(unsafe.Pointer(pConfig)).FnLang; i++ {
		if (*EditDist3Lang)(unsafe.Pointer((*EditDist3Config)(unsafe.Pointer(pConfig)).Fa+uintptr(i)*24)).FiLang == iLang {
			return (*EditDist3Config)(unsafe.Pointer(pConfig)).Fa + uintptr(i)*24
		}
	}
	return uintptr(unsafe.Pointer(&editDist3Lang))
}

// Function:    editdist3(A,B,iLang)
//              editdist3(tablename)
//
// Return the cost of transforming string A into string B using edit
// weights for iLang.
//
// The second form loads edit weights into memory from a table.
func editDist3SqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1170:13: */
	var pConfig uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var rc int32
	if argc == 1 {
		var zTable uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		rc = editDist3ConfigLoad(tls, pConfig, db, zTable)
		if rc != 0 {
			sqlite3.Xsqlite3_result_error_code(tls, context, rc)
		}
	} else {
		var zA uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var zB uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		var nA int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var nB int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		var iLang int32
		if argc == 3 {
			iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		} else {
			iLang = 0
		}
		var pLang uintptr = editDist3FindLang(tls, pConfig, iLang)
		var pFrom uintptr
		var dist int32

		pFrom = editDist3FromStringNew(tls, pLang, zA, nA)
		if pFrom == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
			return
		}
		dist = editDist3Core(tls, pFrom, zB, nB, pLang, uintptr(0))
		editDist3FromStringDelete(tls, pFrom)
		if dist == -1 {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, dist)
		}
	}
}

// Register the editDist3 function with SQLite
func editDist3Install(tls *libc.TLS, db uintptr) int32 { /* spellfix.c:1210:12: */
	var rc int32
	var pConfig uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if pConfig == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pConfig, 0, uint64(unsafe.Sizeof(EditDist3Config{})))
	rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6822, /* "editdist3" */
		2, SQLITE_UTF8|SQLITE_DETERMINISTIC, pConfig,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6822, /* "editdist3" */
			3, SQLITE_UTF8|SQLITE_DETERMINISTIC, pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function_v2(tls, db, ts+6822, /* "editdist3" */
			1, SQLITE_UTF8|SQLITE_DETERMINISTIC, pConfig,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editDist3SqlFunc})), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{editDist3ConfigDelete})))
	} else {
		sqlite3.Xsqlite3_free(tls, pConfig)
	}
	return rc
}

// End configurable cost unicode edit distance routines
//
//
// Begin transliterate unicode-to-ascii implementation

// This lookup table is used to help decode the first byte of
// a multi-byte UTF8 character.
var sqlite3Utf8Trans1 = [64]uint8{
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x10), uint8(0x11), uint8(0x12), uint8(0x13), uint8(0x14), uint8(0x15), uint8(0x16), uint8(0x17),
	uint8(0x18), uint8(0x19), uint8(0x1a), uint8(0x1b), uint8(0x1c), uint8(0x1d), uint8(0x1e), uint8(0x1f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x08), uint8(0x09), uint8(0x0a), uint8(0x0b), uint8(0x0c), uint8(0x0d), uint8(0x0e), uint8(0x0f),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x04), uint8(0x05), uint8(0x06), uint8(0x07),
	uint8(0x00), uint8(0x01), uint8(0x02), uint8(0x03), uint8(0x00), uint8(0x01), uint8(0x00), uint8(0x00),
} /* spellfix.c:1243:28 */

// Return the value of the first UTF-8 character in the string.
func utf8Read(tls *libc.TLS, z uintptr, n int32, pSize uintptr) int32 { /* spellfix.c:1258:12: */
	var c int32
	var i int32

	// All callers to this routine (in the current implementation)
	// always have n>0.
	if 0 != 0 {
		c = libc.AssignInt32(&i, 0)
	} else {
		c = int32(*(*uint8)(unsafe.Pointer(z)))
		i = 1
		if c >= 0xc0 {
			c = int32(sqlite3Utf8Trans1[c-0xc0])
			for i < n && int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))&0xc0 == 0x80 {
				c = c<<6 + 0x3f&int32(*(*uint8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&i, 1)))))
			}
		}
	}
	*(*int32)(unsafe.Pointer(pSize)) = i
	return c
}

// Return the number of characters in the utf-8 string in the nIn byte
// buffer pointed to by zIn.
func utf8Charlen(tls *libc.TLS, zIn uintptr, nIn int32) int32 { /* spellfix.c:1283:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i int32
	var nChar int32 = 0
	for i = 0; i < nIn; nChar++ {
		// var sz int32 at bp, 4

		utf8Read(tls, zIn+uintptr(i), nIn-i, bp /* &sz */)
		i = i + *(*int32)(unsafe.Pointer(bp))
	}
	return nChar
}

type Transliteration1 = struct {
	FcFrom uint16
	FcTo0  uint8
	FcTo1  uint8
	FcTo2  uint8
	FcTo3  uint8
} /* spellfix.c:1294:9 */

type Transliteration = Transliteration1 /* spellfix.c:1294:32 */

// Table of translations from unicode characters into ASCII.
var translit = [389]Transliteration{
	{FcFrom: uint16(0x00A0), FcTo0: uint8(0x20)},                                                             //   to
	{FcFrom: uint16(0x00B5), FcTo0: uint8(0x75)},                                                             // µ to u
	{FcFrom: uint16(0x00C0), FcTo0: uint8(0x41)},                                                             // À to A
	{FcFrom: uint16(0x00C1), FcTo0: uint8(0x41)},                                                             // Á to A
	{FcFrom: uint16(0x00C2), FcTo0: uint8(0x41)},                                                             // Â to A
	{FcFrom: uint16(0x00C3), FcTo0: uint8(0x41)},                                                             // Ã to A
	{FcFrom: uint16(0x00C4), FcTo0: uint8(0x41), FcTo1: uint8(0x65)},                                         // Ä to Ae
	{FcFrom: uint16(0x00C5), FcTo0: uint8(0x41), FcTo1: uint8(0x61)},                                         // Å to Aa
	{FcFrom: uint16(0x00C6), FcTo0: uint8(0x41), FcTo1: uint8(0x45)},                                         // Æ to AE
	{FcFrom: uint16(0x00C7), FcTo0: uint8(0x43)},                                                             // Ç to C
	{FcFrom: uint16(0x00C8), FcTo0: uint8(0x45)},                                                             // È to E
	{FcFrom: uint16(0x00C9), FcTo0: uint8(0x45)},                                                             // É to E
	{FcFrom: uint16(0x00CA), FcTo0: uint8(0x45)},                                                             // Ê to E
	{FcFrom: uint16(0x00CB), FcTo0: uint8(0x45)},                                                             // Ë to E
	{FcFrom: uint16(0x00CC), FcTo0: uint8(0x49)},                                                             // Ì to I
	{FcFrom: uint16(0x00CD), FcTo0: uint8(0x49)},                                                             // Í to I
	{FcFrom: uint16(0x00CE), FcTo0: uint8(0x49)},                                                             // Î to I
	{FcFrom: uint16(0x00CF), FcTo0: uint8(0x49)},                                                             // Ï to I
	{FcFrom: uint16(0x00D0), FcTo0: uint8(0x44)},                                                             // Ð to D
	{FcFrom: uint16(0x00D1), FcTo0: uint8(0x4E)},                                                             // Ñ to N
	{FcFrom: uint16(0x00D2), FcTo0: uint8(0x4F)},                                                             // Ò to O
	{FcFrom: uint16(0x00D3), FcTo0: uint8(0x4F)},                                                             // Ó to O
	{FcFrom: uint16(0x00D4), FcTo0: uint8(0x4F)},                                                             // Ô to O
	{FcFrom: uint16(0x00D5), FcTo0: uint8(0x4F)},                                                             // Õ to O
	{FcFrom: uint16(0x00D6), FcTo0: uint8(0x4F), FcTo1: uint8(0x65)},                                         // Ö to Oe
	{FcFrom: uint16(0x00D7), FcTo0: uint8(0x78)},                                                             // × to x
	{FcFrom: uint16(0x00D8), FcTo0: uint8(0x4F)},                                                             // Ø to O
	{FcFrom: uint16(0x00D9), FcTo0: uint8(0x55)},                                                             // Ù to U
	{FcFrom: uint16(0x00DA), FcTo0: uint8(0x55)},                                                             // Ú to U
	{FcFrom: uint16(0x00DB), FcTo0: uint8(0x55)},                                                             // Û to U
	{FcFrom: uint16(0x00DC), FcTo0: uint8(0x55), FcTo1: uint8(0x65)},                                         // Ü to Ue
	{FcFrom: uint16(0x00DD), FcTo0: uint8(0x59)},                                                             // Ý to Y
	{FcFrom: uint16(0x00DE), FcTo0: uint8(0x54), FcTo1: uint8(0x68)},                                         // Þ to Th
	{FcFrom: uint16(0x00DF), FcTo0: uint8(0x73), FcTo1: uint8(0x73)},                                         // ß to ss
	{FcFrom: uint16(0x00E0), FcTo0: uint8(0x61)},                                                             // à to a
	{FcFrom: uint16(0x00E1), FcTo0: uint8(0x61)},                                                             // á to a
	{FcFrom: uint16(0x00E2), FcTo0: uint8(0x61)},                                                             // â to a
	{FcFrom: uint16(0x00E3), FcTo0: uint8(0x61)},                                                             // ã to a
	{FcFrom: uint16(0x00E4), FcTo0: uint8(0x61), FcTo1: uint8(0x65)},                                         // ä to ae
	{FcFrom: uint16(0x00E5), FcTo0: uint8(0x61), FcTo1: uint8(0x61)},                                         // å to aa
	{FcFrom: uint16(0x00E6), FcTo0: uint8(0x61), FcTo1: uint8(0x65)},                                         // æ to ae
	{FcFrom: uint16(0x00E7), FcTo0: uint8(0x63)},                                                             // ç to c
	{FcFrom: uint16(0x00E8), FcTo0: uint8(0x65)},                                                             // è to e
	{FcFrom: uint16(0x00E9), FcTo0: uint8(0x65)},                                                             // é to e
	{FcFrom: uint16(0x00EA), FcTo0: uint8(0x65)},                                                             // ê to e
	{FcFrom: uint16(0x00EB), FcTo0: uint8(0x65)},                                                             // ë to e
	{FcFrom: uint16(0x00EC), FcTo0: uint8(0x69)},                                                             // ì to i
	{FcFrom: uint16(0x00ED), FcTo0: uint8(0x69)},                                                             // í to i
	{FcFrom: uint16(0x00EE), FcTo0: uint8(0x69)},                                                             // î to i
	{FcFrom: uint16(0x00EF), FcTo0: uint8(0x69)},                                                             // ï to i
	{FcFrom: uint16(0x00F0), FcTo0: uint8(0x64)},                                                             // ð to d
	{FcFrom: uint16(0x00F1), FcTo0: uint8(0x6E)},                                                             // ñ to n
	{FcFrom: uint16(0x00F2), FcTo0: uint8(0x6F)},                                                             // ò to o
	{FcFrom: uint16(0x00F3), FcTo0: uint8(0x6F)},                                                             // ó to o
	{FcFrom: uint16(0x00F4), FcTo0: uint8(0x6F)},                                                             // ô to o
	{FcFrom: uint16(0x00F5), FcTo0: uint8(0x6F)},                                                             // õ to o
	{FcFrom: uint16(0x00F6), FcTo0: uint8(0x6F), FcTo1: uint8(0x65)},                                         // ö to oe
	{FcFrom: uint16(0x00F7), FcTo0: uint8(0x3A)},                                                             // ÷ to :
	{FcFrom: uint16(0x00F8), FcTo0: uint8(0x6F)},                                                             // ø to o
	{FcFrom: uint16(0x00F9), FcTo0: uint8(0x75)},                                                             // ù to u
	{FcFrom: uint16(0x00FA), FcTo0: uint8(0x75)},                                                             // ú to u
	{FcFrom: uint16(0x00FB), FcTo0: uint8(0x75)},                                                             // û to u
	{FcFrom: uint16(0x00FC), FcTo0: uint8(0x75), FcTo1: uint8(0x65)},                                         // ü to ue
	{FcFrom: uint16(0x00FD), FcTo0: uint8(0x79)},                                                             // ý to y
	{FcFrom: uint16(0x00FE), FcTo0: uint8(0x74), FcTo1: uint8(0x68)},                                         // þ to th
	{FcFrom: uint16(0x00FF), FcTo0: uint8(0x79)},                                                             // ÿ to y
	{FcFrom: uint16(0x0100), FcTo0: uint8(0x41)},                                                             // Ā to A
	{FcFrom: uint16(0x0101), FcTo0: uint8(0x61)},                                                             // ā to a
	{FcFrom: uint16(0x0102), FcTo0: uint8(0x41)},                                                             // Ă to A
	{FcFrom: uint16(0x0103), FcTo0: uint8(0x61)},                                                             // ă to a
	{FcFrom: uint16(0x0104), FcTo0: uint8(0x41)},                                                             // Ą to A
	{FcFrom: uint16(0x0105), FcTo0: uint8(0x61)},                                                             // ą to a
	{FcFrom: uint16(0x0106), FcTo0: uint8(0x43)},                                                             // Ć to C
	{FcFrom: uint16(0x0107), FcTo0: uint8(0x63)},                                                             // ć to c
	{FcFrom: uint16(0x0108), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},                                         // Ĉ to Ch
	{FcFrom: uint16(0x0109), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},                                         // ĉ to ch
	{FcFrom: uint16(0x010A), FcTo0: uint8(0x43)},                                                             // Ċ to C
	{FcFrom: uint16(0x010B), FcTo0: uint8(0x63)},                                                             // ċ to c
	{FcFrom: uint16(0x010C), FcTo0: uint8(0x43)},                                                             // Č to C
	{FcFrom: uint16(0x010D), FcTo0: uint8(0x63)},                                                             // č to c
	{FcFrom: uint16(0x010E), FcTo0: uint8(0x44)},                                                             // Ď to D
	{FcFrom: uint16(0x010F), FcTo0: uint8(0x64)},                                                             // ď to d
	{FcFrom: uint16(0x0110), FcTo0: uint8(0x44)},                                                             // Đ to D
	{FcFrom: uint16(0x0111), FcTo0: uint8(0x64)},                                                             // đ to d
	{FcFrom: uint16(0x0112), FcTo0: uint8(0x45)},                                                             // Ē to E
	{FcFrom: uint16(0x0113), FcTo0: uint8(0x65)},                                                             // ē to e
	{FcFrom: uint16(0x0114), FcTo0: uint8(0x45)},                                                             // Ĕ to E
	{FcFrom: uint16(0x0115), FcTo0: uint8(0x65)},                                                             // ĕ to e
	{FcFrom: uint16(0x0116), FcTo0: uint8(0x45)},                                                             // Ė to E
	{FcFrom: uint16(0x0117), FcTo0: uint8(0x65)},                                                             // ė to e
	{FcFrom: uint16(0x0118), FcTo0: uint8(0x45)},                                                             // Ę to E
	{FcFrom: uint16(0x0119), FcTo0: uint8(0x65)},                                                             // ę to e
	{FcFrom: uint16(0x011A), FcTo0: uint8(0x45)},                                                             // Ě to E
	{FcFrom: uint16(0x011B), FcTo0: uint8(0x65)},                                                             // ě to e
	{FcFrom: uint16(0x011C), FcTo0: uint8(0x47), FcTo1: uint8(0x68)},                                         // Ĝ to Gh
	{FcFrom: uint16(0x011D), FcTo0: uint8(0x67), FcTo1: uint8(0x68)},                                         // ĝ to gh
	{FcFrom: uint16(0x011E), FcTo0: uint8(0x47)},                                                             // Ğ to G
	{FcFrom: uint16(0x011F), FcTo0: uint8(0x67)},                                                             // ğ to g
	{FcFrom: uint16(0x0120), FcTo0: uint8(0x47)},                                                             // Ġ to G
	{FcFrom: uint16(0x0121), FcTo0: uint8(0x67)},                                                             // ġ to g
	{FcFrom: uint16(0x0122), FcTo0: uint8(0x47)},                                                             // Ģ to G
	{FcFrom: uint16(0x0123), FcTo0: uint8(0x67)},                                                             // ģ to g
	{FcFrom: uint16(0x0124), FcTo0: uint8(0x48), FcTo1: uint8(0x68)},                                         // Ĥ to Hh
	{FcFrom: uint16(0x0125), FcTo0: uint8(0x68), FcTo1: uint8(0x68)},                                         // ĥ to hh
	{FcFrom: uint16(0x0126), FcTo0: uint8(0x48)},                                                             // Ħ to H
	{FcFrom: uint16(0x0127), FcTo0: uint8(0x68)},                                                             // ħ to h
	{FcFrom: uint16(0x0128), FcTo0: uint8(0x49)},                                                             // Ĩ to I
	{FcFrom: uint16(0x0129), FcTo0: uint8(0x69)},                                                             // ĩ to i
	{FcFrom: uint16(0x012A), FcTo0: uint8(0x49)},                                                             // Ī to I
	{FcFrom: uint16(0x012B), FcTo0: uint8(0x69)},                                                             // ī to i
	{FcFrom: uint16(0x012C), FcTo0: uint8(0x49)},                                                             // Ĭ to I
	{FcFrom: uint16(0x012D), FcTo0: uint8(0x69)},                                                             // ĭ to i
	{FcFrom: uint16(0x012E), FcTo0: uint8(0x49)},                                                             // Į to I
	{FcFrom: uint16(0x012F), FcTo0: uint8(0x69)},                                                             // į to i
	{FcFrom: uint16(0x0130), FcTo0: uint8(0x49)},                                                             // İ to I
	{FcFrom: uint16(0x0131), FcTo0: uint8(0x69)},                                                             // ı to i
	{FcFrom: uint16(0x0132), FcTo0: uint8(0x49), FcTo1: uint8(0x4A)},                                         // Ĳ to IJ
	{FcFrom: uint16(0x0133), FcTo0: uint8(0x69), FcTo1: uint8(0x6A)},                                         // ĳ to ij
	{FcFrom: uint16(0x0134), FcTo0: uint8(0x4A), FcTo1: uint8(0x68)},                                         // Ĵ to Jh
	{FcFrom: uint16(0x0135), FcTo0: uint8(0x6A), FcTo1: uint8(0x68)},                                         // ĵ to jh
	{FcFrom: uint16(0x0136), FcTo0: uint8(0x4B)},                                                             // Ķ to K
	{FcFrom: uint16(0x0137), FcTo0: uint8(0x6B)},                                                             // ķ to k
	{FcFrom: uint16(0x0138), FcTo0: uint8(0x6B)},                                                             // ĸ to k
	{FcFrom: uint16(0x0139), FcTo0: uint8(0x4C)},                                                             // Ĺ to L
	{FcFrom: uint16(0x013A), FcTo0: uint8(0x6C)},                                                             // ĺ to l
	{FcFrom: uint16(0x013B), FcTo0: uint8(0x4C)},                                                             // Ļ to L
	{FcFrom: uint16(0x013C), FcTo0: uint8(0x6C)},                                                             // ļ to l
	{FcFrom: uint16(0x013D), FcTo0: uint8(0x4C)},                                                             // Ľ to L
	{FcFrom: uint16(0x013E), FcTo0: uint8(0x6C)},                                                             // ľ to l
	{FcFrom: uint16(0x013F), FcTo0: uint8(0x4C), FcTo1: uint8(0x2E)},                                         // Ŀ to L.
	{FcFrom: uint16(0x0140), FcTo0: uint8(0x6C), FcTo1: uint8(0x2E)},                                         // ŀ to l.
	{FcFrom: uint16(0x0141), FcTo0: uint8(0x4C)},                                                             // Ł to L
	{FcFrom: uint16(0x0142), FcTo0: uint8(0x6C)},                                                             // ł to l
	{FcFrom: uint16(0x0143), FcTo0: uint8(0x4E)},                                                             // Ń to N
	{FcFrom: uint16(0x0144), FcTo0: uint8(0x6E)},                                                             // ń to n
	{FcFrom: uint16(0x0145), FcTo0: uint8(0x4E)},                                                             // Ņ to N
	{FcFrom: uint16(0x0146), FcTo0: uint8(0x6E)},                                                             // ņ to n
	{FcFrom: uint16(0x0147), FcTo0: uint8(0x4E)},                                                             // Ň to N
	{FcFrom: uint16(0x0148), FcTo0: uint8(0x6E)},                                                             // ň to n
	{FcFrom: uint16(0x0149), FcTo0: uint8(0x27), FcTo1: uint8(0x6E)},                                         // ŉ to 'n
	{FcFrom: uint16(0x014A), FcTo0: uint8(0x4E), FcTo1: uint8(0x47)},                                         // Ŋ to NG
	{FcFrom: uint16(0x014B), FcTo0: uint8(0x6E), FcTo1: uint8(0x67)},                                         // ŋ to ng
	{FcFrom: uint16(0x014C), FcTo0: uint8(0x4F)},                                                             // Ō to O
	{FcFrom: uint16(0x014D), FcTo0: uint8(0x6F)},                                                             // ō to o
	{FcFrom: uint16(0x014E), FcTo0: uint8(0x4F)},                                                             // Ŏ to O
	{FcFrom: uint16(0x014F), FcTo0: uint8(0x6F)},                                                             // ŏ to o
	{FcFrom: uint16(0x0150), FcTo0: uint8(0x4F)},                                                             // Ő to O
	{FcFrom: uint16(0x0151), FcTo0: uint8(0x6F)},                                                             // ő to o
	{FcFrom: uint16(0x0152), FcTo0: uint8(0x4F), FcTo1: uint8(0x45)},                                         // Œ to OE
	{FcFrom: uint16(0x0153), FcTo0: uint8(0x6F), FcTo1: uint8(0x65)},                                         // œ to oe
	{FcFrom: uint16(0x0154), FcTo0: uint8(0x52)},                                                             // Ŕ to R
	{FcFrom: uint16(0x0155), FcTo0: uint8(0x72)},                                                             // ŕ to r
	{FcFrom: uint16(0x0156), FcTo0: uint8(0x52)},                                                             // Ŗ to R
	{FcFrom: uint16(0x0157), FcTo0: uint8(0x72)},                                                             // ŗ to r
	{FcFrom: uint16(0x0158), FcTo0: uint8(0x52)},                                                             // Ř to R
	{FcFrom: uint16(0x0159), FcTo0: uint8(0x72)},                                                             // ř to r
	{FcFrom: uint16(0x015A), FcTo0: uint8(0x53)},                                                             // Ś to S
	{FcFrom: uint16(0x015B), FcTo0: uint8(0x73)},                                                             // ś to s
	{FcFrom: uint16(0x015C), FcTo0: uint8(0x53), FcTo1: uint8(0x68)},                                         // Ŝ to Sh
	{FcFrom: uint16(0x015D), FcTo0: uint8(0x73), FcTo1: uint8(0x68)},                                         // ŝ to sh
	{FcFrom: uint16(0x015E), FcTo0: uint8(0x53)},                                                             // Ş to S
	{FcFrom: uint16(0x015F), FcTo0: uint8(0x73)},                                                             // ş to s
	{FcFrom: uint16(0x0160), FcTo0: uint8(0x53)},                                                             // Š to S
	{FcFrom: uint16(0x0161), FcTo0: uint8(0x73)},                                                             // š to s
	{FcFrom: uint16(0x0162), FcTo0: uint8(0x54)},                                                             // Ţ to T
	{FcFrom: uint16(0x0163), FcTo0: uint8(0x74)},                                                             // ţ to t
	{FcFrom: uint16(0x0164), FcTo0: uint8(0x54)},                                                             // Ť to T
	{FcFrom: uint16(0x0165), FcTo0: uint8(0x74)},                                                             // ť to t
	{FcFrom: uint16(0x0166), FcTo0: uint8(0x54)},                                                             // Ŧ to T
	{FcFrom: uint16(0x0167), FcTo0: uint8(0x74)},                                                             // ŧ to t
	{FcFrom: uint16(0x0168), FcTo0: uint8(0x55)},                                                             // Ũ to U
	{FcFrom: uint16(0x0169), FcTo0: uint8(0x75)},                                                             // ũ to u
	{FcFrom: uint16(0x016A), FcTo0: uint8(0x55)},                                                             // Ū to U
	{FcFrom: uint16(0x016B), FcTo0: uint8(0x75)},                                                             // ū to u
	{FcFrom: uint16(0x016C), FcTo0: uint8(0x55)},                                                             // Ŭ to U
	{FcFrom: uint16(0x016D), FcTo0: uint8(0x75)},                                                             // ŭ to u
	{FcFrom: uint16(0x016E), FcTo0: uint8(0x55)},                                                             // Ů to U
	{FcFrom: uint16(0x016F), FcTo0: uint8(0x75)},                                                             // ů to u
	{FcFrom: uint16(0x0170), FcTo0: uint8(0x55)},                                                             // Ű to U
	{FcFrom: uint16(0x0171), FcTo0: uint8(0x75)},                                                             // ű to u
	{FcFrom: uint16(0x0172), FcTo0: uint8(0x55)},                                                             // Ų to U
	{FcFrom: uint16(0x0173), FcTo0: uint8(0x75)},                                                             // ų to u
	{FcFrom: uint16(0x0174), FcTo0: uint8(0x57)},                                                             // Ŵ to W
	{FcFrom: uint16(0x0175), FcTo0: uint8(0x77)},                                                             // ŵ to w
	{FcFrom: uint16(0x0176), FcTo0: uint8(0x59)},                                                             // Ŷ to Y
	{FcFrom: uint16(0x0177), FcTo0: uint8(0x79)},                                                             // ŷ to y
	{FcFrom: uint16(0x0178), FcTo0: uint8(0x59)},                                                             // Ÿ to Y
	{FcFrom: uint16(0x0179), FcTo0: uint8(0x5A)},                                                             // Ź to Z
	{FcFrom: uint16(0x017A), FcTo0: uint8(0x7A)},                                                             // ź to z
	{FcFrom: uint16(0x017B), FcTo0: uint8(0x5A)},                                                             // Ż to Z
	{FcFrom: uint16(0x017C), FcTo0: uint8(0x7A)},                                                             // ż to z
	{FcFrom: uint16(0x017D), FcTo0: uint8(0x5A)},                                                             // Ž to Z
	{FcFrom: uint16(0x017E), FcTo0: uint8(0x7A)},                                                             // ž to z
	{FcFrom: uint16(0x017F), FcTo0: uint8(0x73)},                                                             // ſ to s
	{FcFrom: uint16(0x0192), FcTo0: uint8(0x66)},                                                             // ƒ to f
	{FcFrom: uint16(0x0218), FcTo0: uint8(0x53)},                                                             // Ș to S
	{FcFrom: uint16(0x0219), FcTo0: uint8(0x73)},                                                             // ș to s
	{FcFrom: uint16(0x021A), FcTo0: uint8(0x54)},                                                             // Ț to T
	{FcFrom: uint16(0x021B), FcTo0: uint8(0x74)},                                                             // ț to t
	{FcFrom: uint16(0x0386), FcTo0: uint8(0x41)},                                                             // Ά to A
	{FcFrom: uint16(0x0388), FcTo0: uint8(0x45)},                                                             // Έ to E
	{FcFrom: uint16(0x0389), FcTo0: uint8(0x49)},                                                             // Ή to I
	{FcFrom: uint16(0x038A), FcTo0: uint8(0x49)},                                                             // Ί to I
	{FcFrom: uint16(0x038C), FcTo0: uint8(0x4f)},                                                             // Ό to O
	{FcFrom: uint16(0x038E), FcTo0: uint8(0x59)},                                                             // Ύ to Y
	{FcFrom: uint16(0x038F), FcTo0: uint8(0x4f)},                                                             // Ώ to O
	{FcFrom: uint16(0x0390), FcTo0: uint8(0x69)},                                                             // ΐ to i
	{FcFrom: uint16(0x0391), FcTo0: uint8(0x41)},                                                             // Α to A
	{FcFrom: uint16(0x0392), FcTo0: uint8(0x42)},                                                             // Β to B
	{FcFrom: uint16(0x0393), FcTo0: uint8(0x47)},                                                             // Γ to G
	{FcFrom: uint16(0x0394), FcTo0: uint8(0x44)},                                                             // Δ to D
	{FcFrom: uint16(0x0395), FcTo0: uint8(0x45)},                                                             // Ε to E
	{FcFrom: uint16(0x0396), FcTo0: uint8(0x5a)},                                                             // Ζ to Z
	{FcFrom: uint16(0x0397), FcTo0: uint8(0x49)},                                                             // Η to I
	{FcFrom: uint16(0x0398), FcTo0: uint8(0x54), FcTo1: uint8(0x68)},                                         // Θ to Th
	{FcFrom: uint16(0x0399), FcTo0: uint8(0x49)},                                                             // Ι to I
	{FcFrom: uint16(0x039A), FcTo0: uint8(0x4b)},                                                             // Κ to K
	{FcFrom: uint16(0x039B), FcTo0: uint8(0x4c)},                                                             // Λ to L
	{FcFrom: uint16(0x039C), FcTo0: uint8(0x4d)},                                                             // Μ to M
	{FcFrom: uint16(0x039D), FcTo0: uint8(0x4e)},                                                             // Ν to N
	{FcFrom: uint16(0x039E), FcTo0: uint8(0x58)},                                                             // Ξ to X
	{FcFrom: uint16(0x039F), FcTo0: uint8(0x4f)},                                                             // Ο to O
	{FcFrom: uint16(0x03A0), FcTo0: uint8(0x50)},                                                             // Π to P
	{FcFrom: uint16(0x03A1), FcTo0: uint8(0x52)},                                                             // Ρ to R
	{FcFrom: uint16(0x03A3), FcTo0: uint8(0x53)},                                                             // Σ to S
	{FcFrom: uint16(0x03A4), FcTo0: uint8(0x54)},                                                             // Τ to T
	{FcFrom: uint16(0x03A5), FcTo0: uint8(0x59)},                                                             // Υ to Y
	{FcFrom: uint16(0x03A6), FcTo0: uint8(0x46)},                                                             // Φ to F
	{FcFrom: uint16(0x03A7), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},                                         // Χ to Ch
	{FcFrom: uint16(0x03A8), FcTo0: uint8(0x50), FcTo1: uint8(0x73)},                                         // Ψ to Ps
	{FcFrom: uint16(0x03A9), FcTo0: uint8(0x4f)},                                                             // Ω to O
	{FcFrom: uint16(0x03AA), FcTo0: uint8(0x49)},                                                             // Ϊ to I
	{FcFrom: uint16(0x03AB), FcTo0: uint8(0x59)},                                                             // Ϋ to Y
	{FcFrom: uint16(0x03AC), FcTo0: uint8(0x61)},                                                             // ά to a
	{FcFrom: uint16(0x03AD), FcTo0: uint8(0x65)},                                                             // έ to e
	{FcFrom: uint16(0x03AE), FcTo0: uint8(0x69)},                                                             // ή to i
	{FcFrom: uint16(0x03AF), FcTo0: uint8(0x69)},                                                             // ί to i
	{FcFrom: uint16(0x03B1), FcTo0: uint8(0x61)},                                                             // α to a
	{FcFrom: uint16(0x03B2), FcTo0: uint8(0x62)},                                                             // β to b
	{FcFrom: uint16(0x03B3), FcTo0: uint8(0x67)},                                                             // γ to g
	{FcFrom: uint16(0x03B4), FcTo0: uint8(0x64)},                                                             // δ to d
	{FcFrom: uint16(0x03B5), FcTo0: uint8(0x65)},                                                             // ε to e
	{FcFrom: uint16(0x03B6), FcTo0: uint8(0x7a)},                                                             // ζ to z
	{FcFrom: uint16(0x03B7), FcTo0: uint8(0x69)},                                                             // η to i
	{FcFrom: uint16(0x03B8), FcTo0: uint8(0x74), FcTo1: uint8(0x68)},                                         // θ to th
	{FcFrom: uint16(0x03B9), FcTo0: uint8(0x69)},                                                             // ι to i
	{FcFrom: uint16(0x03BA), FcTo0: uint8(0x6b)},                                                             // κ to k
	{FcFrom: uint16(0x03BB), FcTo0: uint8(0x6c)},                                                             // λ to l
	{FcFrom: uint16(0x03BC), FcTo0: uint8(0x6d)},                                                             // μ to m
	{FcFrom: uint16(0x03BD), FcTo0: uint8(0x6e)},                                                             // ν to n
	{FcFrom: uint16(0x03BE), FcTo0: uint8(0x78)},                                                             // ξ to x
	{FcFrom: uint16(0x03BF), FcTo0: uint8(0x6f)},                                                             // ο to o
	{FcFrom: uint16(0x03C0), FcTo0: uint8(0x70)},                                                             // π to p
	{FcFrom: uint16(0x03C1), FcTo0: uint8(0x72)},                                                             // ρ to r
	{FcFrom: uint16(0x03C3), FcTo0: uint8(0x73)},                                                             // σ to s
	{FcFrom: uint16(0x03C4), FcTo0: uint8(0x74)},                                                             // τ to t
	{FcFrom: uint16(0x03C5), FcTo0: uint8(0x79)},                                                             // υ to y
	{FcFrom: uint16(0x03C6), FcTo0: uint8(0x66)},                                                             // φ to f
	{FcFrom: uint16(0x03C7), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},                                         // χ to ch
	{FcFrom: uint16(0x03C8), FcTo0: uint8(0x70), FcTo1: uint8(0x73)},                                         // ψ to ps
	{FcFrom: uint16(0x03C9), FcTo0: uint8(0x6f)},                                                             // ω to o
	{FcFrom: uint16(0x03CA), FcTo0: uint8(0x69)},                                                             // ϊ to i
	{FcFrom: uint16(0x03CB), FcTo0: uint8(0x79)},                                                             // ϋ to y
	{FcFrom: uint16(0x03CC), FcTo0: uint8(0x6f)},                                                             // ό to o
	{FcFrom: uint16(0x03CD), FcTo0: uint8(0x79)},                                                             // ύ to y
	{FcFrom: uint16(0x03CE), FcTo0: uint8(0x69)},                                                             // ώ to i
	{FcFrom: uint16(0x0400), FcTo0: uint8(0x45)},                                                             // Ѐ to E
	{FcFrom: uint16(0x0401), FcTo0: uint8(0x45)},                                                             // Ё to E
	{FcFrom: uint16(0x0402), FcTo0: uint8(0x44)},                                                             // Ђ to D
	{FcFrom: uint16(0x0403), FcTo0: uint8(0x47)},                                                             // Ѓ to G
	{FcFrom: uint16(0x0404), FcTo0: uint8(0x45)},                                                             // Є to E
	{FcFrom: uint16(0x0405), FcTo0: uint8(0x5a)},                                                             // Ѕ to Z
	{FcFrom: uint16(0x0406), FcTo0: uint8(0x49)},                                                             // І to I
	{FcFrom: uint16(0x0407), FcTo0: uint8(0x49)},                                                             // Ї to I
	{FcFrom: uint16(0x0408), FcTo0: uint8(0x4a)},                                                             // Ј to J
	{FcFrom: uint16(0x0409), FcTo0: uint8(0x49)},                                                             // Љ to I
	{FcFrom: uint16(0x040A), FcTo0: uint8(0x4e)},                                                             // Њ to N
	{FcFrom: uint16(0x040B), FcTo0: uint8(0x44)},                                                             // Ћ to D
	{FcFrom: uint16(0x040C), FcTo0: uint8(0x4b)},                                                             // Ќ to K
	{FcFrom: uint16(0x040D), FcTo0: uint8(0x49)},                                                             // Ѝ to I
	{FcFrom: uint16(0x040E), FcTo0: uint8(0x55)},                                                             // Ў to U
	{FcFrom: uint16(0x040F), FcTo0: uint8(0x44)},                                                             // Џ to D
	{FcFrom: uint16(0x0410), FcTo0: uint8(0x41)},                                                             // А to A
	{FcFrom: uint16(0x0411), FcTo0: uint8(0x42)},                                                             // Б to B
	{FcFrom: uint16(0x0412), FcTo0: uint8(0x56)},                                                             // В to V
	{FcFrom: uint16(0x0413), FcTo0: uint8(0x47)},                                                             // Г to G
	{FcFrom: uint16(0x0414), FcTo0: uint8(0x44)},                                                             // Д to D
	{FcFrom: uint16(0x0415), FcTo0: uint8(0x45)},                                                             // Е to E
	{FcFrom: uint16(0x0416), FcTo0: uint8(0x5a), FcTo1: uint8(0x68)},                                         // Ж to Zh
	{FcFrom: uint16(0x0417), FcTo0: uint8(0x5a)},                                                             // З to Z
	{FcFrom: uint16(0x0418), FcTo0: uint8(0x49)},                                                             // И to I
	{FcFrom: uint16(0x0419), FcTo0: uint8(0x49)},                                                             // Й to I
	{FcFrom: uint16(0x041A), FcTo0: uint8(0x4b)},                                                             // К to K
	{FcFrom: uint16(0x041B), FcTo0: uint8(0x4c)},                                                             // Л to L
	{FcFrom: uint16(0x041C), FcTo0: uint8(0x4d)},                                                             // М to M
	{FcFrom: uint16(0x041D), FcTo0: uint8(0x4e)},                                                             // Н to N
	{FcFrom: uint16(0x041E), FcTo0: uint8(0x4f)},                                                             // О to O
	{FcFrom: uint16(0x041F), FcTo0: uint8(0x50)},                                                             // П to P
	{FcFrom: uint16(0x0420), FcTo0: uint8(0x52)},                                                             // Р to R
	{FcFrom: uint16(0x0421), FcTo0: uint8(0x53)},                                                             // С to S
	{FcFrom: uint16(0x0422), FcTo0: uint8(0x54)},                                                             // Т to T
	{FcFrom: uint16(0x0423), FcTo0: uint8(0x55)},                                                             // У to U
	{FcFrom: uint16(0x0424), FcTo0: uint8(0x46)},                                                             // Ф to F
	{FcFrom: uint16(0x0425), FcTo0: uint8(0x4b), FcTo1: uint8(0x68)},                                         // Х to Kh
	{FcFrom: uint16(0x0426), FcTo0: uint8(0x54), FcTo1: uint8(0x63)},                                         // Ц to Tc
	{FcFrom: uint16(0x0427), FcTo0: uint8(0x43), FcTo1: uint8(0x68)},                                         // Ч to Ch
	{FcFrom: uint16(0x0428), FcTo0: uint8(0x53), FcTo1: uint8(0x68)},                                         // Ш to Sh
	{FcFrom: uint16(0x0429), FcTo0: uint8(0x53), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)}, // Щ to Shch
	{FcFrom: uint16(0x042A), FcTo0: uint8(0x61)},                                                             //  to A
	{FcFrom: uint16(0x042B), FcTo0: uint8(0x59)},                                                             // Ы to Y
	{FcFrom: uint16(0x042C), FcTo0: uint8(0x59)},                                                             //  to Y
	{FcFrom: uint16(0x042D), FcTo0: uint8(0x45)},                                                             // Э to E
	{FcFrom: uint16(0x042E), FcTo0: uint8(0x49), FcTo1: uint8(0x75)},                                         // Ю to Iu
	{FcFrom: uint16(0x042F), FcTo0: uint8(0x49), FcTo1: uint8(0x61)},                                         // Я to Ia
	{FcFrom: uint16(0x0430), FcTo0: uint8(0x61)},                                                             // а to a
	{FcFrom: uint16(0x0431), FcTo0: uint8(0x62)},                                                             // б to b
	{FcFrom: uint16(0x0432), FcTo0: uint8(0x76)},                                                             // в to v
	{FcFrom: uint16(0x0433), FcTo0: uint8(0x67)},                                                             // г to g
	{FcFrom: uint16(0x0434), FcTo0: uint8(0x64)},                                                             // д to d
	{FcFrom: uint16(0x0435), FcTo0: uint8(0x65)},                                                             // е to e
	{FcFrom: uint16(0x0436), FcTo0: uint8(0x7a), FcTo1: uint8(0x68)},                                         // ж to zh
	{FcFrom: uint16(0x0437), FcTo0: uint8(0x7a)},                                                             // з to z
	{FcFrom: uint16(0x0438), FcTo0: uint8(0x69)},                                                             // и to i
	{FcFrom: uint16(0x0439), FcTo0: uint8(0x69)},                                                             // й to i
	{FcFrom: uint16(0x043A), FcTo0: uint8(0x6b)},                                                             // к to k
	{FcFrom: uint16(0x043B), FcTo0: uint8(0x6c)},                                                             // л to l
	{FcFrom: uint16(0x043C), FcTo0: uint8(0x6d)},                                                             // м to m
	{FcFrom: uint16(0x043D), FcTo0: uint8(0x6e)},                                                             // н to n
	{FcFrom: uint16(0x043E), FcTo0: uint8(0x6f)},                                                             // о to o
	{FcFrom: uint16(0x043F), FcTo0: uint8(0x70)},                                                             // п to p
	{FcFrom: uint16(0x0440), FcTo0: uint8(0x72)},                                                             // р to r
	{FcFrom: uint16(0x0441), FcTo0: uint8(0x73)},                                                             // с to s
	{FcFrom: uint16(0x0442), FcTo0: uint8(0x74)},                                                             // т to t
	{FcFrom: uint16(0x0443), FcTo0: uint8(0x75)},                                                             // у to u
	{FcFrom: uint16(0x0444), FcTo0: uint8(0x66)},                                                             // ф to f
	{FcFrom: uint16(0x0445), FcTo0: uint8(0x6b), FcTo1: uint8(0x68)},                                         // х to kh
	{FcFrom: uint16(0x0446), FcTo0: uint8(0x74), FcTo1: uint8(0x63)},                                         // ц to tc
	{FcFrom: uint16(0x0447), FcTo0: uint8(0x63), FcTo1: uint8(0x68)},                                         // ч to ch
	{FcFrom: uint16(0x0448), FcTo0: uint8(0x73), FcTo1: uint8(0x68)},                                         // ш to sh
	{FcFrom: uint16(0x0449), FcTo0: uint8(0x73), FcTo1: uint8(0x68), FcTo2: uint8(0x63), FcTo3: uint8(0x68)}, // щ to shch
	{FcFrom: uint16(0x044A), FcTo0: uint8(0x61)},                                                             //  to a
	{FcFrom: uint16(0x044B), FcTo0: uint8(0x79)},                                                             // ы to y
	{FcFrom: uint16(0x044C), FcTo0: uint8(0x79)},                                                             //  to y
	{FcFrom: uint16(0x044D), FcTo0: uint8(0x65)},                                                             // э to e
	{FcFrom: uint16(0x044E), FcTo0: uint8(0x69), FcTo1: uint8(0x75)},                                         // ю to iu
	{FcFrom: uint16(0x044F), FcTo0: uint8(0x69), FcTo1: uint8(0x61)},                                         // я to ia
	{FcFrom: uint16(0x0450), FcTo0: uint8(0x65)},                                                             // ѐ to e
	{FcFrom: uint16(0x0451), FcTo0: uint8(0x65)},                                                             // ё to e
	{FcFrom: uint16(0x0452), FcTo0: uint8(0x64)},                                                             // ђ to d
	{FcFrom: uint16(0x0453), FcTo0: uint8(0x67)},                                                             // ѓ to g
	{FcFrom: uint16(0x0454), FcTo0: uint8(0x65)},                                                             // є to e
	{FcFrom: uint16(0x0455), FcTo0: uint8(0x7a)},                                                             // ѕ to z
	{FcFrom: uint16(0x0456), FcTo0: uint8(0x69)},                                                             // і to i
	{FcFrom: uint16(0x0457), FcTo0: uint8(0x69)},                                                             // ї to i
	{FcFrom: uint16(0x0458), FcTo0: uint8(0x6a)},                                                             // ј to j
	{FcFrom: uint16(0x0459), FcTo0: uint8(0x69)},                                                             // љ to i
	{FcFrom: uint16(0x045A), FcTo0: uint8(0x6e)},                                                             // њ to n
	{FcFrom: uint16(0x045B), FcTo0: uint8(0x64)},                                                             // ћ to d
	{FcFrom: uint16(0x045C), FcTo0: uint8(0x6b)},                                                             // ќ to k
	{FcFrom: uint16(0x045D), FcTo0: uint8(0x69)},                                                             // ѝ to i
	{FcFrom: uint16(0x045E), FcTo0: uint8(0x75)},                                                             // ў to u
	{FcFrom: uint16(0x045F), FcTo0: uint8(0x64)},                                                             // џ to d
	{FcFrom: uint16(0x1E02), FcTo0: uint8(0x42)},                                                             // Ḃ to B
	{FcFrom: uint16(0x1E03), FcTo0: uint8(0x62)},                                                             // ḃ to b
	{FcFrom: uint16(0x1E0A), FcTo0: uint8(0x44)},                                                             // Ḋ to D
	{FcFrom: uint16(0x1E0B), FcTo0: uint8(0x64)},                                                             // ḋ to d
	{FcFrom: uint16(0x1E1E), FcTo0: uint8(0x46)},                                                             // Ḟ to F
	{FcFrom: uint16(0x1E1F), FcTo0: uint8(0x66)},                                                             // ḟ to f
	{FcFrom: uint16(0x1E40), FcTo0: uint8(0x4D)},                                                             // Ṁ to M
	{FcFrom: uint16(0x1E41), FcTo0: uint8(0x6D)},                                                             // ṁ to m
	{FcFrom: uint16(0x1E56), FcTo0: uint8(0x50)},                                                             // Ṗ to P
	{FcFrom: uint16(0x1E57), FcTo0: uint8(0x70)},                                                             // ṗ to p
	{FcFrom: uint16(0x1E60), FcTo0: uint8(0x53)},                                                             // Ṡ to S
	{FcFrom: uint16(0x1E61), FcTo0: uint8(0x73)},                                                             // ṡ to s
	{FcFrom: uint16(0x1E6A), FcTo0: uint8(0x54)},                                                             // Ṫ to T
	{FcFrom: uint16(0x1E6B), FcTo0: uint8(0x74)},                                                             // ṫ to t
	{FcFrom: uint16(0x1E80), FcTo0: uint8(0x57)},                                                             // Ẁ to W
	{FcFrom: uint16(0x1E81), FcTo0: uint8(0x77)},                                                             // ẁ to w
	{FcFrom: uint16(0x1E82), FcTo0: uint8(0x57)},                                                             // Ẃ to W
	{FcFrom: uint16(0x1E83), FcTo0: uint8(0x77)},                                                             // ẃ to w
	{FcFrom: uint16(0x1E84), FcTo0: uint8(0x57)},                                                             // Ẅ to W
	{FcFrom: uint16(0x1E85), FcTo0: uint8(0x77)},                                                             // ẅ to w
	{FcFrom: uint16(0x1EF2), FcTo0: uint8(0x59)},                                                             // Ỳ to Y
	{FcFrom: uint16(0x1EF3), FcTo0: uint8(0x79)},                                                             // ỳ to y
	{FcFrom: uint16(0xFB00), FcTo0: uint8(0x66), FcTo1: uint8(0x66)},                                         // ﬀ to ff
	{FcFrom: uint16(0xFB01), FcTo0: uint8(0x66), FcTo1: uint8(0x69)},                                         // ﬁ to fi
	{FcFrom: uint16(0xFB02), FcTo0: uint8(0x66), FcTo1: uint8(0x6C)},                                         // ﬂ to fl
	{FcFrom: uint16(0xFB05), FcTo0: uint8(0x73), FcTo1: uint8(0x74)},                                         // ﬅ to st
	{FcFrom: uint16(0xFB06), FcTo0: uint8(0x73), FcTo1: uint8(0x74)},                                         // ﬆ to st
} /* spellfix.c:1306:30 */

func spellfixFindTranslit(tls *libc.TLS, c int32, pxTop uintptr) uintptr { /* spellfix.c:1698:30: */
	*(*int32)(unsafe.Pointer(pxTop)) = int32(uint64(unsafe.Sizeof(translit))/uint64(unsafe.Sizeof(Transliteration{})) - uint64(1))
	return uintptr(unsafe.Pointer(&translit))
}

// Convert the input string from UTF-8 into pure ASCII by converting
// all non-ASCII characters to some combination of characters in the
// ASCII subset.
//
// The returned string might contain more characters than the input.
//
// Space to hold the returned string comes from sqlite3_malloc() and
// should be freed by the caller.
func transliterate(tls *libc.TLS, zIn uintptr, nIn int32) uintptr { /* spellfix.c:1713:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(nIn*4+1))
	var c int32
	// var sz int32 at bp, 4

	var nOut int32
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	nOut = 0
	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp /* &sz */)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp /* sz */)))
		nIn = nIn - *(*int32)(unsafe.Pointer(bp))
		if c <= 127 {
			*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = uint8(c)
		} else {
			// var xTop int32 at bp+4, 4

			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4 /* &xTop */)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4)) >= xBtm {
				x = (*(*int32)(unsafe.Pointer(bp + 4)) + xBtm) / 2
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo0
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo1
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo2
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = (*Transliteration)(unsafe.Pointer(tbl + uintptr(x)*6)).FcTo3
							}
						}
					}
					c = 0
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) = x - 1
				} else {
					xBtm = x + 1
				}
			}
			if c != 0 {
				*(*uint8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&nOut, 1)))) = uint8('?')
			}
		}
	}
	*(*uint8)(unsafe.Pointer(zOut + uintptr(nOut))) = uint8(0)
	return zOut
}

// Return the number of characters in the shortest prefix of the input
// string that transliterates to an ASCII string nTrans bytes or longer.
// Or, if the transliteration of the input string is less than nTrans
// bytes in size, return the number of characters in the input string.
func translen_to_charlen(tls *libc.TLS, zIn uintptr, nIn int32, nTrans int32) int32 { /* spellfix.c:1771:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var c int32
	// var sz int32 at bp, 4

	var nOut int32
	var nChar int32

	i = libc.AssignInt32(&nOut, 0)
	for nChar = 0; i < nIn && nOut < nTrans; nChar++ {
		c = utf8Read(tls, zIn+uintptr(i), nIn-i, bp /* &sz */)
		i = i + *(*int32)(unsafe.Pointer(bp))

		nOut++
		if c >= 128 {
			// var xTop int32 at bp+4, 4

			var xBtm int32
			var x int32
			var tbl uintptr = spellfixFindTranslit(tls, c, bp+4 /* &xTop */)
			xBtm = 0
			for *(*int32)(unsafe.Pointer(bp + 4)) >= xBtm {
				x = (*(*int32)(unsafe.Pointer(bp + 4)) + xBtm) / 2
				if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) == c {
					if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo1 != 0 {
						nOut++
						if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo2 != 0 {
							nOut++
							if (*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcTo3 != 0 {
								nOut++
							}
						}
					}
					break
				} else if int32((*Transliteration)(unsafe.Pointer(tbl+uintptr(x)*6)).FcFrom) > c {
					*(*int32)(unsafe.Pointer(bp + 4 /* xTop */)) = x - 1
				} else {
					xBtm = x + 1
				}
			}
		}
	}

	return nChar
}

//    spellfix1_translit(X)
//
// Convert a string that contains non-ASCII Roman characters into
// pure ASCII.
func transliterateSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1817:13: */
	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var zOut uintptr = transliterate(tls, zIn, nIn)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	} else {
		sqlite3.Xsqlite3_result_text(tls, context, zOut, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//    spellfix1_scriptcode(X)
//
// Try to determine the dominant script used by the word X and return
// its ISO 15924 numeric code.
//
// The current implementation only understands the following scripts:
//
//    215  (Latin)
//    220  (Cyrillic)
//    200  (Greek)
//
// This routine will return 998 if the input X contains characters from
// two or more of the above scripts or 999 if X contains no characters
// from any of the above scripts.
func scriptCodeSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* spellfix.c:1848:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zIn uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var nIn int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	var c int32
	// var sz int32 at bp, 4

	var scriptMask int32 = 0
	var res int32
	var seenDigit int32 = 0

	for nIn > 0 {
		c = utf8Read(tls, zIn, nIn, bp /* &sz */)
		zIn += uintptr(*(*int32)(unsafe.Pointer(bp /* sz */)))
		nIn = nIn - *(*int32)(unsafe.Pointer(bp))
		if c < 0x02af {
			if c >= 0x80 || int32(midClass[c&0x7f]) < CCLASS_DIGIT {
				scriptMask = scriptMask | SCRIPT_LATIN
			} else if c >= '0' && c <= '9' {
				seenDigit = 1
			}
		} else if c >= 0x0400 && c <= 0x04ff {
			scriptMask = scriptMask | SCRIPT_CYRILLIC
		} else if c >= 0x0386 && c <= 0x03ce {
			scriptMask = scriptMask | SCRIPT_GREEK
		} else if c >= 0x0590 && c <= 0x05ff {
			scriptMask = scriptMask | SCRIPT_HEBREW
		} else if c >= 0x0600 && c <= 0x06ff {
			scriptMask = scriptMask | SCRIPT_ARABIC
		}
	}
	if scriptMask == 0 && seenDigit != 0 {
		scriptMask = SCRIPT_LATIN
	}
	switch scriptMask {
	case 0:
		res = 999
		break
	case SCRIPT_LATIN:
		res = 215
		break
	case SCRIPT_CYRILLIC:
		res = 220
		break
	case SCRIPT_GREEK:
		res = 200
		break
	case SCRIPT_HEBREW:
		res = 125
		break
	case SCRIPT_ARABIC:
		res = 160
		break
	default:
		res = 998
		break
	}
	sqlite3.Xsqlite3_result_int(tls, context, res)
}

// End transliterate
//
//
// Begin spellfix1 virtual table.

// Maximum length of a phonehash used for querying the shadow table

// Maximum number of hash strings to examine per query

type spellfix1_vtab1 = struct {
	Fbase       sqlite3_vtab
	Fdb         uintptr
	FzDbName    uintptr
	FzTableName uintptr
	FzCostTable uintptr
	FpConfig3   uintptr
} /* spellfix.c:1910:9 */

// End transliterate
//
//
// Begin spellfix1 virtual table.

// Maximum length of a phonehash used for querying the shadow table

// Maximum number of hash strings to examine per query

type spellfix1_vtab = spellfix1_vtab1 /* spellfix.c:1910:31 */
type spellfix1_cursor1 = struct {
	Fbase      sqlite3_vtab_cursor
	FpVTab     uintptr
	FzPattern  uintptr
	FidxNum    int32
	FnRow      int32
	FnAlloc    int32
	FiRow      int32
	FiLang     int32
	FiTop      int32
	FiScope    int32
	FnSearch   int32
	FpFullScan uintptr
	Fa         uintptr
} /* spellfix.c:1911:9 */

type spellfix1_cursor = spellfix1_cursor1 /* spellfix.c:1911:33 */

// Fuzzy-search cursor object
type spellfix1_row = struct {
	FiRowid    sqlite3_int64
	FzWord     uintptr
	FiRank     int32
	FiDistance int32
	FiScore    int32
	FiMatchlen int32
	FzHash     [32]int8
} /* spellfix.c:1911:9 */

// Construct one or more SQL statements from the format string given
// and then evaluate those statements. The success code is written
// into *pRc.
//
// If *pRc is initially non-zero then this routine is a no-op.
func spellfix1DbExec(tls *libc.TLS, pRc uintptr, db uintptr, zFormat uintptr, va uintptr) { /* spellfix.c:1955:13: */
	var ap va_list
	_ = ap
	var zSql uintptr
	if *(*int32)(unsafe.Pointer(pRc)) != 0 {
		return
	}
	ap = va
	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFormat, ap)
	_ = ap
	if zSql == uintptr(0) {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	} else {
		*(*int32)(unsafe.Pointer(pRc)) = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
}

// xDisconnect/xDestroy method for the fuzzy-search module.
func spellfix1Uninit(tls *libc.TLS, isDestroy int32, pVTab uintptr) int32 { /* spellfix.c:1978:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr = pVTab
	*(*int32)(unsafe.Pointer(bp + 16 /* rc */)) = SQLITE_OK
	if isDestroy != 0 {
		var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
		spellfix1DbExec(tls, bp+16 /* &rc */, db, ts+6832, /* "DROP TABLE IF EX..." */
			libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
	}
	if *(*int32)(unsafe.Pointer(bp + 16)) == SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
		sqlite3.Xsqlite3_free(tls, p)
	}
	return *(*int32)(unsafe.Pointer(bp + 16 /* rc */))
}

func spellfix1Disconnect(tls *libc.TLS, pVTab uintptr) int32 { /* spellfix.c:1994:12: */
	return spellfix1Uninit(tls, 0, pVTab)
}

func spellfix1Destroy(tls *libc.TLS, pVTab uintptr) int32 { /* spellfix.c:1997:12: */
	return spellfix1Uninit(tls, 1, pVTab)
}

// Make a copy of a string.  Remove leading and trailing whitespace
// and dequote it.
func spellfix1Dequote(tls *libc.TLS, zIn uintptr) uintptr { /* spellfix.c:2005:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zOut uintptr
	var i int32
	var j int32
	var c int8
	for __sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zIn)))), uint64(X_CTYPE_S)) != 0 {
		zIn++
	}
	zOut = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zIn))
	if zOut == uintptr(0) {
		return uintptr(0)
	}
	i = int32(libc.Xstrlen(tls, zOut))
	*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = int8(0)
	c = *(*int8)(unsafe.Pointer(zOut))
	if int32(c) == '\'' || int32(c) == '"' {
		i = 1
		j = 0
		for ; 1 != 0; i++ {
			*(*int8)(unsafe.Pointer(zOut + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zOut + uintptr(i)))
			if int32(*(*int8)(unsafe.Pointer(zOut + uintptr(i)))) == int32(c) {
				if int32(*(*int8)(unsafe.Pointer(zOut + uintptr(i+1)))) == int32(c) {
					i++
				} else {
					*(*int8)(unsafe.Pointer(zOut + uintptr(j-1))) = int8(0)
					break
				}
			}
		}
	}
	return zOut
}

// xConnect/xCreate method for the spellfix1 module. Arguments are:
//
//   argv[0]   -> module name  ("spellfix1")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3].. -> optional arguments (i.e. "edit_cost_table" parameter)
func spellfix1Init(tls *libc.TLS, isCreate int32, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2043:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var pNew uintptr = uintptr(0)
	// const char *zModule = argv[0]; // not used
	var zDbName uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*8))
	var zTableName uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*8))
	var nDbName int32
	*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_OK
	var i int32

	nDbName = int32(libc.Xstrlen(tls, zDbName))
	pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(spellfix1_vtab{}))+uint64(nDbName)+uint64(1)))
	if pNew == uintptr(0) {
		*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_NOMEM
	} else {
		libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(spellfix1_vtab{})))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName = pNew + 1*64
		libc.Xmemcpy(tls, (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzDbName, zDbName, uint64(nDbName+1))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zTableName))
		(*spellfix1_vtab)(unsafe.Pointer(pNew)).Fdb = db
		if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzTableName == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_NOMEM
		} else {
			sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db,

				ts+6869 /* "CREATE TABLE x(w..." */)
		}
		if *(*int32)(unsafe.Pointer(bp + 56)) == SQLITE_OK && isCreate != 0 {
			spellfix1DbExec(tls, bp+56 /* &rc */, db,

				ts+7023, /* "CREATE TABLE IF ..." */
				libc.VaList(bp+8, zDbName, zTableName))
			spellfix1DbExec(tls, bp+56 /* &rc */, db,

				ts+7157, /* "CREATE INDEX IF ..." */
				libc.VaList(bp+24, zDbName, zTableName, zTableName))
		}
		for i = 3; *(*int32)(unsafe.Pointer(bp + 56 /* rc */)) == SQLITE_OK && i < argc; i++ {
			if libc.Xstrncmp(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), ts+7242, uint64(16)) == 0 && (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0) {
				(*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable = spellfix1Dequote(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))+16)
				if (*spellfix1_vtab)(unsafe.Pointer(pNew)).FzCostTable == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_NOMEM
				}
				continue
			}
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+7259 /* "bad argument to ..." */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
			*(*int32)(unsafe.Pointer(bp + 56 /* rc */)) = SQLITE_ERROR
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 56)) != 0 && pNew != 0 {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = uintptr(0)
		spellfix1Uninit(tls, 0, pNew)
	} else {
		*(*uintptr)(unsafe.Pointer(ppVTab)) = pNew
	}
	return *(*int32)(unsafe.Pointer(bp + 56 /* rc */))
}

// The xConnect and xCreate methods
func spellfix1Connect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2133:12: */
	return spellfix1Init(tls, 0, db, pAux, argc, argv, ppVTab, pzErr)
}

func spellfix1Create(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVTab uintptr, pzErr uintptr) int32 { /* spellfix.c:2142:12: */
	return spellfix1Init(tls, 1, db, pAux, argc, argv, ppVTab, pzErr)
}

// Clear all of the content from a cursor.
func spellfix1ResetCursor(tls *libc.TLS, pCur uintptr) { /* spellfix.c:2155:13: */
	var i int32
	for i = 0; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(i)*64)).FzWord)
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch = 0
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan = uintptr(0)
	}
}

// Resize the cursor to hold up to N rows of content
func spellfix1ResizeCursor(tls *libc.TLS, pCur uintptr, N int32) { /* spellfix.c:2172:13: */
	var aNew uintptr

	aNew = sqlite3.Xsqlite3_realloc64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, uint64(uint64(unsafe.Sizeof(spellfix1_row{}))*uint64(N)))
	if aNew == uintptr(0) && N > 0 {
		spellfix1ResetCursor(tls, pCur)
		sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa)
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = 0
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = uintptr(0)
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc = N
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa = aNew
	}
}

// Close a fuzzy-search cursor.
func spellfix1Close(tls *libc.TLS, cur uintptr) int32 { /* spellfix.c:2191:12: */
	var pCur uintptr = cur
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, 0)
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

//
// The plan number is a bitmask of the SPELLFIX_IDXNUM_* values defined
// above.
//
// filter.argv[*] values contains $str, $langid, $top, $scope and $rowid
// if specified and in that order.
func spellfix1BestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* spellfix.c:2217:12: */
	var iPlan int32 = 0
	var iLangTerm int32 = -1
	var iTopTerm int32 = -1
	var iScopeTerm int32 = -1
	var iDistTerm int32 = -1
	var iRowidTerm int32 = -1
	var i int32
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}

		// Terms of the form:  word MATCH $str
		if iPlan&SPELLFIX_IDXNUM_MATCH == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_WORD &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH {
			iPlan = iPlan | SPELLFIX_IDXNUM_MATCH
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).FargvIndex = 1
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(i)*8)).Fomit = uint8(1)
		}

		// Terms of the form:  langid = $langid
		if iPlan&SPELLFIX_IDXNUM_LANGID == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_LANGID &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_LANGID
			iLangTerm = i
		}

		// Terms of the form:  top = $top
		if iPlan&SPELLFIX_IDXNUM_TOP == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_TOP &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_TOP
			iTopTerm = i
		}

		// Terms of the form:  scope = $scope
		if iPlan&SPELLFIX_IDXNUM_SCOPE == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_SCOPE &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_SCOPE
			iScopeTerm = i
		}

		// Terms of the form:  distance < $dist or distance <= $dist
		if iPlan&(0x10|0x20) == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn == SPELLFIX_COL_DISTANCE &&
			(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT ||
				int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE) {
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
				iPlan = iPlan | SPELLFIX_IDXNUM_DISTLT
			} else {
				iPlan = iPlan | SPELLFIX_IDXNUM_DISTLE
			}
			iDistTerm = i
		}

		// Terms of the form:  distance < $dist or distance <= $dist
		if iPlan&SPELLFIX_IDXNUM_ROWID == 0 &&
			(*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn < 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			iPlan = iPlan | SPELLFIX_IDXNUM_ROWID
			iRowidTerm = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	if iPlan&SPELLFIX_IDXNUM_MATCH != 0 {
		var idx int32 = 2
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = iPlan
		if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
			(*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn == SPELLFIX_COL_SCORE &&
			int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1 // Default order by iScore
		}
		if iPlan&SPELLFIX_IDXNUM_LANGID != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLangTerm)*8)).Fomit = uint8(1)
		}
		if iPlan&SPELLFIX_IDXNUM_TOP != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iTopTerm)*8)).Fomit = uint8(1)
		}
		if iPlan&SPELLFIX_IDXNUM_SCOPE != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iScopeTerm)*8)).Fomit = uint8(1)
		}
		if iPlan&(0x10|0x20) != 0 {
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).FargvIndex = libc.PostIncInt32(&idx, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iDistTerm)*8)).Fomit = uint8(1)
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e5
	} else if iPlan&SPELLFIX_IDXNUM_ROWID != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = SPELLFIX_IDXNUM_ROWID
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iRowidTerm)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e50
	}
	return SQLITE_OK
}

// Open a new fuzzy-search cursor.
func spellfix1Open(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* spellfix.c:2331:12: */
	var p uintptr = pVTab
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(spellfix1_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(spellfix1_cursor{})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab = p
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Adjust a distance measurement by the words rank in order to show
// preference to common words.
func spellfix1Score(tls *libc.TLS, iDistance int32, iRank int32) int32 { /* spellfix.c:2346:12: */
	var iLog2 int32
	iLog2 = 0
__1:
	if !(iRank > 0) {
		goto __3
	}
	{
	}
	goto __2
__2:
	iLog2++
	iRank >>= 1
	goto __1
	goto __3
__3:
	;
	return iDistance + 32 - iLog2
}

// Compare two spellfix1_row objects for sorting purposes in qsort() such
// that they sort in order of increasing distance.
func spellfix1RowCompare(tls *libc.TLS, A uintptr, B uintptr) int32 { /* spellfix.c:2356:25: */
	var a uintptr = A
	var b uintptr = B
	return (*spellfix1_row)(unsafe.Pointer(a)).FiScore - (*spellfix1_row)(unsafe.Pointer(b)).FiScore
}

// A structure used to pass information from spellfix1FilterForMatch()
// into spellfix1RunQuery().
type MatchQuery1 = struct {
	FpCur        uintptr
	FpStmt       uintptr
	FzHash       [32]int8
	FzPattern    uintptr
	FnPattern    int32
	F__ccgo_pad1 [4]byte
	FpMatchStr3  uintptr
	FpConfig3    uintptr
	FpLang       uintptr
	FiLang       int32
	FiScope      int32
	FiMaxDist    int32
	Frc          int32
	FnRun        int32
	FazPrior     [1][32]int8
	F__ccgo_pad2 [4]byte
} /* spellfix.c:2366:9 */

// A structure used to pass information from spellfix1FilterForMatch()
// into spellfix1RunQuery().
type MatchQuery = MatchQuery1 /* spellfix.c:2381:3 */

// Run a query looking for the best matches against zPattern using
// zHash as the character class seed hash.
func spellfix1RunQuery(tls *libc.TLS, p uintptr, zQuery uintptr, nQuery int32) { /* spellfix.c:2387:13: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var zK1 uintptr
	var zWord uintptr
	var iDist int32
	var iRank int32
	var iScore int32
	var iWorst int32 = 0
	var idx int32
	var idxWorst int32 = -1
	var i int32
	var iScope int32 = (*MatchQuery)(unsafe.Pointer(p)).FiScope
	var pCur uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpCur
	var pStmt uintptr = (*MatchQuery)(unsafe.Pointer(p)).FpStmt
	// var zHash1 [32]int8 at bp+8, 32

	// var zHash2 [32]int8 at bp+40, 32

	var zClass uintptr
	var nClass int32
	var rc int32

	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0) || (*MatchQuery)(unsafe.Pointer(p)).Frc != 0 {
		return
	} // Prior memory allocation failure
	zClass = phoneticHash(tls, zQuery, nQuery)
	if zClass == uintptr(0) {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
		return
	}
	nClass = int32(libc.Xstrlen(tls, zClass))
	if nClass > SPELLFIX_MX_HASH-2 {
		nClass = SPELLFIX_MX_HASH - 2
		*(*int8)(unsafe.Pointer(zClass + uintptr(nClass))) = int8(0)
	}
	if nClass <= iScope {
		if nClass > 2 {
			iScope = nClass - 1
		} else {
			iScope = nClass
		}
	}
	libc.Xmemcpy(tls, bp+8 /* &zHash1[0] */, zClass, uint64(iScope))
	sqlite3.Xsqlite3_free(tls, zClass)
	*(*int8)(unsafe.Pointer(bp + 8 /* &zHash1[0] */ + uintptr(iScope))) = int8(0)
	libc.Xmemcpy(tls, bp+40 /* &zHash2[0] */, bp+8 /* &zHash1[0] */, uint64(iScope))
	*(*int8)(unsafe.Pointer(bp + 40 /* &zHash2[0] */ + uintptr(iScope))) = int8('Z')
	*(*int8)(unsafe.Pointer(bp + 40 /* &zHash2[0] */ + uintptr(iScope+1))) = int8(0)

	libc.Xmemcpy(tls, p+108+uintptr(libc.PostIncInt32(&(*MatchQuery)(unsafe.Pointer(p)).FnRun, 1))*32, bp+8 /* &zHash1[0] */, uint64(iScope+1))
	if sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, bp+8, -1, uintptr(0)) == SQLITE_NOMEM ||
		sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, bp+40, -1, uintptr(0)) == SQLITE_NOMEM {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
		return
	}
	for sqlite3.Xsqlite3_step(tls, pStmt) == SQLITE_ROW {
		*(*int32)(unsafe.Pointer(bp + 72 /* iMatchlen */)) = -1
		iRank = sqlite3.Xsqlite3_column_int(tls, pStmt, 2)
		if (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3 != 0 {
			var nWord int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, 1)
			zWord = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			iDist = editDist3Core(tls, (*MatchQuery)(unsafe.Pointer(p)).FpMatchStr3, zWord, nWord, (*MatchQuery)(unsafe.Pointer(p)).FpLang, bp+72 /* &iMatchlen */)
		} else {
			zK1 = sqlite3.Xsqlite3_column_text(tls, pStmt, 3)
			if zK1 == uintptr(0) {
				continue
			}
			iDist = editdist1(tls, (*MatchQuery)(unsafe.Pointer(p)).FzPattern, zK1, uintptr(0))
		}
		if iDist < 0 {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
			break
		}
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch++

		// If there is a "distance < $dist" or "distance <= $dist" constraint,
		// check if this row meets it. If not, jump back up to the top of the
		// loop to process the next row. Otherwise, if the row does match the
		// distance constraint, check if the pCur->a[] array is already full.
		// If it is and no explicit "top = ?" constraint was present in the
		// query, grow the array to ensure there is room for the new entry.

		if (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist >= 0 {
			if iDist > (*MatchQuery)(unsafe.Pointer(p)).FiMaxDist {
				continue
			}
			if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc && (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum&SPELLFIX_IDXNUM_TOP == 0 {
				spellfix1ResizeCursor(tls, pCur, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc*2+10)
				if (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa == uintptr(0) {
					break
				}
			}
		}

		iScore = spellfix1Score(tls, iDist, iRank)
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			idx = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
		} else if iScore < iWorst {
			idx = idxWorst
			sqlite3.Xsqlite3_free(tls, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64)).FzWord)
		} else {
			continue
		}

		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FzWord = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pStmt, 1)))
		if (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64)).FzWord == uintptr(0) {
			(*MatchQuery)(unsafe.Pointer(p)).Frc = SQLITE_NOMEM
			break
		}
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiRowid = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiRank = iRank
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiDistance = iDist
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiScore = iScore
		(*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(idx)*64)).FiMatchlen = *(*int32)(unsafe.Pointer(bp + 72 /* iMatchlen */))
		libc.Xmemcpy(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr(idx)*64+32, bp+8 /* &zHash1[0] */, uint64(iScope+1))
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow++
		}
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow == (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnAlloc {
			iWorst = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa)).FiScore
			idxWorst = 0
			for i = 1; i < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow; i++ {
				iScore = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr(i)*64)).FiScore
				if iWorst < iScore {
					iWorst = iScore
					idxWorst = i
				}
			}
		}
	}
	rc = sqlite3.Xsqlite3_reset(tls, pStmt)
	if rc != 0 {
		(*MatchQuery)(unsafe.Pointer(p)).Frc = rc
	}
}

// This version of the xFilter method work if the MATCH term is present
// and we are doing a scan.
func spellfix1FilterForMatch(tls *libc.TLS, pCur uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2526:12: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var idxNum int32
	var zMatchThis uintptr // RHS of the MATCH operator
	var pMatchStr3 uintptr // zMatchThis as an editdist string
	var zPattern uintptr   // Transliteration of zMatchThis
	var nPattern int32     // Length of zPattern
	var iLimit int32       // Max number of rows of output
	var iScope int32       // Use this many characters of zClass
	var iLang int32        // Language code
	var zSql uintptr       // SQL of shadow table query
	// var pStmt uintptr at bp+168, 8
	// Shadow table query
	var rc int32  // Result code
	var idx int32 // Next available filter parameter
	var p uintptr // The virtual table that owns pCur
	// var x MatchQuery at bp+24, 144
	idxNum = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	pMatchStr3 = uintptr(0)
	iLimit = 20
	iScope = 3
	iLang = 0
	*(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */)) = uintptr(0)
	idx = 1
	p = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab // For passing info to RunQuery()

	// Load the cost table if we have not already done so
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable != uintptr(0) && (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0)) {
		goto __1
	}
	(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(EditDist3Config{})))
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 == uintptr(0)) {
		goto __2
	}
	return SQLITE_NOMEM
__2:
	;
	libc.Xmemset(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, 0, uint64(unsafe.Sizeof(EditDist3Config{})))
	rc = editDist3ConfigLoad(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
	if !(rc != 0) {
		goto __3
	}
	return rc
__3:
	;
__1:
	;
	libc.Xmemset(tls, bp+24 /* &x */, 0, uint64(unsafe.Sizeof(MatchQuery{})))
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = 3    // Default scope if none specified by "WHERE scope=N"
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = -1 // Maximum allowed edit distance

	if !(idxNum&2 != 0) {
		goto __4
	}
	iLang = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*8)))
__4:
	;
	if !(idxNum&4 != 0) {
		goto __5
	}
	iLimit = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*8)))
	if !(iLimit < 1) {
		goto __6
	}
	iLimit = 1
__6:
	;
__5:
	;
	if !(idxNum&8 != 0) {
		goto __7
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*8)))
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).FiScope < 1) {
		goto __8
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = 1
__8:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).FiScope > SPELLFIX_MX_HASH-2) {
		goto __9
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiScope = SPELLFIX_MX_HASH - 2
__9:
	;
__7:
	;
	if !(idxNum&(16|32) != 0) {
		goto __10
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(libc.PostIncInt32(&idx, 1))*8)))
	if !(idxNum&16 != 0) {
		goto __11
	}
	(*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FiMaxDist--
__11:
	;
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).FiMaxDist < 0) {
		goto __12
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiMaxDist = 0
__12:
	;
__10:
	;
	spellfix1ResetCursor(tls, pCur)
	spellfix1ResizeCursor(tls, pCur, iLimit)
	zMatchThis = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if !(zMatchThis == uintptr(0)) {
		goto __13
	}
	return SQLITE_OK
__13:
	;
	if !((*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 != 0) {
		goto __14
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpLang = editDist3FindLang(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3, iLang)
	pMatchStr3 = editDist3FromStringNew(tls, (*MatchQuery)(unsafe.Pointer(bp+24 /* &x */)).FpLang, zMatchThis, -1)
	if !(pMatchStr3 == uintptr(0)) {
		goto __16
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
	goto filter_exit
__16:
	;
	goto __15
__14:
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpLang = uintptr(0)
__15:
	;
	zPattern = transliterate(tls, zMatchThis, sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv))))
	sqlite3.Xsqlite3_free(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern = zPattern
	if !(zPattern == uintptr(0)) {
		goto __17
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
	goto filter_exit
__17:
	;
	nPattern = int32(libc.Xstrlen(tls, zPattern))
	if !(int32(*(*int8)(unsafe.Pointer(zPattern + uintptr(nPattern-1)))) == '*') {
		goto __18
	}
	nPattern--
__18:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls,

		ts+7293, /* "SELECT id, word,..." */
		libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, iLang))
	if !(zSql == uintptr(0)) {
		goto __19
	}
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
	*(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */)) = uintptr(0)
	goto filter_exit
__19:
	;
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb, zSql, -1, bp+168 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpCur = pCur
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpStmt = *(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */))
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FzPattern = zPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FnPattern = nPattern
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpMatchStr3 = pMatchStr3
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FiLang = iLang
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = rc
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).FpConfig3 = (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3
	if !((*MatchQuery)(unsafe.Pointer(bp+24)).Frc == SQLITE_OK) {
		goto __20
	}
	spellfix1RunQuery(tls, bp+24 /* &x */, zPattern, nPattern)
__20:
	;

	if !((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa != 0) {
		goto __21
	}
	libc.Xqsort(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa, uint64((*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow), uint64(unsafe.Sizeof(spellfix1_row{})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{spellfix1RowCompare})))
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop = iLimit
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope = iScope
	goto __22
__21:
	(*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc = SQLITE_NOMEM
__22:
	;

filter_exit:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 168 /* pStmt */)))
	editDist3FromStringDelete(tls, pMatchStr3)
	return (*MatchQuery)(unsafe.Pointer(bp + 24 /* &x */)).Frc
}

// This version of xFilter handles a full-table scan case
func spellfix1FilterForFullScan(tls *libc.TLS, pCur uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2641:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	var idxNum int32 = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum
	var zSql uintptr
	var pVTab uintptr = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpVTab
	spellfix1ResetCursor(tls, pCur)

	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+7393, /* "SELECT word, ran..." */
		libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).FzTableName,
			func() uintptr {
				if idxNum&64 != 0 {
					return ts + 7452 /* " WHERE rowid=?" */
				}
				return ts + 584 /* "" */
			}()))
	if zSql == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*spellfix1_vtab)(unsafe.Pointer(pVTab)).Fdb, zSql, -1, pCur+56, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if rc == SQLITE_OK && idxNum&64 != 0 {

		rc = sqlite3.Xsqlite3_bind_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 1, *(*uintptr)(unsafe.Pointer(argv)))
	}
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow = libc.AssignPtrInt32(pCur+36, 0)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
		if rc == SQLITE_ROW {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = -1
			rc = SQLITE_OK
		}
		if rc == SQLITE_DONE {
			rc = SQLITE_OK
		}
	} else {
		(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = 0
	}
	return rc
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any spellfix1Column, spellfix1Rowid, or spellfix1Eof call.
func spellfix1Filter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* spellfix.c:2681:12: */
	var pCur uintptr = cur
	var rc int32
	(*spellfix1_cursor)(unsafe.Pointer(pCur)).FidxNum = idxNum
	if idxNum&1 != 0 {
		rc = spellfix1FilterForMatch(tls, pCur, argc, argv)
	} else {
		rc = spellfix1FilterForFullScan(tls, pCur, argc, argv)
	}
	return rc
}

// Advance a cursor to its next row of output
func spellfix1Next(tls *libc.TLS, cur uintptr) int32 { /* spellfix.c:2701:12: */
	var pCur uintptr = cur
	var rc int32 = SQLITE_OK
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow < (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow {
		if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
			rc = sqlite3.Xsqlite3_step(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan)
			if rc != SQLITE_ROW {
				(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow = (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow
			}
			if rc == SQLITE_ROW || rc == SQLITE_DONE {
				rc = SQLITE_OK
			}
		} else {
			(*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow++
		}
	}
	return rc
}

// Return TRUE if we are at the end-of-file
func spellfix1Eof(tls *libc.TLS, cur uintptr) int32 { /* spellfix.c:2719:12: */
	var pCur uintptr = cur
	return libc.Bool32((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow >= (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnRow)
}

// Return columns from the current row.
func spellfix1Column(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* spellfix.c:2727:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		if i <= SPELLFIX_COL_LANGID {
			sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, i))
		} else {
			sqlite3.Xsqlite3_result_null(tls, ctx)
		}
		return SQLITE_OK
	}
	switch i {
	case SPELLFIX_COL_WORD:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FzWord, -1, uintptr(0))
			break

		}
	case SPELLFIX_COL_RANK:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiRank)
			break

		}
	case SPELLFIX_COL_DISTANCE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiDistance)
			break

		}
	case SPELLFIX_COL_LANGID:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiLang)
			break

		}
	case SPELLFIX_COL_SCORE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiScore)
			break

		}
	case SPELLFIX_COL_MATCHLEN:
		{
			*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiMatchlen
			if *(*int32)(unsafe.Pointer(bp)) < 0 {
				var nPattern int32 = int32(libc.Xstrlen(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern))
				var zWord uintptr = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FzWord
				var nWord int32 = int32(libc.Xstrlen(tls, zWord))

				if nPattern > 0 && int32(*(*int8)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern + uintptr(nPattern-1)))) == '*' {
					var zTranslit uintptr
					var res int32
					zTranslit = transliterate(tls, zWord, nWord)
					if !(zTranslit != 0) {
						return SQLITE_NOMEM
					}
					res = editdist1(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FzPattern, zTranslit, bp /* &iMatchlen */)
					sqlite3.Xsqlite3_free(tls, zTranslit)
					if res < 0 {
						return SQLITE_NOMEM
					}
					*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = translen_to_charlen(tls, zWord, nWord, *(*int32)(unsafe.Pointer(bp /* iMatchlen */)))
				} else {
					*(*int32)(unsafe.Pointer(bp /* iMatchlen */)) = utf8Charlen(tls, zWord, nWord)
				}
			}

			sqlite3.Xsqlite3_result_int(tls, ctx, *(*int32)(unsafe.Pointer(bp /* iMatchlen */)))
			break

		}
	case SPELLFIX_COL_PHONEHASH:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa+uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64+32, -1, uintptr(0))
			break

		}
	case SPELLFIX_COL_TOP:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiTop)
			break

		}
	case SPELLFIX_COL_SCOPE:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FiScope)
			break

		}
	case SPELLFIX_COL_SRCHCNT:
		{
			sqlite3.Xsqlite3_result_int(tls, ctx, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FnSearch)
			break

		}
	default:
		{
			sqlite3.Xsqlite3_result_null(tls, ctx)
			break

		}
	}
	return SQLITE_OK
}

// The rowid.
func spellfix1Rowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* spellfix.c:2813:12: */
	var pCur uintptr = cur
	if (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan != 0 {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*spellfix1_cursor)(unsafe.Pointer(pCur)).FpFullScan, 4)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*spellfix1_row)(unsafe.Pointer((*spellfix1_cursor)(unsafe.Pointer(pCur)).Fa + uintptr((*spellfix1_cursor)(unsafe.Pointer(pCur)).FiRow)*64)).FiRowid
	}
	return SQLITE_OK
}

// This function is called by the xUpdate() method. It returns a string
// containing the conflict mode that xUpdate() should use for the current
// operation. One of: "ROLLBACK", "IGNORE", "ABORT" or "REPLACE".
func spellfix1GetConflict(tls *libc.TLS, db uintptr) uintptr { /* spellfix.c:2828:19: */
	var eConflict int32 = sqlite3.Xsqlite3_vtab_on_conflict(tls, db)

	return azConflict[eConflict-1]
}

var azConflict = [5]uintptr{
	// Note: Instead of "FAIL" - "ABORT".
	ts + 7467 /* "ROLLBACK" */, ts + 7476 /* "IGNORE" */, ts + 7483 /* "ABORT" */, ts + 7483 /* "ABORT" */, ts + 7489, /* "REPLACE" */
} /* spellfix.c:2829:21 */

// The xUpdate() method.
func spellfix1Update(tls *libc.TLS, pVTab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* spellfix.c:2851:12: */
	bp := tls.Alloc(284)
	defer tls.Free(284)

	*(*int32)(unsafe.Pointer(bp + 280 /* rc */)) = SQLITE_OK
	var rowid sqlite3_int64
	var newRowid sqlite3_int64
	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb

	if argc == 1 {
		// A delete operation on the rowid given by argv[0]
		rowid = libc.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
		spellfix1DbExec(tls, bp+280 /* &rc */, db,
			ts+7497, /* "DELETE FROM \"%w\"..." */
			libc.VaList(bp, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, rowid))
	} else {
		var zWord uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		var nWord int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		var iLang int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)))
		var iRank int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))
		var zSoundslike uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 12*8)))
		var nSoundslike int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + 12*8)))
		var zK1 uintptr
		var zK2 uintptr
		var i int32
		var c int8
		var zConflict uintptr = spellfix1GetConflict(tls, db)

		if zWord == uintptr(0) {
			// Inserts of the form:  INSERT INTO table(command) VALUES('xyzzy');
			// cause zWord to be NULL, so we look at the "command" column to see
			// what special actions to take
			var zCmd uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 13*8)))
			if zCmd == uintptr(0) {
				(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+7540, /* "NOT NULL constra..." */
					libc.VaList(bp+24, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName))
				return SQLITE_CONSTRAINT | int32(5)<<8
			}
			if libc.Xstrcmp(tls, zCmd, ts+7576) == 0 {
				// Reset the  edit cost table (if there is one).
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				return SQLITE_OK
			}
			if libc.Xstrncmp(tls, zCmd, ts+7242, uint64(16)) == 0 {
				editDist3ConfigDelete(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FpConfig3 = uintptr(0)
				sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
				(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = spellfix1Dequote(tls, zCmd+uintptr(16))
				if (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable == uintptr(0) {
					return SQLITE_NOMEM
				}
				if int32(*(*int8)(unsafe.Pointer((*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable))) == 0 || sqlite3.Xsqlite3_stricmp(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable, ts+7582) == 0 {
					sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable)
					(*spellfix1_vtab)(unsafe.Pointer(p)).FzCostTable = uintptr(0)
				}
				return SQLITE_OK
			}
			(*sqlite3_vtab)(unsafe.Pointer(pVTab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+7587, /* "unknown value fo..." */
				libc.VaList(bp+32, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zCmd))
			return SQLITE_ERROR
		}
		if iRank < 1 {
			iRank = 1
		}
		if zSoundslike != 0 {
			zK1 = transliterate(tls, zSoundslike, nSoundslike)
		} else {
			zK1 = transliterate(tls, zWord, nWord)
		}
		if zK1 == uintptr(0) {
			return SQLITE_NOMEM
		}
		for i = 0; int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(zK1 + uintptr(i))))) != 0; i++ {
			if int32(c) >= 'A' && int32(c) <= 'Z' {
				*(*int8)(unsafe.Pointer(zK1 + uintptr(i))) += int8('a' - 'A')
			}
		}
		zK2 = phoneticHash(tls, zK1, i)
		if zK2 == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, zK1)
			return SQLITE_NOMEM
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
			if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))) == SQLITE_NULL {
				spellfix1DbExec(tls, bp+280 /* &rc */, db,

					ts+7622, /* "INSERT INTO \"%w\"..." */
					libc.VaList(bp+48, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						iRank, iLang, zWord, zK1, zWord, zK2))
			} else {
				newRowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
				spellfix1DbExec(tls, bp+280 /* &rc */, db,

					ts+7708, /* "INSERT OR %s INT..." */
					libc.VaList(bp+112, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName,
						newRowid, iRank, iLang, zWord, zK1, zWord, zK2))
			}
			*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
		} else {
			rowid = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			newRowid = libc.AssignPtrInt64(pRowid, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))))
			spellfix1DbExec(tls, bp+280 /* &rc */, db,

				ts+7808, /* "UPDATE OR %s \"%w..." */
				libc.VaList(bp+192, zConflict, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, newRowid, iRank, iLang,
					zWord, zK1, zWord, zK2, rowid))
		}
		sqlite3.Xsqlite3_free(tls, zK1)
		sqlite3.Xsqlite3_free(tls, zK2)
	}
	return *(*int32)(unsafe.Pointer(bp + 280 /* rc */))
}

// Rename the spellfix1 table.
func spellfix1Rename(tls *libc.TLS, pVTab uintptr, zNew uintptr) int32 { /* spellfix.c:2966:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var p uintptr = pVTab
	var db uintptr = (*spellfix1_vtab)(unsafe.Pointer(p)).Fdb
	*(*int32)(unsafe.Pointer(bp + 32 /* rc */)) = SQLITE_OK
	var zNewName uintptr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zNew))
	if zNewName == uintptr(0) {
		return SQLITE_NOMEM
	}
	spellfix1DbExec(tls, bp+32 /* &rc */, db,
		ts+7917, /* "ALTER TABLE \"%w\"..." */
		libc.VaList(bp+8, (*spellfix1_vtab)(unsafe.Pointer(p)).FzDbName, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName, zNewName))
	if *(*int32)(unsafe.Pointer(bp + 32)) == SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, (*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName)
		(*spellfix1_vtab)(unsafe.Pointer(p)).FzTableName = zNewName
	} else {
		sqlite3.Xsqlite3_free(tls, zNewName)
	}
	return *(*int32)(unsafe.Pointer(bp + 32 /* rc */))
}

// A virtual table module that provides fuzzy search.
var spellfix1Module = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate - handle CREATE VIRTUAL TABLE
	FxConnect:    0, // xConnect - reconnected to an existing table
	FxBestIndex:  0, // xBestIndex - figure out how to do a query
	FxDisconnect: 0, // xDisconnect - close a connection
	FxDestroy:    0, // xDestroy - handle DROP TABLE
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xFindMethod
	FxRename:     0, // xRename
} /* spellfix.c:2991:23 */

// Register the various functions and the virtual table.
func spellfix1Register(tls *libc.TLS, db uintptr) int32 { /* spellfix.c:3017:12: */
	var rc int32 = SQLITE_OK
	var i int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7966 /* "spellfix1_transl..." */, 1,
		SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{transliterateSqlFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+7985 /* "spellfix1_editdi..." */, 2,
			SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{editdistSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8004 /* "spellfix1_phoneh..." */, 1,
			SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{phoneticHashSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8024 /* "spellfix1_script..." */, 1,
			SQLITE_UTF8|SQLITE_DETERMINISTIC, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{scriptCodeSqlFunc})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8045 /* "spellfix1" */, uintptr(unsafe.Pointer(&spellfix1Module)), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = editDist3Install(tls, db)
	}

	// Verify sanity of the translit[] table
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(translit))/uint64(unsafe.Sizeof(Transliteration{}))-uint64(1); i++ {

	}

	return rc
}

// Extension load function.
func sqlite3_spellfix_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* spellfix.c:3061:5: */
	_ = pApi

	return spellfix1Register(tls, db)
	return SQLITE_OK
}

// Determine if this is running on a big-endian or little-endian
// processor

// Constants for the largest and smallest possible 64-bit signed integers.
// These macros are designed to work correctly on both 32-bit and 64-bit
// compilers.

// Return TRUE if character c is a whitespace character
func totypeIsspace(tls *libc.TLS, c uint8) int32 { /* totype.c:70:12: */
	return libc.Bool32(int32(c) == ' ' || int32(c) == '\t' || int32(c) == '\n' || int32(c) == '\v' || int32(c) == '\f' || int32(c) == '\r')
}

// Return TRUE if character c is a digit
func totypeIsdigit(tls *libc.TLS, c uint8) int32 { /* totype.c:77:12: */
	return libc.Bool32(int32(c) >= '0' && int32(c) <= '9')
}

// Compare the 19-character string zNum against the text representation
// value 2^63:  9223372036854775808.  Return negative, zero, or positive
// if zNum is less than, equal to, or greater than the string.
// Note that zNum must contain exactly 19 characters.
//
// Unlike memcmp() this routine is guaranteed to return the difference
// in the values of the last digit if the only difference is in the
// last digit.  So, for example,
//
//      totypeCompare2pow63("9223372036854775800")
//
// will return -8.
func totypeCompare2pow63(tls *libc.TLS, zNum uintptr) int32 { /* totype.c:95:12: */
	var c int32 = 0
	var i int32
	// 012345678901234567
	var pow63 uintptr = ts + 8055 /* "9223372036854775..." */
	for i = 0; c == 0 && i < 18; i++ {
		c = (int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i)))) - int32(*(*int8)(unsafe.Pointer(pow63 + uintptr(i))))) * 10
	}
	if c == 0 {
		c = int32(*(*int8)(unsafe.Pointer(zNum + 18))) - '8'
	}
	return c
}

// Convert zNum to a 64-bit signed integer.
//
// If the zNum value is representable as a 64-bit twos-complement
// integer, then write that value into *pNum and return 0.
//
// If zNum is exactly 9223372036854665808, return 2.  This special
// case is broken out because while 9223372036854665808 cannot be a
// signed 64-bit integer, its negative -9223372036854665808 can be.
//
// If zNum is too big for a 64-bit integer and is not
// 9223372036854665808  or if zNum contains any non-numeric text,
// then return 1.
//
// The string is not necessarily zero-terminated.
func totypeAtoi64(tls *libc.TLS, zNum uintptr, pNum uintptr, length int32) int32 { /* totype.c:125:12: */
	var u sqlite3_uint64 = uint64(0)
	var neg int32 = 0 // assume positive
	var i int32
	var c int32 = 0
	var nonNum int32 = 0
	var zStart uintptr
	var zEnd uintptr = zNum + uintptr(length)

	for zNum < zEnd && totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(zNum)))) != 0 {
		zNum++
	}
	if zNum < zEnd {
		if int32(*(*int8)(unsafe.Pointer(zNum))) == '-' {
			neg = 1
			zNum++
		} else if int32(*(*int8)(unsafe.Pointer(zNum))) == '+' {
			zNum++
		}
	}
	zStart = zNum
	for zNum < zEnd && int32(*(*int8)(unsafe.Pointer(zNum))) == '0' {
		zNum++
	} // Skip leading zeros.
	for i = 0; zNum+uintptr(i) < zEnd && libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(zNum + uintptr(i))))) >= '0' && c <= '9'; i++ {
		u = u*uint64(10) + sqlite3_uint64(c) - uint64('0')
	}
	if u > uint64(int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32) {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = int64(-1) - (int64(0xffffffff) | sqlite3_int64(int64(0x7fffffff))<<32)
	} else if neg != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = -sqlite3_int64(u)
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pNum)) = sqlite3_int64(u)
	}
	if c != 0 && zNum+uintptr(i) < zEnd || i == 0 && zStart == zNum || i > 19 || nonNum != 0 {
		// zNum is empty or contains non-numeric text or is longer
		// than 19 digits (thus guaranteeing that it is too large)
		return 1
	} else if i < 19 {
		// Less than 19 digits, so we know that it fits in 64 bits

		return 0
	} else {
		// zNum is a 19-digit numbers.  Compare it against 9223372036854775808.
		c = totypeCompare2pow63(tls, zNum)
		if c < 0 {
			// zNum is less than 9223372036854775808 so it fits

			return 0
		} else if c > 0 {
			// zNum is greater than 9223372036854775808 so it overflows
			return 1
		} else {
			// zNum is exactly 9223372036854775808.  Fits if negative.  The
			// special case 2 overflow if positive

			if neg != 0 {
				return 0
			}
			return 2
		}
	}
	return int32(0)
}

// The string z[] is an text representation of a real number.
// Convert this string to a double and write it into *pResult.
//
// The string is not necessarily zero-terminated.
//
// Return TRUE if the result is a valid real number (or integer) and FALSE
// if the string is empty or contains extraneous text.  Valid numbers
// are in one of these formats:
//
//    [+-]digits[E[+-]digits]
//    [+-]digits.[digits][E[+-]digits]
//    [+-].digits[E[+-]digits]
//
// Leading and trailing whitespace is ignored for the purpose of determining
// validity.
//
// If some prefix of the input string is a valid number, this routine
// returns FALSE but it still converts the prefix and writes the result
// into *pResult.
func totypeAtoF(tls *libc.TLS, z uintptr, pResult uintptr, length int32) int32 { /* totype.c:204:12: */
	var zEnd uintptr
	// sign * significand * (10 ^ (esign * exponent))
	var sign int32      // sign of significand
	var s sqlite3_int64 // significand
	var d int32         // adjust exponent for shifting decimal point
	var esign int32     // sign of exponent
	var e int32         // exponent
	var eValid int32    // True exponent is either not used or is well-formed
	var result float64
	var nDigits int32
	var nonNum int32
	var scale float64
	zEnd = z + uintptr(length)
	sign = 1
	s = int64(0)
	d = 0
	esign = 1
	e = 0
	eValid = 1
	nDigits = 0
	nonNum = 0

	*(*float64)(unsafe.Pointer(pResult)) = 0.0 // Default return value, in case of an error

	// skip leading spaces
__1:
	if !(z < zEnd && totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __2
	}
	z++
	goto __1
__2:
	;
	if !(z >= zEnd) {
		goto __3
	}
	return 0
__3:
	;

	// get sign of significand
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __4
	}
	sign = -1
	z++
	goto __5
__4:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __6
	}
	z++
__6:
	;
__5:
	;

	// skip leading zeroes
__7:
	if !(z < zEnd && int32(*(*int8)(unsafe.Pointer(z))) == '0') {
		goto __8
	}
	z++
	nDigits++
	goto __7
__8:
	;

	// copy max significant digits to significand
__9:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0 && s < (int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32-int64(9))/int64(10)) {
		goto __10
	}
	s = s*int64(10) + sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z)))-'0')
	z++
	nDigits++
	goto __9
__10:
	;

	// skip non-significant significand digits
	// (increase exponent by d to shift decimal left)
__11:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __12
	}
	z++
	nDigits++
	d++
	goto __11
__12:
	;
	if !(z >= zEnd) {
		goto __13
	}
	goto totype_atof_calc
__13:
	;

	// if decimal point is present
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '.') {
		goto __14
	}
	z++
	// copy digits from after decimal to significand
	// (decrease exponent by d to shift decimal right)
__15:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0 && s < (int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32-int64(9))/int64(10)) {
		goto __16
	}
	s = s*int64(10) + sqlite3_int64(int32(*(*int8)(unsafe.Pointer(z)))-'0')
	z++
	nDigits++
	d--
	goto __15
__16:
	;
	// skip non-significant digits
__17:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __18
	}
	z++
	nDigits++
	goto __17
__18:
	;
__14:
	;
	if !(z >= zEnd) {
		goto __19
	}
	goto totype_atof_calc
__19:
	;

	// if exponent is present
	if !(int32(*(*int8)(unsafe.Pointer(z))) == 'e' || int32(*(*int8)(unsafe.Pointer(z))) == 'E') {
		goto __20
	}
	z++
	eValid = 0
	if !(z >= zEnd) {
		goto __21
	}
	goto totype_atof_calc
__21:
	;
	// get sign of exponent
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '-') {
		goto __22
	}
	esign = -1
	z++
	goto __23
__22:
	if !(int32(*(*int8)(unsafe.Pointer(z))) == '+') {
		goto __24
	}
	z++
__24:
	;
__23:
	;
	// copy digits to exponent
__25:
	if !(z < zEnd && totypeIsdigit(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __26
	}
	if e < 10000 {
		e = e*10 + (int32(*(*int8)(unsafe.Pointer(z))) - '0')
	} else {
		e = 10000
	}
	z++
	eValid = 1
	goto __25
__26:
	;
__20:
	;

	// skip trailing spaces
	if !(nDigits != 0 && eValid != 0) {
		goto __27
	}
__28:
	if !(z < zEnd && totypeIsspace(tls, uint8(*(*int8)(unsafe.Pointer(z)))) != 0) {
		goto __29
	}
	z++
	goto __28
__29:
	;
__27:
	;

totype_atof_calc:
	// adjust exponent by d, and update sign
	e = e*esign + d
	if !(e < 0) {
		goto __30
	}
	esign = -1
	e = e * -1
	goto __31
__30:
	esign = 1
__31:
	;

	// if 0 significand
	if !!(s != 0) {
		goto __32
	}
	// In the IEEE 754 standard, zero is signed.
	// Add the sign if we've seen at least one digit
	if sign < 0 && nDigits != 0 {
		result = -libc.Float64FromFloat64(float64(0))
	} else {
		result = float64(0)
	}
	goto __33
__32:
	// attempt to reduce exponent
	if !(esign > 0) {
		goto __34
	}
__36:
	if !(s < (int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32)/int64(10) && e > 0) {
		goto __37
	}
	e--
	s = s * int64(10)
	goto __36
__37:
	;
	goto __35
__34:
__38:
	if !(!(int32(s%int64(10)) != 0) && e > 0) {
		goto __39
	}
	e--
	s = s / int64(10)
	goto __38
__39:
	;
__35:
	;

	// adjust the sign of significand
	if sign < 0 {
		s = -s
	} else {
		s = s
	}

	// if exponent, scale significand as appropriate
	// and store in result.
	if !(e != 0) {
		goto __40
	}
	scale = 1.0
	// attempt to handle extremely small/large numbers better
	if !(e > 307 && e < 342) {
		goto __42
	}
__44:
	if !(e%308 != 0) {
		goto __45
	}
	scale = scale * 1.0e+1
	e = e - 1
	goto __44
__45:
	;
	if !(esign < 0) {
		goto __46
	}
	result = float64(s) / scale
	result = result / 1.0e+308
	goto __47
__46:
	result = float64(s) * scale
	result = result * 1.0e+308
__47:
	;
	goto __43
__42:
	if !(e >= 342) {
		goto __48
	}
	if !(esign < 0) {
		goto __50
	}
	result = 0.0 * float64(s)
	goto __51
__50:
	result = libc.Float64(1e308) * libc.Float64(1e308) * float64(s) // Infinity
__51:
	;
	goto __49
__48:
	// 1.0e+22 is the largest power of 10 than can be
	// represented exactly.
__52:
	if !(e%22 != 0) {
		goto __53
	}
	scale = scale * 1.0e+1
	e = e - 1
	goto __52
__53:
	;
__54:
	if !(e > 0) {
		goto __55
	}
	scale = scale * 1.0e+22
	e = e - 22
	goto __54
__55:
	;
	if !(esign < 0) {
		goto __56
	}
	result = float64(s) / scale
	goto __57
__56:
	result = float64(s) * scale
__57:
	;
__49:
	;
__43:
	;
	goto __41
__40:
	result = float64(s)
__41:
	;
__33:
	;

	// store the result
	*(*float64)(unsafe.Pointer(pResult)) = result

	// return true if number and no extra non-whitespace chracters after
	return libc.Bool32(z >= zEnd && nDigits > 0 && eValid != 0 && nonNum == 0)
}

// tointeger(X):  If X is any value (integer, double, blob, or string) that
// can be losslessly converted into an integer, then make the conversion and
// return the result.  Otherwise, return NULL.
func tointegerFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* totype.c:358:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) {
	case SQLITE_FLOAT:
		{
			var rVal float64 = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var iVal sqlite3_int64 = sqlite3_int64(rVal)
			if rVal == float64(iVal) {
				sqlite3.Xsqlite3_result_int64(tls, context, iVal)
			}
			break

		}
	case SQLITE_INTEGER:
		{
			sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
			break

		}
	case SQLITE_BLOB:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if uint64(nBlob) == uint64(unsafe.Sizeof(sqlite3_int64(0))) {
					// var iVal sqlite3_int64 at bp+8, 8

					if 0 != 0 {
						var i int32
						// var zBlobRev [8]uint8 at bp, 8

						for i = 0; uint64(i) < uint64(unsafe.Sizeof(sqlite3_int64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp /* &zBlobRev[0] */ + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(uint64(unsafe.Sizeof(sqlite3_int64(0)))-uint64(1)-uint64(i))))
						}
						libc.Xmemcpy(tls, bp+8 /* &iVal */, bp /* &zBlobRev[0] */, uint64(unsafe.Sizeof(sqlite3_int64(0))))
					} else {
						libc.Xmemcpy(tls, bp+8 /* &iVal */, zBlob, uint64(unsafe.Sizeof(sqlite3_int64(0))))
					}
					sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* iVal */)))
				}
			}
			break

		}
	case SQLITE_TEXT:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if nStr != 0 && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr))) != 0) {
					// var iVal sqlite3_int64 at bp+16, 8

					if !(totypeAtoi64(tls, zStr, bp+16, nStr) != 0) {
						sqlite3.Xsqlite3_result_int64(tls, context, *(*sqlite3_int64)(unsafe.Pointer(bp + 16 /* iVal */)))
					}
				}
			}
			break

		}
	default:
		{

			break

		}
	}
}

// toreal(X): If X is any value (integer, double, blob, or string) that can
// be losslessly converted into a real number, then do so and return that
// real number.  Otherwise return NULL.
func torealFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* totype.c:428:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	_ = argc
	switch sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) {
	case SQLITE_FLOAT:
		{
			sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv))))
			break

		}
	case SQLITE_INTEGER:
		{
			var iVal sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			var rVal float64 = float64(iVal)
			if iVal == sqlite3_int64(rVal) {
				sqlite3.Xsqlite3_result_double(tls, context, rVal)
			}
			break

		}
	case SQLITE_BLOB:
		{
			var zBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zBlob != 0 {
				var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if uint64(nBlob) == uint64(unsafe.Sizeof(float64(0))) {
					// var rVal float64 at bp+8, 8

					if 1 != 0 {
						var i int32
						// var zBlobRev [8]uint8 at bp, 8

						for i = 0; uint64(i) < uint64(unsafe.Sizeof(float64(0))); i++ {
							*(*uint8)(unsafe.Pointer(bp /* &zBlobRev[0] */ + uintptr(i))) = *(*uint8)(unsafe.Pointer(zBlob + uintptr(uint64(unsafe.Sizeof(float64(0)))-uint64(1)-uint64(i))))
						}
						libc.Xmemcpy(tls, bp+8 /* &rVal */, bp /* &zBlobRev[0] */, uint64(unsafe.Sizeof(float64(0))))
					} else {
						libc.Xmemcpy(tls, bp+8 /* &rVal */, zBlob, uint64(unsafe.Sizeof(float64(0))))
					}
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 8 /* rVal */)))
				}
			}
			break

		}
	case SQLITE_TEXT:
		{
			var zStr uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if zStr != 0 {
				var nStr int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
				if nStr != 0 && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr))) != 0) && !(totypeIsspace(tls, *(*uint8)(unsafe.Pointer(zStr + uintptr(nStr-1)))) != 0) {
					// var rVal float64 at bp+16, 8

					if totypeAtoF(tls, zStr, bp+16, nStr) != 0 {
						sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 16 /* rVal */)))
						return
					}
				}
			}
			break

		}
	default:
		{

			break

		}
	}
}

func sqlite3_totype_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* totype.c:497:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Unused parameter
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8074 /* "tointeger" */, 1,
		SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tointegerFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+8084 /* "toreal" */, 1,
			SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{torealFunc})), uintptr(0), uintptr(0))
	}
	return rc
}

// Largest and smallest possible 64-bit signed integers. These macros
// copied from sqliteInt.h.

// The following is also copied from sqliteInt.h. To facilitate coverage
// testing.

// The swarmvtab module attempts to keep the number of open database files
// at or below this limit. This may not be possible if there are too many
// simultaneous queries.

type UnionCsr1 = struct {
	Fbase        sqlite3_vtab_cursor
	FpStmt       uintptr
	FiMaxRowid   sqlite3_int64
	FiTab        int32
	F__ccgo_pad1 [4]byte
} /* unionvtab.c:181:9 */

// Largest and smallest possible 64-bit signed integers. These macros
// copied from sqliteInt.h.

// The following is also copied from sqliteInt.h. To facilitate coverage
// testing.

// The swarmvtab module attempts to keep the number of open database files
// at or below this limit. This may not be possible if there are too many
// simultaneous queries.

type UnionCsr = UnionCsr1 /* unionvtab.c:181:25 */
type UnionTab1 = struct {
	Fbase        sqlite3_vtab
	Fdb          uintptr
	FbSwarm      int32
	FiPK         int32
	FnSrc        int32
	F__ccgo_pad1 [4]byte
	FaSrc        uintptr
	FbHasContext int32
	F__ccgo_pad2 [4]byte
	FzSourceStr  uintptr
	FpNotFound   uintptr
	FpOpenClose  uintptr
	FpClosable   uintptr
	FnOpen       int32
	FnMaxOpen    int32
} /* unionvtab.c:182:9 */

type UnionTab = UnionTab1 /* unionvtab.c:182:25 */
type UnionSrc1 = struct {
	FzDb           uintptr
	FzTab          uintptr
	FiMin          sqlite3_int64
	FiMax          sqlite3_int64
	FzFile         uintptr
	FzContext      uintptr
	FnUser         int32
	F__ccgo_pad1   [4]byte
	Fdb            uintptr
	FpNextClosable uintptr
} /* unionvtab.c:182:9 */

type UnionSrc = UnionSrc1 /* unionvtab.c:183:25 */

// Given UnionTab table pTab and UnionSrc object pSrc, return the database
// handle that should be used to access the table identified by pSrc. This
// is the main db handle for "unionvtab" tables, or the source-specific
// handle for "swarmvtab".

// If *pRc is other than SQLITE_OK when this function is called, it
// always returns NULL. Otherwise, it attempts to allocate and return
// a pointer to nByte bytes of zeroed memory. If the memory allocation
// is attempted but fails, NULL is returned and *pRc is set to
// SQLITE_NOMEM.
func unionMalloc(tls *libc.TLS, pRc uintptr, nByte sqlite3_int64) uintptr { /* unionvtab.c:253:13: */
	var pRet uintptr

	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		pRet = sqlite3.Xsqlite3_malloc64(tls, uint64(nByte))
		if pRet != 0 {
			libc.Xmemset(tls, pRet, 0, size_t(nByte))
		} else {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
	} else {
		pRet = uintptr(0)
	}
	return pRet
}

// If *pRc is other than SQLITE_OK when this function is called, it
// always returns NULL. Otherwise, it attempts to allocate and return
// a copy of the nul-terminated string passed as the second argument.
// If the allocation is attempted but fails, NULL is returned and *pRc is
// set to SQLITE_NOMEM.
func unionStrdup(tls *libc.TLS, pRc uintptr, zIn uintptr) uintptr { /* unionvtab.c:276:13: */
	var zRet uintptr = uintptr(0)
	if zIn != 0 {
		var nByte sqlite3_int64 = sqlite3_int64(libc.Xstrlen(tls, zIn) + uint64(1))
		zRet = unionMalloc(tls, pRc, nByte)
		if zRet != 0 {
			libc.Xmemcpy(tls, zRet, zIn, size_t(nByte))
		}
	}
	return zRet
}

// If the first character of the string passed as the only argument to this
// function is one of the 4 that may be used as an open quote character
// in SQL, this function assumes that the input is a well-formed quoted SQL
// string. In this case the string is dequoted in place.
//
// If the first character of the input is not an open quote, then this
// function is a no-op.
func unionDequote(tls *libc.TLS, z uintptr) { /* unionvtab.c:297:13: */
	if z != 0 {
		var q int8 = *(*int8)(unsafe.Pointer(z))

		// Set stack variable q to the close-quote character
		if int32(q) == '[' || int32(q) == '\'' || int32(q) == '"' || int32(q) == '`' {
			var iIn int32 = 1
			var iOut int32 = 0
			if int32(q) == '[' {
				q = int8(']')
			}
			for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
					if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(q) {
						// Character iIn was the close quote.
						iIn++
						break
					} else {
						// Character iIn and iIn+1 form an escaped quote character. Skip
						// the input cursor past both and copy a single quote character
						// to the output buffer.
						iIn = iIn + 2
						*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
					}
				} else {
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
				}
			}
			*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
		}
	}
}

// This function is a no-op if *pRc is set to other than SQLITE_OK when it
// is called. NULL is returned in this case.
//
// Otherwise, the SQL statement passed as the third argument is prepared
// against the database handle passed as the second. If the statement is
// successfully prepared, a pointer to the new statement handle is
// returned. It is the responsibility of the caller to eventually free the
// statement by calling sqlite3_finalize(). Alternatively, if statement
// compilation fails, NULL is returned, *pRc is set to an SQLite error
// code and *pzErr may be set to an error message buffer allocated by
// sqlite3_malloc().
func unionPrepare(tls *libc.TLS, pRc uintptr, db uintptr, zSql uintptr, pzErr uintptr) uintptr { /* unionvtab.c:341:21: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* pRet */)) = uintptr(0)

	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		var rc int32 = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8 /* &pRet */, uintptr(0))
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8091 /* "sql error: %s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
			*(*int32)(unsafe.Pointer(pRc)) = rc
		}
	}
	return *(*uintptr)(unsafe.Pointer(bp + 8 /* pRet */))
}

// Like unionPrepare(), except prepare the results of vprintf(zFmt, ...)
// instead of a constant SQL string.
func unionPreparePrintf(tls *libc.TLS, pRc uintptr, pzErr uintptr, db uintptr, zFmt uintptr, va uintptr) uintptr { /* unionvtab.c:363:21: */
	var pRet uintptr = uintptr(0)
	var zSql uintptr
	var ap va_list
	_ = ap
	ap = va

	zSql = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		} else {
			pRet = unionPrepare(tls, pRc, db, zSql, pzErr)
		}
	}
	sqlite3.Xsqlite3_free(tls, zSql)

	_ = ap
	return pRet
}

// Call sqlite3_reset() on SQL statement pStmt. If *pRc is set to
// SQLITE_OK when this function is called, then it is set to the
// value returned by sqlite3_reset() before this function exits.
// In this case, *pzErr may be set to point to an error message
// buffer allocated by sqlite3_malloc().

// Call sqlite3_finalize() on SQL statement pStmt. If *pRc is set to
// SQLITE_OK when this function is called, then it is set to the
// value returned by sqlite3_finalize() before this function exits.
func unionFinalize(tls *libc.TLS, pRc uintptr, pStmt uintptr, pzErr uintptr) { /* unionvtab.c:414:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var db uintptr = sqlite3.Xsqlite3_db_handle(tls, pStmt)
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, pStmt)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = rc
		if rc != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}
}

// If an "openclose" UDF was supplied when this virtual table was created,
// invoke it now. The first argument passed is the name of the database
// file for source pSrc. The second is integer value bClose.
//
// If successful, return SQLITE_OK. Otherwise an SQLite error code. In this
// case if argument pzErr is not NULL, also set (*pzErr) to an English
// language error message. The caller is responsible for eventually freeing
// any error message using sqlite3_free().
func unionInvokeOpenClose(tls *libc.TLS, pTab uintptr, pSrc uintptr, bClose int32, pzErr uintptr) int32 { /* unionvtab.c:435:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_bind_int(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose, 2+(*UnionTab)(unsafe.Pointer(pTab)).FbHasContext, bClose)
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		if SQLITE_OK != libc.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)) {
			if pzErr != 0 {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			}
		}
	}
	return rc
}

// This function is a no-op for unionvtab. For swarmvtab, it attempts to
// close open database files until at most nMax are open. An SQLite error
// code is returned if an error occurs, or SQLITE_OK otherwise.
func unionCloseSources(tls *libc.TLS, pTab uintptr, nMax int32) { /* unionvtab.c:463:13: */
	for (*UnionTab)(unsafe.Pointer(pTab)).FpClosable != 0 && (*UnionTab)(unsafe.Pointer(pTab)).FnOpen > nMax {
		var p uintptr
		var pp uintptr
		for pp = pTab + 88; (*UnionSrc)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNextClosable != 0; pp = *(*uintptr)(unsafe.Pointer(pp)) + 64 {
		}
		p = *(*uintptr)(unsafe.Pointer(pp))

		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(p)).Fdb)
		(*UnionSrc)(unsafe.Pointer(p)).Fdb = uintptr(0)
		*(*uintptr)(unsafe.Pointer(pp)) = uintptr(0)
		(*UnionTab)(unsafe.Pointer(pTab)).FnOpen--
		unionInvokeOpenClose(tls, pTab, p, 1, uintptr(0))
	}
}

// xDisconnect method.
func unionDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* unionvtab.c:481:12: */
	if pVtab != 0 {
		var pTab uintptr = pVtab
		var i int32
		for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
			var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*72
			var bHaveSrcDb int32 = libc.Bool32((*UnionSrc)(unsafe.Pointer(pSrc)).Fdb != uintptr(0))
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			if bHaveSrcDb != 0 {
				unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
			}
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile)
			sqlite3.Xsqlite3_free(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext)
		}
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		sqlite3.Xsqlite3_finalize(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr)
		sqlite3.Xsqlite3_free(tls, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc)
		sqlite3.Xsqlite3_free(tls, pTab)
	}
	return SQLITE_OK
}

// Check that the table identified by pSrc is a rowid table. If not,
// return SQLITE_ERROR and set (*pzErr) to point to an English language
// error message. If the table is a rowid table and no error occurs,
// return SQLITE_OK and leave (*pzErr) unmodified.
func unionIsIntkeyTable(tls *libc.TLS, db uintptr, pSrc uintptr, pzErr uintptr) int32 { /* unionvtab.c:512:12: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	*(*int32)(unsafe.Pointer(bp + 32 /* bPk */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* zType */)) = uintptr(0)
	var rc int32

	sqlite3.Xsqlite3_table_column_metadata(tls,
		db, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, ts+8105 /* "_rowid_" */, bp+24 /* &zType */, uintptr(0), uintptr(0), bp+32 /* &bPk */, uintptr(0))
	rc = sqlite3.Xsqlite3_errcode(tls, db)
	if rc == SQLITE_ERROR ||
		rc == SQLITE_OK && (!(*(*int32)(unsafe.Pointer(bp + 32)) != 0) || sqlite3.Xsqlite3_stricmp(tls, ts+8113, *(*uintptr)(unsafe.Pointer(bp + 24))) != 0) {
		rc = SQLITE_ERROR
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8121, /* "no such rowid ta..." */
			libc.VaList(bp, func() uintptr {
				if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
				}
				return ts + 584
			}(),
				func() uintptr {
					if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
						return ts + 8149 /* "." */
					}
					return ts + 584 /* "" */
				}(),
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
	}
	return rc
}

// This function is a no-op if *pRc is other than SQLITE_OK when it is
// called. In this case it returns NULL.
//
// Otherwise, this function checks that the source table passed as the
// second argument (a) exists, (b) is not a view and (c) has a column
// named "_rowid_" of type "integer" that is the primary key.
// If this is not the case, *pRc is set to SQLITE_ERROR and NULL is
// returned.
//
// Finally, if the source table passes the checks above, a nul-terminated
// string describing the column names and types belonging to the source
// table is returned. Tables with the same set of column names and types
// cause this function to return identical strings. Is is the responsibility
// of the caller to free the returned string using sqlite3_free() when
// it is no longer required.
func unionSourceToStr(tls *libc.TLS, pRc uintptr, pTab uintptr, pSrc uintptr, pzErr uintptr) uintptr { /* unionvtab.c:555:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zRet uintptr = uintptr(0)
	if *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		*(*int32)(unsafe.Pointer(bp /* rc */)) = unionIsIntkeyTable(tls, db, pSrc, pzErr)
		var pStmt uintptr = unionPrepare(tls, bp /* &rc */, db,

			ts+8151 /* "SELECT group_con..." */, pzErr)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, -1, uintptr(0))
			sqlite3.Xsqlite3_bind_text(tls, pStmt, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb, -1, uintptr(0))
			if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
				var z uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
				zRet = unionStrdup(tls, bp /* &rc */, z)
			}
			unionFinalize(tls, bp /* &rc */, pStmt, pzErr)
		}
		*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp /* rc */))
	}

	return zRet
}

// Check that all configured source tables exist and have the same column
// names and datatypes. If this is not the case, or if some other error
// occurs, return an SQLite error code. In this case *pzErr may be set
// to point to an error message buffer allocated by sqlite3_mprintf().
// Or, if no problems regarding the source tables are detected and no
// other error occurs, SQLITE_OK is returned.
func unionSourceCheck(tls *libc.TLS, pTab uintptr, pzErr uintptr) int32 { /* unionvtab.c:592:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var z0 uintptr = uintptr(0)
	var i int32

	z0 = unionSourceToStr(tls, bp /* &rc */, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc, pzErr)
	for i = 1; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var z uintptr = unionSourceToStr(tls, bp /* &rc */, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FaSrc+uintptr(i)*72, pzErr)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && sqlite3.Xsqlite3_stricmp(tls, z, z0) != 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8235 /* "source table sch..." */, 0)
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_ERROR
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	sqlite3.Xsqlite3_free(tls, z0)

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Try to open the swarmvtab database.  If initially unable, invoke the
// not-found callback UDF and then try again.
func unionOpenDatabaseInner(tls *libc.TLS, pTab uintptr, pSrc uintptr, pzErr uintptr) int32 { /* unionvtab.c:616:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32

	rc = unionInvokeOpenClose(tls, pTab, pSrc, 0, pzErr)
	if rc != SQLITE_OK {
		return rc
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, pSrc+56, openFlags, uintptr(0))
	if rc == SQLITE_OK {
		return rc
	}
	if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
		sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
		(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
		sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 1, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, -1, uintptr(0))
		if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
			sqlite3.Xsqlite3_bind_text(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound, 2, (*UnionSrc)(unsafe.Pointer(pSrc)).FzContext, -1, uintptr(0))
		}
		sqlite3.Xsqlite3_step(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)
		if SQLITE_OK != libc.AssignInt32(&rc, sqlite3.Xsqlite3_reset(tls, (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound)) {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*UnionTab)(unsafe.Pointer(pTab)).Fdb)))
			return rc
		}
		rc = sqlite3.Xsqlite3_open_v2(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).FzFile, pSrc+56, openFlags, uintptr(0))
	}
	if rc != SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, sqlite3.Xsqlite3_errmsg(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)))
	}
	return rc
}

var openFlags int32 = SQLITE_OPEN_READONLY | SQLITE_OPEN_URI /* unionvtab.c:617:20 */

// This function may only be called for swarmvtab tables. The results of
// calling it on a unionvtab table are undefined.
//
// For a swarmvtab table, this function ensures that source database iSrc
// is open. If the database is opened successfully and the schema is as
// expected, or if it is already open when this function is called, SQLITE_OK
// is returned.
//
// Alternatively If an error occurs while opening the databases, or if the
// database schema is unsuitable, an SQLite error code is returned and (*pzErr)
// may be set to point to an English language error message. In this case it is
// the responsibility of the caller to eventually free the error message buffer
// using sqlite3_free().
func unionOpenDatabase(tls *libc.TLS, pTab uintptr, iSrc int32, pzErr uintptr) int32 { /* unionvtab.c:660:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iSrc)*72

	if (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb == uintptr(0) {
		unionCloseSources(tls, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen-1)
		*(*int32)(unsafe.Pointer(bp /* rc */)) = unionOpenDatabaseInner(tls, pTab, pSrc, pzErr)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			var z uintptr = unionSourceToStr(tls, bp /* &rc */, pTab, pSrc, pzErr)
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				if (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr == uintptr(0) {
					(*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr = z
				} else {
					if sqlite3.Xsqlite3_stricmp(tls, z, (*UnionTab)(unsafe.Pointer(pTab)).FzSourceStr) != 0 {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8235 /* "source table sch..." */, 0)
						*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_ERROR
					}
					sqlite3.Xsqlite3_free(tls, z)
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
			(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			(*UnionTab)(unsafe.Pointer(pTab)).FnOpen++
		} else {
			sqlite3.Xsqlite3_close(tls, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb)
			(*UnionSrc)(unsafe.Pointer(pSrc)).Fdb = uintptr(0)
			unionInvokeOpenClose(tls, pTab, pSrc, 1, uintptr(0))
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// This function is a no-op for unionvtab tables. For swarmvtab, increment
// the reference count for source table iTab. If the reference count was
// zero before it was incremented, also remove the source from the closable
// list.
func unionIncrRefcount(tls *libc.TLS, pTab uintptr, iTab int32) { /* unionvtab.c:704:13: */
	if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
		var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(iTab)*72

		if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
			var pp uintptr
			for pp = pTab + 88; *(*uintptr)(unsafe.Pointer(pp)) != pSrc; pp = *(*uintptr)(unsafe.Pointer(pp)) + 64 {
			}
			*(*uintptr)(unsafe.Pointer(pp)) = (*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable
			(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = uintptr(0)
		}
		(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser++
	}
}

// Finalize the SQL statement pCsr->pStmt and return the result.
//
// If this is a swarmvtab table (not unionvtab) and pCsr->pStmt was not
// NULL when this function was called, also decrement the reference
// count on the associated source table. If this means the source tables
// refcount is now zero, add it to the closable list.
func unionFinalizeCsrStmt(tls *libc.TLS, pCsr uintptr) int32 { /* unionvtab.c:726:12: */
	var rc int32 = SQLITE_OK
	if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*72
		rc = sqlite3.Xsqlite3_finalize(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionSrc)(unsafe.Pointer(pSrc)).FnUser--

			if (*UnionSrc)(unsafe.Pointer(pSrc)).FnUser == 0 {
				(*UnionSrc)(unsafe.Pointer(pSrc)).FpNextClosable = (*UnionTab)(unsafe.Pointer(pTab)).FpClosable
				(*UnionTab)(unsafe.Pointer(pTab)).FpClosable = pSrc
			}
			unionCloseSources(tls, pTab, (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen)
		}
	}
	return rc
}

// Return true if the argument is a space, tab, CR or LF character.
func union_isspace(tls *libc.TLS, c int8) int32 { /* unionvtab.c:749:12: */
	return libc.Bool32(int32(c) == ' ' || int32(c) == '\n' || int32(c) == '\r' || int32(c) == '\t')
}

// Return true if the argument is an alphanumeric character in the
// ASCII range.
func union_isidchar(tls *libc.TLS, c int8) int32 { /* unionvtab.c:757:12: */
	return libc.Bool32(int32(c) >= 'a' && int32(c) <= 'z' || int32(c) >= 'A' && int32(c) < 'Z' || int32(c) >= '0' && int32(c) <= '9')
}

// This function is called to handle all arguments following the first
// (the SQL statement) passed to a swarmvtab (not unionvtab) CREATE
// VIRTUAL TABLE statement. It may bind parameters to the SQL statement
// or configure members of the UnionTab object passed as the second
// argument.
//
// Refer to header comments at the top of this file for a description
// of the arguments parsed.
//
// This function is a no-op if *pRc is other than SQLITE_OK when it is
// called. Otherwise, if an error occurs, *pRc is set to an SQLite error
// code. In this case *pzErr may be set to point to a buffer containing
// an English language error message. It is the responsibility of the
// caller to eventually free the buffer using sqlite3_free().
func unionConfigureVtab(tls *libc.TLS, pRc uintptr, pTab uintptr, pStmt uintptr, nArg int32, azArg uintptr, pzErr uintptr) { /* unionvtab.c:777:13: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = *(*int32)(unsafe.Pointer(pRc))
	var i int32
	if *(*int32)(unsafe.Pointer(bp + 64)) == SQLITE_OK {
		(*UnionTab)(unsafe.Pointer(pTab)).FbHasContext = libc.Bool32(sqlite3.Xsqlite3_column_count(tls, pStmt) > 4)
	}
	for i = 0; *(*int32)(unsafe.Pointer(bp + 64 /* rc */)) == SQLITE_OK && i < nArg; i++ {
		var zArg uintptr = unionStrdup(tls, bp+64 /* &rc */, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8)))
		if zArg != 0 {
			var nOpt int32 = 0 // Size of option name in bytes
			var zOpt uintptr   // Pointer to option name
			var zVal uintptr   // Pointer to value

			unionDequote(tls, zArg)
			zOpt = zArg
			for union_isspace(tls, *(*int8)(unsafe.Pointer(zOpt))) != 0 {
				zOpt++
			}
			zVal = zOpt
			if int32(*(*int8)(unsafe.Pointer(zVal))) == ':' {
				zVal++
			}
			for union_isidchar(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			nOpt = int32((int64(zVal) - int64(zOpt)) / 1)

			for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
				zVal++
			}
			if int32(*(*int8)(unsafe.Pointer(zVal))) == '=' {
				*(*int8)(unsafe.Pointer(zOpt + uintptr(nOpt))) = int8(0)
				zVal++
				for union_isspace(tls, *(*int8)(unsafe.Pointer(zVal))) != 0 {
					zVal++
				}
				zVal = unionStrdup(tls, bp+64 /* &rc */, zVal)
				if zVal != 0 {
					unionDequote(tls, zVal)
					if int32(*(*int8)(unsafe.Pointer(zOpt))) == ':' {
						// A value to bind to the SQL statement
						var iParam int32 = sqlite3.Xsqlite3_bind_parameter_index(tls, pStmt, zOpt)
						if iParam == 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8264 /* "swarmvtab: no su..." */, libc.VaList(bp, zOpt))
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						} else {
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = sqlite3.Xsqlite3_bind_text(tls, pStmt, iParam, zVal, -1, libc.UintptrFromInt32(-1))
						}
					} else if nOpt == 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8301, 7) {
						(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = libc.Xatoi(tls, zVal)
						if (*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen <= 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8309 /* "swarmvtab: illeg..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						}
					} else if nOpt == 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8342, 7) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpNotFound != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8350 /* "swarmvtab: dupli..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+8388 /* "SELECT \"%w\"(?%s)" */, libc.VaList(bp+8, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 8405 /* ",?" */
									}
									return ts + 584 /* "" */
								}()))
						}
					} else if nOpt == 9 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+8408, 9) {
						if (*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose != 0 {
							*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls,
								ts+8418 /* "swarmvtab: dupli..." */, 0)
							*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
						} else {
							(*UnionTab)(unsafe.Pointer(pTab)).FpOpenClose = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
								ts+8458 /* "SELECT \"%w\"(?,?%..." */, libc.VaList(bp+24, zVal, func() uintptr {
									if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
										return ts + 8405 /* ",?" */
									}
									return ts + 584 /* "" */
								}()))
						}
					} else {
						*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8477 /* "swarmvtab: unrec..." */, libc.VaList(bp+40, zOpt))
						*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
					}
					sqlite3.Xsqlite3_free(tls, zVal)
				}
			} else {
				if i == 0 && nArg == 1 {
					(*UnionTab)(unsafe.Pointer(pTab)).FpNotFound = unionPreparePrintf(tls, bp+64 /* &rc */, pzErr, (*UnionTab)(unsafe.Pointer(pTab)).Fdb,
						ts+8512 /* "SELECT \"%w\"(?)" */, libc.VaList(bp+48, zArg))
				} else {
					*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8527 /* "swarmvtab: parse..." */, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(azArg + uintptr(i)*8))))
					*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = SQLITE_ERROR
				}
			}
			sqlite3.Xsqlite3_free(tls, zArg)
		}
	}
	*(*int32)(unsafe.Pointer(pRc)) = *(*int32)(unsafe.Pointer(bp + 64 /* rc */))
}

// xConnect/xCreate method.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("unionvtab" or "swarmvtab")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[3]   -> SQL statement
//   argv[4]   -> not-found callback UDF name
func unionConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* unionvtab.c:883:12: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var pTab uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
	var bSwarm int32 = func() int32 {
		if pAux == uintptr(0) {
			return 0
		}
		return 1
	}()
	var zVtab uintptr = func() uintptr {
		if bSwarm != 0 {
			return ts + 8554
		}
		return ts + 8564
	}()

	if sqlite3.Xsqlite3_stricmp(tls, ts+8574, *(*uintptr)(unsafe.Pointer(argv + 1*8))) != 0 {
		// unionvtab tables may only be created in the temp schema
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8579 /* "%s tables must b..." */, libc.VaList(bp, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
	} else if argc < 4 || argc > 4 && bSwarm == 0 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8620 /* "wrong number of ..." */, libc.VaList(bp+8, zVtab))
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
	} else {
		var nAlloc int32 = 0                                                                          // Allocated size of pTab->aSrc[]
		var pStmt uintptr = uintptr(0)                                                                // Argument statement
		var zArg uintptr = unionStrdup(tls, bp+40 /* &rc */, *(*uintptr)(unsafe.Pointer(argv + 3*8))) // Copy of argument to CVT

		// Prepare the SQL statement. Instead of executing it directly, sort
		// the results by the "minimum rowid" field. This makes it easier to
		// check that there are no rowid range overlaps between source tables
		// and that the UnionTab.aSrc[] array is always sorted by rowid.
		unionDequote(tls, zArg)
		pStmt = unionPreparePrintf(tls, bp+40 /* &rc */, pzErr, db,
			ts+8653 /* "SELECT * FROM (%..." */, libc.VaList(bp+16, zArg))

		// Allocate the UnionTab structure
		pTab = unionMalloc(tls, bp+40 /* &rc */, int64(unsafe.Sizeof(UnionTab{})))
		if pTab != 0 {

			(*UnionTab)(unsafe.Pointer(pTab)).Fdb = db
			(*UnionTab)(unsafe.Pointer(pTab)).FbSwarm = bSwarm
			(*UnionTab)(unsafe.Pointer(pTab)).FnMaxOpen = SWARMVTAB_MAX_OPEN
		}

		// Parse other CVT arguments, if any
		if bSwarm != 0 {
			unionConfigureVtab(tls, bp+40 /* &rc */, pTab, pStmt, argc-4, argv+4*8, pzErr)
		}

		// Iterate through the rows returned by the SQL statement specified
		// as an argument to the CREATE VIRTUAL TABLE statement.
		for *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
			var zDb uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			var zTab uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 1)
			var iMin sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 2)
			var iMax sqlite3_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, 3)
			var pSrc uintptr

			// Grow the pTab->aSrc[] array if required.
			if nAlloc <= (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var nNew int32
				if nAlloc != 0 {
					nNew = nAlloc * 2
				} else {
					nNew = 8
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc64(tls,
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc, uint64(uint64(nNew)*uint64(unsafe.Sizeof(UnionSrc{}))))
				if aNew == uintptr(0) {
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_NOMEM
					break
				} else {
					libc.Xmemset(tls, aNew+uintptr((*UnionTab)(unsafe.Pointer(pTab)).FnSrc)*72, 0, uint64(nNew-(*UnionTab)(unsafe.Pointer(pTab)).FnSrc)*uint64(unsafe.Sizeof(UnionSrc{})))
					(*UnionTab)(unsafe.Pointer(pTab)).FaSrc = aNew
					nAlloc = nNew
				}
			}

			// Check for problems with the specified range of rowids
			if iMax < iMin || (*UnionTab)(unsafe.Pointer(pTab)).FnSrc > 0 && iMin <= (*UnionSrc)(unsafe.Pointer((*UnionTab)(unsafe.Pointer(pTab)).FaSrc+uintptr((*UnionTab)(unsafe.Pointer(pTab)).FnSrc-1)*72)).FiMax {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8683 /* "rowid range mism..." */, 0)
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
			}

			if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
				pSrc = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(libc.PostIncInt32(&(*UnionTab)(unsafe.Pointer(pTab)).FnSrc, 1))*72
				(*UnionSrc)(unsafe.Pointer(pSrc)).FzTab = unionStrdup(tls, bp+40 /* &rc */, zTab)
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMin = iMin
				(*UnionSrc)(unsafe.Pointer(pSrc)).FiMax = iMax
				if bSwarm != 0 {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzFile = unionStrdup(tls, bp+40 /* &rc */, zDb)
				} else {
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzDb = unionStrdup(tls, bp+40 /* &rc */, zDb)
				}
				if (*UnionTab)(unsafe.Pointer(pTab)).FbHasContext != 0 {
					var zContext uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 4)
					(*UnionSrc)(unsafe.Pointer(pSrc)).FzContext = unionStrdup(tls, bp+40 /* &rc */, zContext)
				}
			}
		}
		unionFinalize(tls, bp+40 /* &rc */, pStmt, pzErr)
		pStmt = uintptr(0)

		// It is an error if the SELECT statement returned zero rows. If only
		// because there is no way to determine the schema of the virtual
		// table in this case.
		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK && (*UnionTab)(unsafe.Pointer(pTab)).FnSrc == 0 {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+8710 /* "no source tables..." */, 0)
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
		}

		// For unionvtab, verify that all source tables exist and have
		// compatible schemas. For swarmvtab, attach the first database and
		// check that the first table is a rowid table only.
		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
			if bSwarm != 0 {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = unionOpenDatabase(tls, pTab, 0, pzErr)
			} else {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = unionSourceCheck(tls, pTab, pzErr)
			}
		}

		// Compose a CREATE TABLE statement and pass it to declare_vtab()
		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
			var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc
			var tdb uintptr = func() uintptr {
				if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
					return (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb
				}
				return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
			}()
			pStmt = unionPreparePrintf(tls, bp+40 /* &rc */, pzErr, tdb,

				ts+8738, /* "SELECT 'CREATE T..." */
				libc.VaList(bp+24, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab, (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb))
		}
		if *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, pStmt) {
			var zDecl uintptr = sqlite3.Xsqlite3_column_text(tls, pStmt, 0)
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = sqlite3.Xsqlite3_declare_vtab(tls, db, zDecl)
			(*UnionTab)(unsafe.Pointer(pTab)).FiPK = sqlite3.Xsqlite3_column_int(tls, pStmt, 1)
		}

		unionFinalize(tls, bp+40 /* &rc */, pStmt, pzErr)
	}

	if *(*int32)(unsafe.Pointer(bp + 40)) != SQLITE_OK {
		unionDisconnect(tls, pTab)
		pTab = uintptr(0)
	}

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	return *(*int32)(unsafe.Pointer(bp + 40 /* rc */))
}

// xOpen
func unionOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* unionvtab.c:1033:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	_ = p // Suppress harmless warning
	pCsr = unionMalloc(tls, bp /* &rc */, int64(unsafe.Sizeof(UnionCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// xClose
func unionClose(tls *libc.TLS, cur uintptr) int32 { /* unionvtab.c:1045:12: */
	var pCsr uintptr = cur
	unionFinalizeCsrStmt(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// This function does the work of the xNext() method. Except that, if it
// returns SQLITE_ROW, it should be called again within the same xNext()
// method call. See unionNext() for details.
func doUnionNext(tls *libc.TLS, pCsr uintptr) int32 { /* unionvtab.c:1057:12: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = SQLITE_OK

	if sqlite3.Xsqlite3_step(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt) != SQLITE_ROW {
		var pTab uintptr = (*UnionCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
		*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = unionFinalizeCsrStmt(tls, pCsr)
		if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK && (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab++
			if (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc {
				var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*72
				if (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid >= (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
					// It is necessary to scan the next table.
					*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = unionOpenDatabase(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab, pTab+16)
					(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPreparePrintf(tls, bp+24 /* &rc */, pTab+16, (*UnionSrc)(unsafe.Pointer(pSrc)).Fdb,
						ts+8916, /* "SELECT rowid, * ..." */
						libc.VaList(bp, (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab,
							func() uintptr {
								if (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax > (*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid {
									return ts + 8948 /* "WHERE _rowid_ <=" */
								}
								return ts + 8965 /* "-- " */
							}(),
							(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid))
					if *(*int32)(unsafe.Pointer(bp + 24)) == SQLITE_OK {

						unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
						*(*int32)(unsafe.Pointer(bp + 24 /* rc */)) = SQLITE_ROW
					}
				}
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 24 /* rc */))
}

// xNext
func unionNext(tls *libc.TLS, cur uintptr) int32 { /* unionvtab.c:1092:12: */
	var rc int32
	for ok := true; ok; ok = rc == SQLITE_ROW {
		rc = doUnionNext(tls, cur)
	}
	return rc
}

// xColumn
func unionColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* unionvtab.c:1103:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, i+1))
	return SQLITE_OK
}

// xRowid
func unionRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* unionvtab.c:1116:12: */
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return SQLITE_OK
}

// xEof
func unionEof(tls *libc.TLS, cur uintptr) int32 { /* unionvtab.c:1125:12: */
	var pCsr uintptr = cur
	return libc.Bool32((*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0))
}

// xFilter
func unionFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* unionvtab.c:1133:12: */
	bp := tls.Alloc(108)
	defer tls.Free(108)

	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCsr uintptr = pVtabCursor
	*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_OK
	var i int32
	var zSql uintptr = uintptr(0)
	var bZero int32 = 0

	var iMin sqlite3_int64 = int64(-1) - (int64(0xffffffff) | sqlite3_int64(int64(0x7fffffff))<<32)
	var iMax sqlite3_int64 = int64(0xffffffff) | sqlite3_int64(int64(0x7fffffff))<<32

	_ = idxStr // Suppress harmless warning

	if idxNum == SQLITE_INDEX_CONSTRAINT_EQ {

		iMin = libc.AssignInt64(&iMax, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
	} else {

		if idxNum&(SQLITE_INDEX_CONSTRAINT_LE|SQLITE_INDEX_CONSTRAINT_LT) != 0 {

			iMax = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
			if idxNum&SQLITE_INDEX_CONSTRAINT_LT != 0 {
				if iMax == int64(-1)-(int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32) {
					bZero = 1
				} else {
					iMax--
				}
			}
		}

		if idxNum&(SQLITE_INDEX_CONSTRAINT_GE|SQLITE_INDEX_CONSTRAINT_GT) != 0 {

			iMin = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(argc-1)*8)))
			if idxNum&SQLITE_INDEX_CONSTRAINT_GT != 0 {
				if iMin == int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32 {
					bZero = 1
				} else {
					iMin++
				}
			}
		}
	}

	unionFinalizeCsrStmt(tls, pCsr)
	if bZero != 0 {
		return SQLITE_OK
	}

	for i = 0; i < (*UnionTab)(unsafe.Pointer(pTab)).FnSrc; i++ {
		var pSrc uintptr = (*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr(i)*72
		if iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax || iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
			continue
		}

		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+8969 /* "%z%sSELECT rowid..." */, libc.VaList(bp, zSql, func() uintptr {
			if zSql != 0 {
				return ts + 9003 /* " UNION ALL " */
			}
			return ts + 584 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5624 /* "'" */
			}
			return ts + 584 /* "" */
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb
			}
			return ts + 584
		}(), func() uintptr {
			if (*UnionSrc)(unsafe.Pointer(pSrc)).FzDb != 0 {
				return ts + 5626 /* "'." */
			}
			return ts + 584 /* "" */
		}(), (*UnionSrc)(unsafe.Pointer(pSrc)).FzTab))
		if zSql == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_NOMEM
			break
		}

		if iMin == iMax {
			zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9015 /* "%z WHERE rowid=%..." */, libc.VaList(bp+48, zSql, iMin))
		} else {
			var zWhere uintptr = ts + 9035 /* "WHERE" */
			if iMin != int64(-1)-(int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32) && iMin > (*UnionSrc)(unsafe.Pointer(pSrc)).FiMin {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9041 /* "%z WHERE rowid>=..." */, libc.VaList(bp+64, zSql, iMin))
				zWhere = ts + 9062 /* "AND" */
			}
			if iMax != int64(0xffffffff)|sqlite3_int64(int64(0x7fffffff))<<32 && iMax < (*UnionSrc)(unsafe.Pointer(pSrc)).FiMax {
				zSql = sqlite3.Xsqlite3_mprintf(tls, ts+9066 /* "%z %s rowid<=%ll..." */, libc.VaList(bp+80, zSql, zWhere, iMax))
			}
		}

		if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiTab = i
			(*UnionCsr)(unsafe.Pointer(pCsr)).FiMaxRowid = iMax
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = unionOpenDatabase(tls, pTab, i, pTab+16)
			break
		}
	}

	if zSql == uintptr(0) {
		return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
	} else {
		var db uintptr = func() uintptr {
			if (*UnionTab)(unsafe.Pointer(pTab)).FbSwarm != 0 {
				return (*UnionSrc)(unsafe.Pointer((*UnionTab)(unsafe.Pointer(pTab)).FaSrc + uintptr((*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)*72)).Fdb
			}
			return (*UnionTab)(unsafe.Pointer(pTab)).Fdb
		}()
		(*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt = unionPrepare(tls, bp+104 /* &rc */, db, zSql, pTab+16)
		if (*UnionCsr)(unsafe.Pointer(pCsr)).FpStmt != 0 {
			unionIncrRefcount(tls, pTab, (*UnionCsr)(unsafe.Pointer(pCsr)).FiTab)
		}
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	if *(*int32)(unsafe.Pointer(bp + 104)) != SQLITE_OK {
		return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
	}
	return unionNext(tls, pVtabCursor)
}

// xBestIndex.
//
// This implementation searches for constraints on the rowid field. EQ,
// LE, LT, GE and GT are handled.
//
// If there is an EQ comparison, then idxNum is set to INDEX_CONSTRAINT_EQ.
// In this case the only argument passed to xFilter is the rhs of the ==
// operator.
//
// Otherwise, if an LE or LT constraint is found, then the INDEX_CONSTRAINT_LE
// or INDEX_CONSTRAINT_LT (but not both) bit is set in idxNum. The first
// argument to xFilter is the rhs of the <= or < operator.  Similarly, if
// an GE or GT constraint is found, then the INDEX_CONSTRAINT_GE or
// INDEX_CONSTRAINT_GT bit is set in idxNum. The rhs of the >= or > operator
// is passed as either the first or second argument to xFilter, depending
// on whether or not there is also a LT|LE constraint.
func unionBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* unionvtab.c:1266:12: */
	var pTab uintptr = tab
	var iEq int32 = -1
	var iLt int32 = -1
	var iGt int32 = -1
	var i int32

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0 && ((*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn < 0 || (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == (*UnionTab)(unsafe.Pointer(pTab)).FiPK) {
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) {
			case SQLITE_INDEX_CONSTRAINT_EQ:
				iEq = i
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LE:
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LT:
				iLt = i
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GE:
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GT:
				iGt = i
				break
			}
		}
	}

	if iEq >= 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = int64(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxFlags = SQLITE_INDEX_SCAN_UNIQUE
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 3.0
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = SQLITE_INDEX_CONSTRAINT_EQ
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iEq)*8)).Fomit = uint8(1)
	} else {
		var iCons int32 = 1
		var idxNum int32 = 0
		var nRow sqlite3_int64 = int64(1000000)
		if iLt >= 0 {
			nRow = nRow / int64(2)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).FargvIndex = libc.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iLt)*8)).Fomit = uint8(1)
			idxNum = idxNum | int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(iLt)*12)).Fop)
		}
		if iGt >= 0 {
			nRow = nRow / int64(2)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).FargvIndex = libc.PostIncInt32(&iCons, 1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(iGt)*8)).Fomit = uint8(1)
			idxNum = idxNum | int32((*sqlite3_index_constraint)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint+uintptr(iGt)*12)).Fop)
		}
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = nRow
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 3.0 * float64(nRow)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	}

	return SQLITE_OK
}

// Register the unionvtab virtual table module with database handle db.
func createUnionVtab(tls *libc.TLS, db uintptr) int32 { /* unionvtab.c:1329:12: */
	var rc int32

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8564 /* "unionvtab" */, uintptr(unsafe.Pointer(&unionModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_module(tls, db, ts+8554 /* "swarmvtab" */, uintptr(unsafe.Pointer(&unionModule)), db)
	}
	return rc
}

var unionModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0, // xBestIndex - query planner
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xShadowName
} /* unionvtab.c:1330:25 */

func sqlite3_unionvtab_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* unionvtab.c:1370:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	_ = pzErrMsg // Suppress harmless warning
	rc = createUnionVtab(tls, db)
	return rc
}

// A wholenumber cursor object
type wholenumber_cursor1 = struct {
	Fbase    sqlite3_vtab_cursor
	FiValue  sqlite3_int64
	FmxValue sqlite3_int64
} /* wholenumber.c:34:9 */

// A wholenumber cursor object
type wholenumber_cursor = wholenumber_cursor1 /* wholenumber.c:34:35 */

// Methods for the wholenumber module
func wholenumberConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* wholenumber.c:42:12: */
	var pNew uintptr
	pNew = libc.AssignPtrUintptr(ppVtab, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(sqlite3_vtab{}))))
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+9084 /* "CREATE TABLE x(v..." */)
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_INNOCUOUS, 0)
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(sqlite3_vtab{})))
	return SQLITE_OK
}

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func wholenumberDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* wholenumber.c:60:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// The xDisconnect and xDestroy methods are also the same

// Open a new wholenumber cursor.
func wholenumberOpen(tls *libc.TLS, p uintptr, ppCursor uintptr) int32 { /* wholenumber.c:70:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(wholenumber_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(wholenumber_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Close a wholenumber cursor.
func wholenumberClose(tls *libc.TLS, cur uintptr) int32 { /* wholenumber.c:82:12: */
	sqlite3.Xsqlite3_free(tls, cur)
	return SQLITE_OK
}

// Advance a cursor to its next row of output
func wholenumberNext(tls *libc.TLS, cur uintptr) int32 { /* wholenumber.c:91:12: */
	var pCur uintptr = cur
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue++
	return SQLITE_OK
}

// Return the value associated with a wholenumber.
func wholenumberColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* wholenumber.c:100:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_result_int64(tls, ctx, (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue)
	return SQLITE_OK
}

// The rowid.
func wholenumberRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* wholenumber.c:113:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue
	return SQLITE_OK
}

// When the wholenumber_cursor.rLimit value is 0 or less, that is a signal
// that the cursor has nothing more to output.
func wholenumberEof(tls *libc.TLS, cur uintptr) int32 { /* wholenumber.c:123:12: */
	var pCur uintptr = cur
	return libc.Bool32((*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue || (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue == int64(0))
}

// Called to "rewind" a cursor back to the beginning so that
// it starts its output over again.  Always called at least once
// prior to any wholenumberColumn, wholenumberRowid, or wholenumberEof call.
//
//    idxNum   Constraints
//    ------   ---------------------
//      0      (none)
//      1      value > $argv0
//      2      value >= $argv0
//      4      value < $argv0
//      8      value <= $argv0
//
//      5      value > $argv0 AND value < $argv1
//      6      value >= $argv0 AND value < $argv1
//      9      value > $argv0 AND value <= $argv1
//     10      value >= $argv0 AND value <= $argv1
func wholenumberFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* wholenumber.c:146:12: */
	var pCur uintptr = pVtabCursor
	var v sqlite3_int64
	var i int32 = 0
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = int64(1)
	(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = int64(0xffffffff) // 4294967295
	if idxNum&3 != 0 {
		v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))) + sqlite3_int64(idxNum&1)
		if v > (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue && v <= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue = v
		}
		i++
	}
	if idxNum&12 != 0 {
		v = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) - sqlite3_int64(idxNum>>2&1)
		if v >= (*wholenumber_cursor)(unsafe.Pointer(pCur)).FiValue && v < (*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue {
			(*wholenumber_cursor)(unsafe.Pointer(pCur)).FmxValue = v
		}
	}
	return SQLITE_OK
}

// Search for terms of these forms:
//
//  (1)  value > $value
//  (2)  value >= $value
//  (4)  value < $value
//  (8)  value <= $value
//
// idxNum is an ORed combination of 1 or 2 with 4 or 8.
func wholenumberBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* wholenumber.c:178:12: */
	var i int32
	var idxNum int32 = 0
	var argvIdx int32 = 1
	var ltIdx int32 = -1
	var gtIdx int32 = -1
	var pConstraint uintptr
	pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint
	i = 0
__1:
	if !(i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint) {
		goto __3
	}
	{
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) == 0 {
			goto __2
		}
		if idxNum&3 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_GT {
			idxNum = idxNum | 1
			ltIdx = i
		}
		if idxNum&3 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_GE {
			idxNum = idxNum | 2
			ltIdx = i
		}
		if idxNum&12 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LT {
			idxNum = idxNum | 4
			gtIdx = i
		}
		if idxNum&12 == 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) == SQLITE_INDEX_CONSTRAINT_LE {
			idxNum = idxNum | 8
			gtIdx = i
		}

	}
	goto __2
__2:
	i++
	pConstraint += 12
	goto __1
	goto __3
__3:
	;
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = idxNum
	if ltIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).FargvIndex = libc.PostIncInt32(&argvIdx, 1)
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ltIdx)*8)).Fomit = uint8(1)
	}
	if gtIdx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).FargvIndex = argvIdx
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(gtIdx)*8)).Fomit = uint8(1)
	}
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 &&
		int32((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc) == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}
	if idxNum&12 == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1e99
	} else if idxNum&3 == 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(5)
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(1)
	}
	return SQLITE_OK
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var wholenumberModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* wholenumber.c:236:23 */

func sqlite3_wholenumber_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* wholenumber.c:264:5: */
	var rc int32 = SQLITE_OK
	_ = pApi

	rc = sqlite3.Xsqlite3_create_module(tls, db, ts+9106 /* "wholenumber" */, uintptr(unsafe.Pointer(&wholenumberModule)), uintptr(0))
	return rc
}

type max_align_t = struct {
	F__max_align1 int64
	F__max_align2 float64
} /* stddef.h:69:23 */

// ISO/IEC 9899:2011 K.3.3.2

type z_size_t = size_t /* zconf.h:254:21 */

// Maximum value for memLevel in deflateInit2

// Maximum value for windowBits in deflateInit2 and inflateInit2.
// WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
// created by gzip. (Files created by minigzip can still be extracted by
// gzip.)

// The memory requirements for deflate are (in bytes):
//             (1 << (windowBits+2)) +  (1 << (memLevel+9))
//  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
//  plus a few kilobytes for small objects. For example, if you want to reduce
//  the default memory requirements from 256K to 128K, compile with
//      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
//  Of course this will generally degrade compression (there's no free lunch).
//
//    The memory requirements for inflate are (in bytes) 1 << windowBits
//  that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
//  for small objects.

// Type declarations

// The following definitions for FAR are needed only for MSDOS mixed
// model programming (small or medium model with some far allocations).
// This was tested only with MSC; for other MSDOS compilers you may have
// to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
// just define FAR to be empty.

type Byte = uint8   /* zconf.h:397:24 */ // 8 bits
type uInt = uint32  /* zconf.h:399:24 */ // 16 bits or more
type uLong = uint64 /* zconf.h:400:24 */ // 32 bits or more

type Bytef = Byte   /* zconf.h:406:22 */
type charf = int8   /* zconf.h:408:19 */
type intf = int32   /* zconf.h:409:19 */
type uIntf = uInt   /* zconf.h:410:19 */
type uLongf = uLong /* zconf.h:411:19 */

type voidpc = uintptr /* zconf.h:414:23 */
type voidpf = uintptr /* zconf.h:415:23 */
type voidp = uintptr  /* zconf.h:416:23 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.2 (Berkeley) 1/4/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)syslimits.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// Do not add any new variables here.  (See the comment at the end of
// the file for why.)

// We leave the following values undefined to force applications to either
// assume conservative values or call sysconf() to get the current value.
//
// HOST_NAME_MAX
//
// (We should do this for most of the values currently defined here,
// but many programs are not prepared to deal with this yet.)

type z_crc_t = uint32 /* zconf.h:435:17 */

// These declarations belong elsewhere, but are repeated here and in
// <stdio.h> to give broken programs a better chance of working with
// 64-bit off_t's.

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause
//
// Copyright (c) 2017 Poul-Henning Kamp.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
// "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
// though the former does not conform to the LFS document), but considering
// both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
// equivalently requesting no 64-bit operations

// This is hard-configured for FreeBSD.

// MVS linker does not support external names larger than 8 bytes

//
//     The 'zlib' compression library provides in-memory compression and
//   decompression functions, including integrity checks of the uncompressed data.
//   This version of the library supports only one compression method (deflation)
//   but other algorithms will be added later and will have the same stream
//   interface.
//
//     Compression can be done in a single step if the buffers are large enough,
//   or can be done by repeated calls of the compression function.  In the latter
//   case, the application must provide more input and/or consume the output
//   (providing more output space) before each call.
//
//     The compressed data format used by default by the in-memory functions is
//   the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
//   around a deflate stream, which is itself documented in RFC 1951.
//
//     The library also supports reading and writing files in gzip (.gz) format
//   with an interface similar to that of stdio using the functions that start
//   with "gz".  The gzip format is different from the zlib format.  gzip is a
//   gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
//
//     This library can optionally read and write gzip and raw deflate streams in
//   memory as well.
//
//     The zlib format was designed to be compact and fast for use in memory
//   and on communications channels.  The gzip format was designed for single-
//   file compression on file systems, has a larger header than zlib to maintain
//   directory information, and uses a different, slower check method than zlib.
//
//     The library does not install any signal handler.  The decoder checks
//   the consistency of the compressed data, so the library should never crash
//   even in the case of corrupted input.

type alloc_func = uintptr /* zlib.h:81:16 */
type free_func = uintptr  /* zlib.h:82:16 */

type z_stream_s = struct {
	Fnext_in     uintptr
	Favail_in    uInt
	F__ccgo_pad1 [4]byte
	Ftotal_in    uLong
	Fnext_out    uintptr
	Favail_out   uInt
	F__ccgo_pad2 [4]byte
	Ftotal_out   uLong
	Fmsg         uintptr
	Fstate       uintptr
	Fzalloc      alloc_func
	Fzfree       free_func
	Fopaque      voidpf
	Fdata_type   int32
	F__ccgo_pad3 [4]byte
	Fadler       uLong
	Freserved    uLong
} /* zlib.h:86:9 */

type z_stream = z_stream_s /* zlib.h:106:3 */

type z_streamp = uintptr /* zlib.h:108:22 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type gz_header_s = struct {
	Ftext        int32
	F__ccgo_pad1 [4]byte
	Ftime        uLong
	Fxflags      int32
	Fos          int32
	Fextra       uintptr
	Fextra_len   uInt
	Fextra_max   uInt
	Fname        uintptr
	Fname_max    uInt
	F__ccgo_pad2 [4]byte
	Fcomment     uintptr
	Fcomm_max    uInt
	Fhcrc        int32
	Fdone        int32
	F__ccgo_pad3 [4]byte
} /* zlib.h:114:9 */

//
//      gzip header information passed to and from zlib routines.  See RFC 1952
//   for more details on the meanings of these fields.
type gz_header = gz_header_s /* zlib.h:129:3 */

type gz_headerp = uintptr /* zlib.h:131:23 */
//
//      inflateGetHeader() requests that gzip header information be stored in the
//    provided gz_header structure.  inflateGetHeader() may be called after
//    inflateInit2() or inflateReset(), and before the first call of inflate().
//    As inflate() processes the gzip stream, head->done is zero until the header
//    is completed, at which time head->done is set to one.  If a zlib stream is
//    being decoded, then head->done is set to -1 to indicate that there will be
//    no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
//    used to force inflate() to return immediately after header processing is
//    complete and before any actual data is decompressed.
//
//      The text, time, xflags, and os fields are filled in with the gzip header
//    contents.  hcrc is set to true if there is a header CRC.  (The header CRC
//    was valid if done is set to one.) If extra is not Z_NULL, then extra_max
//    contains the maximum number of bytes to write to extra.  Once done is true,
//    extra_len contains the actual extra field length, and extra contains the
//    extra field, or that field truncated if extra_max is less than extra_len.
//    If name is not Z_NULL, then up to name_max characters are written there,
//    terminated with a zero unless the length is greater than name_max.  If
//    comment is not Z_NULL, then up to comm_max characters are written there,
//    terminated with a zero unless the length is greater than comm_max.  When any
//    of extra, name, or comment are not Z_NULL and the respective field is not
//    present in the header, then that field is set to Z_NULL to signal its
//    absence.  This allows the use of deflateSetHeader() with the returned
//    structure to duplicate the header.  However if those fields are set to
//    allocated memory, then the application will need to save those pointers
//    elsewhere so that they can be eventually freed.
//
//      If inflateGetHeader is not used, then the header information is simply
//    discarded.  The header is always checked for validity, including the header
//    CRC if present.  inflateReset() will reset the process to discard the header
//    information.  The application would need to call inflateGetHeader() again to
//    retrieve the header from the next gzip stream.
//
//      inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
//    stream state was inconsistent.

//
// ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
//                                         unsigned char FAR *window));
//
//      Initialize the internal stream state for decompression using inflateBack()
//    calls.  The fields zalloc, zfree and opaque in strm must be initialized
//    before the call.  If zalloc and zfree are Z_NULL, then the default library-
//    derived memory allocation routines are used.  windowBits is the base two
//    logarithm of the window size, in the range 8..15.  window is a caller
//    supplied buffer of that size.  Except for special applications where it is
//    assured that deflate was used with small window sizes, windowBits must be 15
//    and a 32K byte window must be supplied to be able to decompress general
//    deflate streams.
//
//      See inflateBack() for the usage of these routines.
//
//      inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
//    the parameters are invalid, Z_MEM_ERROR if the internal state could not be
//    allocated, or Z_VERSION_ERROR if the version of the library does not match
//    the version of the header file.

type in_func = uintptr  /* zlib.h:1093:18 */
type out_func = uintptr /* zlib.h:1095:13 */
//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type gzFile_s = struct {
	Fhave        uint32
	F__ccgo_pad1 [4]byte
	Fnext        uintptr
	Fpos         off_t
} /* zlib.h:1304:9 */

//
//      Same as uncompress, except that sourceLen is a pointer, where the
//    length of the source is *sourceLen.  On return, *sourceLen is the number of
//    source bytes consumed.

// gzip file access functions

//
//      This library supports reading and writing files in gzip (.gz) format with
//    an interface similar to that of stdio, using the functions that start with
//    "gz".  The gzip format is different from the zlib format.  gzip is a gzip
//    wrapper, documented in RFC 1952, wrapped around a deflate stream.

type gzFile = uintptr /* zlib.h:1304:25 */ // 2-byte unsigned integer

// Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
//
// In some ways it would be better to obtain these values from system
// header files. But, the dependency is undesirable and (a) these
// have been stable for decades, (b) the values are part of POSIX and
// are also made explicit in [man stat], and (c) are part of the
// file format for zip archives.

var ZIPFILE_SCHEMA =

// 0: Name of file in zip archive
// 1: POSIX mode for file
// 2: Last modification time (secs since 1970)
// 3: Size of object
// 4: Raw data
// 5: Uncompressed data
// 6: Compression method (integer)
// 7: Name of zip file
*(*[91]int8)(unsafe.Pointer(ts + 9118 /* "CREATE TABLE y(n..." */)) /* zipfile.c:94:19 */

// Magic numbers used to read and write zip files.
//
// ZIPFILE_NEWENTRY_MADEBY:
//   Use this value for the "version-made-by" field in new zip file
//   entries. The upper byte indicates "unix", and the lower byte
//   indicates that the zip file matches pkzip specification 3.0.
//   This is what info-zip seems to do.
//
// ZIPFILE_NEWENTRY_REQUIRED:
//   Value for "version-required-to-extract" field of new entries.
//   Version 2.0 is required to support folders and deflate compression.
//
// ZIPFILE_NEWENTRY_FLAGS:
//   Value for "general-purpose-bit-flags" field of new entries. Bit
//   11 means "utf-8 filename and comment".
//
// ZIPFILE_SIGNATURE_CDS:
//   First 4 bytes of a valid CDS record.
//
// ZIPFILE_SIGNATURE_LFH:
//   First 4 bytes of a valid LFH record.
//
// ZIPFILE_SIGNATURE_EOCD
//   First 4 bytes of a valid EOCD record.

// The sizes of the fixed-size part of each of the three main data
// structures in a zip archive.

// 4.3.16  End of central directory record:
//
//   end of central dir signature    4 bytes  (0x06054b50)
//   number of this disk             2 bytes
//   number of the disk with the
//   start of the central directory  2 bytes
//   total number of entries in the
//   central directory on this disk  2 bytes
//   total number of entries in
//   the central directory           2 bytes
//   size of the central directory   4 bytes
//   offset of start of central
//   directory with respect to
//   the starting disk number        4 bytes
//   .ZIP file comment length        2 bytes
//   .ZIP file comment       (variable size)
type ZipfileEOCD1 = struct {
	FiDisk       u16
	FiFirstDisk  u16
	FnEntry      u16
	FnEntryTotal u16
	FnSize       u32
	FiOffset     u32
} /* zipfile.c:170:9 */

// Magic numbers used to read and write zip files.
//
// ZIPFILE_NEWENTRY_MADEBY:
//   Use this value for the "version-made-by" field in new zip file
//   entries. The upper byte indicates "unix", and the lower byte
//   indicates that the zip file matches pkzip specification 3.0.
//   This is what info-zip seems to do.
//
// ZIPFILE_NEWENTRY_REQUIRED:
//   Value for "version-required-to-extract" field of new entries.
//   Version 2.0 is required to support folders and deflate compression.
//
// ZIPFILE_NEWENTRY_FLAGS:
//   Value for "general-purpose-bit-flags" field of new entries. Bit
//   11 means "utf-8 filename and comment".
//
// ZIPFILE_SIGNATURE_CDS:
//   First 4 bytes of a valid CDS record.
//
// ZIPFILE_SIGNATURE_LFH:
//   First 4 bytes of a valid LFH record.
//
// ZIPFILE_SIGNATURE_EOCD
//   First 4 bytes of a valid EOCD record.

// The sizes of the fixed-size part of each of the three main data
// structures in a zip archive.

// 4.3.16  End of central directory record:
//
//   end of central dir signature    4 bytes  (0x06054b50)
//   number of this disk             2 bytes
//   number of the disk with the
//   start of the central directory  2 bytes
//   total number of entries in the
//   central directory on this disk  2 bytes
//   total number of entries in
//   the central directory           2 bytes
//   size of the central directory   4 bytes
//   offset of start of central
//   directory with respect to
//   the starting disk number        4 bytes
//   .ZIP file comment length        2 bytes
//   .ZIP file comment       (variable size)
type ZipfileEOCD = ZipfileEOCD1 /* zipfile.c:170:28 */

// 4.3.12  Central directory structure:
//
// ...
//
//   central file header signature   4 bytes  (0x02014b50)
//   version made by                 2 bytes
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//   file comment length             2 bytes
//   disk number start               2 bytes
//   internal file attributes        2 bytes
//   external file attributes        4 bytes
//   relative offset of local header 4 bytes
type ZipfileCDS1 = struct {
	FiVersionMadeBy  u16
	FiVersionExtract u16
	Fflags           u16
	FiCompression    u16
	FmTime           u16
	FmDate           u16
	Fcrc32           u32
	FszCompressed    u32
	FszUncompressed  u32
	FnFile           u16
	FnExtra          u16
	FnComment        u16
	FiDiskStart      u16
	FiInternalAttr   u16
	F__ccgo_pad1     [2]byte
	FiExternalAttr   u32
	FiOffset         u32
	F__ccgo_pad2     [4]byte
	FzFile           uintptr
} /* zipfile.c:203:9 */

// 4.3.12  Central directory structure:
//
// ...
//
//   central file header signature   4 bytes  (0x02014b50)
//   version made by                 2 bytes
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//   file comment length             2 bytes
//   disk number start               2 bytes
//   internal file attributes        2 bytes
//   external file attributes        4 bytes
//   relative offset of local header 4 bytes
type ZipfileCDS = ZipfileCDS1 /* zipfile.c:203:27 */

// 4.3.7  Local file header:
//
//   local file header signature     4 bytes  (0x04034b50)
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//
type ZipfileLFH1 = struct {
	FiVersionExtract u16
	Fflags           u16
	FiCompression    u16
	FmTime           u16
	FmDate           u16
	F__ccgo_pad1     [2]byte
	Fcrc32           u32
	FszCompressed    u32
	FszUncompressed  u32
	FnFile           u16
	FnExtra          u16
} /* zipfile.c:240:9 */

// 4.3.7  Local file header:
//
//   local file header signature     4 bytes  (0x04034b50)
//   version needed to extract       2 bytes
//   general purpose bit flag        2 bytes
//   compression method              2 bytes
//   last mod file time              2 bytes
//   last mod file date              2 bytes
//   crc-32                          4 bytes
//   compressed size                 4 bytes
//   uncompressed size               4 bytes
//   file name length                2 bytes
//   extra field length              2 bytes
//
type ZipfileLFH = ZipfileLFH1 /* zipfile.c:240:27 */

type ZipfileEntry1 = struct {
	Fcds         ZipfileCDS
	FmUnixTime   u32
	F__ccgo_pad1 [4]byte
	FaExtra      uintptr
	FiDataOff    i64
	FaData       uintptr
	FpNext       uintptr
} /* zipfile.c:254:9 */

type ZipfileEntry = ZipfileEntry1 /* zipfile.c:254:29 */

// Cursor type for zipfile tables.
type ZipfileCsr1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiId         i64
	FbEof        u8
	FbNoop       u8
	F__ccgo_pad1 [6]byte
	FpFile       uintptr
	FiNextOff    i64
	Feocd        ZipfileEOCD
	FpFreeEntry  uintptr
	FpCurrent    uintptr
	FpCsrNext    uintptr
} /* zipfile.c:267:9 */

// Cursor type for zipfile tables.
type ZipfileCsr = ZipfileCsr1 /* zipfile.c:267:27 */

type ZipfileTab1 = struct {
	Fbase        sqlite3_vtab
	FzFile       uintptr
	Fdb          uintptr
	FaBuffer     uintptr
	FpCsrList    uintptr
	FiNextCsrid  i64
	FpFirstEntry uintptr
	FpLastEntry  uintptr
	FpWriteFd    uintptr
	FszCurrent   i64
	FszOrig      i64
} /* zipfile.c:284:9 */

type ZipfileTab = ZipfileTab1 /* zipfile.c:284:27 */

// Set the error message contained in context ctx to the results of
// vprintf(zFmt, ...).
func zipfileCtxErrorMsg(tls *libc.TLS, ctx uintptr, zFmt uintptr, va uintptr) { /* zipfile.c:306:13: */
	var zMsg uintptr = uintptr(0)
	var ap va_list
	_ = ap
	ap = va
	zMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	sqlite3.Xsqlite3_result_error(tls, ctx, zMsg, -1)
	sqlite3.Xsqlite3_free(tls, zMsg)
	_ = ap
}

// If string zIn is quoted, dequote it in place. Otherwise, if the string
// is not quoted, do nothing.
func zipfileDequote(tls *libc.TLS, zIn uintptr) { /* zipfile.c:320:13: */
	var q int8 = *(*int8)(unsafe.Pointer(zIn))
	if int32(q) == '"' || int32(q) == '\'' || int32(q) == '`' || int32(q) == '[' {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}
		for *(*int8)(unsafe.Pointer(zIn + uintptr(iIn))) != 0 {
			var c int8 = *(*int8)(unsafe.Pointer(zIn + uintptr(libc.PostIncInt32(&iIn, 1))))
			if int32(c) == int32(q) && int32(*(*int8)(unsafe.Pointer(zIn + uintptr(libc.PostIncInt32(&iIn, 1))))) != int32(q) {
				break
			}
			*(*int8)(unsafe.Pointer(zIn + uintptr(libc.PostIncInt32(&iOut, 1)))) = c
		}
		*(*int8)(unsafe.Pointer(zIn + uintptr(iOut))) = int8(0)
	}
}

// Construct a new ZipfileTab virtual table object.
//
//   argv[0]   -> module name  ("zipfile")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> "column name" and other module argument fields.
func zipfileConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* zipfile.c:343:12: */
	var nByte int32 = int32(uint64(unsafe.Sizeof(ZipfileTab{})) + uint64(64*1024))
	var nFile int32 = 0
	var zFile uintptr = uintptr(0)
	var pNew uintptr = uintptr(0)
	var rc int32

	// If the table name is not "zipfile", require that the argument be
	// specified. This stops zipfile tables from being created as:
	//
	//   CREATE VIRTUAL TABLE zzz USING zipfile();
	//
	// It does not prevent:
	//
	//   CREATE VIRTUAL TABLE zipfile USING zipfile();

	if 0 != sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+9209) && argc < 4 || argc > 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9217 /* "zipfile construc..." */, 0)
		return SQLITE_ERROR
	}

	if argc > 3 {
		zFile = *(*uintptr)(unsafe.Pointer(argv + 3*8))
		nFile = int32(libc.Xstrlen(tls, zFile)) + 1
	}

	rc = sqlite3.Xsqlite3_declare_vtab(tls, db, uintptr(unsafe.Pointer(&ZIPFILE_SCHEMA)))
	if rc == SQLITE_OK {
		pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(sqlite3_int64(nByte)+sqlite3_int64(nFile)))
		if pNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pNew, 0, uint64(nByte+nFile))
		(*ZipfileTab)(unsafe.Pointer(pNew)).Fdb = db
		(*ZipfileTab)(unsafe.Pointer(pNew)).FaBuffer = pNew + 1*104
		if zFile != 0 {
			(*ZipfileTab)(unsafe.Pointer(pNew)).FzFile = (*ZipfileTab)(unsafe.Pointer(pNew)).FaBuffer + 65536
			libc.Xmemcpy(tls, (*ZipfileTab)(unsafe.Pointer(pNew)).FzFile, zFile, uint64(nFile))
			zipfileDequote(tls, (*ZipfileTab)(unsafe.Pointer(pNew)).FzFile)
		}
	}
	sqlite3.Xsqlite3_vtab_config(tls, db, SQLITE_VTAB_DIRECTONLY, 0)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pNew
	return rc
}

// Free the ZipfileEntry structure indicated by the only argument.
func zipfileEntryFree(tls *libc.TLS, p uintptr) { /* zipfile.c:397:13: */
	if p != 0 {
		sqlite3.Xsqlite3_free(tls, (*ZipfileEntry)(unsafe.Pointer(p)).Fcds.FzFile)
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// Release resources that should be freed at the end of a write
// transaction.
func zipfileCleanupTransaction(tls *libc.TLS, pTab uintptr) { /* zipfile.c:408:13: */
	var pEntry uintptr
	var pNext uintptr

	if (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd != 0 {
		libc.Xfclose(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd)
		(*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd = uintptr(0)
	}
	for pEntry = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry; pEntry != 0; pEntry = pNext {
		pNext = (*ZipfileEntry)(unsafe.Pointer(pEntry)).FpNext
		zipfileEntryFree(tls, pEntry)
	}
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry = uintptr(0)
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpLastEntry = uintptr(0)
	(*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent = int64(0)
	(*ZipfileTab)(unsafe.Pointer(pTab)).FszOrig = int64(0)
}

// This method is the destructor for zipfile vtab objects.
func zipfileDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:429:12: */
	zipfileCleanupTransaction(tls, pVtab)
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// Constructor for a new ZipfileCsr object.
func zipfileOpen(tls *libc.TLS, p uintptr, ppCsr uintptr) int32 { /* zipfile.c:438:12: */
	var pTab uintptr = p
	var pCsr uintptr
	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ZipfileCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCsr)) = pCsr
	if pCsr == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint64(unsafe.Sizeof(ZipfileCsr{})))
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FiId = libc.PreIncInt64(&(*ZipfileTab)(unsafe.Pointer(pTab)).FiNextCsrid, 1)
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext = (*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList = pCsr
	return SQLITE_OK
}

// Reset a cursor back to the state it was in when first returned
// by zipfileOpen().
func zipfileResetCursor(tls *libc.TLS, pCsr uintptr) { /* zipfile.c:457:13: */
	var p uintptr
	var pNext uintptr

	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(0)
	if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile != 0 {
		libc.Xfclose(tls, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile = uintptr(0)
		zipfileEntryFree(tls, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = uintptr(0)
	}

	for p = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry; p != 0; p = pNext {
		pNext = (*ZipfileEntry)(unsafe.Pointer(p)).FpNext
		zipfileEntryFree(tls, p)
	}
}

// Destructor for an ZipfileCsr.
func zipfileClose(tls *libc.TLS, cur uintptr) int32 { /* zipfile.c:478:12: */
	var pCsr uintptr = cur
	var pTab uintptr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	var pp uintptr
	zipfileResetCursor(tls, pCsr)

	// Remove this cursor from the ZipfileTab.pCsrList list.
	for pp = pTab + 48; *(*uintptr)(unsafe.Pointer(pp)) != pCsr; pp = *(*uintptr)(unsafe.Pointer(pp)) + 72 {
	}
	*(*uintptr)(unsafe.Pointer(pp)) = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext

	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// Set the error message for the virtual table associated with cursor
// pCsr to the results of vprintf(zFmt, ...).
func zipfileTableErr(tls *libc.TLS, pTab uintptr, zFmt uintptr, va uintptr) { /* zipfile.c:496:13: */
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_free(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg)
	(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

func zipfileCursorErr(tls *libc.TLS, pCsr uintptr, zFmt uintptr, va uintptr) { /* zipfile.c:503:13: */
	var ap va_list
	_ = ap
	ap = va
	sqlite3.Xsqlite3_free(tls, (*sqlite3_vtab)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab)).FzErrMsg)
	(*sqlite3_vtab)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab)).FzErrMsg = sqlite3.Xsqlite3_vmprintf(tls, zFmt, ap)
	_ = ap
}

// Read nRead bytes of data from offset iOff of file pFile into buffer
// aRead[]. Return SQLITE_OK if successful, or an SQLite error code
// otherwise.
//
// If an error does occur, output variable (*pzErrmsg) may be set to point
// to an English language error message. It is the responsibility of the
// caller to eventually free this buffer using
// sqlite3_free().
func zipfileReadData(tls *libc.TLS, pFile uintptr, aRead uintptr, nRead int32, iOff i64, pzErrmsg uintptr) int32 { /* zipfile.c:521:12: */
	var n size_t
	libc.Xfseek(tls, pFile, int64(iOff), SEEK_SET)
	n = libc.Xfread(tls, aRead, uint64(1), uint64(nRead), pFile)
	if int32(n) != nRead {
		*(*uintptr)(unsafe.Pointer(pzErrmsg)) = sqlite3.Xsqlite3_mprintf(tls, ts+9259 /* "error in fread()" */, 0)
		return SQLITE_ERROR
	}
	return SQLITE_OK
}

func zipfileAppendData(tls *libc.TLS, pTab uintptr, aWrite uintptr, nWrite int32) int32 { /* zipfile.c:538:12: */
	if nWrite > 0 {
		var n size_t = size_t(nWrite)
		libc.Xfseek(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, int64((*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent), SEEK_SET)
		n = libc.Xfwrite(tls, aWrite, uint64(1), uint64(nWrite), (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd)
		if int32(n) != nWrite {
			(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+9276 /* "error in fwrite(..." */, 0)
			return SQLITE_ERROR
		}
		*(*i64)(unsafe.Pointer(pTab + 88)) += i64(nWrite)
	}
	return SQLITE_OK
}

// Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
func zipfileGetU16(tls *libc.TLS, aBuf uintptr) u16 { /* zipfile.c:559:12: */
	return u16(int32(*(*u8)(unsafe.Pointer(aBuf + 1)))<<8 + int32(*(*u8)(unsafe.Pointer(aBuf))))
}

// Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
func zipfileGetU32(tls *libc.TLS, aBuf uintptr) u32 { /* zipfile.c:566:12: */
	if aBuf == uintptr(0) {
		return u32(0)
	}
	return u32(*(*u8)(unsafe.Pointer(aBuf + 3)))<<24 +
		u32(*(*u8)(unsafe.Pointer(aBuf + 2)))<<16 +
		u32(*(*u8)(unsafe.Pointer(aBuf + 1)))<<8 +
		u32(*(*u8)(unsafe.Pointer(aBuf)))<<0
}

// Write a 16-bit little endiate integer into buffer aBuf.
func zipfilePutU16(tls *libc.TLS, aBuf uintptr, val u16) { /* zipfile.c:577:13: */
	*(*u8)(unsafe.Pointer(aBuf)) = u8(int32(val) & 0xFF)
	*(*u8)(unsafe.Pointer(aBuf + 1)) = u8(int32(val) >> 8 & 0xFF)
}

// Write a 32-bit little endiate integer into buffer aBuf.
func zipfilePutU32(tls *libc.TLS, aBuf uintptr, val u32) { /* zipfile.c:585:13: */
	*(*u8)(unsafe.Pointer(aBuf)) = u8(val & u32(0xFF))
	*(*u8)(unsafe.Pointer(aBuf + 1)) = u8(val >> 8 & u32(0xFF))
	*(*u8)(unsafe.Pointer(aBuf + 2)) = u8(val >> 16 & u32(0xFF))
	*(*u8)(unsafe.Pointer(aBuf + 3)) = u8(val >> 24 & u32(0xFF))
}

// Magic numbers used to read CDS records.

// Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
// if the record is not well-formed, or SQLITE_OK otherwise.
func zipfileReadCDS(tls *libc.TLS, aBuf uintptr, pCDS uintptr) int32 { /* zipfile.c:608:12: */
	var aRead uintptr = aBuf
	var sig u32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
	var rc int32 = SQLITE_OK
	if sig != u32(ZIPFILE_SIGNATURE_CDS) {
		rc = SQLITE_ERROR
	} else {
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionMadeBy = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionExtract = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).Fflags = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).Fcrc32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FszCompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()

		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnComment = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiDiskStart = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiInternalAttr = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FiOffset = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()

	}

	return rc
}

// Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
// if the record is not well-formed, or SQLITE_OK otherwise.
func zipfileReadLFH(tls *libc.TLS, aBuffer uintptr, pLFH uintptr) int32 { /* zipfile.c:642:12: */
	var aRead uintptr = aBuffer
	var rc int32 = SQLITE_OK

	var sig u32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
	if sig != u32(ZIPFILE_SIGNATURE_LFH) {
		rc = SQLITE_ERROR
	} else {
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FiVersionExtract = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).Fflags = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FiCompression = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FmTime = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FmDate = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).Fcrc32 = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FszCompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FszUncompressed = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FnFile = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileLFH)(unsafe.Pointer(pLFH)).FnExtra = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
	}
	return rc
}

// Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
// Scan through this buffer to find an "extra-timestamp" field. If one
// exists, extract the 32-bit modification-timestamp from it and store
// the value in output parameter *pmTime.
//
// Zero is returned if no extra-timestamp record could be found (and so
// *pmTime is left unchanged), or non-zero otherwise.
//
// The general format of an extra field is:
//
//   Header ID    2 bytes
//   Data Size    2 bytes
//   Data         N bytes
func zipfileScanExtra(tls *libc.TLS, aExtra uintptr, nExtra int32, pmTime uintptr) int32 { /* zipfile.c:683:12: */
	var ret int32 = 0
	var p uintptr = aExtra
	var pEnd uintptr = aExtra + uintptr(nExtra)

	for p < pEnd {
		var id u16 = func() u16 { p += uintptr(2); return zipfileGetU16(tls, p-uintptr(2)) }()
		var nByte u16 = func() u16 { p += uintptr(2); return zipfileGetU16(tls, p-uintptr(2)) }()

		switch int32(id) {
		case ZIPFILE_EXTRA_TIMESTAMP:
			{
				var b u8 = *(*u8)(unsafe.Pointer(p))
				if int32(b)&0x01 != 0 { // 0x01 -> modtime is present
					*(*u32)(unsafe.Pointer(pmTime)) = zipfileGetU32(tls, p+1)
					ret = 1
				}
				break

			}
		}

		p += uintptr(nByte)
	}
	return ret
}

// Convert the standard MS-DOS timestamp stored in the mTime and mDate
// fields of the CDS structure passed as the only argument to a 32-bit
// UNIX seconds-since-the-epoch timestamp. Return the result.
//
// "Standard" MS-DOS time format:
//
//   File modification time:
//     Bits 00-04: seconds divided by 2
//     Bits 05-10: minute
//     Bits 11-15: hour
//   File modification date:
//     Bits 00-04: day
//     Bits 05-08: month (1-12)
//     Bits 09-15: years from 1980
//
// https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
func zipfileMtime(tls *libc.TLS, pCDS uintptr) u32 { /* zipfile.c:726:12: */
	var Y int32
	var M int32
	var D int32
	var X1 int32
	var X2 int32
	var A int32
	var B int32
	var sec int32
	var min int32
	var hr int32
	var JDsec i64
	Y = 1980 + int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate)>>9&0x7F
	M = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate) >> 5 & 0x0F
	D = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate) & 0x1F
	sec = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime) & 0x1F * 2
	min = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime) >> 5 & 0x3F
	hr = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime) >> 11 & 0x1F
	if M <= 2 {
		Y--
		M = M + 12
	}
	X1 = 36525 * (Y + 4716) / 100
	X2 = 306001 * (M + 1) / 10000
	A = Y / 100
	B = 2 - A + A/4
	JDsec = libc.Int64FromFloat64((float64(X1+X2+D+B)-1524.5)*float64(86400)) + i64(hr*3600) + i64(min*60) + i64(sec)
	return u32(JDsec - int64(24405875)*int64(8640))
}

// The opposite of zipfileMtime(). This function populates the mTime and
// mDate fields of the CDS structure passed as the first argument according
// to the UNIX timestamp value passed as the second.
func zipfileMtimeToDos(tls *libc.TLS, pCds uintptr, mUnixTime u32) { /* zipfile.c:752:13: */
	// Convert unix timestamp to JD (2440588 is noon on 1/1/1970)
	var JD i64 = int64(2440588) + i64(mUnixTime/u32(24*60*60))
	var A int32
	var B int32
	var C int32
	var D int32
	var E int32
	var yr int32
	var mon int32
	var day int32
	var hr int32
	var min int32
	var sec int32

	A = libc.Int32FromFloat64((float64(JD) - 1867216.25) / 36524.25)
	A = int32(JD + int64(1) + i64(A) - i64(A/4))
	B = A + 1524
	C = libc.Int32FromFloat64((float64(B) - 122.1) / 365.25)
	D = 36525 * (C & 32767) / 100
	E = libc.Int32FromFloat64(float64(B-D) / 30.6001)

	day = B - D - libc.Int32FromFloat64(30.6001*float64(E))
	mon = func() int32 {
		if E < 14 {
			return E - 1
		}
		return E - 13
	}()
	if mon > 2 {
		yr = C - 4716
	} else {
		yr = C - 4715
	}

	hr = int32(mUnixTime % u32(24*60*60) / u32(60*60))
	min = int32(mUnixTime % u32(60*60) / u32(60))
	sec = int32(mUnixTime % u32(60))

	if yr >= 1980 {
		(*ZipfileCDS)(unsafe.Pointer(pCds)).FmDate = u16(day + mon<<5 + (yr-1980)<<9)
		(*ZipfileCDS)(unsafe.Pointer(pCds)).FmTime = u16(sec/2 + min<<5 + hr<<11)
	} else {
		(*ZipfileCDS)(unsafe.Pointer(pCds)).FmDate = libc.AssignPtrUint16(pCds+8, u16(0))
	}

}

// If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
// size) containing an entire zip archive image. Or, if aBlob is NULL,
// then pFile is a file-handle open on a zip file. In either case, this
// function creates a ZipfileEntry object based on the zip archive entry
// for which the CDS record is at offset iOff.
//
// If successful, SQLITE_OK is returned and (*ppEntry) set to point to
// the new object. Otherwise, an SQLite error code is returned and the
// final value of (*ppEntry) undefined.
func zipfileGetEntry(tls *libc.TLS, pTab uintptr, aBlob uintptr, nBlob int32, pFile uintptr, iOff i64, ppEntry uintptr) int32 { /* zipfile.c:800:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var aRead uintptr
	var pzErr uintptr = pTab + 16
	var rc int32 = SQLITE_OK

	if aBlob == uintptr(0) {
		aRead = (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer
		rc = zipfileReadData(tls, pFile, aRead, ZIPFILE_CDS_FIXED_SZ, iOff, pzErr)
	} else {
		aRead = aBlob + uintptr(iOff)
	}

	if rc == SQLITE_OK {
		var nAlloc sqlite3_int64
		var pNew uintptr

		var nFile int32 = int32(zipfileGetU16(tls, aRead+28))
		var nExtra int32 = int32(zipfileGetU16(tls, aRead+30))
		nExtra = nExtra + int32(zipfileGetU16(tls, aRead+32))

		nAlloc = sqlite3_int64(uint64(unsafe.Sizeof(ZipfileEntry{})) + uint64(nExtra))
		if aBlob != 0 {
			nAlloc = nAlloc + sqlite3_int64(zipfileGetU32(tls, aRead+20))
		}

		pNew = sqlite3.Xsqlite3_malloc64(tls, uint64(nAlloc))
		if pNew == uintptr(0) {
			rc = SQLITE_NOMEM
		} else {
			libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(ZipfileEntry{})))
			rc = zipfileReadCDS(tls, aRead, pNew)
			if rc != SQLITE_OK {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9294 /* "failed to read C..." */, libc.VaList(bp, iOff))
			} else if aBlob == uintptr(0) {
				rc = zipfileReadData(tls,
					pFile, aRead, nExtra+nFile, iOff+int64(ZIPFILE_CDS_FIXED_SZ), pzErr)
			} else {
				aRead = aBlob + uintptr(iOff+int64(ZIPFILE_CDS_FIXED_SZ))
			}
		}

		if rc == SQLITE_OK {
			var pt uintptr = pNew + 56
			(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile = sqlite3.Xsqlite3_mprintf(tls, ts+9328 /* "%.*s" */, libc.VaList(bp+8, nFile, aRead))
			(*ZipfileEntry)(unsafe.Pointer(pNew)).FaExtra = pNew + 1*96
			libc.Xmemcpy(tls, (*ZipfileEntry)(unsafe.Pointer(pNew)).FaExtra, aRead+uintptr(nFile), uint64(nExtra))
			if (*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile == uintptr(0) {
				rc = SQLITE_NOMEM
			} else if 0 == zipfileScanExtra(tls, aRead+uintptr(nFile), int32((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FnExtra), pt) {
				(*ZipfileEntry)(unsafe.Pointer(pNew)).FmUnixTime = zipfileMtime(tls, pNew)
			}
		}

		if rc == SQLITE_OK {
			// var lfh ZipfileLFH at bp+32, 28

			if pFile != 0 {
				rc = zipfileReadData(tls, pFile, aRead, szFix, int64((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset), pzErr)
			} else {
				aRead = aBlob + uintptr((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset)
			}

			if rc == SQLITE_OK {
				rc = zipfileReadLFH(tls, aRead, bp+32 /* &lfh */)
			}
			if rc == SQLITE_OK {
				(*ZipfileEntry)(unsafe.Pointer(pNew)).FiDataOff = i64((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset + u32(ZIPFILE_LFH_FIXED_SZ))
				*(*i64)(unsafe.Pointer(pNew + 72)) += i64(int32((*ZipfileLFH)(unsafe.Pointer(bp+32)).FnFile) + int32((*ZipfileLFH)(unsafe.Pointer(bp+32)).FnExtra))
				if aBlob != 0 && (*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszCompressed != 0 {
					(*ZipfileEntry)(unsafe.Pointer(pNew)).FaData = (*ZipfileEntry)(unsafe.Pointer(pNew)).FaExtra + uintptr(nExtra)
					libc.Xmemcpy(tls, (*ZipfileEntry)(unsafe.Pointer(pNew)).FaData, aBlob+uintptr((*ZipfileEntry)(unsafe.Pointer(pNew)).FiDataOff), uint64((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszCompressed))
				}
			} else {
				*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9333, /* "failed to read L..." */
					libc.VaList(bp+24, int32((*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset)))
			}
		}

		if rc != SQLITE_OK {
			zipfileEntryFree(tls, pNew)
		} else {
			*(*uintptr)(unsafe.Pointer(ppEntry)) = pNew
		}
	}

	return rc
}

var szFix int32 = ZIPFILE_LFH_FIXED_SZ /* zipfile.c:862:24 */

// Advance an ZipfileCsr to its next row of output.
func zipfileNext(tls *libc.TLS, cur uintptr) int32 { /* zipfile.c:898:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = cur
	var rc int32 = SQLITE_OK

	if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile != 0 {
		var iEof i64 = i64((*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FiOffset + (*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FnSize)
		zipfileEntryFree(tls, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = uintptr(0)
		if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiNextOff >= iEof {
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(1)
		} else {
			*(*uintptr)(unsafe.Pointer(bp /* p */)) = uintptr(0)
			var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
			rc = zipfileGetEntry(tls, pTab, uintptr(0), 0, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiNextOff, bp /* &p */)
			if rc == SQLITE_OK {
				*(*i64)(unsafe.Pointer(pCsr + 32)) += int64(ZIPFILE_CDS_FIXED_SZ)
				*(*i64)(unsafe.Pointer(pCsr + 32)) += i64(int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcds.FnExtra) + int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcds.FnFile) + int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp)))).Fcds.FnComment))
			}
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = *(*uintptr)(unsafe.Pointer(bp /* p */))
		}
	} else {
		if !(int32((*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop) != 0) {
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FpNext
		}
		if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent == uintptr(0) {
			(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(1)
		}
	}

	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop = u8(0)
	return rc
}

func zipfileFree(tls *libc.TLS, p uintptr) { /* zipfile.c:931:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

// Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
// size is nOut bytes. This function uncompresses the data and sets the
// return value in context pCtx to the result (a blob).
//
// If an error occurs, an error code is left in pCtx instead.
func zipfileInflate(tls *libc.TLS, pCtx uintptr, aIn uintptr, nIn int32, nOut int32) { /* zipfile.c:942:13: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var aRes uintptr = sqlite3.Xsqlite3_malloc(tls, nOut)
	if aRes == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		var err int32
		// var str z_stream at bp+16, 112

		libc.Xmemset(tls, bp+16 /* &str */, 0, uint64(unsafe.Sizeof(z_stream{})))

		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Fnext_in = aIn
		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Favail_in = uInt(nIn)
		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Fnext_out = aRes
		(*z_stream)(unsafe.Pointer(bp + 16 /* &str */)).Favail_out = uInt(nOut)

		err = z.XinflateInit2_(tls, bp+16, -15, ts+9365 /* "1.2.11" */, int32(unsafe.Sizeof(z_stream{})))
		if err != Z_OK {
			zipfileCtxErrorMsg(tls, pCtx, ts+9372 /* "inflateInit2() f..." */, libc.VaList(bp, err))
		} else {
			err = z.Xinflate(tls, bp+16 /* &str */, Z_NO_FLUSH)
			if err != Z_STREAM_END {
				zipfileCtxErrorMsg(tls, pCtx, ts+9399 /* "inflate() failed..." */, libc.VaList(bp+8, err))
			} else {
				sqlite3.Xsqlite3_result_blob(tls, pCtx, aRes, nOut, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{zipfileFree})))
				aRes = uintptr(0)
			}
		}
		sqlite3.Xsqlite3_free(tls, aRes)
		z.XinflateEnd(tls, bp+16 /* &str */)
	}
}

// Buffer aIn (size nIn bytes) contains uncompressed data. This function
// compresses it and sets (*ppOut) to point to a buffer containing the
// compressed data. The caller is responsible for eventually calling
// sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut)
// is set to the size of buffer (*ppOut) in bytes.
//
// If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
// code is returned and an error message left in virtual-table handle
// pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
// case.
func zipfileDeflate(tls *libc.TLS, aIn uintptr, nIn int32, ppOut uintptr, pnOut uintptr, pzErr uintptr) int32 { /* zipfile.c:990:12: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var rc int32 = SQLITE_OK
	var nAlloc sqlite3_int64
	// var str z_stream at bp, 112

	var aOut uintptr

	libc.Xmemset(tls, bp /* &str */, 0, uint64(unsafe.Sizeof(z_stream{})))
	(*z_stream)(unsafe.Pointer(bp /* &str */)).Fnext_in = aIn
	(*z_stream)(unsafe.Pointer(bp /* &str */)).Favail_in = uInt(nIn)
	z.XdeflateInit2_(tls, bp, 9, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY, ts+9365 /* "1.2.11" */, int32(unsafe.Sizeof(z_stream{})))

	nAlloc = sqlite3_int64(z.XdeflateBound(tls, bp /* &str */, uint64(nIn)))
	aOut = sqlite3.Xsqlite3_malloc64(tls, uint64(nAlloc))
	if aOut == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		var res int32
		(*z_stream)(unsafe.Pointer(bp /* &str */)).Fnext_out = aOut
		(*z_stream)(unsafe.Pointer(bp /* &str */)).Favail_out = uInt(nAlloc)
		res = z.Xdeflate(tls, bp /* &str */, Z_FINISH)
		if res == Z_STREAM_END {
			*(*uintptr)(unsafe.Pointer(ppOut)) = aOut
			*(*int32)(unsafe.Pointer(pnOut)) = int32((*z_stream)(unsafe.Pointer(bp /* &str */)).Ftotal_out)
		} else {
			sqlite3.Xsqlite3_free(tls, aOut)
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9421 /* "zipfile: deflate..." */, 0)
			rc = SQLITE_ERROR
		}
		z.XdeflateEnd(tls, bp /* &str */)
	}

	return rc
}

// Return values of columns for the row at which the series_cursor
// is currently pointing.
func zipfileColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* zipfile.c:1033:12: */
	var pCsr uintptr = cur
	var pCDS uintptr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent
	var rc int32 = SQLITE_OK
	switch i {
	case 0: // name
		sqlite3.Xsqlite3_result_text(tls, ctx, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FzFile, -1, libc.UintptrFromInt32(-1))
		break
	case 1: // mode
		// TODO: Whether or not the following is correct surely depends on
		// the platform on which the archive was created.
		sqlite3.Xsqlite3_result_int(tls, ctx, int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr>>16))
		break
	case 2:
		{ // mtime
			sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FmUnixTime))
			break

		}
	case 3:
		{ // sz
			if sqlite3.Xsqlite3_vtab_nochange(tls, ctx) == 0 {
				sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed))
			}
			break

		}
	case 4: // rawdata
		if sqlite3.Xsqlite3_vtab_nochange(tls, ctx) != 0 {
			break
		}
		fallthrough
	case 5:
		{ // data
			if i == 4 || int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression) == 0 || int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression) == 8 {
				var sz int32 = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FszCompressed)
				var szFinal int32 = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed)
				if szFinal > 0 {
					var aBuf uintptr
					var aFree uintptr = uintptr(0)
					if (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FaData != 0 {
						aBuf = (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FaData
					} else {
						aBuf = libc.AssignUintptr(&aFree, sqlite3.Xsqlite3_malloc64(tls, uint64(sz)))
						if aBuf == uintptr(0) {
							rc = SQLITE_NOMEM
						} else {
							var pFile uintptr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile
							if pFile == uintptr(0) {
								pFile = (*ZipfileTab)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab)).FpWriteFd
							}
							rc = zipfileReadData(tls, pFile, aBuf, sz, (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FiDataOff,
								(*ZipfileCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab+16)
						}
					}
					if rc == SQLITE_OK {
						if i == 5 && (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression != 0 {
							zipfileInflate(tls, ctx, aBuf, sz, szFinal)
						} else {
							sqlite3.Xsqlite3_result_blob(tls, ctx, aBuf, sz, libc.UintptrFromInt32(-1))
						}
					}
					sqlite3.Xsqlite3_free(tls, aFree)
				} else {
					// Figure out if this is a directory or a zero-sized file. Consider
					// it to be a directory either if the mode suggests so, or if
					// the final character in the name is '/'.
					var mode u32 = (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr >> 16
					if !(mode&u32(S_IFDIR) != 0) && int32(*(*int8)(unsafe.Pointer((*ZipfileCDS)(unsafe.Pointer(pCDS)).FzFile + uintptr(int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile)-1)))) != '/' {
						sqlite3.Xsqlite3_result_blob(tls, ctx, ts+584 /* "" */, 0, uintptr(0))
					}
				}
			}
			break

		}
	case 6: // method
		sqlite3.Xsqlite3_result_int(tls, ctx, int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression))
		break
	default: // z

		sqlite3.Xsqlite3_result_int64(tls, ctx, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiId)
		break
	}

	return rc
}

// Return TRUE if the cursor is at EOF.
func zipfileEof(tls *libc.TLS, cur uintptr) int32 { /* zipfile.c:1120:12: */
	var pCsr uintptr = cur
	return int32((*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof)
}

// If aBlob is not NULL, then it points to a buffer nBlob bytes in size
// containing an entire zip archive image. Or, if aBlob is NULL, then pFile
// is guaranteed to be a file-handle open on a zip file.
//
// This function attempts to locate the EOCD record within the zip archive
// and populate *pEOCD with the results of decoding it. SQLITE_OK is
// returned if successful. Otherwise, an SQLite error code is returned and
// an English language error message may be left in virtual-table pTab.
func zipfileReadEOCD(tls *libc.TLS, pTab uintptr, aBlob uintptr, nBlob int32, pFile uintptr, pEOCD uintptr) int32 { /* zipfile.c:1135:12: */
	var aRead uintptr = (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer // Temporary buffer
	var nRead int32                                                  // Bytes to read from file
	var rc int32 = SQLITE_OK

	libc.Xmemset(tls, pEOCD, 0, uint64(unsafe.Sizeof(ZipfileEOCD{})))
	if aBlob == uintptr(0) {
		var iOff i64   // Offset to read from
		var szFile i64 // Total size of file in bytes
		libc.Xfseek(tls, pFile, int64(0), SEEK_END)
		szFile = i64(libc.Xftell(tls, pFile))
		if szFile == int64(0) {
			return SQLITE_OK
		}
		nRead = func() int32 {
			if szFile < int64(64*1024) {
				return int32(szFile)
			}
			return 64 * 1024
		}()
		iOff = szFile - i64(nRead)
		rc = zipfileReadData(tls, pFile, aRead, nRead, iOff, pTab+16)
	} else {
		nRead = func() int32 {
			if nBlob < 64*1024 {
				return nBlob
			}
			return 64 * 1024
		}()
		aRead = aBlob + uintptr(nBlob-nRead)
	}

	if rc == SQLITE_OK {
		var i int32

		// Scan backwards looking for the signature bytes
		for i = nRead - 20; i >= 0; i-- {
			if int32(*(*u8)(unsafe.Pointer(aRead + uintptr(i)))) == 0x50 && int32(*(*u8)(unsafe.Pointer(aRead + uintptr(i+1)))) == 0x4b &&
				int32(*(*u8)(unsafe.Pointer(aRead + uintptr(i+2)))) == 0x05 && int32(*(*u8)(unsafe.Pointer(aRead + uintptr(i+3)))) == 0x06 {
				break
			}
		}
		if i < 0 {
			(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
				ts+9446 /* "cannot find end ..." */, 0)
			return SQLITE_ERROR
		}

		aRead += uintptr(i + 4)
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FiDisk = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FiFirstDisk = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FnEntry = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FnEntryTotal = func() u16 { aRead += uintptr(2); return zipfileGetU16(tls, aRead-uintptr(2)) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FnSize = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
		(*ZipfileEOCD)(unsafe.Pointer(pEOCD)).FiOffset = func() u32 { aRead += uintptr(4); return zipfileGetU32(tls, aRead-uintptr(4)) }()
	}

	return rc
}

// Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry
// and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
// to the end of the list. Otherwise, it is added to the list immediately
// before pBefore (which is guaranteed to be a part of said list).
func zipfileAddEntry(tls *libc.TLS, pTab uintptr, pBefore uintptr, pNew uintptr) { /* zipfile.c:1199:13: */

	if pBefore == uintptr(0) {
		if (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry == uintptr(0) {
			(*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry = libc.AssignPtrUintptr(pTab+72, pNew)
		} else {

			(*ZipfileEntry)(unsafe.Pointer((*ZipfileTab)(unsafe.Pointer(pTab)).FpLastEntry)).FpNext = pNew
			(*ZipfileTab)(unsafe.Pointer(pTab)).FpLastEntry = pNew
		}
	} else {
		var pp uintptr
		for pp = pTab + 64; *(*uintptr)(unsafe.Pointer(pp)) != pBefore; pp = *(*uintptr)(unsafe.Pointer(pp)) + 88 {
		}
		(*ZipfileEntry)(unsafe.Pointer(pNew)).FpNext = pBefore
		*(*uintptr)(unsafe.Pointer(pp)) = pNew
	}
}

func zipfileLoadDirectory(tls *libc.TLS, pTab uintptr, aBlob uintptr, nBlob int32) int32 { /* zipfile.c:1222:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var eocd ZipfileEOCD at bp, 16

	var rc int32
	var i int32
	var iOff i64

	rc = zipfileReadEOCD(tls, pTab, aBlob, nBlob, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, bp /* &eocd */)
	iOff = i64((*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiOffset)
	for i = 0; rc == SQLITE_OK && i < int32((*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntry); i++ {
		*(*uintptr)(unsafe.Pointer(bp + 16 /* pNew */)) = uintptr(0)
		rc = zipfileGetEntry(tls, pTab, aBlob, nBlob, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, iOff, bp+16 /* &pNew */)

		if rc == SQLITE_OK {
			zipfileAddEntry(tls, pTab, uintptr(0), *(*uintptr)(unsafe.Pointer(bp + 16 /* pNew */)))
			iOff = iOff + int64(ZIPFILE_CDS_FIXED_SZ)
			iOff = iOff + i64(int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Fcds.FnExtra)+int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Fcds.FnFile)+int32((*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 16)))).Fcds.FnComment))
		}
	}
	return rc
}

// xFilter callback.
func zipfileFilter(tls *libc.TLS, cur uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* zipfile.c:1246:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	var pCsr uintptr = cur
	var zFile uintptr = uintptr(0) // Zip file to scan
	var rc int32 = SQLITE_OK       // Return Code
	var bInMemory int32 = 0        // True for an in-memory zipfile

	zipfileResetCursor(tls, pCsr)

	if (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile != 0 {
		zFile = (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile
	} else if idxNum == 0 {
		zipfileCursorErr(tls, pCsr, ts+9490 /* "zipfile() functi..." */, 0)
		return SQLITE_ERROR
	} else if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_BLOB {
		var aBlob uintptr = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var nBlob int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))

		rc = zipfileLoadDirectory(tls, pTab, aBlob, nBlob)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
		(*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry = libc.AssignPtrUintptr(pTab+72, uintptr(0))
		if rc != SQLITE_OK {
			return rc
		}
		bInMemory = 1
	} else {
		zFile = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	}

	if uintptr(0) == (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd && 0 == bInMemory {
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile = libc.Xfopen(tls, zFile, ts+4402 /* "rb" */)
		if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile == uintptr(0) {
			zipfileCursorErr(tls, pCsr, ts+9530 /* "cannot open file..." */, libc.VaList(bp, zFile))
			rc = SQLITE_ERROR
		} else {
			rc = zipfileReadEOCD(tls, pTab, uintptr(0), 0, (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFile, pCsr+40)
			if rc == SQLITE_OK {
				if int32((*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FnEntry) == 0 {
					(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbEof = u8(1)
				} else {
					(*ZipfileCsr)(unsafe.Pointer(pCsr)).FiNextOff = i64((*ZipfileCsr)(unsafe.Pointer(pCsr)).Feocd.FiOffset)
					rc = zipfileNext(tls, cur)
				}
			}
		}
	} else {
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop = u8(1)
		(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = func() uintptr {
			if (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry != 0 {
				return (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpFreeEntry
			}
			return (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
		}()
		rc = zipfileNext(tls, cur)
	}

	return rc
}

// xBestIndex callback.
func zipfileBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* zipfile.c:1305:12: */
	var i int32
	var idx int32 = -1
	var unusable int32 = 0

	for i = 0; i < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; i++ {
		var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(i)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn != ZIPFILE_F_COLUMN_IDX {
			continue
		}
		if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable) == 0 {
			unusable = 1
		} else if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			idx = i
		}
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000.0
	if idx >= 0 {
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).FargvIndex = 1
		(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(idx)*8)).Fomit = uint8(1)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
	} else if unusable != 0 {
		return SQLITE_CONSTRAINT
	}
	return SQLITE_OK
}

func zipfileNewEntry(tls *libc.TLS, zPath uintptr) uintptr { /* zipfile.c:1333:21: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pNew uintptr
	pNew = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(ZipfileEntry{})))
	if pNew != 0 {
		libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(ZipfileEntry{})))
		(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zPath))
		if (*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FzFile == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, pNew)
			pNew = uintptr(0)
		}
	}
	return pNew
}

func zipfileSerializeLFH(tls *libc.TLS, pEntry uintptr, aBuf uintptr) int32 { /* zipfile.c:1347:12: */
	var pCds uintptr = pEntry
	var a uintptr = aBuf

	(*ZipfileCDS)(unsafe.Pointer(pCds)).FnExtra = u16(9)

	/* Write the LFH itself */
	{
		zipfilePutU32(tls, a, uint32(ZIPFILE_SIGNATURE_LFH))
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FiVersionExtract)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).Fflags)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FiCompression)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FmTime)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FmDate)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).Fcrc32)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FszCompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FszUncompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FnFile)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FnExtra)
		a += uintptr(2)
	}

	// Add the file name
	libc.Xmemcpy(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCds)).FzFile, uint64(int32((*ZipfileCDS)(unsafe.Pointer(pCds)).FnFile)))
	a += uintptr(int32((*ZipfileCDS)(unsafe.Pointer(pCds)).FnFile))

	/* The "extra" data */
	{
		zipfilePutU16(tls, a, uint16(ZIPFILE_EXTRA_TIMESTAMP))
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, uint16(5))
		a += uintptr(2)
	}

	*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&a, 1))) = u8(0x01)
	{
		zipfilePutU32(tls, a, (*ZipfileEntry)(unsafe.Pointer(pEntry)).FmUnixTime)
		a += uintptr(4)
	}

	return int32((int64(a) - int64(aBuf)) / 1)
}

func zipfileAppendEntry(tls *libc.TLS, pTab uintptr, pEntry uintptr, pData uintptr, nData int32) int32 { /* zipfile.c:1380:12: */
	var aBuf uintptr = (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer
	var nBuf int32
	var rc int32

	nBuf = zipfileSerializeLFH(tls, pEntry, aBuf)
	rc = zipfileAppendData(tls, pTab, aBuf, nBuf)
	if rc == SQLITE_OK {
		(*ZipfileEntry)(unsafe.Pointer(pEntry)).FiDataOff = (*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent
		rc = zipfileAppendData(tls, pTab, pData, nData)
	}

	return rc
}

func zipfileGetMode(tls *libc.TLS, pVal uintptr, bIsDir int32, pMode uintptr, pzErr uintptr) int32 { /* zipfile.c:1400:12: */
	bp := tls.Alloc(19)
	defer tls.Free(19)

	var z uintptr
	var mode u32
	// var zTemplate [11]int8 at bp+8, 11

	var i int32
	z = sqlite3.Xsqlite3_value_text(tls, pVal)
	mode = u32(0)
	if !(z == uintptr(0)) {
		goto __1
	}
	mode = func() uint32 {
		if bIsDir != 0 {
			return uint32(S_IFDIR + 0755)
		}
		return uint32(S_IFREG + 0644)
	}()
	goto __2
__1:
	if !(int32(*(*int8)(unsafe.Pointer(z))) >= '0' && int32(*(*int8)(unsafe.Pointer(z))) <= '9') {
		goto __3
	}
	mode = uint32(sqlite3.Xsqlite3_value_int(tls, pVal))
	goto __4
__3:
	*(*[11]int8)(unsafe.Pointer(bp + 8 /* zTemplate */)) = *(*[11]int8)(unsafe.Pointer(ts + 9551 /* "-rwxrwxrwx" */))
	if !(libc.Xstrlen(tls, z) != uint64(10)) {
		goto __5
	}
	goto parse_error
__5:
	;
	switch int32(*(*int8)(unsafe.Pointer(z))) {
	case '-':
		goto __7
	case 'd':
		goto __8
	case 'l':
		goto __9
	default:
		goto __10
	}
	goto __6
__7:
	mode = mode | u32(S_IFREG)
	goto __6
__8:
	mode = mode | u32(S_IFDIR)
	goto __6
__9:
	mode = mode | u32(S_IFLNK)
	goto __6
__10:
	goto parse_error
__6:
	;
	i = 1
__11:
	if !(i < 10) {
		goto __13
	}
	if !(int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp + 8 + uintptr(i))))) {
		goto __14
	}
	mode = mode | u32(int32(1)<<(9-i))
	goto __15
__14:
	if !(int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '-') {
		goto __16
	}
	goto parse_error
__16:
	;
__15:
	;
	goto __12
__12:
	i++
	goto __11
	goto __13
__13:
	;
__4:
	;
__2:
	;
	if !(libc.Bool32(mode&u32(S_IFDIR) == u32(0)) == bIsDir) {
		goto __17
	}
	// The "mode" attribute is a directory, but data has been specified.
	// Or vice-versa - no data but "mode" is a file or symlink.
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9562 /* "zipfile: mode do..." */, 0)
	return SQLITE_CONSTRAINT
__17:
	;
	*(*u32)(unsafe.Pointer(pMode)) = mode
	return SQLITE_OK

parse_error:
	*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+9596 /* "zipfile: parse e..." */, libc.VaList(bp, z))
	return SQLITE_ERROR
}

//
// Both (const char*) arguments point to nul-terminated strings. Argument
// nB is the value of strlen(zB). This function returns 0 if the strings are
// identical, ignoring any trailing '/' character in either path.
func zipfileComparePath(tls *libc.TLS, zA uintptr, zB uintptr, nB int32) int32 { /* zipfile.c:1445:12: */
	var nA int32 = int32(libc.Xstrlen(tls, zA))
	if nA > 0 && int32(*(*int8)(unsafe.Pointer(zA + uintptr(nA-1)))) == '/' {
		nA--
	}
	if nB > 0 && int32(*(*int8)(unsafe.Pointer(zB + uintptr(nB-1)))) == '/' {
		nB--
	}
	if nA == nB && libc.Xmemcmp(tls, zA, zB, uint64(nA)) == 0 {
		return 0
	}
	return 1
}

func zipfileBegin(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:1453:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pTab uintptr = pVtab
	var rc int32 = SQLITE_OK

	if (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile == uintptr(0) || int32(*(*int8)(unsafe.Pointer((*ZipfileTab)(unsafe.Pointer(pTab)).FzFile))) == 0 {
		(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+9629 /* "zipfile: missing..." */, 0)
		return SQLITE_ERROR
	}

	// Open a write fd on the file. Also load the entire central directory
	// structure into memory. During the transaction any new file data is
	// appended to the archive file, but the central directory is accumulated
	// in main-memory until the transaction is committed.
	(*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd = libc.Xfopen(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile, ts+9655 /* "ab+" */)
	if (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd == uintptr(0) {
		(*ZipfileTab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls,
			ts+9659 /* "zipfile: failed ..." */, libc.VaList(bp, (*ZipfileTab)(unsafe.Pointer(pTab)).FzFile))
		rc = SQLITE_ERROR
	} else {
		libc.Xfseek(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd, int64(0), SEEK_END)
		(*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent = libc.AssignPtrInt64(pTab+96, i64(libc.Xftell(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd)))
		rc = zipfileLoadDirectory(tls, pTab, uintptr(0), 0)
	}

	if rc != SQLITE_OK {
		zipfileCleanupTransaction(tls, pTab)
	}

	return rc
}

// Return the current time as a 32-bit timestamp in UNIX epoch format (like
// time(2)).
func zipfileTime(tls *libc.TLS) u32 { /* zipfile.c:1490:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	var ret u32
	if pVfs == uintptr(0) {
		return u32(0)
	}
	if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion >= 2 && (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTimeInt64 != 0 {
		// var ms i64 at bp, 8

		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTimeInt64})).f(tls, pVfs, bp /* &ms */)
		ret = u32(*(*i64)(unsafe.Pointer(bp))/int64(1000) - int64(24405875)*int64(8640))
	} else {
		// var day float64 at bp+8, 8

		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTime})).f(tls, pVfs, bp+8 /* &day */)
		ret = libc.Uint32FromFloat64((*(*float64)(unsafe.Pointer(bp + 8)) - 2440587.5) * float64(86400))
	}
	return ret
}

// Return a 32-bit timestamp in UNIX epoch format.
//
// If the value passed as the only argument is either NULL or an SQL NULL,
// return the current time. Otherwise, return the value stored in (*pVal)
// cast to a 32-bit unsigned integer.
func zipfileGetTime(tls *libc.TLS, pVal uintptr) u32 { /* zipfile.c:1513:12: */
	if pVal == uintptr(0) || sqlite3.Xsqlite3_value_type(tls, pVal) == SQLITE_NULL {
		return zipfileTime(tls)
	}
	return u32(sqlite3.Xsqlite3_value_int64(tls, pVal))
}

// Unless it is NULL, entry pOld is currently part of the pTab->pFirstEntry
// linked list.  Remove it from the list and free the object.
func zipfileRemoveEntryFromList(tls *libc.TLS, pTab uintptr, pOld uintptr) { /* zipfile.c:1524:13: */
	if pOld != 0 {
		var pp uintptr
		for pp = pTab + 64; *(*uintptr)(unsafe.Pointer(pp)) != pOld; pp = *(*uintptr)(unsafe.Pointer(pp)) + 88 {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*ZipfileEntry)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNext
		zipfileEntryFree(tls, pOld)
	}
}

// xUpdate method.
func zipfileUpdate(tls *libc.TLS, pVtab uintptr, nVal int32, apVal uintptr, pRowid uintptr) int32 { /* zipfile.c:1536:12: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var pTab uintptr
	var rc int32     // Return Code
	var pNew uintptr // New in-memory CDS entry

	// var mode u32 at bp+36, 4
	// Mode for new entry
	var mTime u32     // Modification time for new entry
	var sz i64        // Uncompressed size
	var zPath uintptr // Path for new entry
	var nPath int32   // strlen(zPath)
	var pData uintptr // Pointer to buffer containing content
	var nData int32   // Size of pData buffer in bytes
	var iMethod int32 // Compression method for new entry
	// var pFree uintptr at bp+24, 8
	// Free this
	var zFree uintptr // Also free this
	var pOld uintptr
	var pOld2 uintptr
	var bUpdate int32 // True for an update that modifies "name"
	var bIsDir int32
	var iCrc32 u32
	var zUpdate uintptr
	var zDelete uintptr
	var nDelete int32
	// var nCmp int32 at bp+32, 4

	// Value specified for "data", and possibly "method". This must be
	// a regular file or a symlink.
	var aIn uintptr
	var nIn int32
	var bAuto int32
	var p uintptr
	var pCsr uintptr
	pTab = pVtab
	rc = SQLITE_OK
	pNew = uintptr(0)
	*(*u32)(unsafe.Pointer(bp + 36 /* mode */)) = u32(0)
	mTime = u32(0)
	sz = int64(0)
	zPath = uintptr(0)
	nPath = 0
	pData = uintptr(0)
	nData = 0
	iMethod = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pFree */)) = uintptr(0)
	zFree = uintptr(0)
	pOld = uintptr(0)
	pOld2 = uintptr(0)
	bUpdate = 0
	bIsDir = 0
	iCrc32 = u32(0)

	if !((*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd == uintptr(0)) {
		goto __1
	}
	rc = zipfileBegin(tls, pVtab)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	return rc
__2:
	;
__1:
	;

	// If this is a DELETE or UPDATE, find the archive entry to delete.
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal))) != SQLITE_NULL) {
		goto __3
	}
	zDelete = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	nDelete = int32(libc.Xstrlen(tls, zDelete))
	if !(nVal > 1) {
		goto __4
	}
	zUpdate = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + 1*8)))
	if !(zUpdate != 0 && zipfileComparePath(tls, zUpdate, zDelete, nDelete) != 0) {
		goto __5
	}
	bUpdate = 1
__5:
	;
__4:
	;
	pOld = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
__6:
	if !(1 != 0) {
		goto __8
	}
	if !(zipfileComparePath(tls, (*ZipfileEntry)(unsafe.Pointer(pOld)).Fcds.FzFile, zDelete, nDelete) == 0) {
		goto __9
	}
	goto __8
__9:
	;

	goto __7
__7:
	pOld = (*ZipfileEntry)(unsafe.Pointer(pOld)).FpNext
	goto __6
	goto __8
__8:
	;
__3:
	;

	if !(nVal > 1) {
		goto __10
	}
	// Check that "sz" and "rawdata" are both NULL:
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 5*8))) != SQLITE_NULL) {
		goto __11
	}
	zipfileTableErr(tls, pTab, ts+9703 /* "sz must be NULL" */, 0)
	rc = SQLITE_CONSTRAINT
__11:
	;
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 6*8))) != SQLITE_NULL) {
		goto __12
	}
	zipfileTableErr(tls, pTab, ts+9719 /* "rawdata must be ..." */, 0)
	rc = SQLITE_CONSTRAINT
__12:
	;

	if !(rc == SQLITE_OK) {
		goto __13
	}
	if !(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 7*8))) == SQLITE_NULL) {
		goto __14
	}
	// data=NULL. A directory
	bIsDir = 1
	goto __15
__14:
	// Value specified for "data", and possibly "method". This must be
	// a regular file or a symlink.
	aIn = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal + 7*8)))
	nIn = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal + 7*8)))
	bAuto = libc.Bool32(sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apVal + 8*8))) == SQLITE_NULL)

	iMethod = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(apVal + 8*8)))
	sz = i64(nIn)
	pData = aIn
	nData = nIn
	if !(iMethod != 0 && iMethod != 8) {
		goto __16
	}
	zipfileTableErr(tls, pTab, ts+9740 /* "unknown compress..." */, libc.VaList(bp, iMethod))
	rc = SQLITE_CONSTRAINT
	goto __17
__16:
	if !(bAuto != 0 || iMethod != 0) {
		goto __18
	}
	rc = zipfileDeflate(tls, aIn, nIn, bp+24 /* &pFree */, bp+32 /* &nCmp */, pTab+16)
	if !(rc == SQLITE_OK) {
		goto __19
	}
	if !(iMethod != 0 || *(*int32)(unsafe.Pointer(bp + 32)) < nIn) {
		goto __20
	}
	iMethod = 8
	pData = *(*uintptr)(unsafe.Pointer(bp + 24 /* pFree */))
	nData = *(*int32)(unsafe.Pointer(bp + 32 /* nCmp */))
__20:
	;
__19:
	;
__18:
	;
	iCrc32 = u32(z.Xcrc32(tls, uint64(0), aIn, uint32(nIn)))
__17:
	;
__15:
	;
__13:
	;

	if !(rc == SQLITE_OK) {
		goto __21
	}
	rc = zipfileGetMode(tls, *(*uintptr)(unsafe.Pointer(apVal + 3*8)), bIsDir, bp+36 /* &mode */, pTab+16)
__21:
	;

	if !(rc == SQLITE_OK) {
		goto __22
	}
	zPath = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apVal + 2*8)))
	if !(zPath == uintptr(0)) {
		goto __23
	}
	zPath = ts + 584 /* "" */
__23:
	;
	nPath = int32(libc.Xstrlen(tls, zPath))
	mTime = zipfileGetTime(tls, *(*uintptr)(unsafe.Pointer(apVal + 4*8)))
__22:
	;

	if !(rc == SQLITE_OK && bIsDir != 0) {
		goto __24
	}
	// For a directory, check that the last character in the path is a
	// '/'. This appears to be required for compatibility with info-zip
	// (the unzip command on unix). It does not create directories
	// otherwise.
	if !(nPath <= 0 || int32(*(*int8)(unsafe.Pointer(zPath + uintptr(nPath-1)))) != '/') {
		goto __25
	}
	zFree = sqlite3.Xsqlite3_mprintf(tls, ts+9771 /* "%s/" */, libc.VaList(bp+8, zPath))
	zPath = zFree
	if !(zFree == uintptr(0)) {
		goto __26
	}
	rc = SQLITE_NOMEM
	nPath = 0
	goto __27
__26:
	nPath = int32(libc.Xstrlen(tls, zPath))
__27:
	;
__25:
	;
__24:
	;

	// Check that we're not inserting a duplicate entry -OR- updating an
	// entry with a path, thereby making it into a duplicate.
	if !((pOld == uintptr(0) || bUpdate != 0) && rc == SQLITE_OK) {
		goto __28
	}
	p = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry
__29:
	if !(p != 0) {
		goto __31
	}
	if !(zipfileComparePath(tls, (*ZipfileEntry)(unsafe.Pointer(p)).Fcds.FzFile, zPath, nPath) == 0) {
		goto __32
	}
	switch sqlite3.Xsqlite3_vtab_on_conflict(tls, (*ZipfileTab)(unsafe.Pointer(pTab)).Fdb) {
	case SQLITE_IGNORE:
		goto __34
	case SQLITE_REPLACE:
		goto __35
	default:
		goto __36
	}
	goto __33
__34:
	goto zipfile_update_done

__35:
	pOld2 = p
	goto __33

__36:
	zipfileTableErr(tls, pTab, ts+9775 /* "duplicate name: ..." */, libc.VaList(bp+16, zPath))
	rc = SQLITE_CONSTRAINT
	goto __33

__33:
	;
	goto __31
__32:
	;
	goto __30
__30:
	p = (*ZipfileEntry)(unsafe.Pointer(p)).FpNext
	goto __29
	goto __31
__31:
	;
__28:
	;

	if !(rc == SQLITE_OK) {
		goto __37
	}
	// Create the new CDS record.
	pNew = zipfileNewEntry(tls, zPath)
	if !(pNew == uintptr(0)) {
		goto __38
	}
	rc = SQLITE_NOMEM
	goto __39
__38:
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiVersionMadeBy = u16(int32(3)<<8 + 30)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiVersionExtract = u16(ZIPFILE_NEWENTRY_REQUIRED)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.Fflags = u16(ZIPFILE_NEWENTRY_FLAGS)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiCompression = u16(iMethod)
	zipfileMtimeToDos(tls, pNew, mTime)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.Fcrc32 = iCrc32
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszCompressed = u32(nData)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FszUncompressed = u32(sz)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiExternalAttr = *(*u32)(unsafe.Pointer(bp + 36)) << 16
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FiOffset = u32((*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).Fcds.FnFile = u16(nPath)
	(*ZipfileEntry)(unsafe.Pointer(pNew)).FmUnixTime = mTime
	rc = zipfileAppendEntry(tls, pTab, pNew, pData, nData)
	zipfileAddEntry(tls, pTab, pOld, pNew)
__39:
	;
__37:
	;
__10:
	;

	if !(rc == SQLITE_OK && (pOld != 0 || pOld2 != 0)) {
		goto __40
	}
	pCsr = (*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList
__41:
	if !(pCsr != 0) {
		goto __43
	}
	if !((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent != 0 && ((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent == pOld || (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent == pOld2)) {
		goto __44
	}
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent = (*ZipfileEntry)(unsafe.Pointer((*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent)).FpNext
	(*ZipfileCsr)(unsafe.Pointer(pCsr)).FbNoop = u8(1)
__44:
	;
	goto __42
__42:
	pCsr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext
	goto __41
	goto __43
__43:
	;

	zipfileRemoveEntryFromList(tls, pTab, pOld)
	zipfileRemoveEntryFromList(tls, pTab, pOld2)
__40:
	;

zipfile_update_done:
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pFree */)))
	sqlite3.Xsqlite3_free(tls, zFree)
	return rc
}

func zipfileSerializeEOCD(tls *libc.TLS, p uintptr, aBuf uintptr) int32 { /* zipfile.c:1727:12: */
	var a uintptr = aBuf
	{
		zipfilePutU32(tls, a, uint32(ZIPFILE_SIGNATURE_EOCD))
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FiDisk)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FiFirstDisk)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FnEntry)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FnEntryTotal)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FnSize)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileEOCD)(unsafe.Pointer(p)).FiOffset)
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, uint16(0))
		a += uintptr(2)
	}
	// Size of trailing comment in bytes

	return int32((int64(a) - int64(aBuf)) / 1)
}

func zipfileAppendEOCD(tls *libc.TLS, pTab uintptr, p uintptr) int32 { /* zipfile.c:1741:12: */
	var nBuf int32 = zipfileSerializeEOCD(tls, p, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer)

	return zipfileAppendData(tls, pTab, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer, nBuf)
}

// Serialize the CDS structure into buffer aBuf[]. Return the number
// of bytes written.
func zipfileSerializeCDS(tls *libc.TLS, pEntry uintptr, aBuf uintptr) int32 { /* zipfile.c:1751:12: */
	var a uintptr = aBuf
	var pCDS uintptr = pEntry

	if (*ZipfileEntry)(unsafe.Pointer(pEntry)).FaExtra == uintptr(0) {
		(*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra = u16(9)
	}

	{
		zipfilePutU32(tls, a, uint32(ZIPFILE_SIGNATURE_CDS))
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionMadeBy)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiVersionExtract)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).Fflags)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiCompression)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FmTime)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FmDate)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).Fcrc32)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FszCompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FszUncompressed)
		a += uintptr(4)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FnComment)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiDiskStart)
		a += uintptr(2)
	}

	{
		zipfilePutU16(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiInternalAttr)
		a += uintptr(2)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiExternalAttr)
		a += uintptr(4)
	}

	{
		zipfilePutU32(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FiOffset)
		a += uintptr(4)
	}

	libc.Xmemcpy(tls, a, (*ZipfileCDS)(unsafe.Pointer(pCDS)).FzFile, uint64((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile))
	a += uintptr((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnFile)

	if (*ZipfileEntry)(unsafe.Pointer(pEntry)).FaExtra != 0 {
		var n int32 = int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnExtra) + int32((*ZipfileCDS)(unsafe.Pointer(pCDS)).FnComment)
		libc.Xmemcpy(tls, a, (*ZipfileEntry)(unsafe.Pointer(pEntry)).FaExtra, uint64(n))
		a += uintptr(n)
	} else {

		{
			zipfilePutU16(tls, a, uint16(ZIPFILE_EXTRA_TIMESTAMP))
			a += uintptr(2)
		}

		{
			zipfilePutU16(tls, a, uint16(5))
			a += uintptr(2)
		}

		*(*u8)(unsafe.Pointer(libc.PostIncUintptr(&a, 1))) = u8(0x01)
		{
			zipfilePutU32(tls, a, (*ZipfileEntry)(unsafe.Pointer(pEntry)).FmUnixTime)
			a += uintptr(4)
		}

	}

	return int32((int64(a) - int64(aBuf)) / 1)
}

func zipfileCommit(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:1796:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pTab uintptr = pVtab
	var rc int32 = SQLITE_OK
	if (*ZipfileTab)(unsafe.Pointer(pTab)).FpWriteFd != 0 {
		var iOffset i64 = (*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent
		var p uintptr
		// var eocd ZipfileEOCD at bp, 16

		var nEntry int32 = 0

		// Write out all entries
		for p = (*ZipfileTab)(unsafe.Pointer(pTab)).FpFirstEntry; rc == SQLITE_OK && p != 0; p = (*ZipfileEntry)(unsafe.Pointer(p)).FpNext {
			var n int32 = zipfileSerializeCDS(tls, p, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer)
			rc = zipfileAppendData(tls, pTab, (*ZipfileTab)(unsafe.Pointer(pTab)).FaBuffer, n)
			nEntry++
		}

		// Write out the EOCD record
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiDisk = u16(0)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiFirstDisk = u16(0)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntry = u16(nEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntryTotal = u16(nEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnSize = u32((*ZipfileTab)(unsafe.Pointer(pTab)).FszCurrent - iOffset)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiOffset = u32(iOffset)
		rc = zipfileAppendEOCD(tls, pTab, bp /* &eocd */)

		zipfileCleanupTransaction(tls, pTab)
	}
	return rc
}

func zipfileRollback(tls *libc.TLS, pVtab uintptr) int32 { /* zipfile.c:1826:12: */
	return zipfileCommit(tls, pVtab)
}

func zipfileFindCursor(tls *libc.TLS, pTab uintptr, iId i64) uintptr { /* zipfile.c:1830:19: */
	var pCsr uintptr
	for pCsr = (*ZipfileTab)(unsafe.Pointer(pTab)).FpCsrList; pCsr != 0; pCsr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCsrNext {
		if iId == (*ZipfileCsr)(unsafe.Pointer(pCsr)).FiId {
			break
		}
	}
	return pCsr
}

func zipfileFunctionCds(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* zipfile.c:1838:13: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	var pCsr uintptr
	var pTab uintptr = sqlite3.Xsqlite3_user_data(tls, context)

	pCsr = zipfileFindCursor(tls, pTab, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv))))
	if pCsr != 0 {
		var p uintptr = (*ZipfileCsr)(unsafe.Pointer(pCsr)).FpCurrent
		var zRes uintptr = sqlite3.Xsqlite3_mprintf(tls,

			ts+9796, /* "{\"version-made-b..." */
			libc.VaList(bp, u32((*ZipfileCDS)(unsafe.Pointer(p)).FiVersionMadeBy), u32((*ZipfileCDS)(unsafe.Pointer(p)).FiVersionExtract),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).Fflags), u32((*ZipfileCDS)(unsafe.Pointer(p)).FiCompression),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).FmTime), u32((*ZipfileCDS)(unsafe.Pointer(p)).FmDate),
				(*ZipfileCDS)(unsafe.Pointer(p)).Fcrc32, (*ZipfileCDS)(unsafe.Pointer(p)).FszCompressed,
				(*ZipfileCDS)(unsafe.Pointer(p)).FszUncompressed, u32((*ZipfileCDS)(unsafe.Pointer(p)).FnFile),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).FnExtra), u32((*ZipfileCDS)(unsafe.Pointer(p)).FnComment),
				u32((*ZipfileCDS)(unsafe.Pointer(p)).FiDiskStart), u32((*ZipfileCDS)(unsafe.Pointer(p)).FiInternalAttr),
				(*ZipfileCDS)(unsafe.Pointer(p)).FiExternalAttr, (*ZipfileCDS)(unsafe.Pointer(p)).FiOffset))

		if zRes == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, context)
		} else {
			sqlite3.Xsqlite3_result_text(tls, context, zRes, -1, libc.UintptrFromInt32(-1))
			sqlite3.Xsqlite3_free(tls, zRes)
		}
	}
}

// xFindFunction method.
func zipfileFindFunction(tls *libc.TLS, pVtab uintptr, nArg int32, zName uintptr, pxFunc uintptr, ppArg uintptr) int32 { /* zipfile.c:1889:12: */
	if sqlite3.Xsqlite3_stricmp(tls, ts+10138, zName) == 0 {
		*(*uintptr)(unsafe.Pointer(pxFunc)) = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{zipfileFunctionCds}))
		*(*uintptr)(unsafe.Pointer(ppArg)) = pVtab
		return 1
	}
	return 0
}

type ZipfileBuffer1 = struct {
	Fa      uintptr
	Fn      int32
	FnAlloc int32
} /* zipfile.c:1904:9 */

type ZipfileBuffer = ZipfileBuffer1 /* zipfile.c:1904:30 */

type ZipfileCtx1 = struct {
	FnEntry      int32
	F__ccgo_pad1 [4]byte
	Fbody        ZipfileBuffer
	Fcds         ZipfileBuffer
} /* zipfile.c:1911:9 */

type ZipfileCtx = ZipfileCtx1 /* zipfile.c:1911:27 */

func zipfileBufferGrow(tls *libc.TLS, pBuf uintptr, nByte int32) int32 { /* zipfile.c:1918:12: */
	if (*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn+nByte > (*ZipfileBuffer)(unsafe.Pointer(pBuf)).FnAlloc {
		var aNew uintptr
		var nNew sqlite3_int64
		if (*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn != 0 {
			nNew = int64((*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn * 2)
		} else {
			nNew = int64(512)
		}
		var nReq int32 = (*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fn + nByte

		for nNew < sqlite3_int64(nReq) {
			nNew = nNew * int64(2)
		}
		aNew = sqlite3.Xsqlite3_realloc64(tls, (*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fa, uint64(nNew))
		if aNew == uintptr(0) {
			return SQLITE_NOMEM
		}
		(*ZipfileBuffer)(unsafe.Pointer(pBuf)).Fa = aNew
		(*ZipfileBuffer)(unsafe.Pointer(pBuf)).FnAlloc = int32(nNew)
	}
	return SQLITE_OK
}

// xStep() callback for the zipfile() aggregate. This can be called in
// any of the following ways:
//
//   SELECT zipfile(name,data) ...
//   SELECT zipfile(name,mode,mtime,data) ...
//   SELECT zipfile(name,mode,mtime,data,method) ...
func zipfileStep(tls *libc.TLS, pCtx uintptr, nVal int32, apVal uintptr) { /* zipfile.c:1941:6: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var p uintptr // Aggregate function context
	// var e ZipfileEntry at bp+16, 96
	// New entry to add to zip archive

	var pName uintptr
	var pMode uintptr
	var pMtime uintptr
	var pData uintptr
	var pMethod uintptr
	var bIsDir int32
	// var mode u32 at bp+136, 4

	var rc int32
	// var zErr uintptr at bp+128, 8

	var iMethod int32 // Compression method to use (0 or 8)

	var aData uintptr        // Possibly compressed data for new entry
	var nData int32          // Size of aData[] in bytes
	var szUncompressed int32 // Size of data before compression
	// var aFree uintptr at bp+112, 8
	// Free this before returning
	var iCrc32 u32 // crc32 of uncompressed data

	var zName uintptr // Path (name) of new entry
	var nName int32   // Size of zName in bytes
	var zFree uintptr // Free this before returning
	var nByte int32
	// var nOut int32 at bp+120, 4
	pName = uintptr(0)
	pMode = uintptr(0)
	pMtime = uintptr(0)
	pData = uintptr(0)
	pMethod = uintptr(0)
	bIsDir = 0
	rc = SQLITE_OK
	*(*uintptr)(unsafe.Pointer(bp + 128 /* zErr */)) = uintptr(0)
	iMethod = -1
	aData = uintptr(0)
	nData = 0
	szUncompressed = 0
	*(*uintptr)(unsafe.Pointer(bp + 112 /* aFree */)) = uintptr(0)
	iCrc32 = u32(0)
	zName = uintptr(0)
	nName = 0
	zFree = uintptr(0)

	libc.Xmemset(tls, bp+16 /* &e */, 0, uint64(unsafe.Sizeof(ZipfileEntry{})))
	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(ZipfileCtx{})))
	if !(p == uintptr(0)) {
		goto __1
	}
	return
__1:
	;

	// Martial the arguments into stack variables
	if !(nVal != 2 && nVal != 4 && nVal != 5) {
		goto __2
	}
	*(*uintptr)(unsafe.Pointer(bp + 128 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+10150 /* "wrong number of ..." */, 0)
	rc = SQLITE_ERROR
	goto zipfile_step_out
__2:
	;
	pName = *(*uintptr)(unsafe.Pointer(apVal))
	if !(nVal == 2) {
		goto __3
	}
	pData = *(*uintptr)(unsafe.Pointer(apVal + 1*8))
	goto __4
__3:
	pMode = *(*uintptr)(unsafe.Pointer(apVal + 1*8))
	pMtime = *(*uintptr)(unsafe.Pointer(apVal + 2*8))
	pData = *(*uintptr)(unsafe.Pointer(apVal + 3*8))
	if !(nVal == 5) {
		goto __5
	}
	pMethod = *(*uintptr)(unsafe.Pointer(apVal + 4*8))
__5:
	;
__4:
	;

	// Check that the 'name' parameter looks ok.
	zName = sqlite3.Xsqlite3_value_text(tls, pName)
	nName = sqlite3.Xsqlite3_value_bytes(tls, pName)
	if !(zName == uintptr(0)) {
		goto __6
	}
	*(*uintptr)(unsafe.Pointer(bp + 128 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+10198 /* "first argument t..." */, 0)
	rc = SQLITE_ERROR
	goto zipfile_step_out
__6:
	;

	// Inspect the 'method' parameter. This must be either 0 (store), 8 (use
	// deflate compression) or NULL (choose automatically).
	if !(pMethod != 0 && SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, pMethod)) {
		goto __7
	}
	iMethod = int32(sqlite3.Xsqlite3_value_int64(tls, pMethod))
	if !(iMethod != 0 && iMethod != 8) {
		goto __8
	}
	*(*uintptr)(unsafe.Pointer(bp + 128 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+10243 /* "illegal method v..." */, libc.VaList(bp, iMethod))
	rc = SQLITE_ERROR
	goto zipfile_step_out
__8:
	;
__7:
	;

	// Now inspect the data. If this is NULL, then the new entry must be a
	// directory.  Otherwise, figure out whether or not the data should
	// be deflated or simply stored in the zip archive.
	if !(sqlite3.Xsqlite3_value_type(tls, pData) == SQLITE_NULL) {
		goto __9
	}
	bIsDir = 1
	iMethod = 0
	goto __10
__9:
	aData = sqlite3.Xsqlite3_value_blob(tls, pData)
	szUncompressed = libc.AssignInt32(&nData, sqlite3.Xsqlite3_value_bytes(tls, pData))
	iCrc32 = u32(z.Xcrc32(tls, uint64(0), aData, uint32(nData)))
	if !(iMethod < 0 || iMethod == 8) {
		goto __11
	}
	*(*int32)(unsafe.Pointer(bp + 120 /* nOut */)) = 0
	rc = zipfileDeflate(tls, aData, nData, bp+112 /* &aFree */, bp+120 /* &nOut */, bp+128 /* &zErr */)
	if !(rc != SQLITE_OK) {
		goto __12
	}
	goto zipfile_step_out
__12:
	;
	if !(iMethod == 8 || *(*int32)(unsafe.Pointer(bp + 120)) < nData) {
		goto __13
	}
	aData = *(*uintptr)(unsafe.Pointer(bp + 112 /* aFree */))
	nData = *(*int32)(unsafe.Pointer(bp + 120 /* nOut */))
	iMethod = 8
	goto __14
__13:
	iMethod = 0
__14:
	;
__11:
	;
__10:
	;

	// Decode the "mode" argument.
	rc = zipfileGetMode(tls, pMode, bIsDir, bp+136 /* &mode */, bp+128 /* &zErr */)
	if !(rc != 0) {
		goto __15
	}
	goto zipfile_step_out
__15:
	;

	// Decode the "mtime" argument.
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).FmUnixTime = zipfileGetTime(tls, pMtime)

	// If this is a directory entry, ensure that there is exactly one '/'
	// at the end of the path. Or, if this is not a directory and the path
	// ends in '/' it is an error.
	if !(bIsDir == 0) {
		goto __16
	}
	if !(nName > 0 && int32(*(*int8)(unsafe.Pointer(zName + uintptr(nName-1)))) == '/') {
		goto __18
	}
	*(*uintptr)(unsafe.Pointer(bp + 128 /* zErr */)) = sqlite3.Xsqlite3_mprintf(tls, ts+10268 /* "non-directory na..." */, 0)
	rc = SQLITE_ERROR
	goto zipfile_step_out
__18:
	;
	goto __17
__16:
	if !(nName == 0 || int32(*(*int8)(unsafe.Pointer(zName + uintptr(nName-1)))) != '/') {
		goto __19
	}
	zName = libc.AssignUintptr(&zFree, sqlite3.Xsqlite3_mprintf(tls, ts+9771 /* "%s/" */, libc.VaList(bp+8, zName)))
	if !(zName == uintptr(0)) {
		goto __21
	}
	rc = SQLITE_NOMEM
	goto zipfile_step_out
__21:
	;
	nName = int32(libc.Xstrlen(tls, zName))
	goto __20
__19:
__22:
	if !(nName > 1 && int32(*(*int8)(unsafe.Pointer(zName + uintptr(nName-2)))) == '/') {
		goto __23
	}
	nName--
	goto __22
__23:
	;
__20:
	;
__17:
	;

	// Assemble the ZipfileEntry object for the new zip archive entry
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiVersionMadeBy = u16(int32(3)<<8 + 30)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiVersionExtract = u16(ZIPFILE_NEWENTRY_REQUIRED)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.Fflags = u16(ZIPFILE_NEWENTRY_FLAGS)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiCompression = u16(iMethod)
	zipfileMtimeToDos(tls, bp+16, (*ZipfileEntry)(unsafe.Pointer(bp+16 /* &e */)).FmUnixTime)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.Fcrc32 = iCrc32
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FszCompressed = u32(nData)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FszUncompressed = u32(szUncompressed)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiExternalAttr = *(*u32)(unsafe.Pointer(bp + 136)) << 16
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FiOffset = u32((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FnFile = u16(nName)
	(*ZipfileEntry)(unsafe.Pointer(bp + 16 /* &e */)).Fcds.FzFile = zName

	// Append the LFH to the body of the new archive
	nByte = ZIPFILE_LFH_FIXED_SZ + int32((*ZipfileEntry)(unsafe.Pointer(bp+16)).Fcds.FnFile) + 9
	if !(libc.AssignInt32(&rc, zipfileBufferGrow(tls, p+8, nByte)) != 0) {
		goto __24
	}
	goto zipfile_step_out
__24:
	;
	*(*int32)(unsafe.Pointer(p + 8 + 8)) += zipfileSerializeLFH(tls, bp+16, (*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa+uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn))

	// Append the data to the body of the new archive
	if !(nData > 0) {
		goto __25
	}
	if !(libc.AssignInt32(&rc, zipfileBufferGrow(tls, p+8, nData)) != 0) {
		goto __26
	}
	goto zipfile_step_out
__26:
	;
	libc.Xmemcpy(tls, (*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa+uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn), aData, uint64(nData))
	*(*int32)(unsafe.Pointer(p + 8 + 8)) += nData
__25:
	;

	// Append the CDS record to the directory of the new archive
	nByte = ZIPFILE_CDS_FIXED_SZ + int32((*ZipfileEntry)(unsafe.Pointer(bp+16)).Fcds.FnFile) + 9
	if !(libc.AssignInt32(&rc, zipfileBufferGrow(tls, p+24, nByte)) != 0) {
		goto __27
	}
	goto zipfile_step_out
__27:
	;
	*(*int32)(unsafe.Pointer(p + 24 + 8)) += zipfileSerializeCDS(tls, bp+16, (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fa+uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn))

	// Increment the count of entries in the archive
	(*ZipfileCtx)(unsafe.Pointer(p)).FnEntry++

zipfile_step_out:
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 112 /* aFree */)))
	sqlite3.Xsqlite3_free(tls, zFree)
	if !(rc != 0) {
		goto __28
	}
	if !(*(*uintptr)(unsafe.Pointer(bp + 128)) != 0) {
		goto __29
	}
	sqlite3.Xsqlite3_result_error(tls, pCtx, *(*uintptr)(unsafe.Pointer(bp + 128 /* zErr */)), -1)
	goto __30
__29:
	sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
__30:
	;
__28:
	;
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* zErr */)))
}

// xFinalize() callback for zipfile aggregate function.
func zipfileFinal(tls *libc.TLS, pCtx uintptr) { /* zipfile.c:2116:6: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var p uintptr
	// var eocd ZipfileEOCD at bp, 16

	var nZip sqlite3_int64
	var aZip uintptr

	p = sqlite3.Xsqlite3_aggregate_context(tls, pCtx, int32(unsafe.Sizeof(ZipfileCtx{})))
	if p == uintptr(0) {
		return
	}
	if (*ZipfileCtx)(unsafe.Pointer(p)).FnEntry > 0 {
		libc.Xmemset(tls, bp /* &eocd */, 0, uint64(unsafe.Sizeof(ZipfileEOCD{})))
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntry = u16((*ZipfileCtx)(unsafe.Pointer(p)).FnEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnEntryTotal = u16((*ZipfileCtx)(unsafe.Pointer(p)).FnEntry)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FnSize = u32((*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn)
		(*ZipfileEOCD)(unsafe.Pointer(bp /* &eocd */)).FiOffset = u32((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn)

		nZip = sqlite3_int64((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn + (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn + ZIPFILE_EOCD_FIXED_SZ)
		aZip = sqlite3.Xsqlite3_malloc64(tls, uint64(nZip))
		if aZip == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
		} else {
			libc.Xmemcpy(tls, aZip, (*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa, uint64((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn))
			libc.Xmemcpy(tls, aZip+uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn), (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fa, uint64((*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn))
			zipfileSerializeEOCD(tls, bp /* &eocd */, aZip+uintptr((*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fn+(*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fn))
			sqlite3.Xsqlite3_result_blob(tls, pCtx, aZip, int32(nZip), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{zipfileFree})))
		}
	}

	sqlite3.Xsqlite3_free(tls, (*ZipfileCtx)(unsafe.Pointer(p)).Fbody.Fa)
	sqlite3.Xsqlite3_free(tls, (*ZipfileCtx)(unsafe.Pointer(p)).Fcds.Fa)
}

// Register the "zipfile" virtual table.
func zipfileRegister(tls *libc.TLS, db uintptr) int32 { /* zipfile.c:2151:12: */

	var rc int32 = sqlite3.Xsqlite3_create_module(tls, db, ts+9209 /* "zipfile" */, uintptr(unsafe.Pointer(&zipfileModule)), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_overload_function(tls, db, ts+10138 /* "zipfile_cds" */, -1)
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, db, ts+9209 /* "zipfile" */, -1, SQLITE_UTF8, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{zipfileStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{zipfileFinal})))
	}

	return rc
}

var zipfileModule = sqlite3_module{
	FiVersion:      1, // iVersion
	FxCreate:       0, // xCreate
	FxConnect:      0, // xConnect
	FxBestIndex:    0, // xBestIndex
	FxDisconnect:   0, // xDisconnect
	FxDestroy:      0, // xDestroy
	FxOpen:         0, // xOpen - open a cursor
	FxClose:        0, // xClose - close a cursor
	FxFilter:       0, // xFilter - configure scan constraints
	FxNext:         0, // xNext - advance a cursor
	FxEof:          0, // xEof - check for end of scan
	FxColumn:       0, // xRowid - read data
	FxUpdate:       0, // xUpdate
	FxBegin:        0, // xSync
	FxCommit:       0, // xCommit
	FxRollback:     0, // xRollback
	FxFindFunction: 0, // xRename
} /* zipfile.c:2152:25 */

func sqlite3_zipfile_init(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* zipfile.c:2195:5: */
	_ = pApi

	_ = pzErrMsg // Unused parameter
	return zipfileRegister(tls, db)
}

func test_rbu_delta(tls *libc.TLS, pCtx uintptr, nArg int32, apVal uintptr) { /* test_rbu.c:34:6: */
	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pCtx)
	var pScript uintptr
	var i int32

	pScript = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, ts+10307 /* "rbu_delta" */, -1))
	for i = 0; i < nArg; i++ {
		var pIn uintptr = *(*uintptr)(unsafe.Pointer(apVal + uintptr(i)*8))
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, pIn)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, z, -1))
	}

	if TCL_OK == tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_GLOBAL_ONLY) {
		var z uintptr = tcl.XTcl_GetStringResult(tls, interp)
		sqlite3.Xsqlite3_result_text(tls, pCtx, z, -1, libc.UintptrFromInt32(-1))
	} else {
		tcl.XTcl_BackgroundError(tls, interp)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func test_sqlite3rbu_cmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:59:26: */
	bp := tls.Alloc(496)
	defer tls.Free(496)

	var ret int32 = TCL_OK
	var pRbu uintptr = clientData
	*(*[14]RbuCmd)(unsafe.Pointer(bp + 24 /* aCmd */)) = [14]RbuCmd{
		{FzName: ts + 10317 /* "step" */, FnArg: 2, FzUsage: ts + 584 /* "" */},                   // 0
		{FzName: ts + 10322 /* "close" */, FnArg: 2, FzUsage: ts + 584 /* "" */},                  // 1
		{FzName: ts + 10328 /* "create_rbu_delta" */, FnArg: 2, FzUsage: ts + 584 /* "" */},       // 2
		{FzName: ts + 10345 /* "savestate" */, FnArg: 2, FzUsage: ts + 584 /* "" */},              // 3
		{FzName: ts + 10355 /* "dbMain_eval" */, FnArg: 3, FzUsage: ts + 10367 /* "SQL" */},       // 4
		{FzName: ts + 10371 /* "bp_progress" */, FnArg: 2, FzUsage: ts + 584 /* "" */},            // 5
		{FzName: ts + 10383 /* "db" */, FnArg: 3, FzUsage: ts + 10386 /* "RBU" */},                // 6
		{FzName: ts + 10390 /* "state" */, FnArg: 2, FzUsage: ts + 584 /* "" */},                  // 7
		{FzName: ts + 10396 /* "progress" */, FnArg: 2, FzUsage: ts + 584 /* "" */},               // 8
		{FzName: ts + 10405 /* "close_no_error" */, FnArg: 2, FzUsage: ts + 584 /* "" */},         // 9
		{FzName: ts + 10420 /* "temp_size_limit" */, FnArg: 3, FzUsage: ts + 10436 /* "LIMIT" */}, // 10
		{FzName: ts + 10442 /* "temp_size" */, FnArg: 2, FzUsage: ts + 584 /* "" */},              // 11
		{FzName: ts + 10452 /* "dbRbu_eval" */, FnArg: 3, FzUsage: ts + 10367 /* "SQL" */},        // 12
		{},
	}
	// var iCmd int32 at bp+360, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10463 /* "METHOD" */)
		return TCL_ERROR
	}
	ret = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+24 /* &aCmd[0] */, int32(unsafe.Sizeof(RbuCmd{})), ts+10470 /* "method" */, 0, bp+360 /* &iCmd */)
	if ret != 0 {
		return TCL_ERROR
	}
	if objc != (*RbuCmd)(unsafe.Pointer(bp+24+uintptr(*(*int32)(unsafe.Pointer(bp + 360)))*24)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, (*RbuCmd)(unsafe.Pointer(bp+24 /* &aCmd */ +uintptr(*(*int32)(unsafe.Pointer(bp + 360 /* iCmd */)))*24)).FzUsage)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp + 360 /* iCmd */)) {
	case 0: /* step */
		{
			var rc int32 = sqlite3.Xsqlite3rbu_step(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			break

		}

	case 9:
		fallthrough /* close_no_error */
	case 1: /* close */
		{
			*(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)) = uintptr(0)
			var rc int32
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
			if *(*int32)(unsafe.Pointer(bp + 360)) == 1 {
				rc = sqlite3.Xsqlite3rbu_close(tls, pRbu, bp+368 /* &zErrmsg */)
			} else {
				rc = sqlite3.Xsqlite3rbu_close(tls, pRbu, uintptr(0))
			}
			if rc == SQLITE_OK || rc == SQLITE_DONE {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))

			} else {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
				if *(*uintptr)(unsafe.Pointer(bp + 368)) != 0 {
					tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10477 /* " - " */, *(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)), 0))
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 368 /* zErrmsg */)))
				}
				ret = TCL_ERROR
			}
			break

		}

	case 2: /* create_rbu_delta */
		{
			var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, 0)
			var rc int32 = sqlite3.Xsqlite3_create_function(tls,
				db, ts+10307 /* "rbu_delta" */, -1, SQLITE_UTF8, interp, *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{test_rbu_delta})), uintptr(0), uintptr(0))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == SQLITE_OK {
					return TCL_OK
				}
				return TCL_ERROR
			}()
			break

		}

	case 3: /* savestate */
		{
			var rc int32 = sqlite3.Xsqlite3rbu_savestate(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			ret = func() int32 {
				if rc == SQLITE_OK {
					return TCL_OK
				}
				return TCL_ERROR
			}()
			break

		}

	case 12:
		fallthrough /* dbRbu_eval */
	case 4: /* dbMain_eval */
		{
			var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 360)) == 12))
			var rc int32 = sqlite3.Xsqlite3_exec(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), uintptr(0), uintptr(0), uintptr(0))
			if rc != SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, db), -1))
				ret = TCL_ERROR
			}
			break

		}

	case 5: /* bp_progress */
		{
			// var one int32 at bp+376, 4

			// var two int32 at bp+380, 4

			var pObj uintptr
			sqlite3.Xsqlite3rbu_bp_progress(tls, pRbu, bp+376 /* &one */, bp+380 /* &two */)

			pObj = tcl.XTcl_NewObj(tls)
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 376 /* one */))))
			tcl.XTcl_ListObjAppendElement(tls, interp, pObj, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 380 /* two */))))
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break

		}

	case 6: /* db */
		{
			// var bArg int32 at bp+384, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+384) != 0 {
				ret = TCL_ERROR
			} else {
				// var zBuf [50]int8 at bp+388, 50

				var db uintptr = sqlite3.Xsqlite3rbu_db(tls, pRbu, *(*int32)(unsafe.Pointer(bp + 384 /* bArg */)))
				if sqlite3TestMakePointerStr(tls, interp, bp+388, db) != 0 {
					ret = TCL_ERROR
				} else {
					tcl.XTcl_SetResult(tls, interp, bp+388 /* &zBuf[0] */, uintptr(1))
				}
			}
			break

		}
	case 7: /* state */
		{
			*(*[6]uintptr)(unsafe.Pointer(bp + 440 /* aRes */)) = [6]uintptr{uintptr(0), ts + 10481 /* "oal" */, ts + 10485 /* "move" */, ts + 10490 /* "checkpoint" */, ts + 10501 /* "done" */, ts + 10506 /* "error" */}
			var eState int32 = sqlite3.Xsqlite3rbu_state(tls, pRbu)

			tcl.XTcl_SetResult(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 440 /* &aRes[0] */ + uintptr(eState)*8)), uintptr(0))
			break

		}
	case 8: /* progress */
		{
			var nStep sqlite3_int64 = sqlite3.Xsqlite3rbu_progress(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, nStep))
			break

		}

	case 10: /* temp_size_limit */
		{
			// var nLimit sqlite3_int64 at bp+488, 8

			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+488) != 0 {
				ret = TCL_ERROR
			} else {
				*(*sqlite3_int64)(unsafe.Pointer(bp + 488 /* nLimit */)) = sqlite3.Xsqlite3rbu_temp_size_limit(tls, pRbu, *(*sqlite3_int64)(unsafe.Pointer(bp + 488 /* nLimit */)))
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 488 /* nLimit */))))
			}
			break

		}
	case 11: /* temp_size */
		{
			var sz sqlite3_int64 = sqlite3.Xsqlite3rbu_temp_size(tls, pRbu)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, sz))
			break

		}

	default: // seems unlikely

		break
	}

	return ret
}

type RbuCmd = struct {
	FzName       uintptr
	FnArg        int32
	F__ccgo_pad1 [4]byte
	FzUsage      uintptr
} /* test_rbu.c:67:3 */

// Tclcmd: sqlite3rbu CMD <target-db> <rbu-db> ?<state-db>?
func test_sqlite3rbu(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:228:26: */
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zRbu uintptr
	var zStateDb uintptr = uintptr(0)

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10512 /* "NAME TARGET-DB R..." */)
		return TCL_ERROR
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	zRbu = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if objc == 5 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))
	}

	pRbu = sqlite3.Xsqlite3rbu_open(tls, zTarget, zRbu, zStateDb)
	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{test_sqlite3rbu_cmd})), pRbu, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	return TCL_OK
}

// Tclcmd: sqlite3rbu_vacuum CMD <target-db> <state-db>
func test_sqlite3rbu_vacuum(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:258:26: */
	var pRbu uintptr = uintptr(0)
	var zCmd uintptr
	var zTarget uintptr
	var zStateDb uintptr = uintptr(0)

	if objc != 3 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10545 /* "NAME TARGET-DB ?..." */)
		return TCL_ERROR
	}
	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zTarget = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if objc == 4 {
		zStateDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	}
	if zStateDb != 0 && int32(*(*int8)(unsafe.Pointer(zStateDb))) == 0 {
		zStateDb = uintptr(0)
	}

	pRbu = sqlite3.Xsqlite3rbu_vacuum(tls, zTarget, zStateDb)
	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{test_sqlite3rbu_cmd})), pRbu, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	return TCL_OK
}

// Tclcmd: sqlite3rbu_create_vfs ?-default? NAME PARENT
func test_sqlite3rbu_create_vfs(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:287:26: */
	var zName uintptr
	var zParent uintptr
	var rc int32

	if objc != 3 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10571 /* "?-default? NAME ..." */)
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*8)))
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8)))
	if int32(*(*int8)(unsafe.Pointer(zParent))) == 0 {
		zParent = uintptr(0)
	}

	rc = sqlite3.Xsqlite3rbu_create_vfs(tls, zName, zParent)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else if objc == 4 {
		var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, zName)
		sqlite3.Xsqlite3_vfs_register(tls, pVfs, 1)
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

// Tclcmd: sqlite3rbu_destroy_vfs NAME
func test_sqlite3rbu_destroy_vfs(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:322:26: */
	var zName uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10594 /* "NAME" */)
		return TCL_ERROR
	}

	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	sqlite3.Xsqlite3rbu_destroy_vfs(tls, zName)
	return TCL_OK
}

// Tclcmd: sqlite3rbu_internal_test
func test_sqlite3rbu_internal_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_rbu.c:343:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var db uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	db = sqlite3.Xsqlite3rbu_db(tls, uintptr(0), 0)
	if db != uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10599 /* "sqlite3rbu_db(0,..." */, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

func SqliteRbu_Init(tls *libc.TLS, interp uintptr) int32 { /* test_rbu.c:365:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd[i].FzName, aObjCmd[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 10622 /* "sqlite3rbu" */, FxProc: 0},
	{FzName: ts + 10633 /* "sqlite3rbu_vacuu..." */, FxProc: 0},
	{FzName: ts + 10651 /* "sqlite3rbu_creat..." */, FxProc: 0},
	{FzName: ts + 10673 /* "sqlite3rbu_destr..." */, FxProc: 0},
	{FzName: ts + 10696 /* "sqlite3rbu_inter..." */, FxProc: 0},
} /* test_rbu.c:369:5 */

// CAPI3REF: Database Connection Handle
// KEYWORDS: {database connection} {database connections}
//
// Each open SQLite database is represented by a pointer to an instance of
// the opaque structure named "sqlite3".  It is useful to think of an sqlite3
// pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
// [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]
// and [sqlite3_close_v2()] are its destructors.  There are many other
// interfaces (such as
// [sqlite3_prepare_v2()], [sqlite3_create_function()], and
// [sqlite3_busy_timeout()] to name but three) that are methods on an
// sqlite3 object.
type sqlite31 = sqlite32 /* sqlite3.h:272:24 */

// CAPI3REF: Dynamic String Object
// KEYWORDS: {dynamic string}
//
// An instance of the sqlite3_str object contains a dynamically-sized
// string under construction.
//
// The lifecycle of an sqlite3_str object is as follows:
// <ol>
// <li> ^The sqlite3_str object is created using [sqlite3_str_new()].
// <li> ^Text is appended to the sqlite3_str object using various
// methods, such as [sqlite3_str_appendf()].
// <li> ^The sqlite3_str object is destroyed and the string it created
// is returned using the [sqlite3_str_finish()] interface.
// </ol>
type sqlite3_str = sqlite3_str1 /* sqlite3.h:8016:28 */

type int_least8_t = int8   /* stdint.h:40:25 */
type int_least16_t = int16 /* stdint.h:41:26 */
type int_least32_t = int32 /* stdint.h:42:26 */
type int_least64_t = int64 /* stdint.h:43:26 */

type uint_least8_t = uint8   /* stdint.h:45:26 */
type uint_least16_t = uint16 /* stdint.h:46:26 */
type uint_least32_t = uint32 /* stdint.h:47:26 */
type uint_least64_t = uint64 /* stdint.h:48:26 */

type int_fast8_t = int32  /* stdint.h:50:24 */
type int_fast16_t = int32 /* stdint.h:51:25 */
type int_fast32_t = int32 /* stdint.h:52:25 */
type int_fast64_t = int64 /* stdint.h:53:25 */

type uint_fast8_t = uint32  /* stdint.h:55:25 */
type uint_fast16_t = uint32 /* stdint.h:56:26 */
type uint_fast32_t = uint32 /* stdint.h:57:26 */
type uint_fast64_t = uint64 /* stdint.h:58:26 */

type imaxdiv_t = struct {
	Fquot intmax_t
	Frem  intmax_t
} /* inttypes.h:47:3 */

// Is the sqlite3ErrName() function needed in the build?  Currently,
// it is needed by "mutex_w32.c" (when debugging), "os_win.c" (when
// OSTRACE is enabled), and by several "test*.c" files (which are
// compiled using SQLITE_TEST).

// SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN

// SQLITE_OMIT_VIRTUALTABLE implies SQLITE_OMIT_ALTERTABLE

// Return true (non-zero) if the input is an integer that is too large
// to fit in 32-bits.  This macro is used inside of various testcase()
// macros to verify that we have tested SQLite for large-file support.

// The macro unlikely() is a hint that surrounds a boolean
// expression that is usually false.  Macro likely() surrounds
// a boolean expression that is usually true.  These hints could,
// in theory, be used by the compiler to generate better code, but
// currently they are just comments for human readers.

// 2001 September 22
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for the generic hash-table implementation
// used in SQLite.

// Forward declarations of structures.
type Hash1 = struct {
	Fhtsize uint32
	Fcount  uint32
	Ffirst  uintptr
	Fht     uintptr
} /* sqlite3.h:272:9 */

// Is the sqlite3ErrName() function needed in the build?  Currently,
// it is needed by "mutex_w32.c" (when debugging), "os_win.c" (when
// OSTRACE is enabled), and by several "test*.c" files (which are
// compiled using SQLITE_TEST).

// SQLITE_ENABLE_EXPLAIN_COMMENTS is incompatible with SQLITE_OMIT_EXPLAIN

// SQLITE_OMIT_VIRTUALTABLE implies SQLITE_OMIT_ALTERTABLE

// Return true (non-zero) if the input is an integer that is too large
// to fit in 32-bits.  This macro is used inside of various testcase()
// macros to verify that we have tested SQLite for large-file support.

// The macro unlikely() is a hint that surrounds a boolean
// expression that is usually false.  Macro likely() surrounds
// a boolean expression that is usually true.  These hints could,
// in theory, be used by the compiler to generate better code, but
// currently they are just comments for human readers.

// 2001 September 22
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for the generic hash-table implementation
// used in SQLite.

// Forward declarations of structures.
type Hash = Hash1 /* hash.h:19:21 */
type HashElem1 = struct {
	Fnext uintptr
	Fprev uintptr
	Fdata uintptr
	FpKey uintptr
} /* sqlite3.h:272:9 */

type HashElem = HashElem1 /* hash.h:20:25 */

// A complete hash table is an instance of the following structure.
// The internals of this structure are intended to be opaque -- client
// code should not attempt to access or modify the fields of this structure
// directly.  Change this structure only by using the routines below.
// However, some of the "procedures" and "functions" for modifying and
// accessing this structure are really macros, so we can't really make
// this structure opaque.
//
// All elements of the hash table are on a single doubly-linked list.
// Hash.first points to the head of this list.
//
// There are Hash.htsize buckets.  Each bucket points to a spot in
// the global doubly-linked list.  The contents of the bucket are the
// element pointed to plus the next _ht.count-1 elements in the list.
//
// Hash.htsize and Hash.ht may be zero.  In that case lookup is done
// by a linear search of the global list.  For small tables, the
// Hash.ht table is never allocated because if there are few elements
// in the table, it is faster to do a linear search than to manage
// the hash table.
type _ht = struct {
	Fcount       uint32
	F__ccgo_pad1 [4]byte
	Fchain       uintptr
} /* sqlite3.h:272:9 */

// 2-byte unsigned integer
type i16 = int16_t /* sqliteInt.h:803:20 */ // 1-byte unsigned integer
type i8 = int8_t   /* sqliteInt.h:805:19 */ // 1-byte signed integer

// SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value
// that can be stored in a u32 without loss of data.  The value
// is 0x00000000ffffffff.  But because of quirks of some compilers, we
// have to specify the value in the less intuitive manner shown:

// The datatype used to store estimates of the number of rows in a
// table or index.  This is an unsigned integer type.  For 99.9% of
// the world, a 32-bit integer is sufficient.  But a 64-bit integer
// can be used at compile-time if desired.
type tRowcnt = u32 /* sqliteInt.h:824:14 */ // 32-bit is the default

// Estimated quantities used for query planning are stored as 16-bit
// logarithms.  For quantity X, the value stored is 10*log2(X).  This
// gives a possible range of values of approximately 1.0e986 to 1e-986.
// But the allowed values are "grainy".  Not every value is representable.
// For example, quantities 16 and 17 are both represented by a LogEst
// of 40.  However, since LogEst quantities are suppose to be estimates,
// not exact values, this imprecision is not a problem.
//
// "LogEst" is short for "Logarithmic Estimate".
//
// Examples:
//      1 -> 0              20 -> 43          10000 -> 132
//      2 -> 10             25 -> 46          25000 -> 146
//      3 -> 16            100 -> 66        1000000 -> 199
//      4 -> 20           1000 -> 99        1048576 -> 200
//     10 -> 33           1024 -> 100    4294967296 -> 320
//
// The LogEst can be negative to indicate fractional values.
// Examples:
//
//    0.5 -> -10           0.1 -> -33        0.0625 -> -40
type LogEst = int16_t /* sqliteInt.h:850:20 */

// Set the SQLITE_PTRSIZE macro to the number of bytes in a pointer

// The uptr type is an unsigned integer large enough to hold a pointer
type uptr = uintptr_t /* sqliteInt.h:871:21 */

// An instance of the following structure is used to store the busy-handler
// callback for a given sqlite handle.
//
// The sqlite.busyHandler member of the sqlite struct contains the busy
// callback for the database handle. Each pager opened via the sqlite
// handle is passed a pointer to sqlite.busyHandler. The busy-handler
// callback is currently invoked only from within pager.c.
type BusyHandler1 = struct {
	FxBusyHandler uintptr
	FpBusyArg     uintptr
	FnBusy        int32
	F__ccgo_pad1  [4]byte
} /* sqlite3.h:272:9 */

// An instance of the following structure is used to store the busy-handler
// callback for a given sqlite handle.
//
// The sqlite.busyHandler member of the sqlite struct contains the busy
// callback for the database handle. Each pager opened via the sqlite
// handle is passed a pointer to sqlite.busyHandler. The busy-handler
// callback is currently invoked only from within pager.c.
type BusyHandler = BusyHandler1 /* sqliteInt.h:1046:28 */

// Name of table that holds the database schema.
//
// The PREFERRED names are used whereever possible.  But LEGACY is also
// used for backwards compatibility.
//
//  1.  Queries can use either the PREFERRED or the LEGACY names
//  2.  The sqlite3_set_authorizer() callback uses the LEGACY name
//  3.  The PRAGMA table_list statement uses the PREFERRED name
//
// The LEGACY names are stored in the internal symbol hash table
// in support of (2).  Names are translated using sqlite3PreferredTableName()
// for (3).  The sqlite3FindTable() function takes care of translating
// names for (1).
//
// Note that "sqlite_temp_schema" can also be called "temp.sqlite_schema".

// The root-page of the schema table.

// The name of the schema table.  The name is different for TEMP.

// A convenience macro that returns the number of elements in
// an array.

// Determine if the argument is a power of two

// The following value as a destructor means to use sqlite3DbFree().
// The sqlite3DbFree() routine requires two parameters instead of the
// one parameter that destructors normally want.  So we have to introduce
// this magic value that the code knows to handle differently.  Any
// pointer will work here as long as it is distinct from SQLITE_STATIC
// and SQLITE_TRANSIENT.

// When SQLITE_OMIT_WSD is defined, it means that the target platform does
// not support Writable Static Data (WSD) such as global and static variables.
// All variables must either be on the stack or dynamically allocated from
// the heap.  When WSD is unsupported, the variable declarations scattered
// throughout the SQLite code must become constants instead.  The SQLITE_WSD
// macro is used for this purpose.  And instead of referencing the variable
// directly, we use its constant as a key to lookup the run-time allocated
// buffer that holds real variable.  The constant is also the initializer
// for the run-time allocated buffer.
//
// In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL
// macros become no-ops and have zero performance impact.

// The following macros are used to suppress compiler warnings and to
// make it clear to human readers when a function parameter is deliberately
// left unused within the body of a function. This usually happens when
// a function is called via a function pointer. For example the
// implementation of an SQL aggregate step callback may not use the
// parameter indicating the number of arguments passed to the aggregate,
// if it knows that this is enforced elsewhere.
//
// When a function parameter is not used at all within the body of a function,
// it is generally named "NotUsed" or "NotUsed2" to make things even clearer.
// However, these macros may also be used to suppress warnings related to
// parameters that may or may not be used depending on compilation options.
// For example those parameters only used in assert() statements. In these
// cases the parameters are named as per the usual conventions.

// Forward references to structures
type AggInfo1 = struct {
	FdirectMode     u8
	FuseSortingIdx  u8
	F__ccgo_pad1    [2]byte
	FsortingIdx     int32
	FsortingIdxPTab int32
	FnSortingColumn int32
	FmnReg          int32
	FmxReg          int32
	FpGroupBy       uintptr
	FaCol           uintptr
	FnColumn        int32
	FnAccumulator   int32
	FaFunc          uintptr
	FnFunc          int32
	FselId          u32
} /* sqlite3.h:272:9 */

// Name of table that holds the database schema.
//
// The PREFERRED names are used whereever possible.  But LEGACY is also
// used for backwards compatibility.
//
//  1.  Queries can use either the PREFERRED or the LEGACY names
//  2.  The sqlite3_set_authorizer() callback uses the LEGACY name
//  3.  The PRAGMA table_list statement uses the PREFERRED name
//
// The LEGACY names are stored in the internal symbol hash table
// in support of (2).  Names are translated using sqlite3PreferredTableName()
// for (3).  The sqlite3FindTable() function takes care of translating
// names for (1).
//
// Note that "sqlite_temp_schema" can also be called "temp.sqlite_schema".

// The root-page of the schema table.

// The name of the schema table.  The name is different for TEMP.

// A convenience macro that returns the number of elements in
// an array.

// Determine if the argument is a power of two

// The following value as a destructor means to use sqlite3DbFree().
// The sqlite3DbFree() routine requires two parameters instead of the
// one parameter that destructors normally want.  So we have to introduce
// this magic value that the code knows to handle differently.  Any
// pointer will work here as long as it is distinct from SQLITE_STATIC
// and SQLITE_TRANSIENT.

// When SQLITE_OMIT_WSD is defined, it means that the target platform does
// not support Writable Static Data (WSD) such as global and static variables.
// All variables must either be on the stack or dynamically allocated from
// the heap.  When WSD is unsupported, the variable declarations scattered
// throughout the SQLite code must become constants instead.  The SQLITE_WSD
// macro is used for this purpose.  And instead of referencing the variable
// directly, we use its constant as a key to lookup the run-time allocated
// buffer that holds real variable.  The constant is also the initializer
// for the run-time allocated buffer.
//
// In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL
// macros become no-ops and have zero performance impact.

// The following macros are used to suppress compiler warnings and to
// make it clear to human readers when a function parameter is deliberately
// left unused within the body of a function. This usually happens when
// a function is called via a function pointer. For example the
// implementation of an SQL aggregate step callback may not use the
// parameter indicating the number of arguments passed to the aggregate,
// if it knows that this is enforced elsewhere.
//
// When a function parameter is not used at all within the body of a function,
// it is generally named "NotUsed" or "NotUsed2" to make things even clearer.
// However, these macros may also be used to suppress warnings related to
// parameters that may or may not be used depending on compilation options.
// For example those parameters only used in assert() statements. In these
// cases the parameters are named as per the usual conventions.

// Forward references to structures
type AggInfo = AggInfo1 /* sqliteInt.h:1156:24 */
type AuthContext1 = struct {
	FzAuthContext uintptr
	FpParse       uintptr
} /* sqliteInt.h:1157:9 */

type AuthContext = AuthContext1 /* sqliteInt.h:1157:28 */
type AutoincInfo1 = struct {
	FpNext  uintptr
	FpTab   uintptr
	FiDb    int32
	FregCtr int32
} /* sqlite3.h:272:9 */

type AutoincInfo = AutoincInfo1 /* sqliteInt.h:1158:28 */
type CollSeq1 = struct {
	FzName       uintptr
	Fenc         u8
	F__ccgo_pad1 [7]byte
	FpUser       uintptr
	FxCmp        uintptr
	FxDel        uintptr
} /* sqlite3.h:272:9 */

type CollSeq = CollSeq1 /* sqliteInt.h:1160:24 */
type Column1 = struct {
	FzCnName     uintptr
	FnotNull     uint8 /* unsigned notNull: 4, unsigned eCType: 4 */
	F__ccgo_pad1 [1]byte
	Faffinity    int8
	FszEst       u8
	FhName       u8
	F__ccgo_pad2 [1]byte
	FiDflt       u16
	FcolFlags    u16
	F__ccgo_pad3 [6]byte
} /* sqlite3.h:272:9 */

type Column = Column1 /* sqliteInt.h:1161:23 */
type Cte1 = struct {
	FzName       uintptr
	FpCols       uintptr
	FpSelect     uintptr
	FzCteErr     uintptr
	FpUse        uintptr
	FeM10d       u8
	F__ccgo_pad1 [7]byte
} /* sqlite3.h:272:9 */

type Cte = Cte1 /* sqliteInt.h:1162:20 */
type CteUse1 = struct {
	FnUse        int32
	FaddrM9e     int32
	FregRtn      int32
	FiCur        int32
	FnRowEst     LogEst
	FeM10d       u8
	F__ccgo_pad1 [1]byte
} /* sqlite3.h:272:9 */

type CteUse = CteUse1 /* sqliteInt.h:1163:23 */
type Db1 = struct {
	FzDbSName     uintptr
	FpBt          uintptr
	Fsafety_level u8
	FbSyncSet     u8
	F__ccgo_pad1  [6]byte
	FpSchema      uintptr
} /* sqlite3.h:272:9 */

type Db = Db1 /* sqliteInt.h:1164:19 */
type DbFixer1 = struct {
	FpParse      uintptr
	Fw           Walker
	FpSchema     uintptr
	FbTemp       u8
	F__ccgo_pad1 [7]byte
	FzDb         uintptr
	FzType       uintptr
	FpName       uintptr
} /* sqliteInt.h:1165:9 */

type DbFixer = DbFixer1 /* sqliteInt.h:1165:24 */
type Schema1 = struct {
	Fschema_cookie int32
	FiGeneration   int32
	FtblHash       Hash
	FidxHash       Hash
	FtrigHash      Hash
	FfkeyHash      Hash
	FpSeqTab       uintptr
	Ffile_format   u8
	Fenc           u8
	FschemaFlags   u16
	Fcache_size    int32
} /* sqlite3.h:272:9 */

type Schema = Schema1 /* sqliteInt.h:1166:23 */
type Expr1 = struct {
	Fop              u8
	FaffExpr         int8
	Fop2             u8
	F__ccgo_pad1     [1]byte
	Fflags           u32
	Fu               struct{ FzToken uintptr }
	FpLeft           uintptr
	FpRight          uintptr
	Fx               struct{ FpList uintptr }
	FnHeight         int32
	FiTable          int32
	FiColumn         ynVar
	FiAgg            i16
	FiRightJoinTable int32
	FpAggInfo        uintptr
	Fy               struct{ FpTab uintptr }
} /* sqlite3.h:272:9 */

type Expr = Expr1 /* sqliteInt.h:1167:21 */
type ExprList1 = struct {
	FnExpr  int32
	FnAlloc int32
	Fa      [1]struct {
		FpExpr       uintptr
		FzEName      uintptr
		FsortFlags   u8
		F__ccgo_pad1 [3]byte
		FeEName      uint8 /* unsigned eEName: 2, unsigned done: 1, unsigned reusable: 1, unsigned bSorterRef: 1, unsigned bNulls: 1 */
		F__ccgo_pad2 [3]byte
		Fu           struct {
			F__ccgo_pad1 [0]uint32
			Fx           struct {
				FiOrderByCol u16
				FiAlias      u16
			}
		}
		F__ccgo_pad3 [4]byte
	}
} /* sqlite3.h:272:9 */

type ExprList = ExprList1 /* sqliteInt.h:1168:25 */
type FKey1 = struct {
	FpFrom       uintptr
	FpNextFrom   uintptr
	FzTo         uintptr
	FpNextTo     uintptr
	FpPrevTo     uintptr
	FnCol        int32
	FisDeferred  u8
	FaAction     [2]u8
	F__ccgo_pad1 [1]byte
	FapTrigger   [2]uintptr
	FaCol        [1]struct {
		FiFrom       int32
		F__ccgo_pad1 [4]byte
		FzCol        uintptr
	}
} /* sqliteInt.h:1169:9 */

type FKey = FKey1 /* sqliteInt.h:1169:21 */
type FuncDestructor1 = struct {
	FnRef        int32
	F__ccgo_pad1 [4]byte
	FxDestroy    uintptr
	FpUserData   uintptr
} /* sqliteInt.h:1170:9 */

type FuncDestructor = FuncDestructor1 /* sqliteInt.h:1170:31 */
type FuncDef1 = struct {
	FnArg        i8
	F__ccgo_pad1 [3]byte
	FfuncFlags   u32
	FpUserData   uintptr
	FpNext       uintptr
	FxSFunc      uintptr
	FxFinalize   uintptr
	FxValue      uintptr
	FxInverse    uintptr
	FzName       uintptr
	Fu           struct{ FpHash uintptr }
} /* sqlite3.h:272:9 */

type FuncDef = FuncDef1                      /* sqliteInt.h:1171:24 */
type FuncDefHash1 = struct{ Fa [23]uintptr } /* sqliteInt.h:1172:9 */

type FuncDefHash = FuncDefHash1 /* sqliteInt.h:1172:28 */
type IdList1 = struct {
	Fa           uintptr
	FnId         int32
	F__ccgo_pad1 [4]byte
} /* sqlite3.h:272:9 */

type IdList = IdList1 /* sqliteInt.h:1173:23 */
type Index1 = struct {
	FzName         uintptr
	FaiColumn      uintptr
	FaiRowLogEst   uintptr
	FpTable        uintptr
	FzColAff       uintptr
	FpNext         uintptr
	FpSchema       uintptr
	FaSortOrder    uintptr
	FazColl        uintptr
	FpPartIdxWhere uintptr
	FaColExpr      uintptr
	Ftnum          Pgno
	FszIdxRow      LogEst
	FnKeyCol       u16
	FnColumn       u16
	FonError       u8
	F__ccgo_pad1   [1]byte
	FidxType       uint16 /* unsigned idxType: 2, unsigned bUnordered: 1, unsigned uniqNotNull: 1, unsigned isResized: 1, unsigned isCovering: 1, unsigned noSkipScan: 1, unsigned hasStat1: 1, unsigned bNoQuery: 1, unsigned bAscKeyBug: 1, unsigned bHasVCol: 1 */
	F__ccgo_pad2   [2]byte
	FnSample       int32
	FnSampleCol    int32
	FaAvgEq        uintptr
	FaSample       uintptr
	FaiRowEst      uintptr
	FnRowEst0      tRowcnt
	F__ccgo_pad3   [4]byte
	FcolNotIdxed   Bitmask
} /* sqlite3.h:272:9 */

type Index = Index1 /* sqliteInt.h:1174:22 */
type IndexSample1 = struct {
	Fp           uintptr
	Fn           int32
	F__ccgo_pad1 [4]byte
	FanEq        uintptr
	FanLt        uintptr
	FanDLt       uintptr
} /* sqlite3.h:272:9 */

type IndexSample = IndexSample1 /* sqliteInt.h:1175:28 */
type KeyInfo1 = struct {
	FnRef        u32
	Fenc         u8
	F__ccgo_pad1 [1]byte
	FnKeyField   u16
	FnAllField   u16
	F__ccgo_pad2 [6]byte
	Fdb          uintptr
	FaSortFlags  uintptr
	FaColl       [1]uintptr
} /* sqlite3.h:272:9 */

type KeyInfo = KeyInfo1 /* sqliteInt.h:1177:24 */
type Lookaside1 = struct {
	FbDisable    u32
	Fsz          u16
	FszTrue      u16
	FbMalloced   u8
	F__ccgo_pad1 [3]byte
	FnSlot       u32
	FanStat      [3]u32
	F__ccgo_pad2 [4]byte
	FpInit       uintptr
	FpFree       uintptr
	FpSmallInit  uintptr
	FpSmallFree  uintptr
	FpMiddle     uintptr
	FpStart      uintptr
	FpEnd        uintptr
} /* sqlite3.h:272:9 */

type Lookaside = Lookaside1                    /* sqliteInt.h:1178:26 */
type LookasideSlot1 = struct{ FpNext uintptr } /* sqlite3.h:272:9 */

type LookasideSlot = LookasideSlot1 /* sqliteInt.h:1179:30 */
type Module1 = struct {
	FpModule     uintptr
	FzName       uintptr
	FnRefModule  int32
	F__ccgo_pad1 [4]byte
	FpAux        uintptr
	FxDestroy    uintptr
	FpEpoTab     uintptr
} /* sqlite3.h:272:9 */

type Module = Module1 /* sqliteInt.h:1180:23 */
type NameContext1 = struct {
	FpParse      uintptr
	FpSrcList    uintptr
	FuNC         struct{ FpEList uintptr }
	FpNext       uintptr
	FnRef        int32
	FnNcErr      int32
	FncFlags     int32
	F__ccgo_pad1 [4]byte
	FpWinSelect  uintptr
} /* sqliteInt.h:1181:9 */

type NameContext = NameContext1 /* sqliteInt.h:1181:28 */
type Parse1 = struct {
	Fdb               uintptr
	FzErrMsg          uintptr
	FpVdbe            uintptr
	Frc               int32
	FcolNamesSet      u8
	FcheckSchema      u8
	Fnested           u8
	FnTempReg         u8
	FisMultiWrite     u8
	FmayAbort         u8
	FhasCompound      u8
	FokConstFactor    u8
	FdisableLookaside u8
	FdisableVtab      u8
	F__ccgo_pad1      [2]byte
	FnRangeReg        int32
	FiRangeReg        int32
	FnErr             int32
	FnTab             int32
	FnMem             int32
	FszOpAlloc        int32
	FiSelfTab         int32
	FnLabel           int32
	FnLabelAlloc      int32
	F__ccgo_pad2      [4]byte
	FaLabel           uintptr
	FpConstExpr       uintptr
	FconstraintName   Token
	FwriteMask        yDbMask
	FcookieMask       yDbMask
	FregRowid         int32
	FregRoot          int32
	FnMaxArg          int32
	FnSelect          int32
	FnTableLock       int32
	F__ccgo_pad3      [4]byte
	FaTableLock       uintptr
	FpAinc            uintptr
	FpToplevel        uintptr
	FpTriggerTab      uintptr
	Fu1               struct {
		F__ccgo_pad1 [0]uint64
		FaddrCrTab   int32
		F__ccgo_pad2 [4]byte
	}
	FnQueryLoop      u32
	Foldmask         u32
	Fnewmask         u32
	FeTriggerOp      u8
	FbReturning      u8
	FeOrconf         u8
	FdisableTriggers u8
	FaTempReg        [8]int32
	FsNameToken      Token
	FsLastToken      Token
	FnVar            ynVar
	FiPkSortOrder    u8
	Fexplain         u8
	FeParseMode      u8
	F__ccgo_pad4     [3]byte
	FnVtabLock       int32
	FnHeight         int32
	FaddrExplain     int32
	F__ccgo_pad5     [4]byte
	FpVList          uintptr
	FpReprepare      uintptr
	FzTail           uintptr
	FpNewTable       uintptr
	FpNewIndex       uintptr
	FpNewTrigger     uintptr
	FzAuthContext    uintptr
	FsArg            Token
	FapVtabLock      uintptr
	FpTriggerPrg     uintptr
	FpWith           uintptr
	FpCleanup        uintptr
	FpRename         uintptr
} /* sqlite3.h:272:9 */

type Parse = Parse1 /* sqliteInt.h:1182:22 */
type ParseCleanup1 = struct {
	FpNext    uintptr
	FpPtr     uintptr
	FxCleanup uintptr
} /* sqlite3.h:272:9 */

type ParseCleanup = ParseCleanup1 /* sqliteInt.h:1183:29 */
type PreUpdate1 = struct {
	Fv            uintptr
	FpCsr         uintptr
	Fop           int32
	F__ccgo_pad1  [4]byte
	FaRecord      uintptr
	Fkeyinfo      KeyInfo
	FpUnpacked    uintptr
	FpNewUnpacked uintptr
	FiNewReg      int32
	FiBlobWrite   int32
	FiKey1        i64
	FiKey2        i64
	FaNew         uintptr
	FpTab         uintptr
	FpPk          uintptr
} /* sqliteInt.h:1184:9 */

type PrintfArguments1 = struct {
	FnArg  int32
	FnUsed int32
	FapArg uintptr
} /* sqliteInt.h:1185:9 */

type PrintfArguments = PrintfArguments1 /* sqliteInt.h:1185:32 */
type Returning1 = struct {
	FpParse      uintptr
	FpReturnEL   uintptr
	FretTrig     Trigger
	FretTStep    TriggerStep
	FiRetCur     int32
	FnRetCol     int32
	FiRetReg     int32
	F__ccgo_pad1 [4]byte
} /* sqliteInt.h:1187:9 */

type Returning = Returning1 /* sqliteInt.h:1187:26 */
type Savepoint1 = struct {
	FzName            uintptr
	FnDeferredCons    i64
	FnDeferredImmCons i64
	FpNext            uintptr
} /* sqlite3.h:272:9 */

type Savepoint = Savepoint1 /* sqliteInt.h:1189:26 */
type Select1 = struct {
	Fop           u8
	F__ccgo_pad1  [1]byte
	FnSelectRow   LogEst
	FselFlags     u32
	FiLimit       int32
	FiOffset      int32
	FselId        u32
	FaddrOpenEphm [2]int32
	F__ccgo_pad2  [4]byte
	FpEList       uintptr
	FpSrc         uintptr
	FpWhere       uintptr
	FpGroupBy     uintptr
	FpHaving      uintptr
	FpOrderBy     uintptr
	FpPrior       uintptr
	FpNext        uintptr
	FpLimit       uintptr
	FpWith        uintptr
	FpWin         uintptr
	FpWinDefn     uintptr
} /* sqlite3.h:272:9 */

type Select = Select1 /* sqliteInt.h:1190:23 */
type SelectDest1 = struct {
	FeDest       u8
	F__ccgo_pad1 [3]byte
	FiSDParm     int32
	FiSDParm2    int32
	FiSdst       int32
	FnSdst       int32
	F__ccgo_pad2 [4]byte
	FzAffSdst    uintptr
	FpOrderBy    uintptr
} /* sqliteInt.h:1192:9 */

type SelectDest = SelectDest1 /* sqliteInt.h:1192:27 */
type SrcItem1 = struct {
	FpSchema     uintptr
	FzDatabase   uintptr
	FzName       uintptr
	FzAlias      uintptr
	FpTab        uintptr
	FpSelect     uintptr
	FaddrFillSub int32
	FregReturn   int32
	FregResult   int32
	Ffg          struct {
		F__ccgo_pad1 [0]uint32
		Fjointype    u8
		F__ccgo_pad2 [3]byte
		FnotIndexed  uint16 /* unsigned notIndexed: 1, unsigned isIndexedBy: 1, unsigned isTabFunc: 1, unsigned isCorrelated: 1, unsigned viaCoroutine: 1, unsigned isRecursive: 1, unsigned fromDDL: 1, unsigned isCte: 1, unsigned notCte: 1 */
		F__ccgo_pad3 [2]byte
	}
	FiCursor int32
	FpOn     uintptr
	FpUsing  uintptr
	FcolUsed Bitmask
	Fu1      struct{ FzIndexedBy uintptr }
	Fu2      struct{ FpIBIndex uintptr }
} /* sqlite3.h:272:9 */

type SrcItem = SrcItem1 /* sqliteInt.h:1193:24 */
type SrcList1 = struct {
	FnSrc   int32
	FnAlloc u32
	Fa      [1]SrcItem
} /* sqlite3.h:272:9 */

type SrcList = SrcList1      /* sqliteInt.h:1194:24 */
type StrAccum = sqlite3_str1 /* sqliteInt.h:1195:28 */ // Internal alias for sqlite3_str
type Table1 = struct {
	FzName      uintptr
	FaCol       uintptr
	FpIndex     uintptr
	FzColAff    uintptr
	FpCheck     uintptr
	Ftnum       Pgno
	FnTabRef    u32
	FtabFlags   u32
	FiPKey      i16
	FnCol       i16
	FnNVCol     i16
	FnRowLogEst LogEst
	FszTabRow   LogEst
	FkeyConf    u8
	FeTabType   u8
	Fu          struct {
		Ftab struct {
			FaddColOffset int32
			F__ccgo_pad1  [4]byte
			FpFKey        uintptr
			FpDfltList    uintptr
		}
	}
	FpTrigger uintptr
	FpSchema  uintptr
} /* sqlite3.h:272:9 */

// Internal alias for sqlite3_str
type Table = Table1 /* sqliteInt.h:1196:22 */
type Token1 = struct {
	Fz           uintptr
	Fn           uint32
	F__ccgo_pad1 [4]byte
} /* sqlite3.h:272:9 */

type Token = Token1 /* sqliteInt.h:1198:22 */
type Trigger1 = struct {
	FzName       uintptr
	Ftable       uintptr
	Fop          u8
	Ftr_tm       u8
	FbReturning  u8
	F__ccgo_pad1 [5]byte
	FpWhen       uintptr
	FpColumns    uintptr
	FpSchema     uintptr
	FpTabSchema  uintptr
	Fstep_list   uintptr
	FpNext       uintptr
} /* sqlite3.h:272:9 */

type Trigger = Trigger1 /* sqliteInt.h:1200:24 */
type TriggerPrg1 = struct {
	FpTrigger    uintptr
	FpNext       uintptr
	FpProgram    uintptr
	Forconf      int32
	FaColmask    [2]u32
	F__ccgo_pad1 [4]byte
} /* sqlite3.h:272:9 */

type TriggerPrg = TriggerPrg1 /* sqliteInt.h:1201:27 */
type TriggerStep1 = struct {
	Fop          u8
	Forconf      u8
	F__ccgo_pad1 [6]byte
	FpTrig       uintptr
	FpSelect     uintptr
	FzTarget     uintptr
	FpFrom       uintptr
	FpWhere      uintptr
	FpExprList   uintptr
	FpIdList     uintptr
	FpUpsert     uintptr
	FzSpan       uintptr
	FpNext       uintptr
	FpLast       uintptr
} /* sqlite3.h:272:9 */

type TriggerStep = TriggerStep1 /* sqliteInt.h:1202:28 */
type UnpackedRecord1 = struct {
	FpKeyInfo    uintptr
	FaMem        uintptr
	FnField      u16
	Fdefault_rc  i8
	FerrCode     u8
	Fr1          i8
	Fr2          i8
	FeqSeen      u8
	F__ccgo_pad1 [1]byte
} /* sqliteInt.h:1203:9 */

type UnpackedRecord = UnpackedRecord1 /* sqliteInt.h:1203:31 */
type Upsert1 = struct {
	FpUpsertTarget      uintptr
	FpUpsertTargetWhere uintptr
	FpUpsertSet         uintptr
	FpUpsertWhere       uintptr
	FpNextUpsert        uintptr
	FisDoUpdate         u8
	F__ccgo_pad1        [7]byte
	FpToFree            uintptr
	FpUpsertIdx         uintptr
	FpUpsertSrc         uintptr
	FregData            int32
	FiDataCur           int32
	FiIdxCur            int32
	F__ccgo_pad2        [4]byte
} /* sqlite3.h:272:9 */

type Upsert = Upsert1 /* sqliteInt.h:1204:23 */
type VTable1 = struct {
	Fdb          uintptr
	FpMod        uintptr
	FpVtab       uintptr
	FnRef        int32
	FbConstraint u8
	FeVtabRisk   u8
	F__ccgo_pad1 [2]byte
	FiSavepoint  int32
	F__ccgo_pad2 [4]byte
	FpNext       uintptr
} /* sqlite3.h:272:9 */

type VTable = VTable1 /* sqliteInt.h:1205:23 */
type Walker1 = struct {
	FpParse           uintptr
	FxExprCallback    uintptr
	FxSelectCallback  uintptr
	FxSelectCallback2 uintptr
	FwalkerDepth      int32
	FeCode            u16
	F__ccgo_pad1      [2]byte
	Fu                struct{ FpNC uintptr }
} /* sqliteInt.h:1165:9 */

type Walker = Walker1 /* sqliteInt.h:1207:23 */
type Window1 = struct {
	FzName          uintptr
	FzBase          uintptr
	FpPartition     uintptr
	FpOrderBy       uintptr
	FeFrmType       u8
	FeStart         u8
	FeEnd           u8
	FbImplicitFrame u8
	FeExclude       u8
	F__ccgo_pad1    [3]byte
	FpStart         uintptr
	FpEnd           uintptr
	FppThis         uintptr
	FpNextWin       uintptr
	FpFilter        uintptr
	FpFunc          uintptr
	FiEphCsr        int32
	FregAccum       int32
	FregResult      int32
	FcsrApp         int32
	FregApp         int32
	FregPart        int32
	FpOwner         uintptr
	FnBufferCol     int32
	FiArgCol        int32
	FregOne         int32
	FregStartRowid  int32
	FregEndRowid    int32
	FbExprArgs      u8
	F__ccgo_pad2    [3]byte
} /* sqlite3.h:272:9 */

type Window = Window1 /* sqliteInt.h:1209:23 */
type With1 = struct {
	FnCte   int32
	FbView  int32
	FpOuter uintptr
	Fa      [1]Cte
} /* sqlite3.h:272:9 */

type With = With1 /* sqliteInt.h:1210:21 */

// The bitmask datatype defined below is used for various optimizations.
//
// Changing this from a 64-bit to a 32-bit type limits the number of
// tables in a join to 32 instead of 64.  But it also reduces the size
// of the library by 738 bytes on ix86.
type Bitmask = u64 /* sqliteInt.h:1223:15 */

// The number of bits in a Bitmask.  "BMS" means "BitMask Size".

// A bit in a Bitmask

// A VList object records a mapping between parameters/variables/wildcards
// in the SQL statement (such as $abc, @pqr, or :xyz) and the integer
// variable number associated with that parameter.  See the format description
// on the sqlite3VListAdd() routine for more information.  A VList is really
// just an array of integers.
type VList = int32 /* sqliteInt.h:1245:13 */

// Defer sourcing vdbe.h and btree.h until after the "u8" and
// "BusyHandler" typedefs. vdbe.h also requires a few of the opaque
// pointer types (i.e. FuncDef) defined above.
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite page cache
// subsystem.  The page cache subsystem reads and writes a file a page
// at a time and provides a journal for rollback.

// Default maximum size for persistent journal files. A negative
// value means no limit. This value may be overridden using the
// sqlite3PagerJournalSizeLimit() API. See also "PRAGMA journal_size_limit".

// The type used to represent a page number.  The first page in a file
// is called page 1.  0 is used to represent "not a page".
type Pgno = u32 /* pager.h:33:13 */

// Handle type for pages.
type PgHdr1 = struct {
	FpPage      uintptr
	FpData      uintptr
	FpExtra     uintptr
	FpCache     uintptr
	FpDirty     uintptr
	FpPager     uintptr
	Fpgno       Pgno
	Fflags      u16
	FnRef       i16
	FpDirtyNext uintptr
	FpDirtyPrev uintptr
} /* pager.h:43:9 */

// Handle type for pages.
type DbPage = PgHdr1 /* pager.h:43:22 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite B-Tree file
// subsystem.  See comments in the source code for a detailed description
// of what each interface routine does.

// TODO: This definition is just included so other modules compile. It
// needs to be revisited.

// If defined as non-zero, auto-vacuum is enabled by default. Otherwise
// it must be turned on for each database using "PRAGMA auto_vacuum = 1".

// Forward declarations of structure
type Btree1 = struct {
	Fdb             uintptr
	FpBt            uintptr
	FinTrans        u8
	Fsharable       u8
	Flocked         u8
	FhasIncrblobCur u8
	FwantToLock     int32
	FnBackup        int32
	FiBDataVersion  u32
	FpNext          uintptr
	FpPrev          uintptr
	Flock           BtLock
} /* btree.h:39:9 */

type BtCursor1 = struct {
	FeState        u8
	FcurFlags      u8
	FcurPagerFlags u8
	Fhints         u8
	FskipNext      int32
	FpBtree        uintptr
	FaOverflow     uintptr
	FpKey          uintptr
	FpBt           uintptr
	FpNext         uintptr
	Finfo          CellInfo
	FnKey          i64
	FpgnoRoot      Pgno
	FiPage         i8
	FcurIntKey     u8
	Fix            u16
	FaiIdx         [19]u16
	F__ccgo_pad1   [2]byte
	FpKeyInfo      uintptr
	FpPage         uintptr
	FapPage        [19]uintptr
} /* btree.h:39:9 */

type BtShared1 = struct {
	FpPager          uintptr
	Fdb              uintptr
	FpCursor         uintptr
	FpPage1          uintptr
	FopenFlags       u8
	FautoVacuum      u8
	FincrVacuum      u8
	FbDoTruncate     u8
	FinTransaction   u8
	Fmax1bytePayload u8
	FnReserveWanted  u8
	F__ccgo_pad1     [1]byte
	FbtsFlags        u16
	FmaxLocal        u16
	FminLocal        u16
	FmaxLeaf         u16
	FminLeaf         u16
	F__ccgo_pad2     [2]byte
	FpageSize        u32
	FusableSize      u32
	FnTransaction    int32
	FnPage           u32
	F__ccgo_pad3     [4]byte
	FpSchema         uintptr
	FxFreeSchema     uintptr
	Fmutex           uintptr
	FpHasContent     uintptr
	FnRef            int32
	F__ccgo_pad4     [4]byte
	FpNext           uintptr
	FpLock           uintptr
	FpWriter         uintptr
	FpTmpSpace       uintptr
	FnPreformatSize  int32
	F__ccgo_pad5     [4]byte
} /* btree.h:39:9 */

type BtreePayload1 = struct {
	FpKey        uintptr
	FnKey        sqlite3_int64
	FpData       uintptr
	FaMem        uintptr
	FnMem        u16
	F__ccgo_pad1 [2]byte
	FnData       int32
	FnZero       int32
	F__ccgo_pad2 [4]byte
} /* btree.h:42:9 */

type BtreePayload = BtreePayload1 /* btree.h:42:29 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Header file for the Virtual DataBase Engine (VDBE)
//
// This header defines the interface to the virtual database engine
// or VDBE.  The VDBE implements an abstract machine that runs a
// simple program to access and modify the underlying database.
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chris Torek.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdio.h	8.5 (Berkeley) 4/29/95
// $FreeBSD$

// A single VDBE is an opaque structure named "Vdbe".  Only routines
// in the source file sqliteVdbe.c are allowed to see the insides
// of this structure.
type Vdbe1 = struct {
	Fdb                 uintptr
	FpPrev              uintptr
	FpNext              uintptr
	FpParse             uintptr
	FnVar               ynVar
	F__ccgo_pad1        [2]byte
	FiVdbeMagic         u32
	FnMem               int32
	FnCursor            int32
	FcacheCtr           u32
	Fpc                 int32
	Frc                 int32
	F__ccgo_pad2        [4]byte
	FnChange            i64
	FiStatement         int32
	F__ccgo_pad3        [4]byte
	FiCurrentTime       i64
	FnFkConstraint      i64
	FnStmtDefCons       i64
	FnStmtDefImmCons    i64
	FaMem               uintptr
	FapArg              uintptr
	FapCsr              uintptr
	FaVar               uintptr
	FaOp                uintptr
	FnOp                int32
	FnOpAlloc           int32
	FaColName           uintptr
	FpResultSet         uintptr
	FzErrMsg            uintptr
	FpVList             uintptr
	FstartTime          i64
	FnResColumn         u16
	FerrorAction        u8
	FminWriteFileFormat u8
	FprepFlags          u8
	FdoingRerun         u8
	F__ccgo_pad4        [2]byte
	Fexpired            uint16 /* bft expired: 2, bft explain: 2, bft changeCntOn: 1, bft runOnlyOnce: 1, bft usesStmtJournal: 1, bft readOnly: 1, bft bIsReader: 1 */
	F__ccgo_pad5        [2]byte
	FbtreeMask          yDbMask
	FlockMask           yDbMask
	FaCounter           [7]u32
	FzSql               uintptr
	FpFree              uintptr
	FpFrame             uintptr
	FpDelFrame          uintptr
	FnFrame             int32
	Fexpmask            u32
	FpProgram           uintptr
	FpAuxData           uintptr
} /* sqlite3.h:4368:9 */

type SubProgram1 = struct {
	FaOp         uintptr
	FnOp         int32
	FnMem        int32
	FnCsr        int32
	F__ccgo_pad1 [4]byte
	FaOnce       uintptr
	Ftoken       uintptr
	FpNext       uintptr
} /* sqlite3.h:272:9 */

type SubProgram = SubProgram1 /* vdbe.h:34:27 */

// A single instruction of the virtual machine has an opcode
// and as many as three operands.  The instruction is recorded
// as an instance of the following structure:
type VdbeOp1 = struct {
	Fopcode u8
	Fp4type int8
	Fp5     u16
	Fp1     int32
	Fp2     int32
	Fp3     int32
	Fp4     struct {
		F__ccgo_pad1 [0]uint64
		Fi           int32
		F__ccgo_pad2 [4]byte
	}
	FzComment uintptr
} /* sqlite3.h:272:9 */

// A single instruction of the virtual machine has an opcode
// and as many as three operands.  The instruction is recorded
// as an instance of the following structure:
type p4union = struct {
	F__ccgo_pad1 [0]uint64
	Fi           int32
	F__ccgo_pad2 [4]byte
} /* sqlite3.h:272:9 */

type VdbeOp = VdbeOp1 /* vdbe.h:80:23 */

// A smaller version of VdbeOp used for the VdbeAddOpList() function because
// it takes up less space.
type VdbeOpList1 = struct {
	Fopcode u8
	Fp1     int8
	Fp2     int8
	Fp3     int8
} /* vdbe.h:100:1 */

type VdbeOpList = VdbeOpList1 /* vdbe.h:106:27 */

type RecordCompare = uintptr /* vdbe.h:286:13 */

// The VdbeCoverage macros are used to set a coverage testing point
// for VDBE branch instructions.  The coverage testing points are line
// numbers in the sqlite3.c source file.  VDBE branch coverage testing
// only works with an amalagmation build.  That's ok since a VDBE branch
// coverage build designed for testing the test suite only.  No application
// should ever ship with VDBE branch coverage measuring turned on.
//
//    VdbeCoverage(v)                  // Mark the previously coded instruction
//                                     // as a branch
//
//    VdbeCoverageIf(v, conditional)   // Mark previous if conditional true
//
//    VdbeCoverageAlwaysTaken(v)       // Previous branch is always taken
//
//    VdbeCoverageNeverTaken(v)        // Previous branch is never taken
//
//    VdbeCoverageNeverNull(v)         // Previous three-way branch is only
//                                     // taken on the first two ways.  The
//                                     // NULL option is not possible
//
//    VdbeCoverageEqNe(v)              // Previous OP_Jump is only interested
//                                     // in distingishing equal and not-equal.
//
// Every VDBE branch operation must be tagged with one of the macros above.
// If not, then when "make test" is run with -DSQLITE_VDBE_COVERAGE and
// -DSQLITE_DEBUG then an ALWAYS() will fail in the vdbeTakeBranch()
// routine in vdbe.c, alerting the developer to the missed tag.
//
// During testing, the test application will invoke
// sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE,...) to set a callback
// routine that is invoked as each bytecode branch is taken.  The callback
// contains the sqlite3.c source line number ov the VdbeCoverage macro and
// flags to indicate whether or not the branch was taken.  The test application
// is responsible for keeping track of this and reporting byte-code branches
// that are never taken.
//
// See the VdbeBranchTaken() macro and vdbeTakeBranch() function in the
// vdbe.c source file for additional information.

// 2008 August 05
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite page cache
// subsystem.

type PgHdr = PgHdr1 /* pcache.h:18:22 */

// typedef for the authorization callback function.
type sqlite3_xauth = uintptr /* sqliteInt.h:1491:15 */

// This is an extra SQLITE_TRACE macro that indicates "legacy" tracing
// in the style of sqlite3_trace()

// Maximum number of sqlite3.aDb[] entries.  This is the number of attached
// databases plus 2 for "main" and "temp".

// Each database connection is an instance of the following structure.
type sqlite3InitInfo = struct {
	FnewTnum       Pgno
	FiDb           u8
	Fbusy          u8
	F__ccgo_pad1   [2]byte
	ForphanTrigger uint8 /* unsigned orphanTrigger: 1, unsigned imposterTable: 1, unsigned reopenMemdb: 1 */
	F__ccgo_pad2   [7]byte
	FazInit        uintptr
} /* sqlite3.h:272:9 */

// Allowed values for Table.tabFlags.
//
// TF_OOOHidden applies to tables or view that have hidden columns that are
// followed by non-hidden columns.  Example:  "CREATE VIRTUAL TABLE x USING
// vtab1(a HIDDEN, b);".  Since "b" is a non-hidden column but "a" is hidden,
// the TF_OOOHidden attribute would apply in this case.  Such tables require
// special handling during INSERT processing. The "OOO" means "Out Of Order".
//
// Constraints:
//
//         TF_HasVirtual == COLFLAG_VIRTUAL
//         TF_HasStored  == COLFLAG_STORED
//         TF_HasHidden  == COLFLAG_HIDDEN

// Allowed values for Table.eTabType

// Test to see whether or not a table is a virtual table.  This is
// done as a macro so that it will be optimized out when virtual
// table support is omitted from the build.

// Macros to determine if a column is hidden.  IsOrdinaryHiddenColumn()
// only works for non-virtual tables (ordinary tables and views) and is
// always false unless SQLITE_ENABLE_HIDDEN_COLUMNS is defined.  The
// IsHiddenColumn() macro is general purpose.

// Does the table have a rowid

// Each foreign key constraint is an instance of the following structure.
//
// A foreign key is associated with two tables.  The "from" table is
// the table that contains the REFERENCES clause that creates the foreign
// key.  The "to" table is the table that is named in the REFERENCES clause.
// Consider this example:
//
//     CREATE TABLE ex1(
//       a INTEGER PRIMARY KEY,
//       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)
//     );
//
// For foreign key "fk1", the from-table is "ex1" and the to-table is "ex2".
// Equivalent names:
//
//     from-table == child-table
//       to-table == parent-table
//
// Each REFERENCES clause generates an instance of the following structure
// which is attached to the from-table.  The to-table need not exist when
// the from-table is created.  The existence of the to-table is not checked.
//
// The list of all parents for child Table X is held at X.pFKey.
//
// A list of all children for a table named Z (which might not even exist)
// is held in Schema.fkeyHash with a hash key of Z.
type sColMap = struct {
	FiFrom       int32
	F__ccgo_pad1 [4]byte
	FzCol        uintptr
} /* sqliteInt.h:1169:9 */

// An instance of this structure contains information needed to generate
// code for a SELECT that contains aggregate functions.
//
// If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
// pointer to this structure.  The Expr.iAgg field is the index in
// AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
// code for that node.
//
// AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
// original Select structure that describes the SELECT statement.  These
// fields do not need to be freed when deallocating the AggInfo structure.
type AggInfo_col = struct {
	FpTab          uintptr
	FpCExpr        uintptr
	FiTable        int32
	FiMem          int32
	FiColumn       i16
	FiSorterColumn i16
	F__ccgo_pad1   [4]byte
} /* sqlite3.h:272:9 */

// An instance of this structure contains information needed to generate
// code for a SELECT that contains aggregate functions.
//
// If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a
// pointer to this structure.  The Expr.iAgg field is the index in
// AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate
// code for that node.
//
// AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the
// original Select structure that describes the SELECT statement.  These
// fields do not need to be freed when deallocating the AggInfo structure.
type AggInfo_func = struct {
	FpFExpr      uintptr
	FpFunc       uintptr
	FiMem        int32
	FiDistinct   int32
	FiDistAddr   int32
	F__ccgo_pad1 [4]byte
} /* sqlite3.h:272:9 */

// The datatype ynVar is a signed integer, either 16-bit or 32-bit.
// Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greater
// than 32767 we have to make it 32-bit.  16-bit is preferred because
// it uses less memory in the Expr object, which is a big memory user
// in systems with lots of prepared statements.  And few applications
// need more than about 10 or 20 variables.  But some extreme users want
// to have prepared statements with over 32766 variables, and for them
// the option is available (at compile-time).
type ynVar = i16 /* sqliteInt.h:2703:13 */

// The following are the meanings of bits in the Expr.flags field.
// Value restrictions:
//
//          EP_Agg == NC_HasAgg == SF_HasAgg
//          EP_Win == NC_HasWin
//   0x400000 // Available
//   0x80000000 // Available

// The EP_Propagate mask is a set of properties that automatically propagate
// upwards into parent nodes.

// Macros can be used to test, set, or clear bits in the
// Expr.flags field.

// Macros used to ensure that the correct members of unions are accessed
// in Expr.

// Flags for use with Expr.vvaFlags

// The ExprSetVVAProperty() macro is used for Verification, Validation,
// and Accreditation only.  It works like ExprSetProperty() during VVA
// processes but is a no-op for delivery.

// Macros to determine the number of bytes required by a normal Expr
// struct, an Expr struct with the EP_Reduced flag set in Expr.flags
// and an Expr struct with the EP_TokenOnly flag set.

// Flags passed to the sqlite3ExprDup() function. See the header comment
// above sqlite3ExprDup() for details.

// True if the expression passed as an argument was a function with
// an OVER() clause (a window function).

// A list of expressions.  Each expression may optionally have a
// name.  An expr/name combination can be used in several ways, such
// as the list of "expr AS ID" fields following a "SELECT" or in the
// list of "ID = expr" items in an UPDATE.  A list of expressions can
// also be used as the argument to a function, in which case the a.zName
// field is not used.
//
// In order to try to keep memory usage down, the Expr.a.zEName field
// is used for multiple purposes:
//
//     eEName          Usage
//    ----------       -------------------------
//    ENAME_NAME       (1) the AS of result set column
//                     (2) COLUMN= of an UPDATE
//
//    ENAME_TAB        DB.TABLE.NAME used to resolve names
//                     of subqueries
//
//    ENAME_SPAN       Text of the original result set
//                     expression.
type ExprList_item = struct {
	FpExpr       uintptr
	FzEName      uintptr
	FsortFlags   u8
	F__ccgo_pad1 [3]byte
	FeEName      uint8 /* unsigned eEName: 2, unsigned done: 1, unsigned reusable: 1, unsigned bSorterRef: 1, unsigned bNulls: 1 */
	F__ccgo_pad2 [3]byte
	Fu           struct {
		F__ccgo_pad1 [0]uint32
		Fx           struct {
			FiOrderByCol u16
			FiAlias      u16
		}
	}
	F__ccgo_pad3 [4]byte
} /* sqlite3.h:272:9 */

// Allowed values for Expr.a.eEName

// An instance of this structure can hold a simple list of identifiers,
// such as the list "a,b,c" in the following statements:
//
//      INSERT INTO t(a,b,c) VALUES ...;
//      CREATE INDEX idx ON t(a,b,c);
//      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;
//
// The IdList.a.idx field is used when the IdList represents the list of
// column names after a table name in an INSERT statement.  In the statement
//
//     INSERT INTO t(a,b,c) ...
//
// If "a" is the k-th column of table "t", then IdList.a[0].idx==k.
type IdList_item = struct {
	FzName       uintptr
	Fidx         int32
	F__ccgo_pad1 [4]byte
} /* sqlite3.h:272:9 */

// The yDbMask datatype for the bitmask of all attached databases.
type yDbMask = uint32 /* sqliteInt.h:3479:24 */

// A pointer to this structure is used to communicate information
// from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.
type InitData = struct {
	Fdb          uintptr
	FpzErrMsg    uintptr
	FiDb         int32
	Frc          int32
	FmInitFlags  u32
	FnInitRow    u32
	FmxPage      Pgno
	F__ccgo_pad1 [4]byte
} /* sqliteInt.h:3838:3 */

// Allowed values for mInitFlags

// Tuning parameters are set using SQLITE_TESTCTRL_TUNE and are controlled
// on debug-builds of the CLI using ".testctrl tune ID VALUE".  Tuning
// parameters are for temporary use during development, to help find
// optimial values for parameters in the query planner.  The should not
// be used on trunk check-ins.  They are a temporary mechanism available
// for transient development builds only.
//
// Tuning parameters are numbered starting with 1.

// Structure containing global configuration data for the SQLite library.
//
// This structure also contains some state information.
type Sqlite3Config = struct {
	FbMemstat            int32
	FbCoreMutex          u8
	FbFullMutex          u8
	FbOpenUri            u8
	FbUseCis             u8
	FbSmallMalloc        u8
	FbExtraSchemaChecks  u8
	F__ccgo_pad1         [2]byte
	FmxStrlen            int32
	FneverCorrupt        int32
	FszLookaside         int32
	FnLookaside          int32
	FnStmtSpill          int32
	Fm                   sqlite3_mem_methods
	Fmutex               sqlite3_mutex_methods
	Fpcache2             sqlite3_pcache_methods2
	FpHeap               uintptr
	FnHeap               int32
	FmnReq               int32
	FmxReq               int32
	F__ccgo_pad2         [4]byte
	FszMmap              sqlite3_int64
	FmxMmap              sqlite3_int64
	FpPage               uintptr
	FszPage              int32
	FnPage               int32
	FmxParserStack       int32
	FsharedCacheEnabled  int32
	FszPma               u32
	FisInit              int32
	FinProgress          int32
	FisMutexInit         int32
	FisMallocInit        int32
	FisPCacheInit        int32
	FnRefInitMutex       int32
	F__ccgo_pad3         [4]byte
	FpInitMutex          uintptr
	FxLog                uintptr
	FpLogArg             uintptr
	FmxMemdbSize         sqlite3_int64
	FxTestCallback       uintptr
	FbLocaltimeFault     int32
	FiOnceResetThreshold int32
	FszSorterRef         u32
	FiPrngSeed           uint32
} /* sqliteInt.h:3869:1 */

type BoxGeomCtx1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* test_rtreedoc.c:28:9 */

type BoxGeomCtx = BoxGeomCtx1 /* test_rtreedoc.c:28:27 */

type BoxQueryCtx1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* test_rtreedoc.c:34:9 */

type BoxQueryCtx = BoxQueryCtx1 /* test_rtreedoc.c:34:28 */

func testDelUser(tls *libc.TLS, pCtx uintptr) { /* test_rtreedoc.c:40:13: */
	var p uintptr = pCtx
	tcl.XTcl_EvalObjEx(tls, (*BoxGeomCtx)(unsafe.Pointer(p)).Finterp, (*BoxGeomCtx)(unsafe.Pointer(p)).FpScript, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*BoxGeomCtx)(unsafe.Pointer(p)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func invokeTclGeomCb(tls *libc.TLS, zName uintptr, p uintptr, nCoord int32, aCoord uintptr) int32 { /* test_rtreedoc.c:47:12: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var rc int32 = SQLITE_OK
	if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpContext != 0 {
		// var aPtr [64]int8 at bp+16, 64

		var pCtx uintptr = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpContext
		var interp uintptr = (*BoxGeomCtx)(unsafe.Pointer(pCtx)).Finterp
		var pScript uintptr = uintptr(0)
		var pParam uintptr = uintptr(0)
		var pCoord uintptr = uintptr(0)
		var ii int32
		var pRes uintptr

		pScript = tcl.XTcl_DuplicateObj(tls, (*BoxGeomCtx)(unsafe.Pointer(pCtx)).FpScript)
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, zName, -1))

		sqlite3.Xsqlite3_snprintf(tls, int32(uint64(unsafe.Sizeof([64]int8{}))-uint64(1)), bp+16 /* &aPtr[0] */, ts+10721 /* "%p" */, libc.VaList(bp, (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpContext))
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, bp+16 /* &aPtr[0] */, -1))

		pParam = tcl.XTcl_NewObj(tls)
		for ii = 0; ii < (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam; ii++ {
			tcl.XTcl_ListObjAppendElement(tls,
				interp, pParam, tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + uintptr(ii)*8))))
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pParam)

		pCoord = tcl.XTcl_NewObj(tls)
		for ii = 0; ii < nCoord; ii++ {
			tcl.XTcl_ListObjAppendElement(tls, interp, pCoord, tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + uintptr(ii)*8))))
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pCoord)

		sqlite3.Xsqlite3_snprintf(tls, int32(uint64(unsafe.Sizeof([64]int8{}))-uint64(1)), bp+16 /* &aPtr[0] */, ts+10721 /* "%p" */, libc.VaList(bp+8, p))
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, bp+16 /* &aPtr[0] */, -1))

		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		if rc != TCL_OK {
			rc = SQLITE_ERROR
		} else {
			*(*int32)(unsafe.Pointer(bp + 80 /* nObj */)) = 0
			*(*uintptr)(unsafe.Pointer(bp + 88 /* aObj */)) = uintptr(0)

			pRes = tcl.XTcl_GetObjResult(tls, interp)
			if tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+80, bp+88) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 80)) > 0 {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 88 /* aObj */)))))
				if 0 == sqlite3.Xsqlite3_stricmp(tls, zCmd, ts+10724) {
					*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam)) = 0.0
					(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam = 1
				} else if 0 == sqlite3.Xsqlite3_stricmp(tls, zCmd, ts+10729) {
					if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser != 0 || (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser != 0 {
						rc = SQLITE_ERROR
					} else {
						var pBGCtx uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(BoxGeomCtx{})))
						if pBGCtx == uintptr(0) {
							rc = SQLITE_NOMEM
						} else {
							(*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).Finterp = interp
							(*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).FpScript = tcl.XTcl_DuplicateObj(tls, pRes)
							(*Tcl_Obj)(unsafe.Pointer((*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).FpScript)).FrefCount++
							tcl.XTcl_ListObjReplace(tls, interp, (*BoxGeomCtx)(unsafe.Pointer(pBGCtx)).FpScript, 0, 1, 0, uintptr(0))
							(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser = pBGCtx
							(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testDelUser}))
						}
					}
				} else if 0 == sqlite3.Xsqlite3_stricmp(tls, zCmd, ts+10734) {
					if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser != 0 || (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser != 0 {
						rc = SQLITE_ERROR
					}
				}
			}
		}
	}
	return rc
}

//
// # EVIDENCE-OF: R-00693-36727 The legacy xGeom callback is invoked with
// # four arguments.
//
// # EVIDENCE-OF: R-50437-53270 The first argument is a pointer to an
// # sqlite3_rtree_geometry structure which provides information about how
// # the SQL function was invoked.
//
// # EVIDENCE-OF: R-00090-24248 The third argument, aCoord[], is an array
// # of nCoord coordinates that defines a bounding box to be tested.
//
// # EVIDENCE-OF: R-28207-40885 The last argument is a pointer into which
// # the callback result should be written.
//
func box_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, pRes uintptr) int32 { /* test_rtreedoc.c:145:12: */
	var ii int32

	if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != nCoord {
		invokeTclGeomCb(tls, ts+10747 /* "box" */, p, nCoord, aCoord)
		return SQLITE_ERROR
	}
	if invokeTclGeomCb(tls, ts+10747, p, nCoord, aCoord) != 0 {
		return SQLITE_ERROR
	}

	for ii = 0; ii < nCoord; ii = ii + 2 {
		if *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + uintptr(ii)*8)) > *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + uintptr(ii+1)*8)) || *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + uintptr(ii+1)*8)) < *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + uintptr(ii)*8)) {
			// R-28207-40885
			*(*int32)(unsafe.Pointer(pRes)) = 0
			return SQLITE_OK
		}
	}

	// R-28207-40885
	*(*int32)(unsafe.Pointer(pRes)) = 1

	return SQLITE_OK
}

func register_box_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtreedoc.c:173:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var db uintptr at bp+8, 8

	var pCtx uintptr
	// var aPtr [64]int8 at bp+16, 64

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10751 /* "DB SCRIPT" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+8) != 0 {
		return TCL_ERROR
	}

	pCtx = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(uintptr(0))))
	(*BoxGeomCtx)(unsafe.Pointer(pCtx)).Finterp = interp
	(*BoxGeomCtx)(unsafe.Pointer(pCtx)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	(*Tcl_Obj)(unsafe.Pointer((*BoxGeomCtx)(unsafe.Pointer(pCtx)).FpScript)).FrefCount++

	sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), ts+10747 /* "box" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{box_geom})), pCtx)

	sqlite3.Xsqlite3_snprintf(tls, 64, bp+16 /* &aPtr[0] */, ts+10721 /* "%p" */, libc.VaList(bp, pCtx))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+16 /* &aPtr[0] */, -1))
	return TCL_OK
}

func box_query(tls *libc.TLS, pInfo uintptr) int32 { /* test_rtreedoc.c:203:12: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	*(*[4]uintptr)(unsafe.Pointer(bp /* azParentWithin */)) = [4]uintptr{ts + 5854 /* "not" */, ts + 10761 /* "partly" */, ts + 10768 /* "fully" */, uintptr(0)}
	var pCtx uintptr = (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FpContext
	var interp uintptr = (*BoxQueryCtx)(unsafe.Pointer(pCtx)).Finterp
	var pEval uintptr
	var pArg uintptr
	var pTmp uintptr = uintptr(0)
	var rc int32
	var ii int32

	pEval = tcl.XTcl_DuplicateObj(tls, (*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++

	// aParam[]
	pTmp = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pTmp)).FrefCount++
	for ii = 0; ii < (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FnParam; ii++ {
		var p uintptr = tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FaParam + uintptr(ii)*8)))
		tcl.XTcl_ListObjAppendElement(tls, interp, pTmp, p)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10774 /* "aParam" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pTmp)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pTmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	// aCoord[]
	pTmp = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pTmp)).FrefCount++
	for ii = 0; ii < (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FnCoord; ii++ {
		var p uintptr = tcl.XTcl_NewDoubleObj(tls, *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FaCoord + uintptr(ii)*8)))
		tcl.XTcl_ListObjAppendElement(tls, interp, pTmp, p)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10781 /* "aCoord" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pTmp)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pTmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	// anQueue[]
	pTmp = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pTmp)).FrefCount++
	for ii = 0; ii <= (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FmxLevel; ii++ {
		var p uintptr = tcl.XTcl_NewIntObj(tls, int32(*(*uint32)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FanQueue + uintptr(ii)*4))))
		tcl.XTcl_ListObjAppendElement(tls, interp, pTmp, p)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10788 /* "anQueue" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pTmp)
	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = pTmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	// iLevel
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10796 /* "iLevel" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewIntObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FiLevel))

	// mxLevel
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10803 /* "mxLevel" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewIntObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FmxLevel))

	// iRowid
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10811 /* "iRowid" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewWideIntObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FiRowid))

	// rParentScore
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10818 /* "rParentScore" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewDoubleObj(tls, (*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FrParentScore))

	// eParentWithin

	tcl.XTcl_ListObjAppendElement(tls, interp, pArg, tcl.XTcl_NewStringObj(tls, ts+10831 /* "eParentWithin" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pArg,
		tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp /* &azParentWithin[0] */ + uintptr((*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FeParentWithin)*8)), -1))

	tcl.XTcl_ListObjAppendElement(tls, interp, pEval, pArg)
	if tcl.XTcl_EvalObjEx(tls, interp, pEval, 0) != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = SQLITE_OK
	}

	if rc == SQLITE_OK {
		*(*float64)(unsafe.Pointer(bp + 48 /* rScore */)) = 0.0
		*(*int32)(unsafe.Pointer(bp + 32 /* nObj */)) = 0
		*(*int32)(unsafe.Pointer(bp + 56 /* eP */)) = 0
		*(*uintptr)(unsafe.Pointer(bp + 40 /* aObj */)) = uintptr(0)
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)

		if tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+32, bp+40) != 0 ||
			*(*int32)(unsafe.Pointer(bp + 32)) != 2 ||
			tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)) + 1*8)), bp+48) != 0 ||
			tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40)))), bp, int32(unsafe.Sizeof(uintptr(0))), ts+10845, 0, bp+56) != 0 {
			rc = SQLITE_ERROR
		} else {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FrScore = *(*float64)(unsafe.Pointer(bp + 48 /* rScore */))
			(*sqlite3_rtree_query_info)(unsafe.Pointer(pInfo)).FeParentWithin = *(*int32)(unsafe.Pointer(bp + 56 /* eP */))
		}
	}

	for ok3 := true; ok3; ok3 = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok4 := true; ok4; ok4 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return rc
}

func box_query_destroy(tls *libc.TLS, p uintptr) { /* test_rtreedoc.c:304:13: */
	var pCtx uintptr = p
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_Free(tls, pCtx)
}

func register_box_query(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtreedoc.c:310:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var pCtx uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10751 /* "DB SCRIPT" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}

	pCtx = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(uintptr(0))))
	(*BoxQueryCtx)(unsafe.Pointer(pCtx)).Finterp = interp
	(*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	(*Tcl_Obj)(unsafe.Pointer((*BoxQueryCtx)(unsafe.Pointer(pCtx)).FpScript)).FrefCount++

	sqlite3.Xsqlite3_rtree_query_callback(tls,
		*(*uintptr)(unsafe.Pointer(bp /* db */)), ts+10851 /* "qbox" */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{box_query})), pCtx, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{box_query_destroy})))

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func Sqlitetestrtreedoc_Init(tls *libc.TLS, interp uintptr) int32 { /* test_rtreedoc.c:342:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+10856 /* "register_box_geo..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_box_geom})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+10874 /* "register_box_que..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_box_query})), uintptr(0), uintptr(0))
	return TCL_OK
}

type TestSession1 = struct {
	FpSession      uintptr
	Finterp        uintptr
	FpFilterScript uintptr
} /* test_session.c:21:9 */

type TestSession = TestSession1 /* test_session.c:21:28 */

type TestStreamInput1 = struct {
	FnStream     int32
	F__ccgo_pad1 [4]byte
	FaData       uintptr
	FnData       int32
	FiData       int32
} /* test_session.c:28:9 */

type TestStreamInput = TestStreamInput1 /* test_session.c:28:32 */

// Extract an sqlite3* db handle from the object passed as the second
// argument. If successful, set *pDb to point to the db handle and return
// TCL_OK. Otherwise, return TCL_ERROR.
func dbHandleFromObj1(tls *libc.TLS, interp uintptr, pObj uintptr, pDb uintptr) int32 { /* test_session.c:41:12: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var info Tcl_CmdInfo at bp+24, 64

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, pObj), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930 /* "no such handle: " */, tcl.XTcl_GetString(tls, pObj), 0))
		return TCL_ERROR
	}

	*(*uintptr)(unsafe.Pointer(pDb)) = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &info */)).FobjClientData))
	return TCL_OK
}

/*************************************************************************
** The following code is copied byte-for-byte from the sessions module
** documentation.  It is used by some of the sessions modules tests to
** ensure that the example in the documentation does actually work.
 */
// Argument zSql points to a buffer containing an SQL script to execute
// against the database handle passed as the first argument. As well as
// executing the SQL script, this function collects a changeset recording
// all changes made to the "main" database file. Assuming no error occurs,
// output variables (*ppChangeset) and (*pnChangeset) are set to point
// to a buffer containing the changeset and the size of the changeset in
// bytes before returning SQLITE_OK. In this case it is the responsibility
// of the caller to eventually free the changeset blob by passing it to
// the sqlite3_free function.
//
// Or, if an error does occur, return an SQLite error code. The final
// value of (*pChangeset) and (*pnChangeset) are undefined in this case.
func sql_exec_changeset(tls *libc.TLS, db uintptr, zSql uintptr, pnChangeset uintptr, ppChangeset uintptr) int32 { /* test_session.c:71:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*uintptr)(unsafe.Pointer(bp /* pSession */)) = uintptr(0)
	var rc int32

	// Create a new session object
	rc = sqlite3.Xsqlite3session_create(tls, db, ts+85 /* "main" */, bp /* &pSession */)

	// Configure the session object to record changes to all tables
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3session_attach(tls, *(*uintptr)(unsafe.Pointer(bp /* pSession */)), uintptr(0))
	}

	// Execute the SQL script
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
	}

	// Collect the changeset
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3session_changeset(tls, *(*uintptr)(unsafe.Pointer(bp /* pSession */)), pnChangeset, ppChangeset)
	}

	// Delete the session object
	sqlite3.Xsqlite3session_delete(tls, *(*uintptr)(unsafe.Pointer(bp /* pSession */)))

	return rc
}

//**********************************************************************

// Tclcmd: sql_exec_changeset DB SQL
func test_sql_exec_changeset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:104:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zSql uintptr
	// var db uintptr at bp+16, 8

	// var pChangeset uintptr at bp+32, 8

	// var nChangeset int32 at bp+24, 4

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10893 /* "DB SQL" */)
		return TCL_ERROR
	}
	if dbHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))

	rc = sql_exec_changeset(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zSql, bp+24 /* &nChangeset */, bp+32 /* &pChangeset */)
	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10900 /* "error in sql_exe..." */, 0))
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pChangeset */)), *(*int32)(unsafe.Pointer(bp + 24 /* nChangeset */))))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pChangeset */)))
	return TCL_OK
}

// Attempt to find the global variable zVar within interpreter interp
// and extract an integer value from it. Return this value.
//
// If the named variable cannot be found, or if it cannot be interpreted
// as a integer, return 0.
func test_tcl_integer(tls *libc.TLS, interp uintptr, zVar uintptr) int32 { /* test_session.c:146:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pObj uintptr
	*(*int32)(unsafe.Pointer(bp /* iVal */)) = 0
	var pName uintptr = tcl.XTcl_NewStringObj(tls, zVar, -1)
	(*Tcl_Obj)(unsafe.Pointer(pName)).FrefCount++
	pObj = tcl.XTcl_ObjGetVar2(tls, interp, pName, uintptr(0), TCL_GLOBAL_ONLY)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pName
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if pObj != 0 {
		tcl.XTcl_GetIntFromObj(tls, uintptr(0), pObj, bp /* &iVal */)
	}
	return *(*int32)(unsafe.Pointer(bp /* iVal */))
}

func test_session_error(tls *libc.TLS, interp uintptr, rc int32, zErr uintptr) int32 { /* test_session.c:157:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	if zErr != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+10477 /* " - " */, zErr, 0))
		sqlite3.Xsqlite3_free(tls, zErr)
	}
	return TCL_ERROR
}

func test_table_filter(tls *libc.TLS, pCtx uintptr, zTbl uintptr) int32 { /* test_session.c:167:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pEval uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp /* bRes */)) = 0

	pEval = tcl.XTcl_DuplicateObj(tls, (*TestSession)(unsafe.Pointer(p)).FpFilterScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	rc = tcl.XTcl_ListObjAppendElement(tls, (*TestSession)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	if rc == TCL_OK {
		rc = tcl.XTcl_EvalObjEx(tls, (*TestSession)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	}
	if rc == TCL_OK {
		rc = tcl.XTcl_GetBooleanFromObj(tls, (*TestSession)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*TestSession)(unsafe.Pointer(p)).Finterp), bp /* &bRes */)
	}
	if rc != TCL_OK {
		// printf("error: %s\n", Tcl_GetStringResult(p->interp));
		tcl.XTcl_BackgroundError(tls, (*TestSession)(unsafe.Pointer(p)).Finterp)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* bRes */))
}

type TestSessionsBlob1 = struct {
	Fp           uintptr
	Fn           int32
	F__ccgo_pad1 [4]byte
} /* test_session.c:191:1 */

type TestSessionsBlob = TestSessionsBlob1 /* test_session.c:195:33 */

func testStreamOutput(tls *libc.TLS, pCtx uintptr, pData uintptr, nData int32) int32 { /* test_session.c:197:12: */
	var pBlob uintptr = pCtx
	var pNew uintptr

	pNew = sqlite3.Xsqlite3_realloc(tls, (*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fp, (*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fn+nData)
	if pNew == uintptr(0) {
		return SQLITE_NOMEM
	}
	(*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fp = pNew
	libc.Xmemcpy(tls, pNew+uintptr((*TestSessionsBlob)(unsafe.Pointer(pBlob)).Fn), pData, uint64(nData))
	*(*int32)(unsafe.Pointer(pBlob + 8)) += nData
	return SQLITE_OK
}

// Tclcmd:  $session attach TABLE
//          $session changeset
//          $session delete
//          $session enable BOOL
//          $session indirect INTEGER
//          $session patchset
//          $session table_filter SCRIPT
func test_session_cmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:225:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var p uintptr = clientData
	var pSession uintptr = (*TestSession)(unsafe.Pointer(p)).FpSession
	// var iSub int32 at bp, 4

	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999 /* "SUBCOMMAND ..." */)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&aSub)), int32(unsafe.Sizeof(SessionSubcmd{})), ts+2014 /* "sub-command" */, 0, bp /* &iSub */)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+aSub[*(*int32)(unsafe.Pointer(bp))].FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, aSub[*(*int32)(unsafe.Pointer(bp /* iSub */))].FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp /* iSub */)) {
	case 0:
		{ // attach
			var zArg uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			if int32(*(*int8)(unsafe.Pointer(zArg))) == '*' && int32(*(*int8)(unsafe.Pointer(zArg + 1))) == 0 {
				zArg = uintptr(0)
			}
			rc = sqlite3.Xsqlite3session_attach(tls, pSession, zArg)
			if rc != SQLITE_OK {
				return test_session_error(tls, interp, rc, uintptr(0))
			}
			break

		}

	case 7:
		fallthrough // patchset
	case 1:
		{ // changeset
			*(*TestSessionsBlob)(unsafe.Pointer(bp + 8 /* o */)) = TestSessionsBlob{}
			if test_tcl_integer(tls, interp, ts+10930) != 0 {
				var pCtx uintptr = bp + 8 /* &o */
				if *(*int32)(unsafe.Pointer(bp)) == 7 {
					rc = sqlite3.Xsqlite3session_patchset_strm(tls, pSession, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					}{testStreamOutput})), pCtx)
				} else {
					rc = sqlite3.Xsqlite3session_changeset_strm(tls, pSession, *(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					}{testStreamOutput})), pCtx)
				}
			} else {
				if *(*int32)(unsafe.Pointer(bp)) == 7 {
					rc = sqlite3.Xsqlite3session_patchset(tls, pSession, bp+8+8, bp+8)
				} else {
					rc = sqlite3.Xsqlite3session_changeset(tls, pSession, bp+8+8, bp+8)
				}
			}
			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+8 /* &o */)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+8 /* &o */)).Fn))
			}
			sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+8 /* &o */)).Fp)
			if rc != SQLITE_OK {
				return test_session_error(tls, interp, rc, uintptr(0))
			}
			break

		}

	case 2: // delete
		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
		break

	case 3:
		{ // enable
			// var val int32 at bp+24, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+24) != 0 {
				return TCL_ERROR
			}
			*(*int32)(unsafe.Pointer(bp + 24 /* val */)) = sqlite3.Xsqlite3session_enable(tls, pSession, *(*int32)(unsafe.Pointer(bp + 24 /* val */)))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 24)) != 0)))
			break

		}

	case 4:
		{ // indirect
			// var val int32 at bp+28, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+28) != 0 {
				return TCL_ERROR
			}
			*(*int32)(unsafe.Pointer(bp + 28 /* val */)) = sqlite3.Xsqlite3session_indirect(tls, pSession, *(*int32)(unsafe.Pointer(bp + 28 /* val */)))
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 28)) != 0)))
			break

		}

	case 5:
		{ // isempty
			var val int32
			val = sqlite3.Xsqlite3session_isempty(tls, pSession)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(val != 0)))
			break

		}

	case 6:
		{ // table_filter
			if (*TestSession)(unsafe.Pointer(p)).FpFilterScript != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*TestSession)(unsafe.Pointer(p)).FpFilterScript
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestSession)(unsafe.Pointer(p)).Finterp = interp
			(*TestSession)(unsafe.Pointer(p)).FpFilterScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			(*Tcl_Obj)(unsafe.Pointer((*TestSession)(unsafe.Pointer(p)).FpFilterScript)).FrefCount++
			sqlite3.Xsqlite3session_table_filter(tls, pSession, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			}{test_table_filter})), clientData)
			break

		}

	case 8:
		{ // diff
			*(*uintptr)(unsafe.Pointer(bp + 32 /* zErr */)) = uintptr(0)
			rc = sqlite3.Xsqlite3session_diff(tls, pSession,
				tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))),
				tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8))),
				bp+32 /* &zErr */)

			if rc != 0 {
				return test_session_error(tls, interp, rc, *(*uintptr)(unsafe.Pointer(bp + 32 /* zErr */)))
			}
			break

		}

	case 9:
		{ // memory_used
			var nMalloc sqlite3_int64 = sqlite3.Xsqlite3session_memory_used(tls, pSession)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, nMalloc))
			break

		}

	case 10:
		{
			var nSize sqlite3_int64 = sqlite3.Xsqlite3session_changeset_size(tls, pSession)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, nSize))
			break

		}
	case 11:
		{
			var rc int32
			// var iArg int32 at bp+40, 4

			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
				return TCL_ERROR
			}
			rc = sqlite3.Xsqlite3session_object_config(tls,
				pSession, SQLITE_SESSION_OBJCONFIG_SIZE, bp+40 /* &iArg */)
			if rc != SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
			} else {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 40 /* iArg */))))
			}
			break

		}
	}

	return TCL_OK
}

type SessionSubcmd = struct {
	FzSub        uintptr
	FnArg        int32
	F__ccgo_pad1 [4]byte
	FzMsg        uintptr
	FiSub        int32
	F__ccgo_pad2 [4]byte
} /* test_session.c:233:10 */

var aSub = [13]SessionSubcmd{
	{FzSub: ts + 10953 /* "attach" */, FnArg: 1, FzMsg: ts + 1951 /* "TABLE" */},                // 0
	{FzSub: ts + 10960 /* "changeset" */, FzMsg: ts + 584 /* "" */},                             // 1
	{FzSub: ts + 10970 /* "delete" */, FzMsg: ts + 584 /* "" */},                                // 2
	{FzSub: ts + 10977 /* "enable" */, FnArg: 1, FzMsg: ts + 10984 /* "BOOL" */},                // 3
	{FzSub: ts + 10989 /* "indirect" */, FnArg: 1, FzMsg: ts + 10984 /* "BOOL" */},              // 4
	{FzSub: ts + 10998 /* "isempty" */, FzMsg: ts + 584 /* "" */},                               // 5
	{FzSub: ts + 11006 /* "table_filter" */, FnArg: 1, FzMsg: ts + 11019 /* "SCRIPT" */},        // 6
	{FzSub: ts + 11026 /* "patchset" */, FzMsg: ts + 584 /* "" */},                              // 7
	{FzSub: ts + 11035 /* "diff" */, FnArg: 2, FzMsg: ts + 11040 /* "FROMDB TBL" */},            // 8
	{FzSub: ts + 11051 /* "memory_used" */, FzMsg: ts + 584 /* "" */},                           // 9
	{FzSub: ts + 11063 /* "changeset_size" */, FzMsg: ts + 584 /* "" */},                        // 10
	{FzSub: ts + 11078 /* "object_config_si..." */, FnArg: 1, FzMsg: ts + 2413 /* "INTEGER" */}, // 11
	{},
} /* test_session.c:238:5 */

func test_session_del(tls *libc.TLS, clientData uintptr) { /* test_session.c:390:27: */
	var p uintptr = clientData
	if (*TestSession)(unsafe.Pointer(p)).FpFilterScript != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestSession)(unsafe.Pointer(p)).FpFilterScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3session_delete(tls, (*TestSession)(unsafe.Pointer(p)).FpSession)
	tcl.XTcl_Free(tls, p)
}

// Tclcmd:  sqlite3session CMD DB-HANDLE DB-NAME
func test_sqlite3session(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:400:26: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var db uintptr
	// var info Tcl_CmdInfo at bp+24, 64

	var rc int32  // sqlite3session_create() return code
	var p uintptr // New wrapper object
	*(*int32)(unsafe.Pointer(bp + 88 /* iArg */)) = -1

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11097 /* "CMD DB-HANDLE DB..." */)
		return TCL_ERROR
	}

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930 /* "no such handle: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), 0))
		return TCL_ERROR
	}
	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &info */)).FobjClientData))

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestSession{})))
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(TestSession{})))
	rc = sqlite3.Xsqlite3session_create(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8))), p)
	if rc != SQLITE_OK {
		tcl.XTcl_Free(tls, p)
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	// Query the SQLITE_SESSION_OBJCONFIG_SIZE option to ensure that it
	// is clear by default. Then set it.
	sqlite3.Xsqlite3session_object_config(tls, (*TestSession)(unsafe.Pointer(p)).FpSession, SQLITE_SESSION_OBJCONFIG_SIZE, bp+88 /* &iArg */)

	*(*int32)(unsafe.Pointer(bp + 88 /* iArg */)) = 1
	sqlite3.Xsqlite3session_object_config(tls, (*TestSession)(unsafe.Pointer(p)).FpSession, SQLITE_SESSION_OBJCONFIG_SIZE, bp+88 /* &iArg */)

	tcl.XTcl_CreateObjCommand(tls,
		interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_session_cmd})), p,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{test_session_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	return TCL_OK
}

func test_append_value(tls *libc.TLS, pList uintptr, pVal uintptr) { /* test_session.c:446:13: */
	if pVal == uintptr(0) {
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewObj(tls))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewObj(tls))
	} else {
		var pObj uintptr
		switch sqlite3.Xsqlite3_value_type(tls, pVal) {
		case SQLITE_NULL:
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+11119 /* "n" */, 1))
			pObj = tcl.XTcl_NewObj(tls)
			break
			fallthrough
		case SQLITE_INTEGER:
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+11121 /* "i" */, 1))
			pObj = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, pVal))
			break
			fallthrough
		case SQLITE_FLOAT:
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+11123 /* "f" */, 1))
			pObj = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, pVal))
			break
			fallthrough
		case SQLITE_TEXT:
			{
				var z uintptr = sqlite3.Xsqlite3_value_blob(tls, pVal)
				var n int32 = sqlite3.Xsqlite3_value_bytes(tls, pVal)
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+11125 /* "t" */, 1))
				pObj = tcl.XTcl_NewStringObj(tls, z, n)
				break

			}
			fallthrough
		default:

			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, tcl.XTcl_NewStringObj(tls, ts+11127 /* "b" */, 1))
			pObj = tcl.XTcl_NewByteArrayObj(tls,
				sqlite3.Xsqlite3_value_blob(tls, pVal),
				sqlite3.Xsqlite3_value_bytes(tls, pVal))
			break
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pList, pObj)
	}
}

type TestConflictHandler1 = struct {
	Finterp          uintptr
	FpConflictScript uintptr
	FpFilterScript   uintptr
} /* test_session.c:485:9 */

type TestConflictHandler = TestConflictHandler1 /* test_session.c:485:36 */

func test_obj_eq_string(tls *libc.TLS, p uintptr, z uintptr) int32 { /* test_session.c:492:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var n int32
	// var nObj int32 at bp, 4

	var zObj uintptr

	n = int32(libc.Xstrlen(tls, z))
	zObj = tcl.XTcl_GetStringFromObj(tls, p, bp /* &nObj */)

	return libc.Bool32(*(*int32)(unsafe.Pointer(bp)) == n && (n == 0 || 0 == libc.Xmemcmp(tls, zObj, z, uint64(n))))
}

func test_filter_handler(tls *libc.TLS, pCtx uintptr, zTab uintptr) int32 { /* test_session.c:503:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	*(*int32)(unsafe.Pointer(bp /* res */)) = 1
	var pEval uintptr
	var interp uintptr = (*TestConflictHandler)(unsafe.Pointer(p)).Finterp

	pEval = tcl.XTcl_DuplicateObj(tls, (*TestConflictHandler)(unsafe.Pointer(p)).FpFilterScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++

	if TCL_OK != tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, zTab, -1)) ||
		TCL_OK != tcl.XTcl_EvalObjEx(tls, interp, pEval, TCL_EVAL_GLOBAL) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, tcl.XTcl_GetObjResult(tls, interp), bp) {
		tcl.XTcl_BackgroundError(tls, interp)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* res */))
}

func test_conflict_handler(tls *libc.TLS, pCtx uintptr, eConf int32, pIter uintptr) int32 { /* test_session.c:526:12: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var p uintptr = pCtx
	var pEval uintptr
	var interp uintptr = (*TestConflictHandler)(unsafe.Pointer(p)).Finterp
	*(*int32)(unsafe.Pointer(bp + 100 /* ret */)) = 0 // Return value

	// var op int32 at bp+12, 4
	// SQLITE_UPDATE, DELETE or INSERT
	// var zTab uintptr at bp, 8
	// Name of table conflict is on
	// var nCol int32 at bp+8, 4
	// Number of columns in table zTab

	pEval = tcl.XTcl_DuplicateObj(tls, (*TestConflictHandler)(unsafe.Pointer(p)).FpConflictScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++

	sqlite3.Xsqlite3changeset_op(tls, pIter, bp /* &zTab */, bp+8 /* &nCol */, bp+12 /* &op */, uintptr(0))

	if eConf == SQLITE_CHANGESET_FOREIGN_KEY {
		// var nFk int32 at bp+16, 4

		sqlite3.Xsqlite3changeset_fk_conflicts(tls, pIter, bp+16 /* &nFk */)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, ts+11129 /* "FOREIGN_KEY" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16 /* nFk */))))
	} else {

		// Append the operation type.
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls,
			func() uintptr {
				if *(*int32)(unsafe.Pointer(bp + 12)) == SQLITE_INSERT {
					return ts + 11141 /* "INSERT" */
				}
				return func() uintptr {
					if *(*int32)(unsafe.Pointer(bp + 12 /* op */)) == SQLITE_UPDATE {
						return ts + 11148 /* "UPDATE" */
					}
					return ts + 11155 /* "DELETE" */
				}()
			}(), -1))

		// Append the table name.
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp /* zTab */)), -1))

		// Append the conflict type.
		switch eConf {
		case SQLITE_CHANGESET_DATA:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+11162 /* "DATA" */, -1))
			break
			fallthrough
		case SQLITE_CHANGESET_NOTFOUND:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+11167 /* "NOTFOUND" */, -1))
			break
			fallthrough
		case SQLITE_CHANGESET_CONFLICT:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+11176 /* "CONFLICT" */, -1))
			break
			fallthrough
		case SQLITE_CHANGESET_CONSTRAINT:
			tcl.XTcl_ListObjAppendElement(tls, interp, pEval, tcl.XTcl_NewStringObj(tls, ts+11185 /* "CONSTRAINT" */, -1))
			break
		}

		// If this is not an INSERT, append the old row
		if *(*int32)(unsafe.Pointer(bp + 12)) != SQLITE_INSERT {
			var i int32
			var pOld uintptr = tcl.XTcl_NewObj(tls)
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)); i++ {
				// var pVal uintptr at bp+24, 8

				sqlite3.Xsqlite3changeset_old(tls, pIter, i, bp+24 /* &pVal */)
				test_append_value(tls, pOld, *(*uintptr)(unsafe.Pointer(bp + 24 /* pVal */)))
			}
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pOld)
		}

		// If this is not a DELETE, append the new row
		if *(*int32)(unsafe.Pointer(bp + 12)) != SQLITE_DELETE {
			var i int32
			var pNew uintptr = tcl.XTcl_NewObj(tls)
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)); i++ {
				// var pVal uintptr at bp+32, 8

				sqlite3.Xsqlite3changeset_new(tls, pIter, i, bp+32 /* &pVal */)
				test_append_value(tls, pNew, *(*uintptr)(unsafe.Pointer(bp + 32 /* pVal */)))
			}
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pNew)
		}

		// If this is a CHANGESET_DATA or CHANGESET_CONFLICT conflict, append
		// the conflicting row.
		if eConf == SQLITE_CHANGESET_DATA || eConf == SQLITE_CHANGESET_CONFLICT {
			var i int32
			var pConflict uintptr = tcl.XTcl_NewObj(tls)
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)); i++ {
				var rc int32
				_ = rc
				// var pVal uintptr at bp+40, 8

				rc = sqlite3.Xsqlite3changeset_conflict(tls, pIter, i, bp+40 /* &pVal */)

				test_append_value(tls, pConflict, *(*uintptr)(unsafe.Pointer(bp + 40 /* pVal */)))
			}
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pConflict)
		}

		// **********************************************************************
		//
		// This block is purely for testing some error conditions.
		if eConf == SQLITE_CHANGESET_CONSTRAINT ||
			eConf == SQLITE_CHANGESET_NOTFOUND {
			// var pVal uintptr at bp+48, 8

			var rc int32 = sqlite3.Xsqlite3changeset_conflict(tls, pIter, 0, bp+48 /* &pVal */)
			_ = rc

		} else {
			// var pVal uintptr at bp+56, 8

			var rc int32 = sqlite3.Xsqlite3changeset_conflict(tls, pIter, -1, bp+56 /* &pVal */)
			_ = rc

			rc = sqlite3.Xsqlite3changeset_conflict(tls, pIter, *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)), bp+56 /* &pVal */)

		}
		if *(*int32)(unsafe.Pointer(bp + 12)) == SQLITE_DELETE {
			// var pVal uintptr at bp+64, 8

			var rc int32 = sqlite3.Xsqlite3changeset_new(tls, pIter, 0, bp+64 /* &pVal */)
			_ = rc

		} else {
			// var pVal uintptr at bp+72, 8

			var rc int32 = sqlite3.Xsqlite3changeset_new(tls, pIter, -1, bp+72 /* &pVal */)
			_ = rc

			rc = sqlite3.Xsqlite3changeset_new(tls, pIter, *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)), bp+72 /* &pVal */)

		}
		if *(*int32)(unsafe.Pointer(bp + 12)) == SQLITE_INSERT {
			// var pVal uintptr at bp+80, 8

			var rc int32 = sqlite3.Xsqlite3changeset_old(tls, pIter, 0, bp+80 /* &pVal */)
			_ = rc

		} else {
			// var pVal uintptr at bp+88, 8

			var rc int32 = sqlite3.Xsqlite3changeset_old(tls, pIter, -1, bp+88 /* &pVal */)
			_ = rc

			rc = sqlite3.Xsqlite3changeset_old(tls, pIter, *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)), bp+88 /* &pVal */)

		}
		if eConf != SQLITE_CHANGESET_FOREIGN_KEY {
			// eConf!=FOREIGN_KEY is always true at this point. The condition is
			// just there to make it clearer what is being tested.
			// var nDummy int32 at bp+96, 4

			var rc int32 = sqlite3.Xsqlite3changeset_fk_conflicts(tls, pIter, bp+96 /* &nDummy */)
			_ = rc

		}
		// End of testing block
		//
	}

	if TCL_OK != tcl.XTcl_EvalObjEx(tls, interp, pEval, TCL_EVAL_GLOBAL) {
		tcl.XTcl_BackgroundError(tls, interp)
	} else {
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		if test_obj_eq_string(tls, pRes, ts+11196) != 0 || test_obj_eq_string(tls, pRes, ts+584) != 0 {
			*(*int32)(unsafe.Pointer(bp + 100 /* ret */)) = SQLITE_CHANGESET_OMIT
		} else if test_obj_eq_string(tls, pRes, ts+7489) != 0 {
			*(*int32)(unsafe.Pointer(bp + 100 /* ret */)) = SQLITE_CHANGESET_REPLACE
		} else if test_obj_eq_string(tls, pRes, ts+7483) != 0 {
			*(*int32)(unsafe.Pointer(bp + 100 /* ret */)) = SQLITE_CHANGESET_ABORT
		} else {
			tcl.XTcl_GetIntFromObj(tls, uintptr(0), pRes, bp+100 /* &ret */)
		}
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return *(*int32)(unsafe.Pointer(bp + 100 /* ret */))
}

// The conflict handler used by sqlite3changeset_apply_replace_all().
// This conflict handler calls sqlite3_value_text16() on all available
// sqlite3_value objects and then returns CHANGESET_REPLACE, or
// CHANGESET_OMIT if REPLACE is not applicable. This is used to test the
// effect of a malloc failure within an sqlite3_value_xxx() function
// invoked by a conflict-handler callback.
func replace_handler(tls *libc.TLS, pCtx uintptr, eConf int32, pIter uintptr) int32 { /* test_session.c:693:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var op int32 at bp+12, 4
	// SQLITE_UPDATE, DELETE or INSERT
	// var zTab uintptr at bp, 8
	// Name of table conflict is on
	// var nCol int32 at bp+8, 4
	// Number of columns in table zTab
	var i int32
	var x int32 = 0

	sqlite3.Xsqlite3changeset_op(tls, pIter, bp /* &zTab */, bp+8 /* &nCol */, bp+12 /* &op */, uintptr(0))

	if *(*int32)(unsafe.Pointer(bp + 12)) != SQLITE_INSERT {
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)); i++ {
			// var pVal uintptr at bp+16, 8

			sqlite3.Xsqlite3changeset_old(tls, pIter, i, bp+16 /* &pVal */)
			sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pVal */)))
			x++
		}
	}

	if *(*int32)(unsafe.Pointer(bp + 12)) != SQLITE_DELETE {
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 8 /* nCol */)); i++ {
			// var pVal uintptr at bp+24, 8

			sqlite3.Xsqlite3changeset_new(tls, pIter, i, bp+24 /* &pVal */)
			sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pVal */)))
			x++
		}
	}

	if eConf == SQLITE_CHANGESET_DATA {
		return SQLITE_CHANGESET_REPLACE
	}
	return SQLITE_CHANGESET_OMIT
}

func testStreamInput(tls *libc.TLS, pCtx uintptr, pData uintptr, pnData uintptr) int32 { /* test_session.c:730:12: */
	var p uintptr = pCtx
	var nReq int32 = *(*int32)(unsafe.Pointer(pnData))                                                           // Bytes of data requested
	var nRem int32 = (*TestStreamInput)(unsafe.Pointer(p)).FnData - (*TestStreamInput)(unsafe.Pointer(p)).FiData // Bytes of data available
	var nRet int32 = (*TestStreamInput)(unsafe.Pointer(p)).FnStream                                              // Bytes actually returned

	// Allocate and free some space. There is no point to this, other than
	// that it allows the regular OOM fault-injection tests to cause an error
	// in this function.
	var pAlloc uintptr = sqlite3.Xsqlite3_malloc(tls, 10)
	if pAlloc == uintptr(0) {
		return SQLITE_NOMEM
	}
	sqlite3.Xsqlite3_free(tls, pAlloc)

	if nRet > nReq {
		nRet = nReq
	}
	if nRet > nRem {
		nRet = nRem
	}

	if nRet > 0 {
		libc.Xmemcpy(tls, pData, (*TestStreamInput)(unsafe.Pointer(p)).FaData+uintptr((*TestStreamInput)(unsafe.Pointer(p)).FiData), uint64(nRet))
		*(*int32)(unsafe.Pointer(p + 20)) += nRet
	}

	*(*int32)(unsafe.Pointer(pnData)) = nRet
	return SQLITE_OK
}

func testSqlite3changesetApply(tls *libc.TLS, bV2 int32, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:761:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	var db uintptr // Database handle
	// var info Tcl_CmdInfo at bp+48, 64
	// Database Tcl command (objv[1]) info
	var rc int32           // Return code from changeset_invert()
	var pChangeset uintptr // Buffer containing changeset
	// var nChangeset int32 at bp+112, 4
	// Size of buffer aChangeset in bytes
	// var ctx TestConflictHandler at bp+120, 24

	// var sStr TestStreamInput at bp+24, 24

	*(*uintptr)(unsafe.Pointer(bp + 144 /* pRebase */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 152 /* nRebase */)) = 0
	var flags int32 = 0 // Flags for apply_v2()

	libc.Xmemset(tls, bp+24 /* &sStr */, 0, uint64(unsafe.Sizeof(TestStreamInput{})))
	(*TestStreamInput)(unsafe.Pointer(bp + 24 /* &sStr */)).FnStream = test_tcl_integer(tls, interp, ts+10930 /* "sqlite3session_s..." */)

	// Check for the -nosavepoint flag
	if bV2 != 0 {
		if objc > 1 {
			var z1 uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
			var n int32 = int32(libc.Xstrlen(tls, z1))
			if n > 1 && n <= 12 && 0 == sqlite3.Xsqlite3_strnicmp(tls, ts+11201, z1, n) {
				flags = flags | SQLITE_CHANGESETAPPLY_NOSAVEPOINT
				objc--
				objv += 8
			}
		}
		if objc > 1 {
			var z1 uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
			var n int32 = int32(libc.Xstrlen(tls, z1))
			if n > 1 && n <= 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, ts+11214, z1, n) {
				flags = flags | SQLITE_CHANGESETAPPLY_INVERT
				objc--
				objv += 8
			}
		}
	}

	if objc != 4 && objc != 5 {
		var zMsg uintptr
		if bV2 != 0 {
			zMsg = ts + 11222 /* "?-nosavepoint? ?..." */
		} else {
			zMsg = ts + 11293 /* "DB CHANGESET CON..." */
		}
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, zMsg)
		return TCL_ERROR
	}
	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930 /* "no such handle: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), 0))
		return TCL_ERROR
	}
	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 48 /* &info */)).FobjClientData))
	pChangeset = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+112 /* &nChangeset */)
	(*TestConflictHandler)(unsafe.Pointer(bp + 120 /* &ctx */)).FpConflictScript = *(*uintptr)(unsafe.Pointer(objv + 3*8))
	(*TestConflictHandler)(unsafe.Pointer(bp + 120 /* &ctx */)).FpFilterScript = func() uintptr {
		if objc == 5 {
			return *(*uintptr)(unsafe.Pointer(objv + 4*8))
		}
		return uintptr(0)
	}()
	(*TestConflictHandler)(unsafe.Pointer(bp + 120 /* &ctx */)).Finterp = interp

	if (*TestStreamInput)(unsafe.Pointer(bp+24)).FnStream == 0 {
		if bV2 == 0 {
			rc = sqlite3.Xsqlite3changeset_apply(tls, db, *(*int32)(unsafe.Pointer(bp + 112 /* nChangeset */)), pChangeset,
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(), *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+120 /* &ctx */)
		} else {
			rc = sqlite3.Xsqlite3changeset_apply_v2(tls, db, *(*int32)(unsafe.Pointer(bp + 112 /* nChangeset */)), pChangeset,
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(), *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+120, /* &ctx */
				bp+144 /* &pRebase */, bp+152 /* &nRebase */, flags)
		}
	} else {
		(*TestStreamInput)(unsafe.Pointer(bp + 24 /* &sStr */)).FaData = pChangeset
		(*TestStreamInput)(unsafe.Pointer(bp + 24 /* &sStr */)).FnData = *(*int32)(unsafe.Pointer(bp + 112 /* nChangeset */))
		if bV2 == 0 {
			rc = sqlite3.Xsqlite3changeset_apply_strm(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp+24, /* &sStr */
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+120 /* &ctx */)
		} else {
			rc = sqlite3.Xsqlite3changeset_apply_v2_strm(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp+24, /* &sStr */
				func() uintptr {
					if objc == 5 {
						return *(*uintptr)(unsafe.Pointer(&struct {
							f func(*libc.TLS, uintptr, uintptr) int32
						}{test_filter_handler}))
					}
					return uintptr(0)
				}(),
				*(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr) int32
				}{test_conflict_handler})), bp+120, /* &ctx */
				bp+144 /* &pRebase */, bp+152 /* &nRebase */, flags)
		}
	}

	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	} else {
		tcl.XTcl_ResetResult(tls, interp)
		if bV2 != 0 && *(*uintptr)(unsafe.Pointer(bp + 144)) != 0 {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 144 /* pRebase */)), *(*int32)(unsafe.Pointer(bp + 152 /* nRebase */))))
		}
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 144 /* pRebase */)))
	return TCL_OK
}

// sqlite3changeset_apply DB CHANGESET CONFLICT-SCRIPT ?FILTER-SCRIPT?
func test_sqlite3changeset_apply(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:868:26: */
	return testSqlite3changesetApply(tls, 0, clientData, interp, objc, objv)
}

// sqlite3changeset_apply_v2 DB CHANGESET CONFLICT-SCRIPT ?FILTER-SCRIPT?
func test_sqlite3changeset_apply_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:879:26: */
	return testSqlite3changesetApply(tls, 1, clientData, interp, objc, objv)
}

// sqlite3changeset_apply_replace_all DB CHANGESET
func test_sqlite3changeset_apply_replace_all(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:891:26: */
	bp := tls.Alloc(92)
	defer tls.Free(92)

	var db uintptr // Database handle
	// var info Tcl_CmdInfo at bp+24, 64
	// Database Tcl command (objv[1]) info
	var rc int32           // Return code from changeset_invert()
	var pChangeset uintptr // Buffer containing changeset
	// var nChangeset int32 at bp+88, 4
	// Size of buffer aChangeset in bytes

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11338 /* "DB CHANGESET" */)
		return TCL_ERROR
	}
	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+24) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+1930 /* "no such handle: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), 0))
		return TCL_ERROR
	}
	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24 /* &info */)).FobjClientData))
	pChangeset = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+88 /* &nChangeset */)

	rc = sqlite3.Xsqlite3changeset_apply(tls, db, *(*int32)(unsafe.Pointer(bp + 88 /* nChangeset */)), pChangeset, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{replace_handler})), uintptr(0))
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}
	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

// sqlite3changeset_invert CHANGESET
func test_sqlite3changeset_invert(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:926:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32 // Return code from changeset_invert()
	// var sIn TestStreamInput at bp, 24
	// Input stream
	// var sOut TestSessionsBlob at bp+24, 16
	// Output blob

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11351 /* "CHANGESET" */)
		return TCL_ERROR
	}

	libc.Xmemset(tls, bp /* &sIn */, 0, uint64(unsafe.Sizeof(TestStreamInput{})))
	libc.Xmemset(tls, bp+24 /* &sOut */, 0, uint64(unsafe.Sizeof(TestSessionsBlob{})))
	(*TestStreamInput)(unsafe.Pointer(bp /* &sIn */)).FnStream = test_tcl_integer(tls, interp, ts+10930 /* "sqlite3session_s..." */)
	(*TestStreamInput)(unsafe.Pointer(bp /* &sIn */)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16)

	if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream != 0 {
		rc = sqlite3.Xsqlite3changeset_invert_strm(tls,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp /* &sIn */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			}{testStreamOutput})), bp+24 /* &sOut */)
	} else {
		rc = sqlite3.Xsqlite3changeset_invert(tls, (*TestStreamInput)(unsafe.Pointer(bp /* &sIn */)).FnData, (*TestStreamInput)(unsafe.Pointer(bp /* &sIn */)).FaData, bp+24+8, bp+24)
	}
	if rc != SQLITE_OK {
		rc = test_session_error(tls, interp, rc, uintptr(0))
	} else {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+24 /* &sOut */)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+24 /* &sOut */)).Fn))
	}
	sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+24 /* &sOut */)).Fp)
	return rc
}

// sqlite3changeset_concat LEFT RIGHT
func test_sqlite3changeset_concat(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:965:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var rc int32 // Return code from changeset_invert()

	// var sLeft TestStreamInput at bp, 24
	// Input stream
	// var sRight TestStreamInput at bp+24, 24
	// Input stream
	*(*TestSessionsBlob)(unsafe.Pointer(bp + 48 /* sOut */)) = TestSessionsBlob{} // Output blob

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11361 /* "LEFT RIGHT" */)
		return TCL_ERROR
	}

	libc.Xmemset(tls, bp /* &sLeft */, 0, uint64(unsafe.Sizeof(TestStreamInput{})))
	libc.Xmemset(tls, bp+24 /* &sRight */, 0, uint64(unsafe.Sizeof(TestStreamInput{})))
	(*TestStreamInput)(unsafe.Pointer(bp /* &sLeft */)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16)
	(*TestStreamInput)(unsafe.Pointer(bp + 24 /* &sRight */)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+24+16)
	(*TestStreamInput)(unsafe.Pointer(bp /* &sLeft */)).FnStream = test_tcl_integer(tls, interp, ts+10930 /* "sqlite3session_s..." */)
	(*TestStreamInput)(unsafe.Pointer(bp + 24 /* &sRight */)).FnStream = (*TestStreamInput)(unsafe.Pointer(bp /* &sLeft */)).FnStream

	if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream > 0 {
		rc = sqlite3.Xsqlite3changeset_concat_strm(tls,
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp, /* &sLeft */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp+24, /* &sRight */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			}{testStreamOutput})), bp+48 /* &sOut */)
	} else {
		rc = sqlite3.Xsqlite3changeset_concat(tls,
			(*TestStreamInput)(unsafe.Pointer(bp /* &sLeft */)).FnData, (*TestStreamInput)(unsafe.Pointer(bp /* &sLeft */)).FaData, (*TestStreamInput)(unsafe.Pointer(bp+24 /* &sRight */)).FnData, (*TestStreamInput)(unsafe.Pointer(bp+24 /* &sRight */)).FaData, bp+48+8, bp+48)
	}

	if rc != SQLITE_OK {
		rc = test_session_error(tls, interp, rc, uintptr(0))
	} else {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+48 /* &sOut */)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+48 /* &sOut */)).Fn))
	}
	sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+48 /* &sOut */)).Fp)
	return rc
}

// sqlite3session_foreach VARNAME CHANGESET SCRIPT
func test_sqlite3session_foreach(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:1013:26: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	var pChangeset uintptr
	// var nChangeset int32 at bp+24, 4

	// var pIter uintptr at bp+32, 8

	var rc int32
	var pVarname uintptr
	var pCS uintptr
	var pScript uintptr
	var isCheckNext int32 = 0
	var isInvert int32 = 0
	// var sStr TestStreamInput at bp, 24

	libc.Xmemset(tls, bp /* &sStr */, 0, uint64(unsafe.Sizeof(TestStreamInput{})))

	for objc > 1 {
		var zOpt uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
		var nOpt int32 = int32(libc.Xstrlen(tls, zOpt))
		if int32(*(*int8)(unsafe.Pointer(zOpt))) != '-' {
			break
		}
		if nOpt <= 7 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+11214, nOpt) {
			isInvert = 1
		} else if nOpt <= 5 && 0 == sqlite3.Xsqlite3_strnicmp(tls, zOpt, ts+11372, nOpt) {
			isCheckNext = 1
		} else {
			break
		}
		objv += 8
		objc--
	}
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+11378 /* "?-next? ?-invert..." */)
		return TCL_ERROR
	}

	pVarname = *(*uintptr)(unsafe.Pointer(objv + 1*8))
	pCS = *(*uintptr)(unsafe.Pointer(objv + 2*8))
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*8))

	pChangeset = tcl.XTcl_GetByteArrayFromObj(tls, pCS, bp+24 /* &nChangeset */)
	(*TestStreamInput)(unsafe.Pointer(bp /* &sStr */)).FnStream = test_tcl_integer(tls, interp, ts+10930 /* "sqlite3session_s..." */)
	if isInvert != 0 {
		var f int32 = SQLITE_CHANGESETSTART_INVERT
		if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream == 0 {
			rc = sqlite3.Xsqlite3changeset_start_v2(tls, bp+32 /* &pIter */, *(*int32)(unsafe.Pointer(bp + 24 /* nChangeset */)), pChangeset, f)
		} else {
			var pCtx uintptr = bp /* &sStr */
			(*TestStreamInput)(unsafe.Pointer(bp /* &sStr */)).FaData = pChangeset
			(*TestStreamInput)(unsafe.Pointer(bp /* &sStr */)).FnData = *(*int32)(unsafe.Pointer(bp + 24 /* nChangeset */))
			rc = sqlite3.Xsqlite3changeset_start_v2_strm(tls, bp+32 /* &pIter */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), pCtx, f)
		}
	} else {
		if (*TestStreamInput)(unsafe.Pointer(bp)).FnStream == 0 {
			rc = sqlite3.Xsqlite3changeset_start(tls, bp+32 /* &pIter */, *(*int32)(unsafe.Pointer(bp + 24 /* nChangeset */)), pChangeset)
		} else {
			(*TestStreamInput)(unsafe.Pointer(bp /* &sStr */)).FaData = pChangeset
			(*TestStreamInput)(unsafe.Pointer(bp /* &sStr */)).FnData = *(*int32)(unsafe.Pointer(bp + 24 /* nChangeset */))
			rc = sqlite3.Xsqlite3changeset_start_strm(tls, bp+32 /* &pIter */, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			}{testStreamInput})), bp /* &sStr */)
		}
	}
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	for SQLITE_ROW == sqlite3.Xsqlite3changeset_next(tls, *(*uintptr)(unsafe.Pointer(bp + 32))) {
		// var nCol int32 at bp+56, 4
		// Number of columns in table
		// var nCol2 int32 at bp+80, 4
		// Number of columns in table
		// var op int32 at bp+60, 4
		// SQLITE_INSERT, UPDATE or DELETE
		// var zTab uintptr at bp+48, 8
		// Name of table change applies to
		var pVar uintptr // Tcl value to set $VARNAME to
		var pOld uintptr // Vector of old.* values
		var pNew uintptr // Vector of new.* values
		// var bIndirect int32 at bp+64, 4

		var zPK uintptr
		// var abPK uintptr at bp+72, 8

		var i int32

		// Test that _fk_conflicts() returns SQLITE_MISUSE if called on this
		// iterator.
		// var nDummy int32 at bp+40, 4

		if SQLITE_MISUSE != sqlite3.Xsqlite3changeset_fk_conflicts(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), bp+40) {
			sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)))
			return TCL_ERROR
		}

		sqlite3.Xsqlite3changeset_op(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)), bp+48 /* &zTab */, bp+56 /* &nCol */, bp+60 /* &op */, bp+64 /* &bIndirect */)
		pVar = tcl.XTcl_NewObj(tls)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewStringObj(tls,
			func() uintptr {
				if *(*int32)(unsafe.Pointer(bp + 60)) == SQLITE_INSERT {
					return ts + 11141 /* "INSERT" */
				}
				return func() uintptr {
					if *(*int32)(unsafe.Pointer(bp + 60 /* op */)) == SQLITE_UPDATE {
						return ts + 11148 /* "UPDATE" */
					}
					return ts + 11155 /* "DELETE" */
				}()
			}(), -1))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* zTab */)), -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewIntObj(tls, libc.Bool32(*(*int32)(unsafe.Pointer(bp + 64)) != 0)))

		zPK = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 56))+1))
		libc.Xmemset(tls, zPK, 0, uint64(*(*int32)(unsafe.Pointer(bp + 56))+1))
		sqlite3.Xsqlite3changeset_pk(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)), bp+72 /* &abPK */, bp+80 /* &nCol2 */)

		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 56 /* nCol */)); i++ {
			*(*int8)(unsafe.Pointer(zPK + uintptr(i))) = func() int8 {
				if *(*uint8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 72)) + uintptr(i))) != 0 {
					return int8('X')
				}
				return int8('.')
			}()
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, tcl.XTcl_NewStringObj(tls, zPK, -1))
		tcl.XTcl_Free(tls, zPK)

		pOld = tcl.XTcl_NewObj(tls)
		if *(*int32)(unsafe.Pointer(bp + 60)) != SQLITE_INSERT {
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 56 /* nCol */)); i++ {
				// var pVal uintptr at bp+88, 8

				sqlite3.Xsqlite3changeset_old(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)), i, bp+88 /* &pVal */)
				test_append_value(tls, pOld, *(*uintptr)(unsafe.Pointer(bp + 88 /* pVal */)))
			}
		}
		pNew = tcl.XTcl_NewObj(tls)
		if *(*int32)(unsafe.Pointer(bp + 60)) != SQLITE_DELETE {
			for i = 0; i < *(*int32)(unsafe.Pointer(bp + 56 /* nCol */)); i++ {
				// var pVal uintptr at bp+96, 8

				sqlite3.Xsqlite3changeset_new(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)), i, bp+96 /* &pVal */)
				test_append_value(tls, pNew, *(*uintptr)(unsafe.Pointer(bp + 96 /* pVal */)))
			}
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, pOld)
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pVar, pNew)

		tcl.XTcl_ObjSetVar2(tls, interp, pVarname, uintptr(0), pVar, 0)
		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		if rc != TCL_OK && rc != TCL_CONTINUE {
			sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)))
			if rc == TCL_BREAK {
				return TCL_OK
			}
			return rc
		}
	}

	if isCheckNext != 0 {
		var rc2 int32 = sqlite3.Xsqlite3changeset_next(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)))
		_ = rc2
		rc = sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)))

	} else {
		rc = sqlite3.Xsqlite3changeset_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pIter */)))
	}
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	return TCL_OK
}

// tclcmd: CMD configure REBASE-BLOB
// tclcmd: CMD rebase CHANGESET
// tclcmd: CMD delete
func test_rebaser_cmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:1171:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var p uintptr = clientData
	// var iSub int32 at bp, 4

	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999 /* "SUBCOMMAND ..." */)
		return TCL_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&aSub1)), int32(unsafe.Sizeof(RebaseSubcmd{})), ts+2014 /* "sub-command" */, 0, bp /* &iSub */)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+aSub1[*(*int32)(unsafe.Pointer(bp))].FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, aSub1[*(*int32)(unsafe.Pointer(bp /* iSub */))].FzMsg)
		return TCL_ERROR
	}

	switch *(*int32)(unsafe.Pointer(bp /* iSub */)) {
	case 0:
		{ // configure
			*(*int32)(unsafe.Pointer(bp + 4 /* nRebase */)) = 0
			var pRebase uintptr = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4 /* &nRebase */)
			rc = sqlite3.Xsqlite3rebaser_configure(tls, p, *(*int32)(unsafe.Pointer(bp + 4 /* nRebase */)), pRebase)
			break

		}

	case 1: // delete
		tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
		break

	default:
		{ // rebase
			// var sStr TestStreamInput at bp+8, 24
			// Input stream
			// var sOut TestSessionsBlob at bp+32, 16
			// Output blob

			libc.Xmemset(tls, bp+8 /* &sStr */, 0, uint64(unsafe.Sizeof(TestStreamInput{})))
			libc.Xmemset(tls, bp+32 /* &sOut */, 0, uint64(unsafe.Sizeof(TestSessionsBlob{})))
			(*TestStreamInput)(unsafe.Pointer(bp + 8 /* &sStr */)).FaData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8+16)
			(*TestStreamInput)(unsafe.Pointer(bp + 8 /* &sStr */)).FnStream = test_tcl_integer(tls, interp, ts+10930 /* "sqlite3session_s..." */)

			if (*TestStreamInput)(unsafe.Pointer(bp+8)).FnStream != 0 {
				rc = sqlite3.Xsqlite3rebaser_rebase_strm(tls, p,
					*(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, uintptr) int32
					}{testStreamInput})), bp+8, /* &sStr */
					*(*uintptr)(unsafe.Pointer(&struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					}{testStreamOutput})), bp+32 /* &sOut */)
			} else {
				rc = sqlite3.Xsqlite3rebaser_rebase(tls, p, (*TestStreamInput)(unsafe.Pointer(bp+8 /* &sStr */)).FnData, (*TestStreamInput)(unsafe.Pointer(bp+8 /* &sStr */)).FaData, bp+32+8, bp+32)
			}

			if rc == SQLITE_OK {
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+32 /* &sOut */)).Fp, (*TestSessionsBlob)(unsafe.Pointer(bp+32 /* &sOut */)).Fn))
			}
			sqlite3.Xsqlite3_free(tls, (*TestSessionsBlob)(unsafe.Pointer(bp+32 /* &sOut */)).Fp)
			break

		}
	}

	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}
	return TCL_OK
}

type RebaseSubcmd = struct {
	FzSub        uintptr
	FnArg        int32
	F__ccgo_pad1 [4]byte
	FzMsg        uintptr
	FiSub        int32
	F__ccgo_pad2 [4]byte
} /* test_session.c:1177:10 */

var aSub1 = [4]RebaseSubcmd{
	{FzSub: ts + 11421 /* "configure" */, FnArg: 1, FzMsg: ts + 11431 /* "REBASE-BLOB" */}, // 0
	{FzSub: ts + 10970 /* "delete" */, FzMsg: ts + 584 /* "" */},                           // 1
	{FzSub: ts + 11443 /* "rebase" */, FnArg: 1, FzMsg: ts + 11351 /* "CHANGESET" */},      // 2
	{},
} /* test_session.c:1182:5 */

func test_rebaser_del(tls *libc.TLS, clientData uintptr) { /* test_session.c:1252:27: */
	var p uintptr = clientData
	sqlite3.Xsqlite3rebaser_delete(tls, p)
}

// tclcmd: sqlite3rebaser_create NAME
func test_sqlite3rebaser_create(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:1260:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp /* pNew */)) = uintptr(0)
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10594 /* "NAME" */)
		return SQLITE_ERROR
	}

	rc = sqlite3.Xsqlite3rebaser_create(tls, bp /* &pNew */)
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}

	tcl.XTcl_CreateObjCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_rebaser_cmd})),
		*(*uintptr)(unsafe.Pointer(bp /* pNew */)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{test_rebaser_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	return TCL_OK
}

// tclcmd: sqlite3rebaser_configure OP VALUE
func test_sqlite3session_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_session.c:1288:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var iSub int32 at bp, 4

	// var iVal int32 at bp+4, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11450 /* "OP VALUE" */)
		return SQLITE_ERROR
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&aSub2)), int32(unsafe.Sizeof(ConfigOpt{})), ts+2014 /* "sub-command" */, 0, bp /* &iSub */)
	if rc != TCL_OK {
		return rc
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3session_config(tls, aSub2[*(*int32)(unsafe.Pointer(bp /* iSub */))].Fop, bp+4 /* &iVal */)
	if rc != SQLITE_OK {
		return test_session_error(tls, interp, rc, uintptr(0))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 /* iVal */))))
	return TCL_OK
}

type ConfigOpt = struct {
	FzSub        uintptr
	Fop          int32
	F__ccgo_pad1 [4]byte
} /* test_session.c:1294:10 */

var aSub2 = [3]ConfigOpt{
	{FzSub: ts + 11459 /* "strm_size" */, Fop: SQLITE_SESSION_CONFIG_STRMSIZE},
	{FzSub: ts + 2758 /* "invalid" */},
	{},
} /* test_session.c:1297:5 */

func TestSession_Init(tls *libc.TLS, interp uintptr) int32 { /* test_session.c:1324:5: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	*(*[10]struct {
		FzCmd  uintptr
		FxProc uintptr
	})(unsafe.Pointer(bp)) = [10]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{
		{FzCmd: ts + 11469 /* "sqlite3session" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3session}))},
		{FzCmd: ts + 11484 /* "sqlite3session_f..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3session_foreach}))},
		{FzCmd: ts + 11507 /* "sqlite3changeset..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_invert}))},
		{FzCmd: ts + 11531 /* "sqlite3changeset..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_concat}))},
		{FzCmd: ts + 11555 /* "sqlite3changeset..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_apply}))},
		{FzCmd: ts + 11578 /* "sqlite3changeset..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3changeset_apply_v2}))},
		{FzCmd: ts + 11604, /* "sqlite3changeset..." */
			FxProc: *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			}{test_sqlite3changeset_apply_replace_all}))},
		{FzCmd: ts + 11639 /* "sql_exec_changes..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sql_exec_changeset}))},
		{FzCmd: ts + 11658 /* "sqlite3rebaser_c..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3rebaser_create}))},
		{FzCmd: ts + 11680 /* "sqlite3session_c..." */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_sqlite3session_config}))},
	}
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof([10]struct {
		FzCmd  uintptr
		FxProc uintptr
	}{}))/uint64(unsafe.Sizeof(struct {
		FzCmd  uintptr
		FxProc uintptr
	}{})); i++ {
		var p uintptr = bp + uintptr(i)*16
		tcl.XTcl_CreateObjCommand(tls, interp, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FzCmd, (*struct {
			FzCmd  uintptr
			FxProc uintptr
		})(unsafe.Pointer(p)).FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

// 2014-09-08
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// This file contains the bulk of the implementation of the
// user-authentication extension feature.  Some parts of the user-
// authentication code are contained within the SQLite core (in the
// src/ subdirectory of the main source code tree) but those parts
// that could reasonable be separated out are moved into this file.
//
// To compile with the user-authentication feature, append this file to
// end of an SQLite amalgamation, then add the SQLITE_USER_AUTHENTICATION
// compile-time option.  See the user-auth.txt file in the same source
// directory as this file for additional information.

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1988, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)limits.h	8.3 (Berkeley) 1/4/94
// $FreeBSD$

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// Copyright (c) 2003 Peter Wemm.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.1 (Berkeley) 6/11/93
// $FreeBSD$

// Machine-dependent signal definitions

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1989, 1991, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)signal.h	8.4 (Berkeley) 5/4/95
// $FreeBSD$

type sig_atomic_t = int64 /* signal.h:101:14 */

// Information pushed on stack when a signal is delivered.
// This is used by the kernel to restore state following
// execution of the signal handler.  It is also made available
// to the handler to allow it to restore state properly if
// a non-standard exit is performed.
//
// The sequence of the fields/registers after sc_mask in struct
// sigcontext must match those in mcontext_t and struct trapframe.
type sigcontext = struct {
	Fsc_mask          struct{ F__bits [4]uint32 }
	Fsc_onstack       int64
	Fsc_rdi           int64
	Fsc_rsi           int64
	Fsc_rdx           int64
	Fsc_rcx           int64
	Fsc_r8            int64
	Fsc_r9            int64
	Fsc_rax           int64
	Fsc_rbx           int64
	Fsc_rbp           int64
	Fsc_r10           int64
	Fsc_r11           int64
	Fsc_r12           int64
	Fsc_r13           int64
	Fsc_r14           int64
	Fsc_r15           int64
	Fsc_trapno        int32
	Fsc_fs            int16
	Fsc_gs            int16
	Fsc_addr          int64
	Fsc_flags         int32
	Fsc_es            int16
	Fsc_ds            int16
	Fsc_err           int64
	Fsc_rip           int64
	Fsc_cs            int64
	Fsc_rflags        int64
	Fsc_rsp           int64
	Fsc_ss            int64
	Fsc_len           int64
	Fsc_fpformat      int64
	Fsc_ownedfp       int64
	Fsc_fpstate       [64]int64
	Fsc_fsbase        int64
	Fsc_gsbase        int64
	Fsc_xfpustate     int64
	Fsc_xfpustate_len int64
	Fsc_spare         [4]int64
} /* signal.h:114:1 */

type sigval = struct {
	F__ccgo_pad1 [0]uint64
	Fsival_int   int32
	F__ccgo_pad2 [4]byte
} /* signal.h:171:1 */

type __siginfo = struct {
	Fsi_signo  int32
	Fsi_errno  int32
	Fsi_code   int32
	Fsi_pid    int32
	Fsi_uid    uint32
	Fsi_status int32
	Fsi_addr   uintptr
	Fsi_value  struct {
		F__ccgo_pad1 [0]uint64
		Fsival_int   int32
		F__ccgo_pad2 [4]byte
	}
	F_reason struct {
		F__ccgo_pad1 [0]uint64
		F_fault      struct{ F_trapno int32 }
		F__ccgo_pad2 [36]byte
	}
} /* signal.h:229:9 */

type siginfo_t = __siginfo /* signal.h:263:3 */

// Signal vector "template" used in sigaction call.
type sigaction = struct {
	F__sigaction_u struct{ F__sa_handler uintptr }
	Fsa_flags      int32
	Fsa_mask       sigset_t
	F__ccgo_pad1   [4]byte
} /* signal.h:368:1 */

// If SA_SIGINFO is set, sa_sigaction must be used instead of sa_handler.

// a timer set by timer_settime().
// an asynchronous I/O request.
// message on an empty message queue.

type sig_t = uintptr /* signal.h:420:24 */

type sigaltstack = struct {
	Fss_sp       uintptr
	Fss_size     uint64
	Fss_flags    int32
	F__ccgo_pad1 [4]byte
} /* signal.h:428:9 */

type stack_t = sigaltstack /* signal.h:428:26 */

// 4.3 compatibility:
// Signal vector "template" used in sigvec call.
type sigvec = struct {
	Fsv_handler uintptr
	Fsv_mask    int32
	Fsv_flags   int32
} /* signal.h:452:1 */

// Keep this in one place only

// Structure used in sigstack call.
type sigstack = struct {
	Fss_sp       uintptr
	Fss_onstack  int32
	F__ccgo_pad1 [4]byte
} /* signal.h:479:1 */

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 2003 Peter Wemm
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// mc_flags bits. Shall be in sync with TF_XXX.

type __mcontext = struct {
	Fmc_onstack       int64
	Fmc_rdi           int64
	Fmc_rsi           int64
	Fmc_rdx           int64
	Fmc_rcx           int64
	Fmc_r8            int64
	Fmc_r9            int64
	Fmc_rax           int64
	Fmc_rbx           int64
	Fmc_rbp           int64
	Fmc_r10           int64
	Fmc_r11           int64
	Fmc_r12           int64
	Fmc_r13           int64
	Fmc_r14           int64
	Fmc_r15           int64
	Fmc_trapno        uint32
	Fmc_fs            uint16
	Fmc_gs            uint16
	Fmc_addr          int64
	Fmc_flags         uint32
	Fmc_es            uint16
	Fmc_ds            uint16
	Fmc_err           int64
	Fmc_rip           int64
	Fmc_cs            int64
	Fmc_rflags        int64
	Fmc_rsp           int64
	Fmc_ss            int64
	Fmc_len           int64
	Fmc_fpformat      int64
	Fmc_ownedfp       int64
	Fmc_fpstate       [64]int64
	Fmc_fsbase        int64
	Fmc_gsbase        int64
	Fmc_xfpustate     int64
	Fmc_xfpustate_len int64
	Fmc_spare         [4]int64
} /* ucontext.h:106:9 */

// -
// This file is in the public domain.
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 2003 Peter Wemm
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// mc_flags bits. Shall be in sync with TF_XXX.

type mcontext_t = __mcontext /* ucontext.h:164:3 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

type __ucontext = struct {
	Fuc_sigmask  struct{ F__bits [4]uint32 }
	Fuc_mcontext mcontext_t
	Fuc_link     uintptr
	Fuc_stack    struct {
		Fss_sp       uintptr
		Fss_size     uint64
		Fss_flags    int32
		F__ccgo_pad1 [4]byte
	}
	Fuc_flags    int32
	F__spare__   [4]int32
	F__ccgo_pad1 [4]byte
} /* _ucontext.h:36:9 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1999 Marcel Moolenaar
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer
//    in this position and unchanged.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

type ucontext_t = __ucontext /* _ucontext.h:52:3 */ // getopt(3) external variable

// Windows needs to know which symbols to export.  Unix does not.
// BUILD_sqlite should be undefined for Unix.

// Forward declaration
type SqliteDb = struct {
	Fdb             uintptr
	Finterp         uintptr
	FzBusy          uintptr
	FzCommit        uintptr
	FzTrace         uintptr
	FzTraceV2       uintptr
	FzProfile       uintptr
	FzProgress      uintptr
	FzBindFallback  uintptr
	FzAuth          uintptr
	FdisableAuth    int32
	F__ccgo_pad1    [4]byte
	FzNull          uintptr
	FpFunc          uintptr
	FpUpdateHook    uintptr
	FpPreUpdateHook uintptr
	FpRollbackHook  uintptr
	FpWalHook       uintptr
	FpUnlockNotify  uintptr
	FpCollate       uintptr
	Frc             int32
	F__ccgo_pad2    [4]byte
	FpCollateNeeded uintptr
	FstmtList       uintptr
	FstmtLast       uintptr
	FmaxStmt        int32
	FnStmt          int32
	FpIncrblob      uintptr
	FnStep          int32
	FnSort          int32
	FnIndex         int32
	FnVMStep        int32
	FnTransaction   int32
	FopenFlags      int32
	FnRef           int32
	FbLegacyPrepare int32
} /* tclsqlite.c:91:25 */

// New SQL functions can be created as TCL scripts.  Each such function
// is described by an instance of the following structure.
//
// Variable eType may be set to SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT,
// SQLITE_BLOB or SQLITE_NULL. If it is SQLITE_NULL, then the implementation
// attempts to determine the type of the result based on the Tcl object.
// If it is SQLITE_TEXT or SQLITE_BLOB, then a text (sqlite3_result_text())
// or blob (sqlite3_result_blob()) is returned. If it is SQLITE_INTEGER
// or SQLITE_FLOAT, then an attempt is made to return an integer or float
// value, falling back to float and then text if this is not possible.
type SqlFunc1 = struct {
	Finterp      uintptr
	FpScript     uintptr
	FpDb         uintptr
	FuseEvalObjv int32
	FeType       int32
	FzName       uintptr
	FpNext       uintptr
} /* tclsqlite.c:105:9 */

// New SQL functions can be created as TCL scripts.  Each such function
// is described by an instance of the following structure.
//
// Variable eType may be set to SQLITE_INTEGER, SQLITE_FLOAT, SQLITE_TEXT,
// SQLITE_BLOB or SQLITE_NULL. If it is SQLITE_NULL, then the implementation
// attempts to determine the type of the result based on the Tcl object.
// If it is SQLITE_TEXT or SQLITE_BLOB, then a text (sqlite3_result_text())
// or blob (sqlite3_result_blob()) is returned. If it is SQLITE_INTEGER
// or SQLITE_FLOAT, then an attempt is made to return an integer or float
// value, falling back to float and then text if this is not possible.
type SqlFunc = SqlFunc1 /* tclsqlite.c:105:24 */

// New collation sequences function can be created as TCL scripts.  Each such
// function is described by an instance of the following structure.
type SqlCollate1 = struct {
	Finterp  uintptr
	FzScript uintptr
	FpNext   uintptr
} /* tclsqlite.c:120:9 */

// New collation sequences function can be created as TCL scripts.  Each such
// function is described by an instance of the following structure.
type SqlCollate = SqlCollate1 /* tclsqlite.c:120:27 */

// Prepared statements are cached for faster execution.  Each prepared
// statement is described by an instance of the following structure.
type SqlPreparedStmt1 = struct {
	FpNext       uintptr
	FpPrev       uintptr
	FpStmt       uintptr
	FnSql        int32
	F__ccgo_pad1 [4]byte
	FzSql        uintptr
	FnParm       int32
	F__ccgo_pad2 [4]byte
	FapParm      uintptr
} /* tclsqlite.c:131:9 */

// Prepared statements are cached for faster execution.  Each prepared
// statement is described by an instance of the following structure.
type SqlPreparedStmt = SqlPreparedStmt1 /* tclsqlite.c:131:32 */

type IncrblobChannel1 = struct {
	FpBlob       uintptr
	FpDb         uintptr
	FiSeek       int32
	F__ccgo_pad1 [4]byte
	Fchannel     Tcl_Channel
	FpNext       uintptr
	FpPrev       uintptr
} /* tclsqlite.c:142:9 */

type IncrblobChannel = IncrblobChannel1 /* tclsqlite.c:142:32 */

// Compute a string length that is limited to what can be stored in
// lower 30 bits of a 32-bit signed integer.
func strlen30(tls *libc.TLS, z uintptr) int32 { /* tclsqlite.c:203:12: */
	var z2 uintptr = z
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return 0x3fffffff & int32((int64(z2)-int64(z))/1)
}

// Close all incrblob channels opened using database connection pDb.
// This is called when shutting down the database connection.
func closeIncrblobChannels(tls *libc.TLS, pDb uintptr) { /* tclsqlite.c:215:13: */
	var p uintptr
	var pNext uintptr

	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob; p != 0; p = pNext {
		pNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext

		// Note: Calling unregister here call Tcl_Close on the incrblob channel,
		// which deletes the IncrblobChannel structure at *p. So do not
		// call Tcl_Free() here.
		tcl.XTcl_UnregisterChannel(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)
	}
}

// Close an incremental blob channel.
func incrblobClose(tls *libc.TLS, instanceData ClientData, interp uintptr) int32 { /* tclsqlite.c:233:26: */
	var p uintptr = instanceData
	var rc int32 = sqlite3.Xsqlite3_blob_close(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	var db uintptr = (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).Fdb

	// Remove the channel from the SqliteDb.pIncrblob list.
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev
	}
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpPrev != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpPrev)).FpNext = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}
	if (*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob == p {
		(*SqliteDb)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpDb)).FpIncrblob = (*IncrblobChannel)(unsafe.Pointer(p)).FpNext
	}

	// Free the IncrblobChannel structure
	tcl.XTcl_Free(tls, p)

	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, db), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Read data from an incremental blob channel.
func incrblobInput(tls *libc.TLS, instanceData ClientData, buf uintptr, bufSize int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:265:26: */
	var p uintptr = instanceData
	var nRead int32 = bufSize // Number of bytes to read
	var nBlob int32           // Total size of the blob
	var rc int32              // sqlite error code

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek+nRead > nBlob {
		nRead = nBlob - (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek
	}
	if nRead <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_read(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nRead, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != SQLITE_OK {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = rc
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 16)) += nRead
	return nRead
}

// Write data to an incremental blob channel.
func incrblobOutput(tls *libc.TLS, instanceData ClientData, buf uintptr, toWrite int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:297:26: */
	var p uintptr = instanceData
	var nWrite int32 = toWrite // Number of bytes to write
	var nBlob int32            // Total size of the blob
	var rc int32               // sqlite error code

	nBlob = sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek+nWrite > nBlob {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = EINVAL
		return -1
	}
	if nWrite <= 0 {
		return 0
	}

	rc = sqlite3.Xsqlite3_blob_write(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob, buf, nWrite, (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek)
	if rc != SQLITE_OK {
		*(*int32)(unsafe.Pointer(errorCodePtr)) = EIO
		return -1
	}

	*(*int32)(unsafe.Pointer(p + 16)) += nWrite
	return nWrite
}

// Seek an incremental blob channel.
func incrblobSeek(tls *libc.TLS, instanceData ClientData, offset int64, seekMode int32, errorCodePtr uintptr) int32 { /* tclsqlite.c:330:26: */
	var p uintptr = instanceData

	switch seekMode {
	case SEEK_SET:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = int32(offset)
		break
	case SEEK_CUR:
		*(*int32)(unsafe.Pointer(p + 16)) += int32(offset)
		break
	case SEEK_END:
		(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = int32(int64(sqlite3.Xsqlite3_blob_bytes(tls, (*IncrblobChannel)(unsafe.Pointer(p)).FpBlob)) + offset)
		break

	default:
	}

	return (*IncrblobChannel)(unsafe.Pointer(p)).FiSeek
}

func incrblobWatch(tls *libc.TLS, instanceData ClientData, mode int32) { /* tclsqlite.c:356:27: */
	// NO-OP
}

func incrblobHandle(tls *libc.TLS, instanceData ClientData, dir int32, hPtr uintptr) int32 { /* tclsqlite.c:362:26: */
	return TCL_ERROR
}

var IncrblobChannelType = Tcl_ChannelType{
	FtypeName:      ts + 11702, /* "incrblob" */ // typeName
	Fversion:       uintptr(0x2),
	FcloseProc:     0, // closeProc
	FinputProc:     0, // inputProc
	FoutputProc:    0, // outputProc
	FseekProc:      0, // getOptionProc
	FwatchProc:     0, // watchProc (this is a no-op)
	FgetHandleProc: 0, // wideSeekProc
} /* tclsqlite.c:370:24 */

// Create a new incrblob channel.
func createIncrblobChannel(tls *libc.TLS, interp uintptr, pDb uintptr, zDb uintptr, zTable uintptr, zColumn uintptr, iRow sqlite_int64, isReadonly int32) int32 { /* tclsqlite.c:391:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var p uintptr
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb
	// var pBlob uintptr at bp+8, 8

	var rc int32
	var flags int32 = int32(1)<<1 | func() int32 {
		if isReadonly != 0 {
			return 0
		}
		return int32(1) << 2
	}()
	// var zChannel [64]int8 at bp+16, 64

	rc = sqlite3.Xsqlite3_blob_open(tls, db, zDb, zTable, zColumn, iRow, libc.BoolInt32(!(isReadonly != 0)), bp+8 /* &pBlob */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
		return TCL_ERROR
	}

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(IncrblobChannel{})))
	(*IncrblobChannel)(unsafe.Pointer(p)).FiSeek = 0
	(*IncrblobChannel)(unsafe.Pointer(p)).FpBlob = *(*uintptr)(unsafe.Pointer(bp + 8 /* pBlob */))

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zChannel[0] */, ts+11711 /* "incrblob_%d" */, libc.VaList(bp, libc.PreIncInt32(&count, 1)))
	(*IncrblobChannel)(unsafe.Pointer(p)).Fchannel = tcl.XTcl_CreateChannel(tls, uintptr(unsafe.Pointer(&IncrblobChannelType)), bp+16 /* &zChannel[0] */, p, flags)
	tcl.XTcl_RegisterChannel(tls, interp, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel)

	// Link the new channel into the SqliteDb.pIncrblob list.
	(*IncrblobChannel)(unsafe.Pointer(p)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob
	(*IncrblobChannel)(unsafe.Pointer(p)).FpPrev = uintptr(0)
	if (*IncrblobChannel)(unsafe.Pointer(p)).FpNext != 0 {
		(*IncrblobChannel)(unsafe.Pointer((*IncrblobChannel)(unsafe.Pointer(p)).FpNext)).FpPrev = p
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FpIncrblob = p
	(*IncrblobChannel)(unsafe.Pointer(p)).FpDb = pDb

	tcl.XTcl_SetResult(tls, interp, tcl.XTcl_GetChannelName(tls, (*IncrblobChannel)(unsafe.Pointer(p)).Fchannel), uintptr(1))
	return TCL_OK
}

var count int32 = 0 /* tclsqlite.c:407:14 */

// Look at the script prefix in pCmd.  We will be executing this script
// after first appending one or more arguments.  This routine analyzes
// the script to see if it is safe to use Tcl_EvalObjv() on the script
// rather than the more general Tcl_EvalEx().  Tcl_EvalObjv() is much
// faster.
//
// Scripts that are safe to use with Tcl_EvalObjv() consists of a
// command name followed by zero or more arguments with no [...] or $
// or {...} or ; to be seen anywhere.  Most callback scripts consist
// of just a single procedure name and they meet this requirement.
func safeToUseEvalObjv(tls *libc.TLS, interp uintptr, pCmd uintptr) int32 { /* tclsqlite.c:452:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// We could try to do something with Tcl_Parse().  But we will instead
	// just do a search for forbidden characters.  If any of the forbidden
	// characters appear in pCmd, we will report the string as unsafe.
	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pCmd, bp /* &n */)
	for libc.PostDecInt32(&*(*int32)(unsafe.Pointer(bp)), 1) > 0 {
		var c int32 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
		if c == '$' || c == '[' || c == ';' {
			return 0
		}
	}
	return 1
}

// Find an SqlFunc structure with the given name.  Or create a new
// one if an existing one cannot be found.  Return a pointer to the
// structure.
func findSqlFunc(tls *libc.TLS, pDb uintptr, zName uintptr) uintptr { /* tclsqlite.c:472:16: */
	var p uintptr
	var pNew uintptr
	var nName int32 = strlen30(tls, zName)
	pNew = tcl.XTcl_Alloc(tls, uint32(uint64(unsafe.Sizeof(SqlFunc{}))+uint64(nName)+uint64(1)))
	(*SqlFunc)(unsafe.Pointer(pNew)).FzName = pNew + 1*48
	libc.Xmemcpy(tls, (*SqlFunc)(unsafe.Pointer(pNew)).FzName, zName, uint64(nName+1))
	for p = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc; p != 0; p = (*SqlFunc)(unsafe.Pointer(p)).FpNext {
		if sqlite3.Xsqlite3_stricmp(tls, (*SqlFunc)(unsafe.Pointer(p)).FzName, (*SqlFunc)(unsafe.Pointer(pNew)).FzName) == 0 {
			tcl.XTcl_Free(tls, pNew)
			return p
		}
	}
	(*SqlFunc)(unsafe.Pointer(pNew)).Finterp = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp
	(*SqlFunc)(unsafe.Pointer(pNew)).FpDb = pDb
	(*SqlFunc)(unsafe.Pointer(pNew)).FpScript = uintptr(0)
	(*SqlFunc)(unsafe.Pointer(pNew)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
	(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = pNew
	return pNew
}

// Free a single SqlPreparedStmt object.
func dbFreeStmt(tls *libc.TLS, pStmt uintptr) { /* tclsqlite.c:495:13: */
	if sqlite3.Xsqlite3_sql(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt) == uintptr(0) {
		tcl.XTcl_Free(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FzSql)
	}
	sqlite3.Xsqlite3_finalize(tls, (*SqlPreparedStmt)(unsafe.Pointer(pStmt)).FpStmt)
	tcl.XTcl_Free(tls, pStmt)
}

// Finalize and free a list of prepared statements
func flushStmtCache(tls *libc.TLS, pDb uintptr) { /* tclsqlite.c:508:13: */
	var pPreStmt uintptr
	var pNext uintptr

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = pNext {
		pNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
		dbFreeStmt(tls, pPreStmt)
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt = 0
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = uintptr(0)
	(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = uintptr(0)
}

// Increment the reference counter on the SqliteDb object. The reference
// should be released by calling delDatabaseRef().
func addDatabaseRef(tls *libc.TLS, pDb uintptr) { /* tclsqlite.c:525:13: */
	(*SqliteDb)(unsafe.Pointer(pDb)).FnRef++
}

// Decrement the reference counter associated with the SqliteDb object.
// If it reaches zero, delete the object.
func delDatabaseRef(tls *libc.TLS, pDb uintptr) { /* tclsqlite.c:533:13: */

	(*SqliteDb)(unsafe.Pointer(pDb)).FnRef--
	if (*SqliteDb)(unsafe.Pointer(pDb)).FnRef == 0 {
		flushStmtCache(tls, pDb)
		closeIncrblobChannels(tls, pDb)
		sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
		for (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc != 0 {
			var pFunc uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpFunc
			(*SqliteDb)(unsafe.Pointer(pDb)).FpFunc = (*SqlFunc)(unsafe.Pointer(pFunc)).FpNext

			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_Free(tls, pFunc)
		}
		for (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate != 0 {
			var pCollate uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
			(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = (*SqlCollate)(unsafe.Pointer(pCollate)).FpNext
			tcl.XTcl_Free(tls, pCollate)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0 {
			tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook != 0 {
			for ok2 := true; ok2; ok2 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
			for ok3 := true; ok3; ok3 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
			for ok4 := true; ok4; ok4 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0 {
			for ok5 := true; ok5; ok5 = 0 != 0 {
				var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		tcl.XTcl_Free(tls, pDb)
	}
}

// TCL calls this procedure when an sqlite3 database command is
// deleted.
func DbDeleteCmd(tls *libc.TLS, db uintptr) { /* tclsqlite.c:596:27: */
	var pDb uintptr = db
	delDatabaseRef(tls, pDb)
}

// This routine is called when a database file is locked while trying
// to execute SQL.
func DbBusyHandler(tls *libc.TLS, cd uintptr, nTries int32) int32 { /* tclsqlite.c:605:12: */
	bp := tls.Alloc(70)
	defer tls.Free(70)

	var pDb uintptr = cd
	var rc int32
	// var zVal [30]int8 at bp+40, 30

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+40 /* &zVal[0] */, ts+1333 /* "%d" */, libc.VaList(bp, nTries))
	rc = tcl.XTcl_VarEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, libc.VaList(bp+8, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, ts+4894 /* " " */, bp+40 /* &zVal[0] */, uintptr(0)))
	if rc != TCL_OK || libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0 {
		return 0
	}
	return 1
}

// This routine is invoked as the 'progress callback' for the database.
func DbProgressHandler(tls *libc.TLS, cd uintptr) int32 { /* tclsqlite.c:622:12: */
	var pDb uintptr = cd
	var rc int32

	rc = tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress)
	if rc != TCL_OK || libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0 {
		return 1
	}
	return 0
}

// This routine is called by the SQLite trace handler whenever a new
// block of SQL is executed.  The TCL script in pDb->zTrace is executed.
func DbTraceHandler(tls *libc.TLS, cd uintptr, zSql uintptr) { /* tclsqlite.c:641:13: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var pDb uintptr = cd
	// var str Tcl_DString at bp, 216

	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppend(tls, bp /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, -1)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, zSql)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

// This routine is called by the SQLite trace_v2 handler whenever a new
// supported event is generated.  Unsupported event types are ignored.
// The TCL script in pDb->zTraceV2 is executed, with the arguments for
// the event appended to it (as list elements).
func DbTraceV2Handler(tls *libc.TLS, type1 uint32, cd uintptr, pd uintptr, xd uintptr) int32 { /* tclsqlite.c:661:12: */
	var pDb uintptr = cd
	var pCmd uintptr

	switch type1 {
	case uint32(SQLITE_TRACE_STMT):
		{
			var pStmt uintptr = pd
			var zSql uintptr = xd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewStringObj(tls, zSql, -1))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_PROFILE):
		{
			var pStmt uintptr = pd
			var ns sqlite3_int64 = *(*sqlite3_int64)(unsafe.Pointer(xd))

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, ns))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok1 := true; ok1; ok1 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_ROW):
		{
			var pStmt uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(pStmt)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok2 := true; ok2; ok2 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	case uint32(SQLITE_TRACE_CLOSE):
		{
			var db uintptr = pd

			pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, -1)
			(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd,
				tcl.XTcl_NewWideIntObj(tls, int64(db)))
			tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
			for ok3 := true; ok3; ok3 = 0 != 0 {
				var _objPtr uintptr = pCmd
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			break

		}
	}
	return SQLITE_OK
}

// This routine is called by the SQLite profile handler after a statement
// SQL has executed.  The TCL script in pDb->zProfile is evaluated.
func DbProfileHandler(tls *libc.TLS, cd uintptr, zSql uintptr, tm1 sqlite_uint64) { /* tclsqlite.c:736:13: */
	bp := tls.Alloc(328)
	defer tls.Free(328)

	var pDb uintptr = cd
	// var str Tcl_DString at bp+112, 216

	// var zTm [100]int8 at bp+8, 100

	sqlite3.Xsqlite3_snprintf(tls, int32(uint64(unsafe.Sizeof([100]int8{}))-uint64(1)), bp+8 /* &zTm[0] */, ts+11723 /* "%lld" */, libc.VaList(bp, tm1))
	tcl.XTcl_DStringInit(tls, bp+112 /* &str */)
	tcl.XTcl_DStringAppend(tls, bp+112 /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, -1)
	tcl.XTcl_DStringAppendElement(tls, bp+112 /* &str */, zSql)
	tcl.XTcl_DStringAppendElement(tls, bp+112 /* &str */, bp+8 /* &zTm[0] */)
	tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp+112)).Fstring)
	tcl.XTcl_DStringFree(tls, bp+112 /* &str */)
	tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
}

// This routine is called when a transaction is committed.  The
// TCL script in pDb->zCommit is executed.  If it returns non-zero or
// if it throws an exception, the transaction is rolled back instead
// of being committed.
func DbCommitHandler(tls *libc.TLS, cd uintptr) int32 { /* tclsqlite.c:758:12: */
	var pDb uintptr = cd
	var rc int32

	rc = tcl.XTcl_Eval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
	if rc != TCL_OK || libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)) != 0 {
		return 1
	}
	return 0
}

func DbRollbackHandler(tls *libc.TLS, clientData uintptr) { /* tclsqlite.c:769:13: */
	var pDb uintptr = clientData

	if TCL_OK != tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook, 0) {
		tcl.XTcl_BackgroundError(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}
}

// This procedure handles wal_hook callbacks.
func DbWalHandler(tls *libc.TLS, clientData uintptr, db uintptr, zDb uintptr, nEntry int32) int32 { /* tclsqlite.c:780:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* ret */)) = SQLITE_OK
	var p uintptr
	var pDb uintptr = clientData
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp

	p = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook)
	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, p, tcl.XTcl_NewIntObj(tls, nEntry))
	if TCL_OK != tcl.XTcl_EvalObjEx(tls, interp, p, 0) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, tcl.XTcl_GetObjResult(tls, interp), bp) {
		tcl.XTcl_BackgroundError(tls, interp)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = p
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* ret */))
}

func setTestUnlockNotifyVars(tls *libc.TLS, interp uintptr, iArg int32, nArg int32) { /* tclsqlite.c:808:13: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var zBuf [64]int8 at bp+16, 64

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp, iArg))
	tcl.XTcl_SetVar2(tls, interp, ts+11728 /* "sqlite_unlock_no..." */, uintptr(0), bp+16 /* &zBuf[0] */, TCL_GLOBAL_ONLY)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([64]int8{})), bp+16 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+8, nArg))
	tcl.XTcl_SetVar2(tls, interp, ts+11753 /* "sqlite_unlock_no..." */, uintptr(0), bp+16 /* &zBuf[0] */, TCL_GLOBAL_ONLY)
}

func DbUnlockNotify(tls *libc.TLS, apArg uintptr, nArg int32) { /* tclsqlite.c:820:13: */
	var i int32
	for i = 0; i < nArg; i++ {
		var flags int32 = TCL_EVAL_GLOBAL | TCL_EVAL_DIRECT
		var pDb uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))
		setTestUnlockNotifyVars(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, i, nArg)

		tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify, flags)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
	}
}

// Pre-update hook callback.
func DbPreUpdateHandler(tls *libc.TLS, p uintptr, db uintptr, op int32, zDb uintptr, zTbl uintptr, iKey1 sqlite_int64, iKey2 sqlite_int64) { /* tclsqlite.c:838:13: */
	var pDb uintptr = p
	var pCmd uintptr

	pCmd = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, azStr[(op-1)/9], -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, iKey1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, iKey2))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

var azStr = [3]uintptr{ts + 11155 /* "DELETE" */, ts + 11141 /* "INSERT" */, ts + 11148 /* "UPDATE" */} /* tclsqlite.c:849:21 */

func DbUpdateHandler(tls *libc.TLS, p uintptr, op int32, zDb uintptr, zTbl uintptr, rowid sqlite_int64) { /* tclsqlite.c:870:13: */
	var pDb uintptr = p
	var pCmd uintptr

	pCmd = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, azStr1[(op-1)/9], -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zDb, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewStringObj(tls, zTbl, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pCmd, tcl.XTcl_NewWideIntObj(tls, rowid))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

var azStr1 = [3]uintptr{ts + 11155 /* "DELETE" */, ts + 11141 /* "INSERT" */, ts + 11148 /* "UPDATE" */} /* tclsqlite.c:879:21 */

func tclCollateNeeded(tls *libc.TLS, pCtx uintptr, db uintptr, enc int32, zName uintptr) { /* tclsqlite.c:898:13: */
	var pDb uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zName, -1))
	tcl.XTcl_EvalObjEx(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, pScript, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

// This routine is called to evaluate an SQL collation function implemented
// using TCL script.
func tclSqlCollate(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 { /* tclsqlite.c:916:12: */
	var p uintptr = pCtx
	var pCmd uintptr

	pCmd = tcl.XTcl_NewStringObj(tls, (*SqlCollate)(unsafe.Pointer(p)).FzScript, -1)
	(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zA, nA))
	tcl.XTcl_ListObjAppendElement(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, tcl.XTcl_NewStringObj(tls, zB, nB))
	tcl.XTcl_EvalObjEx(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp, pCmd, TCL_EVAL_DIRECT)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, (*SqlCollate)(unsafe.Pointer(p)).Finterp))
}

// This routine is called to evaluate an SQL function implemented
// using TCL script.
func tclSqlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* tclsqlite.c:939:13: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var p uintptr = sqlite3.Xsqlite3_user_data(tls, context)
	var pCmd uintptr
	var i int32
	var rc int32

	if argc == 0 {
		// If there are no arguments to the function, call Tcl_EvalObjEx on the
		// script object directly.  This allows the TCL compiler to generate
		// bytecode for the command on the first invocation and thus make
		// subsequent invocations much faster.
		pCmd = (*SqlFunc)(unsafe.Pointer(p)).FpScript
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, 0)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pCmd
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	} else {
		// If there are arguments to the function, make a shallow copy of the
		// script object, lappend the arguments, then evaluate the copy.
		//
		// By "shallow" copy, we mean only the outer list Tcl_Obj is duplicated.
		// The new Tcl_Obj contains pointers to the original list elements.
		// That way, when Tcl_EvalObjv() is run and shimmers the first element
		// of the list to tclCmdNameType, that alternate representation will
		// be preserved and reused on the next invocation.
		// var aArg uintptr at bp+8, 8

		// var nArg int32 at bp, 4

		if tcl.XTcl_ListObjGetElements(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, (*SqlFunc)(unsafe.Pointer(p)).FpScript, bp, bp+8) != 0 {
			sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
			return
		}
		pCmd = tcl.XTcl_NewListObj(tls, *(*int32)(unsafe.Pointer(bp /* nArg */)), *(*uintptr)(unsafe.Pointer(bp + 8 /* aArg */)))
		(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
		for i = 0; i < argc; i++ {
			var pIn uintptr = *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
			var pVal uintptr

			// Set pVal to contain the i'th column of this row.
			switch sqlite3.Xsqlite3_value_type(tls, pIn) {
			case SQLITE_BLOB:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewByteArrayObj(tls, sqlite3.Xsqlite3_value_blob(tls, pIn), bytes)
					break

				}
				fallthrough
			case SQLITE_INTEGER:
				{
					var v sqlite_int64 = sqlite3.Xsqlite3_value_int64(tls, pIn)
					if v >= int64(-2147483647) && v <= int64(2147483647) {
						pVal = tcl.XTcl_NewIntObj(tls, int32(v))
					} else {
						pVal = tcl.XTcl_NewWideIntObj(tls, v)
					}
					break

				}
				fallthrough
			case SQLITE_FLOAT:
				{
					var r float64 = sqlite3.Xsqlite3_value_double(tls, pIn)
					pVal = tcl.XTcl_NewDoubleObj(tls, r)
					break

				}
				fallthrough
			case SQLITE_NULL:
				{
					pVal = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*SqlFunc)(unsafe.Pointer(p)).FpDb)).FzNull, -1)
					break

				}
				fallthrough
			default:
				{
					var bytes int32 = sqlite3.Xsqlite3_value_bytes(tls, pIn)
					pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pIn), bytes)
					break

				}
			}
			rc = tcl.XTcl_ListObjAppendElement(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, pVal)
			if rc != 0 {
				for ok1 := true; ok1; ok1 = 0 != 0 {
					var _objPtr uintptr = pCmd
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
				return
			}
		}
		if !((*SqlFunc)(unsafe.Pointer(p)).FuseEvalObjv != 0) {
			// Tcl_EvalObjEx() will automatically call Tcl_EvalObjv() if pCmd
			// is a list without a string representation.  To prevent this from
			// happening, make sure pCmd has a valid string representation
			tcl.XTcl_GetString(tls, pCmd)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp, pCmd, TCL_EVAL_DIRECT)
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = pCmd
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if rc != 0 && rc != TCL_RETURN {
		sqlite3.Xsqlite3_result_error(tls, context, tcl.XTcl_GetStringResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp), -1)
	} else {
		var pVar uintptr = tcl.XTcl_GetObjResult(tls, (*SqlFunc)(unsafe.Pointer(p)).Finterp)
		// var n int32 at bp+16, 4

		var data uintptr
		var zType uintptr = func() uintptr {
			if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
				return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
			}
			return ts + 584
		}()
		var c int8 = *(*int8)(unsafe.Pointer(zType))
		var eType int32 = (*SqlFunc)(unsafe.Pointer(p)).FeType

		if eType == SQLITE_NULL {
			if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2544) == 0 && (*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0) {
				// Only return a BLOB type if the Tcl variable is a bytearray and
				// has no string representation.
				eType = SQLITE_BLOB
			} else if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2554) == 0 ||
				int32(c) == 'w' && libc.Xstrcmp(tls, zType, ts+2569) == 0 ||
				int32(c) == 'i' && libc.Xstrcmp(tls, zType, ts+2577) == 0 {
				eType = SQLITE_INTEGER
			} else if int32(c) == 'd' && libc.Xstrcmp(tls, zType, ts+2562) == 0 {
				eType = SQLITE_FLOAT
			} else {
				eType = SQLITE_TEXT
			}
		}

		switch eType {
		case SQLITE_BLOB:
			{
				data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+16 /* &n */)
				sqlite3.Xsqlite3_result_blob(tls, context, data, *(*int32)(unsafe.Pointer(bp + 16 /* n */)), libc.UintptrFromInt32(-1))
				break

			}
			fallthrough
		case SQLITE_INTEGER:
			{
				// var v Tcl_WideInt at bp+24, 8

				if TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), pVar, bp+24) {
					sqlite3.Xsqlite3_result_int64(tls, context, *(*Tcl_WideInt)(unsafe.Pointer(bp + 24 /* v */)))
					break
				}
				// fall-through

			}
			fallthrough
		case SQLITE_FLOAT:
			{
				// var r float64 at bp+32, 8

				if TCL_OK == tcl.XTcl_GetDoubleFromObj(tls, uintptr(0), pVar, bp+32) {
					sqlite3.Xsqlite3_result_double(tls, context, *(*float64)(unsafe.Pointer(bp + 32 /* r */)))
					break
				}
				// fall-through

			}
			fallthrough
		default:
			{
				data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+16 /* &n */)
				sqlite3.Xsqlite3_result_text(tls, context, data, *(*int32)(unsafe.Pointer(bp + 16 /* n */)), libc.UintptrFromInt32(-1))
				break

			}
		}

	}
}

// This is the authentication function.  It appends the authentication
// type code and the two arguments to zCmd[] then invokes the result
// on the interpreter.  The reply is examined to determine if the
// authentication fails or succeeds.
func auth_callback(tls *libc.TLS, pArg uintptr, code int32, zArg1 uintptr, zArg2 uintptr, zArg3 uintptr, zArg4 uintptr) int32 { /* tclsqlite.c:1090:12: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var zCode uintptr
	// var str Tcl_DString at bp, 216

	var rc int32
	var zReply uintptr
	// EVIDENCE-OF: R-38590-62769 The first parameter to the authorizer
	// callback is a copy of the third parameter to the
	// sqlite3_set_authorizer() interface.
	var pDb uintptr = pArg
	if (*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth != 0 {
		return SQLITE_OK
	}

	// EVIDENCE-OF: R-56518-44310 The second parameter to the callback is an
	// integer action code that specifies the particular action to be
	// authorized.
	switch code {
	case SQLITE_COPY:
		zCode = ts + 11783 /* "SQLITE_COPY" */
		break
	case SQLITE_CREATE_INDEX:
		zCode = ts + 11795 /* "SQLITE_CREATE_IN..." */
		break
	case SQLITE_CREATE_TABLE:
		zCode = ts + 11815 /* "SQLITE_CREATE_TA..." */
		break
	case SQLITE_CREATE_TEMP_INDEX:
		zCode = ts + 11835 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TEMP_TABLE:
		zCode = ts + 11860 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TEMP_TRIGGER:
		zCode = ts + 11885 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TEMP_VIEW:
		zCode = ts + 11912 /* "SQLITE_CREATE_TE..." */
		break
	case SQLITE_CREATE_TRIGGER:
		zCode = ts + 11936 /* "SQLITE_CREATE_TR..." */
		break
	case SQLITE_CREATE_VIEW:
		zCode = ts + 11958 /* "SQLITE_CREATE_VI..." */
		break
	case SQLITE_DELETE:
		zCode = ts + 11977 /* "SQLITE_DELETE" */
		break
	case SQLITE_DROP_INDEX:
		zCode = ts + 11991 /* "SQLITE_DROP_INDE..." */
		break
	case SQLITE_DROP_TABLE:
		zCode = ts + 12009 /* "SQLITE_DROP_TABL..." */
		break
	case SQLITE_DROP_TEMP_INDEX:
		zCode = ts + 12027 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TEMP_TABLE:
		zCode = ts + 12050 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TEMP_TRIGGER:
		zCode = ts + 12073 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TEMP_VIEW:
		zCode = ts + 12098 /* "SQLITE_DROP_TEMP..." */
		break
	case SQLITE_DROP_TRIGGER:
		zCode = ts + 12120 /* "SQLITE_DROP_TRIG..." */
		break
	case SQLITE_DROP_VIEW:
		zCode = ts + 12140 /* "SQLITE_DROP_VIEW" */
		break
	case SQLITE_INSERT:
		zCode = ts + 12157 /* "SQLITE_INSERT" */
		break
	case SQLITE_PRAGMA:
		zCode = ts + 12171 /* "SQLITE_PRAGMA" */
		break
	case SQLITE_READ:
		zCode = ts + 12185 /* "SQLITE_READ" */
		break
	case SQLITE_SELECT:
		zCode = ts + 12197 /* "SQLITE_SELECT" */
		break
	case SQLITE_TRANSACTION:
		zCode = ts + 12211 /* "SQLITE_TRANSACTI..." */
		break
	case SQLITE_UPDATE:
		zCode = ts + 12230 /* "SQLITE_UPDATE" */
		break
	case SQLITE_ATTACH:
		zCode = ts + 12244 /* "SQLITE_ATTACH" */
		break
	case SQLITE_DETACH:
		zCode = ts + 12258 /* "SQLITE_DETACH" */
		break
	case SQLITE_ALTER_TABLE:
		zCode = ts + 12272 /* "SQLITE_ALTER_TAB..." */
		break
	case SQLITE_REINDEX:
		zCode = ts + 12291 /* "SQLITE_REINDEX" */
		break
	case SQLITE_ANALYZE:
		zCode = ts + 12306 /* "SQLITE_ANALYZE" */
		break
	case SQLITE_CREATE_VTABLE:
		zCode = ts + 12321 /* "SQLITE_CREATE_VT..." */
		break
	case SQLITE_DROP_VTABLE:
		zCode = ts + 12342 /* "SQLITE_DROP_VTAB..." */
		break
	case SQLITE_FUNCTION:
		zCode = ts + 12361 /* "SQLITE_FUNCTION" */
		break
	case SQLITE_SAVEPOINT:
		zCode = ts + 12377 /* "SQLITE_SAVEPOINT" */
		break
	case SQLITE_RECURSIVE:
		zCode = ts + 12394 /* "SQLITE_RECURSIVE" */
		break
	default:
		zCode = ts + 12411 /* "????" */
		break
	}
	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppend(tls, bp /* &str */, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, -1)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, zCode)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg1 != 0 {
			return zArg1
		}
		return ts + 584 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg2 != 0 {
			return zArg2
		}
		return ts + 584 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg3 != 0 {
			return zArg3
		}
		return ts + 584 /* "" */
	}())
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, func() uintptr {
		if zArg4 != 0 {
			return zArg4
		}
		return ts + 584 /* "" */
	}())
	rc = tcl.XTcl_GlobalEval(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	if rc == TCL_OK {
		zReply = tcl.XTcl_GetStringResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	} else {
		zReply = ts + 12416 /* "SQLITE_DENY" */
	}
	if libc.Xstrcmp(tls, zReply, ts+2127) == 0 {
		rc = SQLITE_OK
	} else if libc.Xstrcmp(tls, zReply, ts+12416) == 0 {
		rc = SQLITE_DENY
	} else if libc.Xstrcmp(tls, zReply, ts+12428) == 0 {
		rc = SQLITE_IGNORE
	} else {
		rc = 999
	}
	return rc
}

// This routine reads a line of text from FILE in, stores
// the text in memory obtained from malloc() and returns a pointer
// to the text.  NULL is returned at end of file, or if malloc()
// fails.
//
// The interface is like "readline" but no command-line editing
// is done.
//
// copied from shell.c from '.import' command
func local_getline(tls *libc.TLS, zPrompt uintptr, in uintptr) uintptr { /* tclsqlite.c:1189:13: */
	var zLine uintptr
	var nLine int32
	var n int32

	nLine = 100
	zLine = libc.Xmalloc(tls, uint64(nLine))
	if zLine == uintptr(0) {
		return uintptr(0)
	}
	n = 0
	for 1 != 0 {
		if n+100 > nLine {
			nLine = nLine*2 + 100
			zLine = libc.Xrealloc(tls, zLine, uint64(nLine))
			if zLine == uintptr(0) {
				return uintptr(0)
			}
		}
		if libc.Xfgets(tls, zLine+uintptr(n), nLine-n, in) == uintptr(0) {
			if n == 0 {
				libc.Xfree(tls, zLine)
				return uintptr(0)
			}
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
		for *(*int8)(unsafe.Pointer(zLine + uintptr(n))) != 0 {
			n++
		}
		if n > 0 && int32(*(*int8)(unsafe.Pointer(zLine + uintptr(n-1)))) == '\n' {
			n--
			*(*int8)(unsafe.Pointer(zLine + uintptr(n))) = int8(0)
			break
		}
	}
	zLine = libc.Xrealloc(tls, zLine, uint64(n+1))
	return zLine
}

// This function is part of the implementation of the command:
//
//   $db transaction [-deferred|-immediate|-exclusive] SCRIPT
//
// It is invoked after evaluating the script SCRIPT to commit or rollback
// the transaction or savepoint opened by the [transaction] command.
func DbTransPostCmd(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclsqlite.c:1232:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var pDb uintptr = *(*ClientData)(unsafe.Pointer(data))
	var rc int32 = result
	var zEnd uintptr

	(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction--
	zEnd = azEnd[libc.Bool32(rc == TCL_ERROR)*2+libc.Bool32((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0)]

	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
	if sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zEnd, uintptr(0), uintptr(0), uintptr(0)) != 0 {
		// This is a tricky scenario to handle. The most likely cause of an
		// error is that the exec() above was an attempt to commit the
		// top-level transaction that returned SQLITE_BUSY. Or, less likely,
		// that an IO-error has occurred. In either case, throw a Tcl exception
		// and try to rollback the transaction.
		//
		// But it could also be that the user executed one or more BEGIN,
		// COMMIT, SAVEPOINT, RELEASE or ROLLBACK commands that are confusing
		// this method's logic. Not clear how this would be best handled.
		if rc != TCL_ERROR {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
			rc = TCL_ERROR
		}
		sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+7467 /* "ROLLBACK" */, uintptr(0), uintptr(0), uintptr(0))
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--

	delDatabaseRef(tls, pDb)
	return rc
}

var azEnd = [4]uintptr{
	ts + 12442, /* "RELEASE _tcl_tra..." */ // rc==TCL_ERROR, nTransaction!=0
	ts + 12467, /* "COMMIT" */              // rc!=TCL_ERROR, nTransaction==0
	ts + 12474, /* "ROLLBACK TO _tcl..." */
	ts + 7467,  /* "ROLLBACK" */ // rc==TCL_ERROR, nTransaction==0
} /* tclsqlite.c:1237:21 */

// Unless SQLITE_TEST is defined, this function is a simple wrapper around
// sqlite3_prepare_v2(). If SQLITE_TEST is defined, then it uses either
// sqlite3_prepare_v2() or legacy interface sqlite3_prepare(), depending
// on whether or not the [db_use_legacy_prepare] command has been used to
// configure the connection.
func dbPrepare(tls *libc.TLS, pDb uintptr, zSql uintptr, ppStmt uintptr, pzOut uintptr) int32 { /* tclsqlite.c:1281:12: */
	var prepFlags uint32 = uint32(0)
	if (*SqliteDb)(unsafe.Pointer(pDb)).FbLegacyPrepare != 0 {
		return sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, ppStmt, pzOut)
	}
	// If the statement cache is large, use the SQLITE_PREPARE_PERSISTENT
	// flags, which uses less lookaside memory.  But if the cache is small,
	// omit that flag to make full use of lookaside
	if (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt > 5 {
		prepFlags = uint32(SQLITE_PREPARE_PERSISTENT)
	}

	return sqlite3.Xsqlite3_prepare_v3(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, prepFlags, ppStmt, pzOut)
}

// Search the cache for a prepared-statement object that implements the
// first SQL statement in the buffer pointed to by parameter zIn. If
// no such prepared-statement can be found, allocate and prepare a new
// one. In either case, bind the current values of the relevant Tcl
// variables to any $var, :var or @var variables in the statement. Before
// returning, set *ppPreStmt to point to the prepared-statement object.
//
// Output parameter *pzOut is set to point to the next SQL statement in
// buffer zIn, or to the '\0' byte at the end of zIn if there is no
// next statement.
//
// If successful, TCL_OK is returned. Otherwise, TCL_ERROR is returned
// and an error message loaded into interpreter pDb->interp.
func dbPrepareAndBind(tls *libc.TLS, pDb uintptr, zIn uintptr, pzOut uintptr, ppPreStmt uintptr) int32 { /* tclsqlite.c:1316:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zSql uintptr = zIn                                   // Pointer to first SQL statement in zIn
	*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0) // Prepared statement object
	var pPreStmt uintptr                                     // Pointer to cached statement
	var nSql int32                                           // Length of zSql in bytes
	var nVar int32 = 0                                       // Number of variables in statement
	var iParm int32 = 0                                      // Next free entry in apParm
	var c int8
	var i int32
	var needResultReset int32 = 0 // Need to invoke Tcl_ResetResult()
	var rc int32 = SQLITE_OK      // Value to return
	var interp uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Finterp

	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = uintptr(0)

	// Trim spaces from the start of zSql and calculate the remaining length.
	for int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer(zSql)))) == ' ' || int32(c) == '\t' || int32(c) == '\r' || int32(c) == '\n' {
		zSql++
	}
	nSql = strlen30(tls, zSql)

	for pPreStmt = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList; pPreStmt != 0; pPreStmt = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext {
		var n int32 = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql
		if nSql >= n &&
			libc.Xmemcmp(tls, (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql, zSql, uint64(n)) == 0 &&
			(int32(*(*int8)(unsafe.Pointer(zSql + uintptr(n)))) == 0 || int32(*(*int8)(unsafe.Pointer(zSql + uintptr(n-1)))) == ';') {
			*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt
			*(*uintptr)(unsafe.Pointer(pzOut)) = zSql + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql)

			// When a prepared statement is found, unlink it from the
			// cache list.  It will later be added back to the beginning
			// of the cache list in order to implement LRU replacement.
			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev)).FpNext = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext
			}
			if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext != 0 {
				(*SqlPreparedStmt)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext)).FpPrev = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			} else {
				(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev
			}
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
			break
		}
	}

	// If no prepared statement was found. Compile the SQL text. Also allocate
	// a new SqlPreparedStmt structure.
	if pPreStmt == uintptr(0) {
		var nByte int32

		if SQLITE_OK != dbPrepare(tls, pDb, zSql, bp, pzOut) {
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
			return TCL_ERROR
		}
		if *(*uintptr)(unsafe.Pointer(bp)) == uintptr(0) {
			if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb) {
				// A compile-time error in the statement.
				tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return TCL_ERROR
			} else {
				// The statement was a no-op.  Continue to the next statement
				// in the SQL string.
				return TCL_OK
			}
		}

		nVar = sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		nByte = int32(uint64(unsafe.Sizeof(SqlPreparedStmt{})) + uint64(nVar)*uint64(unsafe.Sizeof(uintptr(0))))
		pPreStmt = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemset(tls, pPreStmt, 0, uint64(nByte))

		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt = *(*uintptr)(unsafe.Pointer(bp /* pStmt */))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql = int32((int64(*(*uintptr)(unsafe.Pointer(pzOut))) - int64(zSql)) / 1)
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm = pPreStmt + 1*56
		if (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql == uintptr(0) {
			var zCopy uintptr = tcl.XTcl_Alloc(tls, uint32((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql+1))
			libc.Xmemcpy(tls, zCopy, zSql, uint64((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))
			*(*int8)(unsafe.Pointer(zCopy + uintptr((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnSql))) = int8(0)
			(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FzSql = zCopy
		}
	}

	// Bind values to parameters that begin with $ or :
	for i = 1; i <= nVar; i++ {
		var zVar uintptr = sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i)
		if zVar != uintptr(0) && (int32(*(*int8)(unsafe.Pointer(zVar))) == '$' || int32(*(*int8)(unsafe.Pointer(zVar))) == ':' || int32(*(*int8)(unsafe.Pointer(zVar))) == '@') {
			var pVar uintptr = tcl.XTcl_GetVar2Ex(tls, interp, zVar+1, uintptr(0), 0)
			if pVar == uintptr(0) && (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != uintptr(0) {
				var pCmd uintptr
				var rx int32
				pCmd = tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, -1)
				(*Tcl_Obj)(unsafe.Pointer(pCmd)).FrefCount++
				tcl.XTcl_ListObjAppendElement(tls, interp, pCmd, tcl.XTcl_NewStringObj(tls, zVar, -1))
				if needResultReset != 0 {
					tcl.XTcl_ResetResult(tls, interp)
				}
				needResultReset = 1
				rx = tcl.XTcl_EvalObjEx(tls, interp, pCmd, TCL_EVAL_DIRECT)
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = pCmd
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rx == TCL_OK {
					pVar = tcl.XTcl_GetObjResult(tls, interp)
				} else if rx == TCL_ERROR {
					rc = TCL_ERROR
					break
				} else {
					pVar = uintptr(0)
				}
			}
			if pVar != 0 {
				// var n int32 at bp+8, 4

				var data uintptr
				var zType uintptr = func() uintptr {
					if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
						return (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname
					}
					return ts + 584
				}()
				c = *(*int8)(unsafe.Pointer(zType))
				if int32(*(*int8)(unsafe.Pointer(zVar))) == '@' || int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2544) == 0 && (*Tcl_Obj)(unsafe.Pointer(pVar)).Fbytes == uintptr(0) {
					// Load a BLOB type if the Tcl variable is a bytearray and
					// it has no string representation or the host
					// parameter name begins with "@".
					data = tcl.XTcl_GetByteArrayFromObj(tls, pVar, bp+8 /* &n */)
					sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, data, *(*int32)(unsafe.Pointer(bp + 8 /* n */)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(libc.PostIncInt32(&iParm, 1))*8)) = pVar
				} else if int32(c) == 'b' && libc.Xstrcmp(tls, zType, ts+2554) == 0 {
					tcl.XTcl_GetIntFromObj(tls, interp, pVar, bp+8 /* &n */)
					sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*int32)(unsafe.Pointer(bp + 8 /* n */)))
				} else if int32(c) == 'd' && libc.Xstrcmp(tls, zType, ts+2562) == 0 {
					// var r float64 at bp+16, 8

					tcl.XTcl_GetDoubleFromObj(tls, interp, pVar, bp+16 /* &r */)
					sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*float64)(unsafe.Pointer(bp + 16 /* r */)))
				} else if int32(c) == 'w' && libc.Xstrcmp(tls, zType, ts+2569) == 0 || int32(c) == 'i' && libc.Xstrcmp(tls, zType, ts+2577) == 0 {
					// var v Tcl_WideInt at bp+24, 8

					tcl.XTcl_GetWideIntFromObj(tls, interp, pVar, bp+24 /* &v */)
					sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, *(*Tcl_WideInt)(unsafe.Pointer(bp + 24 /* v */)))
				} else {
					data = tcl.XTcl_GetStringFromObj(tls, pVar, bp+8 /* &n */)
					sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i, data, *(*int32)(unsafe.Pointer(bp + 8 /* n */)), uintptr(0))
					(*Tcl_Obj)(unsafe.Pointer(pVar)).FrefCount++
					*(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(libc.PostIncInt32(&iParm, 1))*8)) = pVar
				}
			} else {
				sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), i)
			}
			if needResultReset != 0 {
				tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = iParm
	*(*uintptr)(unsafe.Pointer(ppPreStmt)) = pPreStmt
	if needResultReset != 0 && rc == TCL_OK {
		tcl.XTcl_ResetResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp)
	}

	return rc
}

// Release a statement reference obtained by calling dbPrepareAndBind().
// There should be exactly one call to this function for each call to
// dbPrepareAndBind().
//
// If the discard parameter is non-zero, then the statement is deleted
// immediately. Otherwise it is added to the LRU list and may be returned
// by a subsequent call to dbPrepareAndBind().
func dbReleaseStmt(tls *libc.TLS, pDb uintptr, pPreStmt uintptr, discard int32) { /* tclsqlite.c:1492:13: */
	var i int32

	// Free the bound string and blob parameters
	for i = 0; i < (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm; i++ {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FapParm + uintptr(i)*8))
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FnParm = 0

	if (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt <= 0 || discard != 0 {
		// If the cache is turned off, deallocated the statement
		dbFreeStmt(tls, pPreStmt)
	} else {
		// Add the prepared statement to the beginning of the cache list.
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList
		(*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpPrev = uintptr(0)
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpPrev = pPreStmt
		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FstmtList = pPreStmt
		if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast == uintptr(0) {

			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = pPreStmt
		} else {

		}
		(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt++

		// If we have too many statement in cache, remove the surplus from
		// the end of the cache list.
		for (*SqliteDb)(unsafe.Pointer(pDb)).FnStmt > (*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt {
			var pLast uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast
			(*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast = (*SqlPreparedStmt)(unsafe.Pointer(pLast)).FpPrev
			(*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtLast)).FpNext = uintptr(0)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnStmt--
			dbFreeStmt(tls, pLast)
		}
	}
}

// Structure used with dbEvalXXX() functions:
//
//   dbEvalInit()
//   dbEvalStep()
//   dbEvalFinalize()
//   dbEvalRowInfo()
//   dbEvalColumnValue()
type DbEvalContext1 = struct {
	FpDb       uintptr
	FpSql      uintptr
	FzSql      uintptr
	FpPreStmt  uintptr
	FnCol      int32
	FevalFlags int32
	FpArray    uintptr
	FapColName uintptr
} /* tclsqlite.c:1545:9 */

// Structure used with dbEvalXXX() functions:
//
//   dbEvalInit()
//   dbEvalStep()
//   dbEvalFinalize()
//   dbEvalRowInfo()
//   dbEvalColumnValue()
type DbEvalContext = DbEvalContext1 /* tclsqlite.c:1545:30 */

// Release any cache of column names currently held as part of
// the DbEvalContext structure passed as the first argument.
func dbReleaseColumnNames(tls *libc.TLS, p uintptr) { /* tclsqlite.c:1563:13: */
	if (*DbEvalContext)(unsafe.Pointer(p)).FapColName != 0 {
		var i int32
		for i = 0; i < (*DbEvalContext)(unsafe.Pointer(p)).FnCol; i++ {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FapColName + uintptr(i)*8))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
		tcl.XTcl_Free(tls, (*DbEvalContext)(unsafe.Pointer(p)).FapColName)
		(*DbEvalContext)(unsafe.Pointer(p)).FapColName = uintptr(0)
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FnCol = 0
}

// Initialize a DbEvalContext structure.
//
// If pArray is not NULL, then it contains the name of a Tcl array
// variable. The "*" member of this array is set to a list containing
// the names of the columns returned by the statement as part of each
// call to dbEvalStep(), in order from left to right. e.g. if the names
// of the returned columns are a, b and c, it does the equivalent of the
// tcl command:
//
//     set ${pArray}(*) {a b c}
func dbEvalInit(tls *libc.TLS, p uintptr, pDb uintptr, pSql uintptr, pArray uintptr, evalFlags int32) { /* tclsqlite.c:1587:13: */
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(DbEvalContext{})))
	(*DbEvalContext)(unsafe.Pointer(p)).FpDb = pDb
	(*DbEvalContext)(unsafe.Pointer(p)).FzSql = tcl.XTcl_GetString(tls, pSql)
	(*DbEvalContext)(unsafe.Pointer(p)).FpSql = pSql
	(*Tcl_Obj)(unsafe.Pointer(pSql)).FrefCount++
	if pArray != 0 {
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = pArray
		(*Tcl_Obj)(unsafe.Pointer(pArray)).FrefCount++
	}
	(*DbEvalContext)(unsafe.Pointer(p)).FevalFlags = evalFlags
	addDatabaseRef(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb)
}

// Obtain information about the row that the DbEvalContext passed as the
// first argument currently points to.
func dbEvalRowInfo(tls *libc.TLS, p uintptr, pnCol uintptr, papColName uintptr) { /* tclsqlite.c:1611:13: */
	// Compute column names
	if uintptr(0) == (*DbEvalContext)(unsafe.Pointer(p)).FapColName {
		var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
		var i int32                        // Iterator variable
		var nCol int32                     // Number of columns returned by pStmt
		var apColName uintptr = uintptr(0) // Array of column names

		(*DbEvalContext)(unsafe.Pointer(p)).FnCol = libc.AssignInt32(&nCol, sqlite3.Xsqlite3_column_count(tls, pStmt))
		if nCol > 0 && (papColName != 0 || (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0) {
			apColName = tcl.XTcl_Alloc(tls, uint32(uint64(unsafe.Sizeof(uintptr(0)))*uint64(nCol)))
			for i = 0; i < nCol; i++ {
				*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*8)) = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_name(tls, pStmt, i), -1)
				(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*8)))).FrefCount++
			}
			(*DbEvalContext)(unsafe.Pointer(p)).FapColName = apColName
		}

		// If results are being stored in an array variable, then create
		// the array(*) entry for that array
		if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
			var interp uintptr = (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).Finterp
			var pColList uintptr = tcl.XTcl_NewObj(tls)
			var pStar uintptr = tcl.XTcl_NewStringObj(tls, ts+3840 /* "*" */, -1)

			for i = 0; i < nCol; i++ {
				tcl.XTcl_ListObjAppendElement(tls, interp, pColList, *(*uintptr)(unsafe.Pointer(apColName + uintptr(i)*8)))
			}
			(*Tcl_Obj)(unsafe.Pointer(pStar)).FrefCount++
			tcl.XTcl_ObjSetVar2(tls, interp, (*DbEvalContext)(unsafe.Pointer(p)).FpArray, pStar, pColList, 0)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = pStar
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
		}
	}

	if papColName != 0 {
		*(*uintptr)(unsafe.Pointer(papColName)) = (*DbEvalContext)(unsafe.Pointer(p)).FapColName
	}
	if pnCol != 0 {
		*(*int32)(unsafe.Pointer(pnCol)) = (*DbEvalContext)(unsafe.Pointer(p)).FnCol
	}
}

// Return one of TCL_OK, TCL_BREAK or TCL_ERROR. If TCL_ERROR is
// returned, then an error message is stored in the interpreter before
// returning.
//
// A return value of TCL_OK means there is a row of data available. The
// data may be accessed using dbEvalRowInfo() and dbEvalColumnValue(). This
// is analogous to a return of SQLITE_ROW from sqlite3_step(). If TCL_BREAK
// is returned, then the SQL script has finished executing and there are
// no further rows available. This is similar to SQLITE_DONE.
func dbEvalStep(tls *libc.TLS, p uintptr) int32 { /* tclsqlite.c:1669:12: */
	var zPrevSql uintptr = uintptr(0) // Previous value of p->zSql

	for *(*int8)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FzSql)) != 0 || (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0 {
		var rc int32
		if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt == uintptr(0) {
			zPrevSql = func() uintptr {
				if (*DbEvalContext)(unsafe.Pointer(p)).FzSql == zPrevSql {
					return uintptr(0)
				}
				return (*DbEvalContext)(unsafe.Pointer(p)).FzSql
			}()
			rc = dbPrepareAndBind(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FzSql, p+16, p+24)
			if rc != TCL_OK {
				return rc
			}
		} else {
			var rcs int32
			var pDb uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpDb
			var pPreStmt uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt
			var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer(pPreStmt)).FpStmt

			rcs = sqlite3.Xsqlite3_step(tls, pStmt)
			if rcs == SQLITE_ROW {
				return TCL_OK
			}
			if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
				dbEvalRowInfo(tls, p, uintptr(0), uintptr(0))
			}
			rcs = sqlite3.Xsqlite3_reset(tls, pStmt)

			(*SqliteDb)(unsafe.Pointer(pDb)).FnStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnSort = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_SORT, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnIndex = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_AUTOINDEX, 1)
			(*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep = sqlite3.Xsqlite3_stmt_status(tls, pStmt, SQLITE_STMTSTATUS_VM_STEP, 1)
			dbReleaseColumnNames(tls, p)
			(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)

			if rcs != SQLITE_OK {
				// If a run-time error occurs, report the error and stop reading
				// the SQL.
				dbReleaseStmt(tls, pDb, pPreStmt, 1)
				if (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FbLegacyPrepare != 0 && rcs == SQLITE_SCHEMA && zPrevSql != 0 {
					// If the runtime error was an SQLITE_SCHEMA, and the database
					// handle is configured to use the legacy sqlite3_prepare()
					// interface, retry prepare()/step() on the same SQL statement.
					// This only happens once. If there is a second SQLITE_SCHEMA
					// error, the error will be returned to the caller.
					(*DbEvalContext)(unsafe.Pointer(p)).FzSql = zPrevSql
					continue
				}
				tcl.XTcl_SetObjResult(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Finterp,
					tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), -1))
				return TCL_ERROR
			} else {
				dbReleaseStmt(tls, pDb, pPreStmt, 0)
			}
		}
	}

	// Finished
	return TCL_BREAK
}

// Free all resources currently held by the DbEvalContext structure passed
// as the first argument. There should be exactly one call to this function
// for each call to dbEvalInit().
func dbEvalFinalize(tls *libc.TLS, p uintptr) { /* tclsqlite.c:1733:13: */
	if (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt != 0 {
		sqlite3.Xsqlite3_reset(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt)
		dbReleaseStmt(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb, (*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt, 0)
		(*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt = uintptr(0)
	}
	if (*DbEvalContext)(unsafe.Pointer(p)).FpArray != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*DbEvalContext)(unsafe.Pointer(p)).FpArray = uintptr(0)
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpSql
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbReleaseColumnNames(tls, p)
	delDatabaseRef(tls, (*DbEvalContext)(unsafe.Pointer(p)).FpDb)
}

// Return a pointer to a Tcl_Obj structure with ref-count 0 that contains
// the value for the iCol'th column of the row currently pointed to by
// the DbEvalContext structure passed as the first argument.
func dbEvalColumnValue(tls *libc.TLS, p uintptr, iCol int32) uintptr { /* tclsqlite.c:1753:16: */
	var pStmt uintptr = (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt
	switch sqlite3.Xsqlite3_column_type(tls, pStmt, iCol) {
	case SQLITE_BLOB:
		{
			var bytes int32 = sqlite3.Xsqlite3_column_bytes(tls, pStmt, iCol)
			var zBlob uintptr = sqlite3.Xsqlite3_column_blob(tls, pStmt, iCol)
			if !(zBlob != 0) {
				bytes = 0
			}
			return tcl.XTcl_NewByteArrayObj(tls, zBlob, bytes)

		}
	case SQLITE_INTEGER:
		{
			var v sqlite_int64 = sqlite3.Xsqlite3_column_int64(tls, pStmt, iCol)
			if v >= int64(-2147483647) && v <= int64(2147483647) {
				return tcl.XTcl_NewIntObj(tls, int32(v))
			} else {
				return tcl.XTcl_NewWideIntObj(tls, v)
			}

		}
		fallthrough
	case SQLITE_FLOAT:
		{
			return tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_column_double(tls, pStmt, iCol))

		}
	case SQLITE_NULL:
		{
			return tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpDb)).FzNull, -1)

		}
	}

	return tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_column_text(tls, pStmt, iCol), -1)
}

// If using Tcl version 8.6 or greater, use the NR functions to avoid
// recursive evalution of scripts by the [db eval] and [db trans]
// commands. Even if the headers used while compiling the extension
// are 8.6 or newer, the code still tests the Tcl version at runtime.
// This allows stubs-enabled builds to be used with older Tcl libraries.
func DbUseNre(tls *libc.TLS) int32 { /* tclsqlite.c:1790:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var major int32 at bp, 4

	// var minor int32 at bp+4, 4

	tcl.XTcl_GetVersion(tls, bp /* &major */, bp+4 /* &minor */, uintptr(0), uintptr(0))
	return libc.Bool32(*(*int32)(unsafe.Pointer(bp)) == 8 && *(*int32)(unsafe.Pointer(bp + 4)) >= 6 || *(*int32)(unsafe.Pointer(bp)) > 8)
}

// This function is part of the implementation of the command:
//
//   $db eval SQL ?ARRAYNAME? SCRIPT
func DbEvalNextCmd(tls *libc.TLS, data uintptr, interp uintptr, result int32) int32 { /* tclsqlite.c:1817:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = result // Return code

	// The first element of the data[] array is a pointer to a DbEvalContext
	// structure allocated using Tcl_Alloc(). The second element of data[]
	// is a pointer to a Tcl_Obj containing the script to run for each row
	// returned by the queries encapsulated in data[0].
	var p uintptr = *(*ClientData)(unsafe.Pointer(data))
	var pScript uintptr = *(*ClientData)(unsafe.Pointer(data + 1*8))
	var pArray uintptr = (*DbEvalContext)(unsafe.Pointer(p)).FpArray

	for (rc == TCL_OK || rc == TCL_CONTINUE) && TCL_OK == libc.AssignInt32(&rc, dbEvalStep(tls, p)) {
		var i int32
		// var nCol int32 at bp, 4

		// var apColName uintptr at bp+8, 8

		dbEvalRowInfo(tls, p, bp /* &nCol */, bp+8 /* &apColName */)
		for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nCol */)); i++ {
			if pArray == uintptr(0) {
				tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apColName */)) + uintptr(i)*8)), uintptr(0), dbEvalColumnValue(tls, p, i), 0)
			} else if (*DbEvalContext)(unsafe.Pointer(p)).FevalFlags&SQLITE_EVAL_WITHOUTNULLS != 0 &&
				sqlite3.Xsqlite3_column_type(tls, (*SqlPreparedStmt)(unsafe.Pointer((*DbEvalContext)(unsafe.Pointer(p)).FpPreStmt)).FpStmt, i) == SQLITE_NULL {
				tcl.XTcl_UnsetVar2(tls, interp, tcl.XTcl_GetString(tls, pArray),
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apColName */)) + uintptr(i)*8))), 0)
			} else {
				tcl.XTcl_ObjSetVar2(tls, interp, pArray, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apColName */)) + uintptr(i)*8)), dbEvalColumnValue(tls, p, i), 0)
			}
		}

		// The required interpreter variables are now populated with the data
		// from the current row. If using NRE, schedule callbacks to evaluate
		// script pScript, then to invoke this function again to fetch the next
		// row (or clean up if there is no next row or the script throws an
		// exception). After scheduling the callbacks, return control to the
		// caller.
		//
		// If not using NRE, evaluate pScript directly and continue with the
		// next iteration of this while(...) loop.
		if DbUseNre(tls) != 0 {
			tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			}{DbEvalNextCmd})), p, pScript, uintptr(0), uintptr(0))
			return tcl.XTcl_NREvalObj(tls, interp, pScript, 0)
		} else {
			rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, 0)
		}
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	dbEvalFinalize(tls, p)
	tcl.XTcl_Free(tls, p)

	if rc == TCL_OK || rc == TCL_BREAK {
		tcl.XTcl_ResetResult(tls, interp)
		rc = TCL_OK
	}
	return rc
}

// This function is used by the implementations of the following database
// handle sub-commands:
//
//   $db update_hook ?SCRIPT?
//   $db wal_hook ?SCRIPT?
//   $db commit_hook ?SCRIPT?
//   $db preupdate hook ?SCRIPT?
func DbHookCmd(tls *libc.TLS, interp uintptr, pDb uintptr, pArg uintptr, ppHook uintptr) { /* tclsqlite.c:1887:13: */
	var db uintptr = (*SqliteDb)(unsafe.Pointer(pDb)).Fdb

	if *(*uintptr)(unsafe.Pointer(ppHook)) != 0 {
		tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(ppHook)))
		if pArg != 0 {
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = *(*uintptr)(unsafe.Pointer(ppHook))
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			*(*uintptr)(unsafe.Pointer(ppHook)) = uintptr(0)
		}
	}
	if pArg != 0 {

		if tcl.XTcl_GetCharLength(tls, pArg) > 0 {
			*(*uintptr)(unsafe.Pointer(ppHook)) = pArg
			(*Tcl_Obj)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppHook)))).FrefCount++
		}
	}

	sqlite3.Xsqlite3_preupdate_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpPreUpdateHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, sqlite_int64, sqlite_int64)
			}{DbPreUpdateHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_update_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpUpdateHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, uintptr, sqlite_int64)
			}{DbUpdateHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_rollback_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpRollbackHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbRollbackHandler}))
		}
		return uintptr(0)
	}(), pDb)
	sqlite3.Xsqlite3_wal_hook(tls, db, func() uintptr {
		if (*SqliteDb)(unsafe.Pointer(pDb)).FpWalHook != 0 {
			return *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr, int32) int32
			}{DbWalHandler}))
		}
		return uintptr(0)
	}(), pDb)
}

// The "sqlite" command below creates a new Tcl command for each
// connection it opens to an SQLite database.  This routine is invoked
// whenever one of those connection-specific commands is executed
// in Tcl.  For example, if you run Tcl code like this:
//
//       sqlite3 db1  "my_database"
//       db1 close
//
// The first command opens a connection to the "my_database" database
// and calls that connection "db1".  The second command causes this
// subroutine to be invoked.
func DbObjCmd(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:1931:26: */
	bp := tls.Alloc(1588)
	defer tls.Free(1588)
	*(*uintptr)(unsafe.Pointer(bp + 1464)) = cd

	var pDb uintptr
	// var choice int32 at bp+1016, 4

	var rc int32
	var zAuth uintptr
	// var len int32 at bp+1020, 4

	var zDestFile uintptr
	var zSrcDb uintptr
	// var pDest uintptr at bp+1024, 8

	var pBackup uintptr
	var zCallback uintptr
	// var len1 int32 at bp+1032, 4

	var zBusy uintptr
	// var len2 int32 at bp+1036, 4

	var subCmd uintptr
	// var n int32 at bp+1040, 4

	var pResult uintptr
	var pCollate uintptr
	var zName uintptr
	var zScript uintptr
	// var nScript int32 at bp+1044, 4

	var _objPtr uintptr
	var zCommit uintptr
	// var len3 int32 at bp+1048, 4

	var pResult1 uintptr
	var isComplete int32
	// var v int32 at bp+1052, 4

	var zOpt uintptr
	// var onoff int32 at bp+1056, 4

	// var v1 int32 at bp+1060, 4

	var pResult2 uintptr
	var ii int32
	var zErr uintptr
	var nErr int32
	var z uintptr
	var zTable uintptr    // Insert data into this table
	var zFile uintptr     // The file from which to extract data
	var zConflict uintptr // The conflict algorithm to use
	// var pStmt uintptr at bp+1064, 8
	// A statement
	var nCol int32  // Number of columns in the table
	var nByte int32 // Number of bytes in an SQL string
	var i int32
	var j int32          // Loop counters
	var nSep int32       // Number of bytes in zSep[]
	var nNull int32      // Number of bytes in zNull[]
	var zSql uintptr     // An SQL statement
	var zLine uintptr    // A single line of input from the file
	var azCol uintptr    // zLine[] broken up into columns
	var zCommit1 uintptr // How to commit changes
	var in uintptr       // The input file
	var lineno int32     // Line number of input file
	// var zLineNum [80]int8 at bp+1072, 80
	// Line number print buffer
	var pResult3 uintptr // interp result

	var zSep uintptr
	var zNull uintptr
	// var x Tcl_WideInt at bp+1152, 8

	var z1 uintptr
	var flags int32
	var zSchema uintptr
	var pValue uintptr
	var pBA uintptr
	var pData uintptr
	// var len4 int32 at bp+1164, 4

	var xrc int32
	// var mxSize sqlite3_int64 at bp+1168, 8

	var i1 int32
	// var isReadonly int32 at bp+1160, 4

	var pResult4 uintptr
	// var sEval DbEvalContext at bp+1176, 56

	var i2 int32
	// var nCol1 int32 at bp+1288, 4

	var _objPtr1 uintptr
	// var sEval1 DbEvalContext at bp+1232, 56

	var pRet uintptr
	// var cd2 [2]ClientData at bp+1296, 16

	var p uintptr
	var pArray uintptr
	var pScript uintptr
	var evalFlags int32
	var zOpt1 uintptr
	// var azType [6]uintptr at bp+1320, 48

	var z2 uintptr
	var n1 int32
	var _objPtr2 uintptr
	var flags1 int32
	var pFunc uintptr
	var pScript1 uintptr
	var zName1 uintptr
	// var nArg int32 at bp+1312, 4

	var i3 int32
	// var eType int32 at bp+1368, 4

	var isReadonly1 int32
	var zDb uintptr
	var zTable1 uintptr
	var zColumn uintptr
	// var iRow Tcl_WideInt at bp+1376, 8

	// var len5 int32 at bp+1384, 4

	var zNull1 uintptr
	var pResult5 uintptr
	var rowid Tcl_WideInt
	var zProgress uintptr
	// var len6 int32 at bp+1392, 4

	// var N int32 at bp+1388, 4

	var zProfile uintptr
	// var len7 int32 at bp+1396, 4

	var zSrcFile uintptr
	var zDestDb uintptr
	// var pSrc uintptr at bp+1400, 8

	var pBackup1 uintptr
	var nTimeout int32
	var needFree int32
	var zSchema1 uintptr
	// var sz sqlite3_int64 at bp+1408, 8

	var pData1 uintptr
	var v2 int32
	var zOp uintptr
	// var ms int32 at bp+1416, 4

	var pResult6 uintptr
	var zTrace uintptr
	// var len8 int32 at bp+1420, 4

	var _objPtr3 uintptr
	var _objPtr4 uintptr
	// var wType Tcl_WideInt at bp+1448, 8

	var pError uintptr
	// var pObj uintptr at bp+1432, 8

	// var ttype int32 at bp+1440, 4

	var i4 int32
	var zTraceV2 uintptr
	// var len9 int32 at bp+1424, 4

	var wMask Tcl_WideInt
	// var ttype1 int32 at bp+1456, 4

	var pScript2 uintptr
	var zBegin uintptr
	var _objPtr5 uintptr
	var xNotify uintptr
	var pNotifyArg uintptr
	var nCol2 int32
	var pRet1 uintptr
	var pObj1 uintptr
	// var iIdx int32 at bp+1476, 4

	// var pValue1 uintptr at bp+1480, 8

	// var iSub int32 at bp+1472, 4

	// set ppHook to point at pUpdateHook or pRollbackHook, depending on
	// whether [$db update_hook] or [$db rollback_hook] was invoked.
	var ppHook uintptr
	// var zBuf [100]int8 at bp+1488, 100

	var zArg uintptr
	var i5 int32
	pDb = *(*uintptr)(unsafe.Pointer(bp + 1464 /* cd */))
	rc = TCL_OK
	// don't leave trailing commas on DB_enum, it confuses the AIX xlc compiler

	if !(objc < 2) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999 /* "SUBCOMMAND ..." */)
	return TCL_ERROR
__1:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&DB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+12530, 0, bp+1016) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	switch uint32(*(*int32)(unsafe.Pointer(bp + 1016 /* choice */))) {

	// $db authorizer ?CALLBACK?
	//
	// Invoke the given callback to authorize each SQL operation as it is
	// compiled.  5 arguments are appended to the callback before it is
	// invoked:
	//
	//   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)
	//   (2) First descriptive name (depends on authorization type)
	//   (3) Second descriptive name
	//   (4) Name of the database (ex: "main", "temp")
	//   (5) Name of trigger that is doing the access
	//
	// The callback should return on of the following strings: SQLITE_OK,
	// SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.
	//
	// If this method is invoked with no arguments, the current authorization
	// callback string is returned.
	case uint32(0) /* DB_AUTHORIZER */ :
		goto __4

	// $db backup ?DATABASE? FILENAME
	//
	// Open or create a database file named FILENAME.  Transfer the
	// content of local database DATABASE (default: "main") into the
	// FILENAME database.
	case uint32(1) /* DB_BACKUP */ :
		goto __5

	// $db bind_fallback ?CALLBACK?
	//
	// When resolving bind parameters in an SQL statement, if the parameter
	// cannot be associated with a TCL variable then invoke CALLBACK with a
	// single argument that is the name of the parameter and use the return
	// value of the CALLBACK as the binding.  If CALLBACK returns something
	// other than TCL_OK or TCL_ERROR then bind a NULL.
	//
	// If CALLBACK is an empty string, then revert to the default behavior
	// which is to set the binding to NULL.
	//
	// If CALLBACK returns an error, that causes the statement execution to
	// abort.  Hence, to configure a connection so that it throws an error
	// on an attempt to bind an unknown variable, do something like this:
	//
	//     proc bind_error {name} {error "no such variable: $name"}
	//     db bind_fallback bind_error
	case uint32(2) /* DB_BIND_FALLBACK */ :
		goto __6

	// $db busy ?CALLBACK?
	//
	// Invoke the given callback if an SQL statement attempts to open
	// a locked database file.
	case uint32(3) /* DB_BUSY */ :
		goto __7

	// $db cache flush
	//     $db cache size n
	//
	// Flush the prepared statement cache, or set the maximum number of
	// cached statements.
	case uint32(4) /* DB_CACHE */ :
		goto __8

	// $db changes
	//
	// Return the number of rows that were modified, inserted, or deleted by
	// the most recent INSERT, UPDATE or DELETE statement, not including
	// any changes made by trigger programs.
	case uint32(5) /* DB_CHANGES */ :
		goto __9

	// $db close
	//
	// Shutdown the database
	case uint32(6) /* DB_CLOSE */ :
		goto __10

	//     $db collate NAME SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
	case uint32(7) /* DB_COLLATE */ :
		goto __11

	//     $db collation_needed SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
	case uint32(8) /* DB_COLLATION_NEEDED */ :
		goto __12

	// $db commit_hook ?CALLBACK?
	//
	// Invoke the given callback just before committing every SQL transaction.
	// If the callback throws an exception or returns non-zero, then the
	// transaction is aborted.  If CALLBACK is an empty string, the callback
	// is disabled.
	case uint32(9) /* DB_COMMIT_HOOK */ :
		goto __13

	// $db complete SQL
	//
	// Return TRUE if SQL is a complete SQL statement.  Return FALSE if
	// additional lines of input are needed.  This is similar to the
	// built-in "info complete" command of Tcl.
	case uint32(10) /* DB_COMPLETE */ :
		goto __14

	// $db config ?OPTION? ?BOOLEAN?
	//
	// Configure the database connection using the sqlite3_db_config()
	// interface.
	case uint32(11) /* DB_CONFIG */ :
		goto __15

	// $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?
	//
	// Copy data into table from filename, optionally using SEPARATOR
	// as column separators.  If a column contains a null string, or the
	// value of NULLINDICATOR, a NULL is inserted for the column.
	// conflict-algorithm is one of the sqlite conflict algorithms:
	//    rollback, abort, fail, ignore, replace
	// On success, return the number of lines processed, not necessarily same
	// as 'db changes' due to conflict-algorithm selected.
	//
	// This code is basically an implementation/enhancement of
	// the sqlite3 shell.c ".import" command.
	//
	// This command usage is equivalent to the sqlite2.x COPY statement,
	// which imports file data into a table using the PostgreSQL COPY file format:
	//   $db copy $conflit_algo $table_name $filename \t \\N
	case uint32(12) /* DB_COPY */ :
		goto __16

	//     $db deserialize ?-maxsize N? ?-readonly BOOL? ?DATABASE? VALUE
	//
	// Reopen DATABASE (default "main") using the content in $VALUE
	case uint32(13) /* DB_DESERIALIZE */ :
		goto __17

	//    $db enable_load_extension BOOLEAN
	//
	// Turn the extension loading feature on or off.  It if off by
	// default.
	case uint32(14) /* DB_ENABLE_LOAD_EXTENSION */ :
		goto __18

	//    $db errorcode
	//
	// Return the numeric error code that was returned by the most recent
	// call to sqlite3_exec().
	case uint32(15) /* DB_ERRORCODE */ :
		goto __19

	//    $db exists $sql
	//    $db onecolumn $sql
	//
	// The onecolumn method is the equivalent of:
	//     lindex [$db eval $sql] 0
	case uint32(17) /* DB_EXISTS */ :
		goto __20
	case uint32(23) /* DB_ONECOLUMN */ :
		goto __21

	//    $db eval ?options? $sql ?array? ?{  ...code... }?
	//
	// The SQL statement in $sql is evaluated.  For each row, the values are
	// placed in elements of the array named "array" and ...code... is executed.
	// If "array" and "code" are omitted, then no callback is every invoked.
	// If "array" is an empty string, then the values are placed in variables
	// that have the same name as the fields extracted by the query.
	case uint32(16) /* DB_EVAL */ :
		goto __22

	//     $db function NAME [OPTIONS] SCRIPT
	//
	// Create a new SQL function called NAME.  Whenever that function is
	// called, invoke SCRIPT to evaluate the function.
	//
	// Options:
	//         --argcount N           Function has exactly N arguments
	//         --deterministic        The function is pure
	//         --directonly           Prohibit use inside triggers and views
	//         --innocuous            Has no side effects or information leaks
	//         --returntype TYPE      Specify the return type of the function
	case uint32(18) /* DB_FUNCTION */ :
		goto __23

	//     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID
	case uint32(19) /* DB_INCRBLOB */ :
		goto __24

	//     $db interrupt
	//
	// Interrupt the execution of the inner-most SQL interpreter.  This
	// causes the SQL statement to return an error of SQLITE_INTERRUPT.
	case uint32(20) /* DB_INTERRUPT */ :
		goto __25

	//     $db nullvalue ?STRING?
	//
	// Change text used when a NULL comes back from the database. If ?STRING?
	// is not present, then the current string used for NULL is returned.
	// If STRING is present, then STRING is returned.
	//
	case uint32(22) /* DB_NULLVALUE */ :
		goto __26

	//     $db last_insert_rowid
	//
	// Return an integer which is the ROWID for the most recent insert.
	case uint32(21) /* DB_LAST_INSERT_ROWID */ :
		goto __27

	// The DB_ONECOLUMN method is implemented together with DB_EXISTS.

	// $db progress ?N CALLBACK?
	//
	// Invoke the given callback every N virtual machine opcodes while executing
	// queries.
	case uint32(26) /* DB_PROGRESS */ :
		goto __28

	// $db profile ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine after each SQL statement
	// that has run.  The text of the SQL and the amount of elapse time are
	// appended to CALLBACK before the script is run.
	case uint32(25) /* DB_PROFILE */ :
		goto __29

	//     $db rekey KEY
	//
	// Change the encryption key on the currently open database.
	case uint32(27) /* DB_REKEY */ :
		goto __30

	// $db restore ?DATABASE? FILENAME
	//
	// Open a database file named FILENAME.  Transfer the content
	// of FILENAME into the local database DATABASE (default: "main").
	case uint32(28) /* DB_RESTORE */ :
		goto __31

	//     $db serialize ?DATABASE?
	//
	// Return a serialization of a database.
	case uint32(30) /* DB_SERIALIZE */ :
		goto __32

	//     $db status (step|sort|autoindex|vmstep)
	//
	// Display SQLITE_STMTSTATUS_FULLSCAN_STEP or
	// SQLITE_STMTSTATUS_SORT for the most recent eval.
	case uint32(31) /* DB_STATUS */ :
		goto __33

	//     $db timeout MILLESECONDS
	//
	// Delay for the number of milliseconds specified when a file is locked.
	case uint32(32) /* DB_TIMEOUT */ :
		goto __34

	//     $db total_changes
	//
	// Return the number of rows that were modified, inserted, or deleted
	// since the database handle was created.
	case uint32(33) /* DB_TOTAL_CHANGES */ :
		goto __35

	// $db trace ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine for each SQL statement
	// that is executed.  The text of the SQL is appended to CALLBACK before
	// it is executed.
	case uint32(34) /* DB_TRACE */ :
		goto __36

	// $db trace_v2 ?CALLBACK? ?MASK?
	//
	// Make arrangements to invoke the CALLBACK routine for each trace event
	// matching the mask that is generated.  The parameters are appended to
	// CALLBACK before it is executed.
	case uint32(35) /* DB_TRACE_V2 */ :
		goto __37

	// $db transaction [-deferred|-immediate|-exclusive] SCRIPT
	//
	// Start a new transaction (if we are not already in the midst of a
	// transaction) and execute the TCL script SCRIPT.  After SCRIPT
	// completes, either commit the transaction or roll it back if SCRIPT
	// throws an exception.  Or if no new transation was started, do nothing.
	// pass the exception on up the stack.
	//
	// This command was inspired by Dave Thomas's talk on Ruby at the
	// 2005 O'Reilly Open Source Convention (OSCON).
	case uint32(36) /* DB_TRANSACTION */ :
		goto __38

	//    $db unlock_notify ?script?
	case uint32(37) /* DB_UNLOCK_NOTIFY */ :
		goto __39

	//    $db preupdate_hook count
	//    $db preupdate_hook hook ?SCRIPT?
	//    $db preupdate_hook new INDEX
	//    $db preupdate_hook old INDEX
	case uint32(24) /* DB_PREUPDATE */ :
		goto __40

	//    $db wal_hook ?script?
	//    $db update_hook ?script?
	//    $db rollback_hook ?script?
	case uint32(40) /* DB_WAL_HOOK */ :
		goto __41
	case uint32(38) /* DB_UPDATE_HOOK */ :
		goto __42
	case uint32(29) /* DB_ROLLBACK_HOOK */ :
		goto __43

	// $db version
	//
	// Return the version string for this database.
	case uint32(39) /* DB_VERSION */ :
		goto __44
	}
	goto __3

	// $db authorizer ?CALLBACK?
	//
	// Invoke the given callback to authorize each SQL operation as it is
	// compiled.  5 arguments are appended to the callback before it is
	// invoked:
	//
	//   (1) The authorization type (ex: SQLITE_CREATE_TABLE, SQLITE_INSERT, ...)
	//   (2) First descriptive name (depends on authorization type)
	//   (3) Second descriptive name
	//   (4) Name of the database (ex: "main", "temp")
	//   (5) Name of trigger that is doing the access
	//
	// The callback should return on of the following strings: SQLITE_OK,
	// SQLITE_IGNORE, or SQLITE_DENY.  Any other return value is an error.
	//
	// If this method is invoked with no arguments, the current authorization
	// callback string is returned.
__4:
	if !(objc > 3) {
		goto __45
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12537 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __46
__45:
	if !(objc == 2) {
		goto __47
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __49
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, uintptr(0)))
__49:
	;
	goto __48
__47:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __50
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth)
__50:
	;
	zAuth = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1020 /* &len */)
	if !(zAuth != 0 && *(*int32)(unsafe.Pointer(bp + 1020)) > 0) {
		goto __51
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1020))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzAuth, zAuth, uint64(*(*int32)(unsafe.Pointer(bp + 1020))+1))
	goto __52
__51:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzAuth = uintptr(0)
__52:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzAuth != 0) {
		goto __53
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr, uintptr) int32
	}{auth_callback})), pDb)
	goto __54
__53:
	sqlite3.Xsqlite3_set_authorizer(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__54:
	;
__48:
	;
__46:
	;
	goto __3

	// $db backup ?DATABASE? FILENAME
	//
	// Open or create a database file named FILENAME.  Transfer the
	// content of local database DATABASE (default: "main") into the
	// FILENAME database.
__5:

	if !(objc == 3) {
		goto __55
	}
	zSrcDb = ts + 85 /* "main" */
	zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	goto __56
__55:
	if !(objc == 4) {
		goto __57
	}
	zSrcDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	zDestFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	goto __58
__57:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12548 /* "?DATABASE? FILEN..." */)
	return TCL_ERROR
__58:
	;
__56:
	;
	rc = sqlite3.Xsqlite3_open_v2(tls, zDestFile, bp+1024, /* &pDest */
		SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|(*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __59
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+12568, /* "cannot open targ..." */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)))
	return TCL_ERROR
__59:
	;
	pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)), ts+85 /* "main" */, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSrcDb)
	if !(pBackup == uintptr(0)) {
		goto __60
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+12598, /* "backup failed: " */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)))
	return TCL_ERROR
__60:
	;
__61:
	if !(libc.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup, 100)) == SQLITE_OK) {
		goto __62
	}
	goto __61
__62:
	;
	sqlite3.Xsqlite3_backup_finish(tls, pBackup)
	if !(rc == SQLITE_DONE) {
		goto __63
	}
	rc = TCL_OK
	goto __64
__63:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, ts+12598, /* "backup failed: " */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */))), uintptr(0)))
	rc = TCL_ERROR
__64:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1024 /* pDest */)))
	goto __3

	// $db bind_fallback ?CALLBACK?
	//
	// When resolving bind parameters in an SQL statement, if the parameter
	// cannot be associated with a TCL variable then invoke CALLBACK with a
	// single argument that is the name of the parameter and use the return
	// value of the CALLBACK as the binding.  If CALLBACK returns something
	// other than TCL_OK or TCL_ERROR then bind a NULL.
	//
	// If CALLBACK is an empty string, then revert to the default behavior
	// which is to set the binding to NULL.
	//
	// If CALLBACK returns an error, that causes the statement execution to
	// abort.  Hence, to configure a connection so that it throws an error
	// on an attempt to bind an unknown variable, do something like this:
	//
	//     proc bind_error {name} {error "no such variable: $name"}
	//     db bind_fallback bind_error
__6:
	if !(objc > 3) {
		goto __65
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12537 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __66
__65:
	if !(objc == 2) {
		goto __67
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0) {
		goto __69
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+88, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, uintptr(0)))
__69:
	;
	goto __68
__67:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback != 0) {
		goto __70
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback)
__70:
	;
	zCallback = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1032 /* &len1 */)
	if !(zCallback != 0 && *(*int32)(unsafe.Pointer(bp + 1032)) > 0) {
		goto __71
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1032))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback, zCallback, uint64(*(*int32)(unsafe.Pointer(bp + 1032))+1))
	goto __72
__71:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBindFallback = uintptr(0)
__72:
	;
__68:
	;
__66:
	;
	goto __3

	// $db busy ?CALLBACK?
	//
	// Invoke the given callback if an SQL statement attempts to open
	// a locked database file.
__7:
	if !(objc > 3) {
		goto __73
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12614 /* "CALLBACK" */)
	return TCL_ERROR
	goto __74
__73:
	if !(objc == 2) {
		goto __75
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __77
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+104, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, uintptr(0)))
__77:
	;
	goto __76
__75:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __78
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy)
__78:
	;
	zBusy = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1036 /* &len2 */)
	if !(zBusy != 0 && *(*int32)(unsafe.Pointer(bp + 1036)) > 0) {
		goto __79
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1036))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzBusy, zBusy, uint64(*(*int32)(unsafe.Pointer(bp + 1036))+1))
	goto __80
__79:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzBusy = uintptr(0)
__80:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzBusy != 0) {
		goto __81
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{DbBusyHandler})), pDb)
	goto __82
__81:
	sqlite3.Xsqlite3_busy_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__82:
	;
__76:
	;
__74:
	;
	goto __3

	// $db cache flush
	//     $db cache size n
	//
	// Flush the prepared statement cache, or set the maximum number of
	// cached statements.
__8:

	if !(objc <= 2) {
		goto __83
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+12623 /* "cache option ?ar..." */)
	return TCL_ERROR
__83:
	;
	subCmd = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0))
	if !(int32(*(*int8)(unsafe.Pointer(subCmd))) == 'f' && libc.Xstrcmp(tls, subCmd, ts+12642) == 0) {
		goto __84
	}
	if !(objc != 3) {
		goto __86
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12642 /* "flush" */)
	return TCL_ERROR
	goto __87
__86:
	flushStmtCache(tls, pDb)
__87:
	;
	goto __85
__84:
	if !(int32(*(*int8)(unsafe.Pointer(subCmd))) == 's' && libc.Xstrcmp(tls, subCmd, ts+12648) == 0) {
		goto __88
	}
	if !(objc != 4) {
		goto __90
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12653 /* "size n" */)
	return TCL_ERROR
	goto __91
__90:
	if !(TCL_ERROR == tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+1040)) {
		goto __92
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+120, ts+12660, /* "cannot convert \"" */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), uintptr(0)), ts+12677 /* "\" to integer" */, uintptr(0)))
	return TCL_ERROR
	goto __93
__92:
	if !(*(*int32)(unsafe.Pointer(bp + 1040)) < 0) {
		goto __94
	}
	flushStmtCache(tls, pDb)
	*(*int32)(unsafe.Pointer(bp + 1040 /* n */)) = 0
	goto __95
__94:
	if !(*(*int32)(unsafe.Pointer(bp + 1040)) > MAX_PREPARED_STMTS) {
		goto __96
	}
	*(*int32)(unsafe.Pointer(bp + 1040 /* n */)) = MAX_PREPARED_STMTS
__96:
	;
__95:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FmaxStmt = *(*int32)(unsafe.Pointer(bp + 1040 /* n */))
__93:
	;
__91:
	;
	goto __89
__88:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+152, ts+12690, /* "bad option \"" */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0)), ts+12703, /* "\": must be flush..." */
		uintptr(0)))
	return TCL_ERROR
__89:
	;
__85:
	;
	goto __3

	// $db changes
	//
	// Return the number of rows that were modified, inserted, or deleted by
	// the most recent INSERT, UPDATE or DELETE statement, not including
	// any changes made by trigger programs.
__9:
	if !(objc != 2) {
		goto __97
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
	return TCL_ERROR
__97:
	;
	pResult = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetWideIntObj(tls, pResult, sqlite3.Xsqlite3_changes64(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	goto __3

	// $db close
	//
	// Shutdown the database
__10:
	tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)))
	goto __3

	//     $db collate NAME SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
__11:
	if !(objc != 4) {
		goto __98
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12728 /* "NAME SCRIPT" */)
	return TCL_ERROR
__98:
	;
	zName = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0))
	zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+1044 /* &nScript */)
	pCollate = tcl.XTcl_Alloc(tls, uint32(uint64(unsafe.Sizeof(SqlCollate{}))+uint64(*(*int32)(unsafe.Pointer(bp + 1044)))+uint64(1)))
	if !(pCollate == uintptr(0)) {
		goto __99
	}
	return TCL_ERROR
__99:
	;
	(*SqlCollate)(unsafe.Pointer(pCollate)).Finterp = interp
	(*SqlCollate)(unsafe.Pointer(pCollate)).FpNext = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollate
	(*SqlCollate)(unsafe.Pointer(pCollate)).FzScript = pCollate + 1*24
	(*SqliteDb)(unsafe.Pointer(pDb)).FpCollate = pCollate
	libc.Xmemcpy(tls, (*SqlCollate)(unsafe.Pointer(pCollate)).FzScript, zScript, uint64(*(*int32)(unsafe.Pointer(bp + 1044))+1))
	if !(sqlite3.Xsqlite3_create_collation(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName, SQLITE_UTF8,
		pCollate, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{tclSqlCollate}))) != 0) {
		goto __100
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
	return TCL_ERROR
__100:
	;
	goto __3

	//     $db collation_needed SCRIPT
	//
	// Create a new SQL collation function called NAME.  Whenever
	// that function is called, invoke SCRIPT to evaluate the function.
__12:
	if !(objc != 3) {
		goto __101
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+11019 /* "SCRIPT" */)
	return TCL_ERROR
__101:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded != 0) {
		goto __102
	}
__103:
	_objPtr = (*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1) {
		goto __106
	}
	tcl.XTclFreeObj(tls, _objPtr)
__106:
	;
	goto __104
__104:
	if 0 != 0 {
		goto __103
	}
	goto __105
__105:
	;
__102:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpCollateNeeded)).FrefCount++
	sqlite3.Xsqlite3_collation_needed(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, pDb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr)
	}{tclCollateNeeded})))
	goto __3

	// $db commit_hook ?CALLBACK?
	//
	// Invoke the given callback just before committing every SQL transaction.
	// If the callback throws an exception or returns non-zero, then the
	// transaction is aborted.  If CALLBACK is an empty string, the callback
	// is disabled.
__13:
	if !(objc > 3) {
		goto __107
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12537 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __108
__107:
	if !(objc == 2) {
		goto __109
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __111
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+184, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, uintptr(0)))
__111:
	;
	goto __110
__109:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __112
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit)
__112:
	;
	zCommit = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1048 /* &len3 */)
	if !(zCommit != 0 && *(*int32)(unsafe.Pointer(bp + 1048)) > 0) {
		goto __113
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1048))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzCommit, zCommit, uint64(*(*int32)(unsafe.Pointer(bp + 1048))+1))
	goto __114
__113:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzCommit = uintptr(0)
__114:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzCommit != 0) {
		goto __115
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{DbCommitHandler})), pDb)
	goto __116
__115:
	sqlite3.Xsqlite3_commit_hook(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__116:
	;
__110:
	;
__108:
	;
	goto __3

	// $db complete SQL
	//
	// Return TRUE if SQL is a complete SQL statement.  Return FALSE if
	// additional lines of input are needed.  This is similar to the
	// built-in "info complete" command of Tcl.
__14:
	if !(objc != 3) {
		goto __117
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+10367 /* "SQL" */)
	return TCL_ERROR
__117:
	;
	isComplete = sqlite3.Xsqlite3_complete(tls, tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0)))
	pResult1 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult1, libc.Bool32(isComplete != 0))
	goto __3

	// $db config ?OPTION? ?BOOLEAN?
	//
	// Configure the database connection using the sqlite3_db_config()
	// interface.
__15:
	if !(objc > 4) {
		goto __118
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12740 /* "?OPTION? ?BOOLEA..." */)
	return TCL_ERROR
__118:
	;
	if !(objc == 2) {
		goto __119
	}
	// With no arguments, list all configuration options and with the
	// current value
	pResult2 = tcl.XTcl_NewListObj(tls, 0, uintptr(0))
	ii = 0
__121:
	if !(uint64(ii) < uint64(unsafe.Sizeof(aDbConfig))/uint64(unsafe.Sizeof(DbConfigChoices{}))) {
		goto __123
	}
	*(*int32)(unsafe.Pointer(bp + 1052 /* v */)) = 0
	sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, libc.VaList(bp+200, -1, bp+1052 /* &v */))
	tcl.XTcl_ListObjAppendElement(tls, interp, pResult2,
		tcl.XTcl_NewStringObj(tls, aDbConfig[ii].FzName, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pResult2,
		tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1052 /* v */))))
	goto __122
__122:
	ii++
	goto __121
	goto __123
__123:
	;
	goto __120
__119:
	zOpt = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	*(*int32)(unsafe.Pointer(bp + 1056 /* onoff */)) = -1
	*(*int32)(unsafe.Pointer(bp + 1060 /* v1 */)) = 0
	if !(int32(*(*int8)(unsafe.Pointer(zOpt))) == '-') {
		goto __124
	}
	zOpt++
__124:
	;
	ii = 0
__125:
	if !(uint64(ii) < uint64(unsafe.Sizeof(aDbConfig))/uint64(unsafe.Sizeof(DbConfigChoices{}))) {
		goto __127
	}
	if !(libc.Xstrcmp(tls, aDbConfig[ii].FzName, zOpt) == 0) {
		goto __128
	}
	goto __127
__128:
	;
	goto __126
__126:
	ii++
	goto __125
	goto __127
__127:
	;
	if !(uint64(ii) >= uint64(unsafe.Sizeof(aDbConfig))/uint64(unsafe.Sizeof(DbConfigChoices{}))) {
		goto __129
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+216, ts+12759 /* "unknown config o..." */, zOpt,
		ts+12784 /* "\"" */, uintptr(0)))
	return TCL_ERROR
__129:
	;
	if !(objc == 4) {
		goto __130
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+1056) != 0) {
		goto __131
	}
	return TCL_ERROR
__131:
	;
__130:
	;
	sqlite3.Xsqlite3_db_config(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, aDbConfig[ii].Fop, libc.VaList(bp+248, *(*int32)(unsafe.Pointer(bp + 1056 /* onoff */)), bp+1060 /* &v1 */))
	pResult2 = tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 1060 /* v1 */)))
__120:
	;
	tcl.XTcl_SetObjResult(tls, interp, pResult2)
	goto __3

	// $db copy conflict-algorithm table filename ?SEPARATOR? ?NULLINDICATOR?
	//
	// Copy data into table from filename, optionally using SEPARATOR
	// as column separators.  If a column contains a null string, or the
	// value of NULLINDICATOR, a NULL is inserted for the column.
	// conflict-algorithm is one of the sqlite conflict algorithms:
	//    rollback, abort, fail, ignore, replace
	// On success, return the number of lines processed, not necessarily same
	// as 'db changes' due to conflict-algorithm selected.
	//
	// This code is basically an implementation/enhancement of
	// the sqlite3 shell.c ".import" command.
	//
	// This command usage is equivalent to the sqlite2.x COPY statement,
	// which imports file data into a table using the PostgreSQL COPY file format:
	//   $db copy $conflit_algo $table_name $filename \t \\N
__16: // The input file
	lineno = 0
	if !(objc < 5 || objc > 7) {
		goto __132
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
		ts+12786 /* "CONFLICT-ALGORIT..." */)
	return TCL_ERROR
__132:
	;
	if !(objc >= 6) {
		goto __133
	}
	zSep = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 5*8)), uintptr(0))
	goto __134
__133:
	zSep = ts + 12848 /* "\t" */
__134:
	;
	if !(objc >= 7) {
		goto __135
	}
	zNull = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 6*8)), uintptr(0))
	goto __136
__135:
	zNull = ts + 584 /* "" */
__136:
	;
	zConflict = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0))
	zTable = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), uintptr(0))
	zFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)), uintptr(0))
	nSep = strlen30(tls, zSep)
	nNull = strlen30(tls, zNull)
	if !(nSep == 0) {
		goto __137
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+264, ts+12850, /* "Error: non-null ..." */
		uintptr(0)))
	return TCL_ERROR
__137:
	;
	if !(libc.Xstrcmp(tls, zConflict, ts+12894) != 0 && libc.Xstrcmp(tls, zConflict, ts+12903) != 0 && libc.Xstrcmp(tls, zConflict, ts+12909) != 0 && libc.Xstrcmp(tls, zConflict, ts+12914) != 0 && libc.Xstrcmp(tls, zConflict, ts+12921) != 0) {
		goto __138
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+280, ts+12929 /* "Error: \"" */, zConflict,

		ts+12938 /* "\", conflict-algo..." */, uintptr(0)))
	return TCL_ERROR
__138:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+13018 /* "SELECT * FROM '%..." */, libc.VaList(bp+312, zTable))
	if !(zSql == uintptr(0)) {
		goto __139
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+320, ts+13037 /* "Error: no such t..." */, zTable, uintptr(0)))
	return TCL_ERROR
__139:
	;
	nByte = strlen30(tls, zSql)
	rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1064 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != 0) {
		goto __140
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+344, ts+13060 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	nCol = 0
	goto __141
__140:
	nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)))
__141:
	;
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)))
	if !(nCol == 0) {
		goto __142
	}
	return TCL_ERROR
__142:
	;
	zSql = libc.Xmalloc(tls, uint64(nByte+50+nCol*2))
	if !(zSql == uintptr(0)) {
		goto __143
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+368, ts+13068 /* "Error: can't mal..." */, uintptr(0)))
	return TCL_ERROR
__143:
	;
	sqlite3.Xsqlite3_snprintf(tls, nByte+50, zSql, ts+13090, /* "INSERT OR %q INT..." */
		libc.VaList(bp+384, zConflict, zTable))
	j = strlen30(tls, zSql)
	i = 1
__144:
	if !(i < nCol) {
		goto __146
	}
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(',')
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8('?')
	goto __145
__145:
	i++
	goto __144
	goto __146
__146:
	;
	*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(')')
	*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
	rc = sqlite3.Xsqlite3_prepare(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSql, -1, bp+1064 /* &pStmt */, uintptr(0))
	libc.Xfree(tls, zSql)
	if !(rc != 0) {
		goto __147
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+400, ts+13060 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)))
	return TCL_ERROR
__147:
	;
	in = libc.Xfopen(tls, zFile, ts+4402 /* "rb" */)
	if !(in == uintptr(0)) {
		goto __148
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+424, ts+13122 /* "Error: cannot op..." */, zFile, uintptr(0)))
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)))
	return TCL_ERROR
__148:
	;
	azCol = libc.Xmalloc(tls, uint64(unsafe.Sizeof(uintptr(0)))*uint64(nCol+1))
	if !(azCol == uintptr(0)) {
		goto __149
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+448, ts+13068 /* "Error: can't mal..." */, uintptr(0)))
	libc.Xfclose(tls, in)
	return TCL_ERROR
__149:
	;
	sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, ts+13148 /* "BEGIN" */, uintptr(0), uintptr(0), uintptr(0))
	zCommit1 = ts + 12467 /* "COMMIT" */
__150:
	if !(libc.AssignUintptr(&zLine, local_getline(tls, uintptr(0), in)) != uintptr(0)) {
		goto __151
	}
	lineno++
	*(*uintptr)(unsafe.Pointer(azCol)) = zLine
	i = 0
	z = zLine
__152:
	if !(*(*int8)(unsafe.Pointer(z)) != 0) {
		goto __154
	}
	if !(int32(*(*int8)(unsafe.Pointer(z))) == int32(*(*int8)(unsafe.Pointer(zSep))) && libc.Xstrncmp(tls, z, zSep, uint64(nSep)) == 0) {
		goto __155
	}
	*(*int8)(unsafe.Pointer(z)) = int8(0)
	i++
	if !(i < nCol) {
		goto __156
	}
	*(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8)) = z + uintptr(nSep)
	z += uintptr(nSep - 1)
__156:
	;
__155:
	;
	goto __153
__153:
	z++
	goto __152
	goto __154
__154:
	;
	if !(i+1 != nCol) {
		goto __157
	}
	nErr = strlen30(tls, zFile) + 200
	zErr = libc.Xmalloc(tls, uint64(nErr))
	if !(zErr != 0) {
		goto __158
	}
	sqlite3.Xsqlite3_snprintf(tls, nErr, zErr,
		ts+13154, /* "Error: %s line %..." */
		libc.VaList(bp+464, zFile, lineno, nCol, i+1))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+496, zErr, uintptr(0)))
	libc.Xfree(tls, zErr)
__158:
	;
	zCommit1 = ts + 7467 /* "ROLLBACK" */
	goto __151
__157:
	;
	i = 0
__159:
	if !(i < nCol) {
		goto __161
	}
	// check for null data, if so, bind as null
	if !(nNull > 0 && libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8)), zNull) == 0 ||
		strlen30(tls, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8))) == 0) {
		goto __162
	}
	sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)), i+1)
	goto __163
__162:
	sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)), i+1, *(*uintptr)(unsafe.Pointer(azCol + uintptr(i)*8)), -1, uintptr(0))
__163:
	;
	goto __160
__160:
	i++
	goto __159
	goto __161
__161:
	;
	sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)))
	rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)))
	libc.Xfree(tls, zLine)
	if !(rc != SQLITE_OK) {
		goto __164
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+512, ts+13060 /* "Error: " */, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	zCommit1 = ts + 7467 /* "ROLLBACK" */
	goto __151
__164:
	;
	goto __150
__151:
	;
	libc.Xfree(tls, azCol)
	libc.Xfclose(tls, in)
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 1064 /* pStmt */)))
	sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zCommit1, uintptr(0), uintptr(0), uintptr(0))

	if !(int32(*(*int8)(unsafe.Pointer(zCommit1))) == 'C') {
		goto __165
	}
	// success, set result as number of lines processed
	pResult3 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetIntObj(tls, pResult3, lineno)
	rc = TCL_OK
	goto __166
__165:
	// failure, append lineno where failed
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+1072 /* &zLineNum[0] */, ts+1333 /* "%d" */, libc.VaList(bp+536, lineno))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+544, ts+13214 /* ", failed while p..." */, bp+1072, /* &zLineNum[0] */
		uintptr(0)))
	rc = TCL_ERROR
__166:
	;
	goto __3

	//     $db deserialize ?-maxsize N? ?-readonly BOOL? ?DATABASE? VALUE
	//
	// Reopen DATABASE (default "main") using the content in $VALUE
__17:
	zSchema = uintptr(0)
	pValue = uintptr(0)
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1168 /* mxSize */)) = int64(0)
	*(*int32)(unsafe.Pointer(bp + 1160 /* isReadonly */)) = 0

	if !(objc < 3) {
		goto __167
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13247 /* "?DATABASE? VALUE" */)
	rc = TCL_ERROR
	goto __3
__167:
	;
	i1 = 2
__168:
	if !(i1 < objc-1) {
		goto __170
	}
	z1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i1)*8)))
	if !(libc.Xstrcmp(tls, z1, ts+13264) == 0 && i1 < objc-2) {
		goto __171
	}
	rc = tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(libc.PreIncInt32(&i1, 1))*8)), bp+1152 /* &x */)
	if !(rc != 0) {
		goto __172
	}
	goto deserialize_error
__172:
	;
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1168 /* mxSize */)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 1152 /* x */))
	goto __169
__171:
	;
	if !(libc.Xstrcmp(tls, z1, ts+13273) == 0 && i1 < objc-2) {
		goto __173
	}
	rc = tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(libc.PreIncInt32(&i1, 1))*8)), bp+1160 /* &isReadonly */)
	if !(rc != 0) {
		goto __174
	}
	goto deserialize_error
__174:
	;
	goto __169
__173:
	;
	if !(zSchema == uintptr(0) && i1 == objc-2 && int32(*(*int8)(unsafe.Pointer(z1))) != '-') {
		goto __175
	}
	zSchema = z1
	goto __169
__175:
	;
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+568, ts+13283 /* "unknown option: " */, z1, uintptr(0)))
	rc = TCL_ERROR
	goto deserialize_error
	goto __169
__169:
	i1++
	goto __168
	goto __170
__170:
	;
	pValue = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8))
	pBA = tcl.XTcl_GetByteArrayFromObj(tls, pValue, bp+1164 /* &len4 */)
	pData = sqlite3.Xsqlite3_malloc64(tls, uint64(*(*int32)(unsafe.Pointer(bp + 1164 /* len4 */))))
	if !(pData == uintptr(0) && *(*int32)(unsafe.Pointer(bp + 1164)) > 0) {
		goto __176
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+592, ts+2069 /* "out of memory" */, uintptr(0)))
	rc = TCL_ERROR
	goto __177
__176:
	if !(*(*int32)(unsafe.Pointer(bp + 1164)) > 0) {
		goto __178
	}
	libc.Xmemcpy(tls, pData, pBA, uint64(*(*int32)(unsafe.Pointer(bp + 1164 /* len4 */))))
__178:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1160)) != 0) {
		goto __179
	}
	flags = SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_READONLY
	goto __180
__179:
	flags = SQLITE_DESERIALIZE_FREEONCLOSE | SQLITE_DESERIALIZE_RESIZEABLE
__180:
	;
	xrc = sqlite3.Xsqlite3_deserialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema, pData, int64(*(*int32)(unsafe.Pointer(bp + 1164 /* len4 */))), int64(*(*int32)(unsafe.Pointer(bp + 1164 /* len4 */))), uint32(flags))
	if !(xrc != 0) {
		goto __181
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+608, ts+13300 /* "unable to set ME..." */, uintptr(0)))
	rc = TCL_ERROR
__181:
	;
	if !(*(*sqlite3_int64)(unsafe.Pointer(bp + 1168)) > int64(0)) {
		goto __182
	}
	sqlite3.Xsqlite3_file_control(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema, SQLITE_FCNTL_SIZE_LIMIT, bp+1168 /* &mxSize */)
__182:
	;
__177:
	;
deserialize_error:
	goto __3

	//    $db enable_load_extension BOOLEAN
	//
	// Turn the extension loading feature on or off.  It if off by
	// default.
__18:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+624, ts+13328, /* "extension loadin..." */
		uintptr(0)))
	return TCL_ERROR

	//    $db errorcode
	//
	// Return the numeric error code that was returned by the most recent
	// call to sqlite3_exec().
__19:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)))
	goto __3

	//    $db exists $sql
	//    $db onecolumn $sql
	//
	// The onecolumn method is the equivalent of:
	//     lindex [$db eval $sql] 0
__20:
__21:
	pResult4 = uintptr(0)
	if !(objc != 3) {
		goto __183
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+10367 /* "SQL" */)
	return TCL_ERROR
__183:
	;

	dbEvalInit(tls, bp+1176 /* &sEval */, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0), 0)
	rc = dbEvalStep(tls, bp+1176 /* &sEval */)
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 23) {
		goto __184
	}
	if !(rc == TCL_OK) {
		goto __186
	}
	pResult4 = dbEvalColumnValue(tls, bp+1176 /* &sEval */, 0)
	goto __187
__186:
	if !(rc == TCL_BREAK) {
		goto __188
	}
	tcl.XTcl_ResetResult(tls, interp)
__188:
	;
__187:
	;
	goto __185
__184:
	if !(rc == TCL_BREAK || rc == TCL_OK) {
		goto __189
	}
	pResult4 = tcl.XTcl_NewIntObj(tls, libc.Bool32(libc.Bool32(rc == TCL_OK) != 0))
__189:
	;
__185:
	;
	dbEvalFinalize(tls, bp+1176 /* &sEval */)
	if !(pResult4 != 0) {
		goto __190
	}
	tcl.XTcl_SetObjResult(tls, interp, pResult4)
__190:
	;

	if !(rc == TCL_BREAK) {
		goto __191
	}
	rc = TCL_OK
__191:
	;
	goto __3

	//    $db eval ?options? $sql ?array? ?{  ...code... }?
	//
	// The SQL statement in $sql is evaluated.  For each row, the values are
	// placed in elements of the array named "array" and ...code... is executed.
	// If "array" and "code" are omitted, then no callback is every invoked.
	// If "array" is an empty string, then the values are placed in variables
	// that have the same name as the fields extracted by the query.
__22:
	evalFlags = 0
__192:
	if !(objc > 3 && libc.AssignUintptr(&zOpt1, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))) != uintptr(0) && int32(*(*int8)(unsafe.Pointer(zOpt1))) == '-') {
		goto __193
	}
	if !(libc.Xstrcmp(tls, zOpt1, ts+13376) == 0) {
		goto __194
	}
	evalFlags = evalFlags | SQLITE_EVAL_WITHOUTNULLS
	goto __195
__194:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+640, ts+13390 /* "unknown option: ..." */, zOpt1, ts+12784 /* "\"" */, uintptr(0)))
	return TCL_ERROR
__195:
	;
	objc--
	objv += 8
	goto __192
__193:
	;
	if !(objc < 3 || objc > 5) {
		goto __196
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv,
		ts+13408 /* "?OPTIONS? SQL ?A..." */)
	return TCL_ERROR
__196:
	;

	if !(objc == 3) {
		goto __197
	}
	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	dbEvalInit(tls, bp+1232 /* &sEval1 */, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0), 0)
__199:
	if !(TCL_OK == libc.AssignInt32(&rc, dbEvalStep(tls, bp+1232))) {
		goto __200
	}
	dbEvalRowInfo(tls, bp+1232 /* &sEval1 */, bp+1288 /* &nCol1 */, uintptr(0))
	i2 = 0
__201:
	if !(i2 < *(*int32)(unsafe.Pointer(bp + 1288))) {
		goto __203
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, dbEvalColumnValue(tls, bp+1232 /* &sEval1 */, i2))
	goto __202
__202:
	i2++
	goto __201
	goto __203
__203:
	;
	goto __199
__200:
	;
	dbEvalFinalize(tls, bp+1232 /* &sEval1 */)
	if !(rc == TCL_BREAK) {
		goto __204
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	rc = TCL_OK
__204:
	;
__205:
	_objPtr1 = pRet
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr1)).FrefCount, 1) <= 1) {
		goto __208
	}
	tcl.XTclFreeObj(tls, _objPtr1)
__208:
	;
	goto __206
__206:
	if 0 != 0 {
		goto __205
	}
	goto __207
__207:
	;
	goto __198
__197:
	pArray = uintptr(0)

	if !(objc >= 5 && *(*int8)(unsafe.Pointer(tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8))))) != 0) {
		goto __209
	}
	pArray = *(*uintptr)(unsafe.Pointer(objv + 3*8))
__209:
	;
	pScript = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8))
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++

	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(DbEvalContext{})))
	dbEvalInit(tls, p, pDb, *(*uintptr)(unsafe.Pointer(objv + 2*8)), pArray, evalFlags)

	*(*ClientData)(unsafe.Pointer(bp + 1296 /* &cd2[0] */)) = p
	*(*ClientData)(unsafe.Pointer(bp + 1296 /* &cd2[0] */ + 1*8)) = pScript
	rc = DbEvalNextCmd(tls, bp+1296 /* &cd2[0] */, interp, TCL_OK)
__198:
	;
	goto __3

	//     $db function NAME [OPTIONS] SCRIPT
	//
	// Create a new SQL function called NAME.  Whenever that function is
	// called, invoke SCRIPT to evaluate the function.
	//
	// Options:
	//         --argcount N           Function has exactly N arguments
	//         --deterministic        The function is pure
	//         --directonly           Prohibit use inside triggers and views
	//         --innocuous            Has no side effects or information leaks
	//         --returntype TYPE      Specify the return type of the function
__23:
	flags1 = SQLITE_UTF8
	*(*int32)(unsafe.Pointer(bp + 1312 /* nArg */)) = -1
	*(*int32)(unsafe.Pointer(bp + 1368 /* eType */)) = SQLITE_NULL
	if !(objc < 4) {
		goto __210
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13444 /* "NAME ?SWITCHES? ..." */)
	return TCL_ERROR
__210:
	;
	i3 = 3
__211:
	if !(i3 < objc-1) {
		goto __213
	}
	z2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3)*8)))
	n1 = strlen30(tls, z2)
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+13467, uint64(n1)) == 0) {
		goto __214
	}
	if !(i3 == objc-2) {
		goto __216
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+672, ts+13477 /* "option requires ..." */, z2, uintptr(0)))
	return TCL_ERROR
__216:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3+1)*8)), bp+1312) != 0) {
		goto __217
	}
	return TCL_ERROR
__217:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1312)) < 0) {
		goto __218
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+696, ts+13507, /* "number of argume..." */
		uintptr(0)))
	return TCL_ERROR
__218:
	;
	i3++
	goto __215
__214:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+13548, uint64(n1)) == 0) {
		goto __219
	}
	flags1 = flags1 | SQLITE_DETERMINISTIC
	goto __220
__219:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+13563, uint64(n1)) == 0) {
		goto __221
	}
	flags1 = flags1 | SQLITE_DIRECTONLY
	goto __222
__221:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+13575, uint64(n1)) == 0) {
		goto __223
	}
	flags1 = flags1 | SQLITE_INNOCUOUS
	goto __224
__223:
	if !(n1 > 1 && libc.Xstrncmp(tls, z2, ts+13586, uint64(n1)) == 0) {
		goto __225
	}
	*(*[6]uintptr)(unsafe.Pointer(bp + 1320 /* azType */)) = [6]uintptr{ts + 8113 /* "integer" */, ts + 13598 /* "real" */, ts + 13603 /* "text" */, ts + 13608 /* "blob" */, ts + 13613 /* "any" */, uintptr(0)}

	if !(i3 == objc-2) {
		goto __227
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+712, ts+13477 /* "option requires ..." */, z2, uintptr(0)))
	return TCL_ERROR
__227:
	;
	i3++
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i3)*8)), bp+1320, int32(unsafe.Sizeof(uintptr(0))), ts+13617, 0, bp+1368) != 0) {
		goto __228
	}
	return TCL_ERROR
__228:
	;
	*(*int32)(unsafe.Pointer(bp + 1368 /* eType */))++
	goto __226
__225:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+736, ts+12690 /* "bad option \"" */, z2,

		ts+13622 /* "\": must be -argc..." */, uintptr(0)))
	return TCL_ERROR
__226:
	;
__224:
	;
__222:
	;
__220:
	;
__215:
	;
	goto __212
__212:
	i3++
	goto __211
	goto __213
__213:
	;

	pScript1 = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8))
	zName1 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0))
	pFunc = findSqlFunc(tls, pDb, zName1)
	if !(pFunc == uintptr(0)) {
		goto __229
	}
	return TCL_ERROR
__229:
	;
	if !((*SqlFunc)(unsafe.Pointer(pFunc)).FpScript != 0) {
		goto __230
	}
__231:
	_objPtr2 = (*SqlFunc)(unsafe.Pointer(pFunc)).FpScript
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr2)).FrefCount, 1) <= 1) {
		goto __234
	}
	tcl.XTclFreeObj(tls, _objPtr2)
__234:
	;
	goto __232
__232:
	if 0 != 0 {
		goto __231
	}
	goto __233
__233:
	;
__230:
	;
	(*SqlFunc)(unsafe.Pointer(pFunc)).FpScript = pScript1
	(*Tcl_Obj)(unsafe.Pointer(pScript1)).FrefCount++
	(*SqlFunc)(unsafe.Pointer(pFunc)).FuseEvalObjv = safeToUseEvalObjv(tls, interp, pScript1)
	(*SqlFunc)(unsafe.Pointer(pFunc)).FeType = *(*int32)(unsafe.Pointer(bp + 1368 /* eType */))
	rc = sqlite3.Xsqlite3_create_function(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zName1, *(*int32)(unsafe.Pointer(bp + 1312 /* nArg */)), flags1,
		pFunc, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tclSqlFunc})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __235
	}
	rc = TCL_ERROR
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(1))
__235:
	;
	goto __3

	//     $db incrblob ?-readonly? ?DB? TABLE COLUMN ROWID
__24:
	isReadonly1 = 0
	zDb = ts + 85 /* "main" */

	// Check for the -readonly option
	if !(objc > 3 && libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), ts+13273) == 0) {
		goto __236
	}
	isReadonly1 = 1
__236:
	;

	if !(objc != 5+isReadonly1 && objc != 6+isReadonly1) {
		goto __237
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13700 /* "?-readonly? ?DB?..." */)
	return TCL_ERROR
__237:
	;

	if !(objc == 6+isReadonly1) {
		goto __238
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
__238:
	;
	zTable1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*8)))
	zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*8)))
	rc = tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8)), bp+1376 /* &iRow */)

	if !(rc == TCL_OK) {
		goto __239
	}
	rc = createIncrblobChannel(tls,
		interp, pDb, zDb, zTable1, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 1376 /* iRow */)), isReadonly1)
__239:
	;
	goto __3

	//     $db interrupt
	//
	// Interrupt the execution of the inner-most SQL interpreter.  This
	// causes the SQL statement to return an error of SQLITE_INTERRUPT.
__25:
	sqlite3.Xsqlite3_interrupt(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	goto __3

	//     $db nullvalue ?STRING?
	//
	// Change text used when a NULL comes back from the database. If ?STRING?
	// is not present, then the current string used for NULL is returned.
	// If STRING is present, then STRING is returned.
	//
__26:
	if !(objc != 2 && objc != 3) {
		goto __240
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13736 /* "NULLVALUE" */)
	return TCL_ERROR
__240:
	;
	if !(objc == 3) {
		goto __241
	}
	zNull1 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1384 /* &len5 */)
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzNull != 0) {
		goto __242
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull)
__242:
	;
	if !(zNull1 != 0 && *(*int32)(unsafe.Pointer(bp + 1384)) > 0) {
		goto __243
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1384))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, zNull1, uint64(*(*int32)(unsafe.Pointer(bp + 1384 /* len5 */))))
	*(*int8)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FzNull + uintptr(*(*int32)(unsafe.Pointer(bp + 1384 /* len5 */))))) = int8(0)
	goto __244
__243:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzNull = uintptr(0)
__244:
	;
__241:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzNull, -1))
	goto __3

	//     $db last_insert_rowid
	//
	// Return an integer which is the ROWID for the most recent insert.
__27:
	if !(objc != 2) {
		goto __245
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
	return TCL_ERROR
__245:
	;
	rowid = sqlite3.Xsqlite3_last_insert_rowid(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	pResult5 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetWideIntObj(tls, pResult5, rowid)
	goto __3

	// The DB_ONECOLUMN method is implemented together with DB_EXISTS.

	// $db progress ?N CALLBACK?
	//
	// Invoke the given callback every N virtual machine opcodes while executing
	// queries.
__28:
	if !(objc == 2) {
		goto __246
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __248
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+768, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, uintptr(0)))
__248:
	;
	goto __247
__246:
	if !(objc == 4) {
		goto __249
	}
	if !(TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1388)) {
		goto __251
	}
	return TCL_ERROR
__251:
	;

	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __252
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress)
__252:
	;
	zProgress = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+1392 /* &len6 */)
	if !(zProgress != 0 && *(*int32)(unsafe.Pointer(bp + 1392)) > 0) {
		goto __253
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1392))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProgress, zProgress, uint64(*(*int32)(unsafe.Pointer(bp + 1392))+1))
	goto __254
__253:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProgress = uintptr(0)
__254:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProgress != 0) {
		goto __255
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_progress_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1388 /* N */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{DbProgressHandler})), pDb)
	goto __256
__255:
	sqlite3.Xsqlite3_progress_handler(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, 0, uintptr(0), uintptr(0))
__256:
	;
	goto __250
__249:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13746 /* "N CALLBACK" */)
	return TCL_ERROR
__250:
	;
__247:
	;
	goto __3

	// $db profile ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine after each SQL statement
	// that has run.  The text of the SQL and the amount of elapse time are
	// appended to CALLBACK before the script is run.
__29:
	if !(objc > 3) {
		goto __257
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12537 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __258
__257:
	if !(objc == 2) {
		goto __259
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __261
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+784, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, uintptr(0)))
__261:
	;
	goto __260
__259:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __262
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile)
__262:
	;
	zProfile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1396 /* &len7 */)
	if !(zProfile != 0 && *(*int32)(unsafe.Pointer(bp + 1396)) > 0) {
		goto __263
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1396))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzProfile, zProfile, uint64(*(*int32)(unsafe.Pointer(bp + 1396))+1))
	goto __264
__263:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzProfile = uintptr(0)
__264:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzProfile != 0) {
		goto __265
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, sqlite_uint64)
	}{DbProfileHandler})), pDb)
	goto __266
__265:
	sqlite3.Xsqlite3_profile(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__266:
	;
__260:
	;
__258:
	;
	goto __3

	//     $db rekey KEY
	//
	// Change the encryption key on the currently open database.
__30:
	if !(objc != 3) {
		goto __267
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13757 /* "KEY" */)
	return TCL_ERROR
__267:
	;
	goto __3

	// $db restore ?DATABASE? FILENAME
	//
	// Open a database file named FILENAME.  Transfer the content
	// of FILENAME into the local database DATABASE (default: "main").
__31:
	nTimeout = 0

	if !(objc == 3) {
		goto __268
	}
	zDestDb = ts + 85 /* "main" */
	zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	goto __269
__268:
	if !(objc == 4) {
		goto __270
	}
	zDestDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	zSrcFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	goto __271
__270:
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12548 /* "?DATABASE? FILEN..." */)
	return TCL_ERROR
__271:
	;
__269:
	;
	rc = sqlite3.Xsqlite3_open_v2(tls, zSrcFile, bp+1400, /* &pSrc */
		SQLITE_OPEN_READONLY|(*SqliteDb)(unsafe.Pointer(pDb)).FopenFlags, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __272
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+800, ts+13761, /* "cannot open sour..." */
		sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 1400 /* pSrc */))), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1400 /* pSrc */)))
	return TCL_ERROR
__272:
	;
	pBackup1 = sqlite3.Xsqlite3_backup_init(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zDestDb, *(*uintptr)(unsafe.Pointer(bp + 1400 /* pSrc */)), ts+85 /* "main" */)
	if !(pBackup1 == uintptr(0)) {
		goto __273
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+824, ts+13791, /* "restore failed: " */
		sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1400 /* pSrc */)))
	return TCL_ERROR
__273:
	;
__274:
	if !(libc.AssignInt32(&rc, sqlite3.Xsqlite3_backup_step(tls, pBackup1, 100)) == SQLITE_OK ||
		rc == SQLITE_BUSY) {
		goto __275
	}
	if !(rc == SQLITE_BUSY) {
		goto __276
	}
	if !(libc.PostIncInt32(&nTimeout, 1) >= 3) {
		goto __277
	}
	goto __275
__277:
	;
	sqlite3.Xsqlite3_sleep(tls, 100)
__276:
	;
	goto __274
__275:
	;
	sqlite3.Xsqlite3_backup_finish(tls, pBackup1)
	if !(rc == SQLITE_DONE) {
		goto __278
	}
	rc = TCL_OK
	goto __279
__278:
	if !(rc == SQLITE_BUSY || rc == SQLITE_LOCKED) {
		goto __280
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+848, ts+13808, /* "restore failed: ..." */
		uintptr(0)))
	rc = TCL_ERROR
	goto __281
__280:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+864, ts+13791, /* "restore failed: " */
		sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	rc = TCL_ERROR
__281:
	;
__279:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 1400 /* pSrc */)))
	goto __3

	//     $db serialize ?DATABASE?
	//
	// Return a serialization of a database.
__32:
	if objc >= 3 {
		zSchema1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	} else {
		zSchema1 = ts + 85 /* "main" */
	}
	*(*sqlite3_int64)(unsafe.Pointer(bp + 1408 /* sz */)) = int64(0)
	if !(objc != 2 && objc != 3) {
		goto __282
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13845 /* "?DATABASE?" */)
	rc = TCL_ERROR
	goto __283
__282:
	pData1 = sqlite3.Xsqlite3_serialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema1, bp+1408 /* &sz */, uint32(SQLITE_SERIALIZE_NOCOPY))
	if !(pData1 != 0) {
		goto __284
	}
	needFree = 0
	goto __285
__284:
	pData1 = sqlite3.Xsqlite3_serialize(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zSchema1, bp+1408 /* &sz */, uint32(0))
	needFree = 1
__285:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, pData1, int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 1408 /* sz */)))))
	if !(needFree != 0) {
		goto __286
	}
	sqlite3.Xsqlite3_free(tls, pData1)
__286:
	;
__283:
	;
	goto __3

	//     $db status (step|sort|autoindex|vmstep)
	//
	// Display SQLITE_STMTSTATUS_FULLSCAN_STEP or
	// SQLITE_STMTSTATUS_SORT for the most recent eval.
__33:
	if !(objc != 3) {
		goto __287
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13856 /* "(step|sort|autoi..." */)
	return TCL_ERROR
__287:
	;
	zOp = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(libc.Xstrcmp(tls, zOp, ts+10317) == 0) {
		goto __288
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnStep
	goto __289
__288:
	if !(libc.Xstrcmp(tls, zOp, ts+13878) == 0) {
		goto __290
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnSort
	goto __291
__290:
	if !(libc.Xstrcmp(tls, zOp, ts+13883) == 0) {
		goto __292
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnIndex
	goto __293
__292:
	if !(libc.Xstrcmp(tls, zOp, ts+13893) == 0) {
		goto __294
	}
	v2 = (*SqliteDb)(unsafe.Pointer(pDb)).FnVMStep
	goto __295
__294:
	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp+888, ts+13900, /* "bad argument: sh..." */
			uintptr(0)))
	return TCL_ERROR
__295:
	;
__293:
	;
__291:
	;
__289:
	;
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, v2))
	goto __3

	//     $db timeout MILLESECONDS
	//
	// Delay for the number of milliseconds specified when a file is locked.
__34:
	if !(objc != 3) {
		goto __296
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13956 /* "MILLISECONDS" */)
	return TCL_ERROR
__296:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1416) != 0) {
		goto __297
	}
	return TCL_ERROR
__297:
	;
	sqlite3.Xsqlite3_busy_timeout(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1416 /* ms */)))
	goto __3

	//     $db total_changes
	//
	// Return the number of rows that were modified, inserted, or deleted
	// since the database handle was created.
__35:
	if !(objc != 2) {
		goto __298
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
	return TCL_ERROR
__298:
	;
	pResult6 = tcl.XTcl_GetObjResult(tls, interp)
	tcl.XTcl_SetWideIntObj(tls, pResult6, sqlite3.Xsqlite3_total_changes64(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	goto __3

	// $db trace ?CALLBACK?
	//
	// Make arrangements to invoke the CALLBACK routine for each SQL statement
	// that is executed.  The text of the SQL is appended to CALLBACK before
	// it is executed.
__36:
	if !(objc > 3) {
		goto __299
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+12537 /* "?CALLBACK?" */)
	return TCL_ERROR
	goto __300
__299:
	if !(objc == 2) {
		goto __301
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __303
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+904, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, uintptr(0)))
__303:
	;
	goto __302
__301:
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __304
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace)
__304:
	;
	zTrace = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1420 /* &len8 */)
	if !(zTrace != 0 && *(*int32)(unsafe.Pointer(bp + 1420)) > 0) {
		goto __305
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1420))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTrace, zTrace, uint64(*(*int32)(unsafe.Pointer(bp + 1420))+1))
	goto __306
__305:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTrace = uintptr(0)
__306:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTrace != 0) {
		goto __307
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{DbTraceHandler})), pDb)
	goto __308
__307:
	sqlite3.Xsqlite3_trace(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uintptr(0), uintptr(0))
__308:
	;
__302:
	;
__300:
	;
	goto __3

	// $db trace_v2 ?CALLBACK? ?MASK?
	//
	// Make arrangements to invoke the CALLBACK routine for each trace event
	// matching the mask that is generated.  The parameters are appended to
	// CALLBACK before it is executed.
__37:
	if !(objc > 4) {
		goto __309
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+13969 /* "?CALLBACK? ?MASK..." */)
	return TCL_ERROR
	goto __310
__309:
	if !(objc == 2) {
		goto __311
	}
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __313
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+920, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, uintptr(0)))
__313:
	;
	goto __312
__311:
	wMask = int64(0)
	if !(objc == 4) {
		goto __314
	}
	if !(TCL_OK != tcl.XTcl_ListObjLength(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+1424)) {
		goto __316
	}
	return TCL_ERROR
__316:
	;
	i4 = 0
__317:
	if !(i4 < *(*int32)(unsafe.Pointer(bp + 1424))) {
		goto __319
	}
	if !(TCL_OK != tcl.XTcl_ListObjIndex(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), i4, bp+1432)) {
		goto __320
	}
	return TCL_ERROR
__320:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1432)), uintptr(unsafe.Pointer(&TTYPE_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+13987, 0, bp+1440) != TCL_OK) {
		goto __321
	}
	pError = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, interp))
	(*Tcl_Obj)(unsafe.Pointer(pError)).FrefCount++
	if !(TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 1432)), bp+1448)) {
		goto __323
	}
__325:
	_objPtr3 = pError
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr3)).FrefCount, 1) <= 1) {
		goto __328
	}
	tcl.XTclFreeObj(tls, _objPtr3)
__328:
	;
	goto __326
__326:
	if 0 != 0 {
		goto __325
	}
	goto __327
__327:
	;
	wMask = wMask | *(*Tcl_WideInt)(unsafe.Pointer(bp + 1448))
	goto __324
__323:
	tcl.XTcl_SetObjResult(tls, interp, pError)
__329:
	_objPtr4 = pError
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr4)).FrefCount, 1) <= 1) {
		goto __332
	}
	tcl.XTclFreeObj(tls, _objPtr4)
__332:
	;
	goto __330
__330:
	if 0 != 0 {
		goto __329
	}
	goto __331
__331:
	;
	return TCL_ERROR
__324:
	;
	goto __322
__321:
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1440 /* ttype */))) {
	case uint32(0) /* TTYPE_STMT */ :
		goto __334
	case uint32(1) /* TTYPE_PROFILE */ :
		goto __335
	case uint32(2) /* TTYPE_ROW */ :
		goto __336
	case uint32(3) /* TTYPE_CLOSE */ :
		goto __337
	}
	goto __333
__334:
	wMask = wMask | int64(SQLITE_TRACE_STMT)
	goto __333
__335:
	wMask = wMask | int64(SQLITE_TRACE_PROFILE)
	goto __333
__336:
	wMask = wMask | int64(SQLITE_TRACE_ROW)
	goto __333
__337:
	wMask = wMask | int64(SQLITE_TRACE_CLOSE)
	goto __333
__333:
	;
__322:
	;
	goto __318
__318:
	i4++
	goto __317
	goto __319
__319:
	;
	goto __315
__314:
	wMask = int64(SQLITE_TRACE_STMT) // use the "legacy" default
__315:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __338
	}
	tcl.XTcl_Free(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2)
__338:
	;
	zTraceV2 = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+1424 /* &len9 */)
	if !(zTraceV2 != 0 && *(*int32)(unsafe.Pointer(bp + 1424)) > 0) {
		goto __339
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = tcl.XTcl_Alloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 1424))+1))
	libc.Xmemcpy(tls, (*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2, zTraceV2, uint64(*(*int32)(unsafe.Pointer(bp + 1424))+1))
	goto __340
__339:
	(*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 = uintptr(0)
__340:
	;
	if !((*SqliteDb)(unsafe.Pointer(pDb)).FzTraceV2 != 0) {
		goto __341
	}
	(*SqliteDb)(unsafe.Pointer(pDb)).Finterp = interp
	sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(wMask), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uint32, uintptr, uintptr, uintptr) int32
	}{DbTraceV2Handler})), pDb)
	goto __342
__341:
	sqlite3.Xsqlite3_trace_v2(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, uint32(0), uintptr(0), uintptr(0))
__342:
	;
__312:
	;
__310:
	;
	goto __3

	// $db transaction [-deferred|-immediate|-exclusive] SCRIPT
	//
	// Start a new transaction (if we are not already in the midst of a
	// transaction) and execute the TCL script SCRIPT.  After SCRIPT
	// completes, either commit the transaction or roll it back if SCRIPT
	// throws an exception.  Or if no new transation was started, do nothing.
	// pass the exception on up the stack.
	//
	// This command was inspired by Dave Thomas's talk on Ruby at the
	// 2005 O'Reilly Open Source Convention (OSCON).
__38:
	zBegin = ts + 13998 /* "SAVEPOINT _tcl_t..." */
	if !(objc != 3 && objc != 4) {
		goto __343
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+14025 /* "[TYPE] SCRIPT" */)
	return TCL_ERROR
__343:
	;

	if !((*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction == 0 && objc == 4) {
		goto __344
	}
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(unsafe.Pointer(&TTYPE_strs1)), int32(unsafe.Sizeof(uintptr(0))), ts+14039, 0, bp+1456) != 0) {
		goto __345
	}
	return TCL_ERROR
__345:
	;
	switch uint32(*(*int32)(unsafe.Pointer(bp + 1456 /* ttype1 */))) {
	case uint32(0) /* TTYPE_DEFERRED */ :
		goto __347
	case uint32(1) /* TTYPE_EXCLUSIVE */ :
		goto __348
	case uint32(2) /* TTYPE_IMMEDIATE */ :
		goto __349
	}
	goto __346
__347: /* no-op */
	;
	goto __346
__348:
	zBegin = ts + 14056 /* "BEGIN EXCLUSIVE" */
	goto __346
__349:
	zBegin = ts + 14072 /* "BEGIN IMMEDIATE" */
	goto __346
__346:
	;
__344:
	;
	pScript2 = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8))

	// Run the SQLite BEGIN command to open a transaction or savepoint.
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth++
	rc = sqlite3.Xsqlite3_exec(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, zBegin, uintptr(0), uintptr(0), uintptr(0))
	(*SqliteDb)(unsafe.Pointer(pDb)).FdisableAuth--
	if !(rc != SQLITE_OK) {
		goto __350
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+936, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	return TCL_ERROR
__350:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FnTransaction++

	// If using NRE, schedule a callback to invoke the script pScript, then
	// a second callback to commit (or rollback) the transaction or savepoint
	// opened above. If not using NRE, evaluate the script directly, then
	// call function DbTransPostCmd() to commit (or rollback) the transaction
	// or savepoint.
	addDatabaseRef(tls, pDb) // DbTransPostCmd() calls delDatabaseRef()
	if !(DbUseNre(tls) != 0) {
		goto __351
	}
	tcl.XTcl_NRAddCallback(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{DbTransPostCmd})), *(*uintptr)(unsafe.Pointer(bp + 1464 /* cd */)), uintptr(0), uintptr(0), uintptr(0))
	tcl.XTcl_NREvalObj(tls, interp, pScript2, 0)
	goto __352
__351:
	rc = DbTransPostCmd(tls, bp+1464 /* &cd */, interp, tcl.XTcl_EvalObjEx(tls, interp, pScript2, 0))
__352:
	;
	goto __3

	//    $db unlock_notify ?script?
__39:
	if !(objc != 2 && objc != 3) {
		goto __353
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+14088 /* "?SCRIPT?" */)
	rc = TCL_ERROR
	goto __354
__353:
	xNotify = uintptr(0)
	pNotifyArg = uintptr(0)

	if !((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify != 0) {
		goto __355
	}
__356:
	_objPtr5 = (*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify
	if !(libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr5)).FrefCount, 1) <= 1) {
		goto __359
	}
	tcl.XTclFreeObj(tls, _objPtr5)
__359:
	;
	goto __357
__357:
	if 0 != 0 {
		goto __356
	}
	goto __358
__358:
	;
	(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = uintptr(0)
__355:
	;

	if !(objc == 3) {
		goto __360
	}
	xNotify = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{DbUnlockNotify}))
	pNotifyArg = pDb
	(*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify = *(*uintptr)(unsafe.Pointer(objv + 2*8))
	(*Tcl_Obj)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FpUnlockNotify)).FrefCount++
__360:
	;

	if !(sqlite3.Xsqlite3_unlock_notify(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, xNotify, pNotifyArg) != 0) {
		goto __361
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+952, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	rc = TCL_ERROR
__361:
	;
__354:
	;
	goto __3

	//    $db preupdate_hook count
	//    $db preupdate_hook hook ?SCRIPT?
	//    $db preupdate_hook new INDEX
	//    $db preupdate_hook old INDEX
__40:

	if !(objc < 3) {
		goto __362
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+14097 /* "SUB-COMMAND ?ARG..." */)
__362:
	;
	if !(tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(unsafe.Pointer(&azSub)), int32(unsafe.Sizeof(uintptr(0))), ts+2014, 0, bp+1472) != 0) {
		goto __363
	}
	return TCL_ERROR
__363:
	;

	switch uint32(*(*int32)(unsafe.Pointer(bp + 1472 /* iSub */))) {
	case uint32(0) /* PRE_COUNT */ :
		goto __365

	case uint32(2) /* PRE_HOOK */ :
		goto __366

	case uint32(1) /* PRE_DEPTH */ :
		goto __367

	case uint32(3) /* PRE_NEW */ :
		goto __368
	case uint32(4) /* PRE_OLD */ :
		goto __369
	}
	goto __364
__365:
	nCol2 = sqlite3.Xsqlite3_preupdate_count(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nCol2))
	goto __364

__366:
	if !(objc > 4) {
		goto __370
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+14116 /* "hook ?SCRIPT?" */)
	return TCL_ERROR
__370:
	;
	DbHookCmd(tls, interp, pDb, func() uintptr {
		if objc == 4 {
			return *(*uintptr)(unsafe.Pointer(objv + 3*8))
		}
		return uintptr(0)
	}(), pDb+112)
	goto __364

__367:
	if !(objc != 3) {
		goto __371
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+584 /* "" */)
	return TCL_ERROR
__371:
	;
	pRet1 = tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_preupdate_depth(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb))
	tcl.XTcl_SetObjResult(tls, interp, pRet1)
	goto __364

__368:
__369:
	if !(objc != 4) {
		goto __372
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+14130 /* "INDEX" */)
	return TCL_ERROR
__372:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+1476) != 0) {
		goto __373
	}
	return TCL_ERROR
__373:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 1472)) == 4) {
		goto __374
	}
	rc = sqlite3.Xsqlite3_preupdate_old(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1476 /* iIdx */)), bp+1480 /* &pValue1 */)
	goto __375
__374:
	;
	rc = sqlite3.Xsqlite3_preupdate_new(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb, *(*int32)(unsafe.Pointer(bp + 1476 /* iIdx */)), bp+1480 /* &pValue1 */)
__375:
	;

	if !(rc == SQLITE_OK) {
		goto __376
	}
	pObj1 = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(bp + 1480 /* pValue1 */))), -1)
	tcl.XTcl_SetObjResult(tls, interp, pObj1)
	goto __377
__376:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+968, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(pDb)).Fdb), uintptr(0)))
	return TCL_ERROR
__377:
	;

__364:
	;
	goto __3

	//    $db wal_hook ?script?
	//    $db update_hook ?script?
	//    $db rollback_hook ?script?
__41:
__42:
__43:
	// set ppHook to point at pUpdateHook or pRollbackHook, depending on
	// whether [$db update_hook] or [$db rollback_hook] was invoked.
	ppHook = uintptr(0)
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 40) {
		goto __378
	}
	ppHook = pDb + 128
__378:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 38) {
		goto __379
	}
	ppHook = pDb + 104
__379:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 1016)) == 29) {
		goto __380
	}
	ppHook = pDb + 120
__380:
	;
	if !(objc > 3) {
		goto __381
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+14088 /* "?SCRIPT?" */)
	return TCL_ERROR
__381:
	;

	DbHookCmd(tls, interp, pDb, func() uintptr {
		if objc == 3 {
			return *(*uintptr)(unsafe.Pointer(objv + 2*8))
		}
		return uintptr(0)
	}(), ppHook)
	goto __3

	// $db version
	//
	// Return the version string for this database.
__44:
	i5 = 2
__382:
	if !(i5 < objc) {
		goto __384
	}
	zArg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i5)*8)))
	// Optional arguments to $db version are used for testing purpose
	// $db version -use-legacy-prepare BOOLEAN
	//
	// Turn the use of legacy sqlite3_prepare() on or off.
	if !(libc.Xstrcmp(tls, zArg, ts+14136) == 0 && i5+1 < objc) {
		goto __385
	}
	i5++
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i5)*8)), pDb+228) != 0) {
		goto __387
	}
	return TCL_ERROR
__387:
	;
	goto __386
__385:

	// $db version -last-stmt-ptr
	//
	// Return a string which is a hex encoding of the pointer to the
	// most recent sqlite3_stmt in the statement cache.
	if !(libc.Xstrcmp(tls, zArg, ts+14156) == 0) {
		goto __388
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+1488 /* &zBuf[0] */, ts+10721, /* "%p" */
		libc.VaList(bp+984, func() uintptr {
			if (*SqliteDb)(unsafe.Pointer(pDb)).FstmtList != 0 {
				return (*SqlPreparedStmt)(unsafe.Pointer((*SqliteDb)(unsafe.Pointer(pDb)).FstmtList)).FpStmt
			}
			return uintptr(0)
		}()))
	tcl.XTcl_SetResult(tls, interp, bp+1488 /* &zBuf[0] */, uintptr(1))
	goto __389
__388:

	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+992, ts+14171 /* "unknown argument..." */, zArg, uintptr(0)))
	return TCL_ERROR
__389:
	;
__386:
	;
	goto __383
__383:
	i5++
	goto __382
	goto __384
__384:
	;
	if !(i5 == 2) {
		goto __390
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_libversion(tls), uintptr(0))
__390:
	;
	goto __3

__3:
	; // End of the SWITCH statement
	return rc
}

type DbConfigChoices = struct {
	FzName       uintptr
	Fop          int32
	F__ccgo_pad1 [4]byte
} /* tclsqlite.c:2364:18 */

var DB_strs = [42]uintptr{
	ts + 14190 /* "authorizer" */, ts + 14201 /* "backup" */, ts + 14208, /* "bind_fallback" */
	ts + 14222 /* "busy" */, ts + 14227 /* "cache" */, ts + 14233, /* "changes" */
	ts + 10322 /* "close" */, ts + 14241 /* "collate" */, ts + 14249, /* "collation_needed" */
	ts + 14266 /* "commit_hook" */, ts + 14278 /* "complete" */, ts + 14287, /* "config" */
	ts + 14294 /* "copy" */, ts + 14299 /* "deserialize" */, ts + 14311, /* "enable_load_exte..." */
	ts + 14333 /* "errorcode" */, ts + 4896 /* "eval" */, ts + 14343, /* "exists" */
	ts + 14350 /* "function" */, ts + 11702 /* "incrblob" */, ts + 14359, /* "interrupt" */
	ts + 14369 /* "last_insert_rowi..." */, ts + 14387 /* "nullvalue" */, ts + 14397, /* "onecolumn" */
	ts + 14407 /* "preupdate" */, ts + 14417 /* "profile" */, ts + 10396, /* "progress" */
	ts + 14425 /* "rekey" */, ts + 14431 /* "restore" */, ts + 14439, /* "rollback_hook" */
	ts + 14453 /* "serialize" */, ts + 14463 /* "status" */, ts + 14470, /* "timeout" */
	ts + 14478 /* "total_changes" */, ts + 14492 /* "trace" */, ts + 14498, /* "trace_v2" */
	ts + 14507 /* "transaction" */, ts + 14519 /* "unlock_notify" */, ts + 14533, /* "update_hook" */
	ts + 14545 /* "version" */, ts + 14553 /* "wal_hook" */, uintptr(0),
} /* tclsqlite.c:1940:21 */
var aDbConfig = [16]DbConfigChoices{
	{FzName: ts + 14562 /* "defensive" */, Fop: SQLITE_DBCONFIG_DEFENSIVE},
	{FzName: ts + 14572 /* "dqs_ddl" */, Fop: SQLITE_DBCONFIG_DQS_DDL},
	{FzName: ts + 14580 /* "dqs_dml" */, Fop: SQLITE_DBCONFIG_DQS_DML},
	{FzName: ts + 14588 /* "enable_fkey" */, Fop: SQLITE_DBCONFIG_ENABLE_FKEY},
	{FzName: ts + 14600 /* "enable_qpsg" */, Fop: SQLITE_DBCONFIG_ENABLE_QPSG},
	{FzName: ts + 14612 /* "enable_trigger" */, Fop: SQLITE_DBCONFIG_ENABLE_TRIGGER},
	{FzName: ts + 14627 /* "enable_view" */, Fop: SQLITE_DBCONFIG_ENABLE_VIEW},
	{FzName: ts + 14639 /* "fts3_tokenizer" */, Fop: SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER},
	{FzName: ts + 14654 /* "legacy_alter_tab..." */, Fop: SQLITE_DBCONFIG_LEGACY_ALTER_TABLE},
	{FzName: ts + 14673 /* "legacy_file_form..." */, Fop: SQLITE_DBCONFIG_LEGACY_FILE_FORMAT},
	{FzName: ts + 14692 /* "load_extension" */, Fop: SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION},
	{FzName: ts + 14707 /* "no_ckpt_on_close" */, Fop: SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE},
	{FzName: ts + 14724 /* "reset_database" */, Fop: SQLITE_DBCONFIG_RESET_DATABASE},
	{FzName: ts + 14739 /* "trigger_eqp" */, Fop: SQLITE_DBCONFIG_TRIGGER_EQP},
	{FzName: ts + 14751 /* "trusted_schema" */, Fop: SQLITE_DBCONFIG_TRUSTED_SCHEMA},
	{FzName: ts + 14766 /* "writable_schema" */, Fop: SQLITE_DBCONFIG_WRITABLE_SCHEMA},
} /* tclsqlite.c:2367:7 */
var TTYPE_strs = [5]uintptr{
	ts + 14782 /* "statement" */, ts + 14417 /* "profile" */, ts + 14792 /* "row" */, ts + 10322 /* "close" */, uintptr(0),
} /* tclsqlite.c:3347:27 */
var TTYPE_strs1 = [4]uintptr{
	ts + 14796 /* "deferred" */, ts + 14805 /* "exclusive" */, ts + 14815 /* "immediate" */, uintptr(0),
}                                                                                                                                                              /* tclsqlite.c:3430:25 */
var azSub = [6]uintptr{ts + 1965 /* "count" */, ts + 14825 /* "depth" */, ts + 14831 /* "hook" */, ts + 14836 /* "new" */, ts + 14840 /* "old" */, uintptr(0)} /* tclsqlite.c:3523:23 */

// Adaptor that provides an objCmd interface to the NRE-enabled
// interface implementation.
func DbObjCmdAdaptor(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:3674:26: */
	return tcl.XTcl_NRCallObjProc(tls, interp, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{DbObjCmd})), cd, objc, objv)
}

// Issue the usage message when the "sqlite3" command arguments are
// incorrect.
func sqliteCmdUsage(tls *libc.TLS, interp uintptr, objv uintptr) int32 { /* tclsqlite.c:3688:12: */
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,

		ts+14844 /* "HANDLE ?FILENAME..." */)
	return TCL_ERROR
}

//   sqlite3 DBNAME FILENAME ?-vfs VFSNAME? ?-key KEY? ?-readonly BOOLEAN?
//                           ?-create BOOLEAN? ?-nomutex BOOLEAN?
//                           ?-nofollow BOOLEAN?
//
// This is the main Tcl command.  When the "sqlite" Tcl command is
// invoked, this routine runs to process that command.
//
// The first argument, DBNAME, is an arbitrary name for a new
// database connection.  This command creates a new command named
// DBNAME that is used to control that connection.  The database
// connection is deleted when the DBNAME command is deleted.
//
// The second argument is the name of the database file.
//
func DbMain(tls *libc.TLS, cd uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* tclsqlite.c:3716:26: */
	bp := tls.Alloc(336)
	defer tls.Free(336)

	var p uintptr
	var zArg uintptr
	var zErrMsg uintptr
	var i int32
	var zFile uintptr = uintptr(0)
	var zVfs uintptr = uintptr(0)
	var flags int32
	*(*int32)(unsafe.Pointer(bp + 112 /* bTranslateFileName */)) = 1
	// var translatedFilename Tcl_DString at bp+120, 216

	var rc int32

	// In normal use, each TCL interpreter runs in a single thread.  So
	// by default, we can turn off mutexing on SQLite database connections.
	// However, for testing purposes it is useful to have mutexes turned
	// on.  So, by default, mutexes default off.  But if compiled with
	// SQLITE_TCL_DEFAULT_FULLMUTEX then mutexes default on.
	flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_NOMUTEX

	if objc == 1 {
		return sqliteCmdUsage(tls, interp, objv)
	}
	if objc == 2 {
		zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(0))
		if libc.Xstrcmp(tls, zArg, ts+14990) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_libversion(tls), uintptr(0)))
			return TCL_OK
		}
		if libc.Xstrcmp(tls, zArg, ts+14999) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3_sourceid(tls), uintptr(0)))
			return TCL_OK
		}
		if libc.Xstrcmp(tls, zArg, ts+15009) == 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+15020 /* "0" */, uintptr(0)))
			return TCL_OK
		}
		if int32(*(*int8)(unsafe.Pointer(zArg))) == '-' {
			return sqliteCmdUsage(tls, interp, objv)
		}
	}
	for i = 2; i < objc; i++ {
		zArg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
		if int32(*(*int8)(unsafe.Pointer(zArg))) != '-' {
			if zFile != uintptr(0) {
				return sqliteCmdUsage(tls, interp, objv)
			}
			zFile = zArg
			continue
		}
		if i == objc-1 {
			return sqliteCmdUsage(tls, interp, objv)
		}
		i++
		if libc.Xstrcmp(tls, zArg, ts+15022) == 0 {
			// no-op
		} else if libc.Xstrcmp(tls, zArg, ts+15027) == 0 {
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
		} else if libc.Xstrcmp(tls, zArg, ts+13273) == 0 {
			// var b int32 at bp+88, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+88) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 88)) != 0 {
				flags = flags & libc.CplInt32(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE)
				flags = flags | SQLITE_OPEN_READONLY
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_READONLY)
				flags = flags | SQLITE_OPEN_READWRITE
			}
		} else if libc.Xstrcmp(tls, zArg, ts+15032) == 0 {
			// var b int32 at bp+92, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+92) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 92)) != 0 && flags&SQLITE_OPEN_READONLY == 0 {
				flags = flags | SQLITE_OPEN_CREATE
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_CREATE)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+15040) == 0 {
			// var b int32 at bp+96, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+96) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 96)) != 0 {
				flags = flags | SQLITE_OPEN_NOFOLLOW
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_NOFOLLOW)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+15050) == 0 {
			// var b int32 at bp+100, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+100) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 100)) != 0 {
				flags = flags | SQLITE_OPEN_NOMUTEX
				flags = flags & libc.CplInt32(SQLITE_OPEN_FULLMUTEX)
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_NOMUTEX)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+15059) == 0 {
			// var b int32 at bp+104, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+104) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 104)) != 0 {
				flags = flags | SQLITE_OPEN_FULLMUTEX
				flags = flags & libc.CplInt32(SQLITE_OPEN_NOMUTEX)
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_FULLMUTEX)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+15070) == 0 {
			// var b int32 at bp+108, 4

			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+108) != 0 {
				return TCL_ERROR
			}
			if *(*int32)(unsafe.Pointer(bp + 108)) != 0 {
				flags = flags | SQLITE_OPEN_URI
			} else {
				flags = flags & libc.CplInt32(SQLITE_OPEN_URI)
			}
		} else if libc.Xstrcmp(tls, zArg, ts+15075) == 0 {
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+112) != 0 {
				return TCL_ERROR
			}
		} else {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+13283 /* "unknown option: " */, zArg, uintptr(0)))
			return TCL_ERROR
		}
	}
	zErrMsg = uintptr(0)
	p = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(SqliteDb{})))
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(SqliteDb{})))
	if zFile == uintptr(0) {
		zFile = ts + 584 /* "" */
	}
	if *(*int32)(unsafe.Pointer(bp + 112)) != 0 {
		zFile = tcl.XTcl_TranslateFileName(tls, interp, zFile, bp+120 /* &translatedFilename */)
	}
	rc = sqlite3.Xsqlite3_open_v2(tls, zFile, p, flags, zVfs)
	if *(*int32)(unsafe.Pointer(bp + 112)) != 0 {
		tcl.XTcl_DStringFree(tls, bp+120 /* &translatedFilename */)
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb != 0 {
		if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb) {
			zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+72, sqlite3.Xsqlite3_errmsg(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)))
			sqlite3.Xsqlite3_close(tls, (*SqliteDb)(unsafe.Pointer(p)).Fdb)
			(*SqliteDb)(unsafe.Pointer(p)).Fdb = uintptr(0)
		}
	} else {
		zErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+80, sqlite3.Xsqlite3_errstr(tls, rc)))
	}
	if (*SqliteDb)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, zErrMsg, uintptr(1))
		tcl.XTcl_Free(tls, p)
		sqlite3.Xsqlite3_free(tls, zErrMsg)
		return TCL_ERROR
	}
	(*SqliteDb)(unsafe.Pointer(p)).FmaxStmt = NUM_PREPARED_STMTS
	(*SqliteDb)(unsafe.Pointer(p)).FopenFlags = flags & SQLITE_OPEN_URI
	(*SqliteDb)(unsafe.Pointer(p)).Finterp = interp
	zArg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(0))
	if DbUseNre(tls) != 0 {
		tcl.XTcl_NRCreateCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmdAdaptor})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})),
			p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbDeleteCmd})))
	} else {
		tcl.XTcl_CreateObjCommand(tls, interp, zArg, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbObjCmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{DbDeleteCmd})))
	}
	(*SqliteDb)(unsafe.Pointer(p)).FnRef = 1
	return TCL_OK
}

// Provide a dummy Tcl_InitStubs if we are using this as a static
// library.

// Make sure we have a PACKAGE_VERSION macro defined.  This will be
// defined automatically by the TEA makefile.  But other makefiles
// do not define it.

// Initialize this module.
//
// This Tcl module contains only a single new Tcl command named "sqlite".
// (Hence there is no namespace.  There is no point in using a namespace
// if the extension only supplies one new name!)  The "sqlite" command is
// used to open a new SQLite database.  See the DbMain() routine above
// for additional information.
//
// The EXTERN macros are required by TCL in order to work on windows.
func Sqlite3_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3905:12: */
	var rc int32
	if 1 != 0 {
		rc = TCL_OK
	} else {
		rc = TCL_ERROR
	}
	if rc == TCL_OK {
		tcl.XTcl_CreateObjCommand(tls, interp, ts+15094 /* "sqlite3" */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))
		// The "sqlite" alias is undocumented.  It is here only to support
		// legacy scripts.  All new scripts should use only the "sqlite3"
		// command.
		tcl.XTcl_CreateObjCommand(tls, interp, ts+15102 /* "sqlite" */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{DbMain})), uintptr(0), uintptr(0))
		rc = tcl.XTcl_PkgProvideEx(tls, interp, ts+15094 /* "sqlite3" */, ts+15109 /* "3.37.0" */, uintptr(0))
	}
	return rc
}

func Tclsqlite3_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3919:12: */
	return Sqlite3_Init(tls, interp)
}

func Sqlite3_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3920:12: */
	return TCL_OK
}

func Tclsqlite3_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3921:12: */
	return TCL_OK
}

// Because it accesses the file-system and uses persistent state, SQLite
// is not considered appropriate for safe interpreters.  Hence, we cause
// the _SafeInit() interfaces return TCL_ERROR.
func Sqlite3_SafeInit(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3927:12: */
	return TCL_ERROR
}

func Sqlite3_SafeUnload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3928:12: */
	return TCL_ERROR
}

func Sqlite_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3933:5: */
	return Sqlite3_Init(tls, interp)
}

func Tclsqlite_Init(tls *libc.TLS, interp uintptr) int32 { /* tclsqlite.c:3934:5: */
	return Sqlite3_Init(tls, interp)
}

func Sqlite_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3935:5: */
	return TCL_OK
}

func Tclsqlite_Unload(tls *libc.TLS, interp uintptr, flags int32) int32 { /* tclsqlite.c:3936:5: */
	return TCL_OK
}

// If the TCLSH macro is defined, add code to make a stand-alone program.

// This is the main routine for an ordinary TCL shell.  If there are
// are arguments, run the first argument as a script.  Otherwise,
// read TCL commands from standard input
func tclsh_main_loop(tls *libc.TLS) uintptr { /* tclsqlite.c:3948:19: */
	return uintptr(unsafe.Pointer(&zMainloop))
}

var zMainloop = *(*[431]int8)(unsafe.Pointer(ts + 15116 /* "if {[llength $ar..." */)) /* tclsqlite.c:3949:21 */

func main1(tls *libc.TLS, argc int32, argv uintptr) int32 { /* tclsqlite.c:3983:18: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var interp uintptr
	var i int32
	var zScript uintptr = uintptr(0)
	// var zArgc [32]int8 at bp+32, 32

	if libc.Xgetenv(tls, ts+15547) != 0 {
		if libc.Xisatty(tls, 0) != 0 && libc.Xisatty(tls, 2) != 0 {
			libc.Xfprintf(tls, libc.X__stderrp,
				ts+15566, /* "attach debugger ..." */
				libc.VaList(bp, libc.Xgetpid(tls)))
			libc.Xfgetc(tls, libc.X__stdinp)
		} else {
			libc.Xraise(tls, SIGTRAP)
		}
	}

	// Call sqlite3_shutdown() once before doing anything else. This is to
	// test that sqlite3_shutdown() can be safely called by a process before
	// sqlite3_initialize() is.
	sqlite3.Xsqlite3_shutdown(tls)

	tcl.XTcl_FindExecutable(tls, *(*uintptr)(unsafe.Pointer(argv)))
	tcl.XTcl_SetSystemEncoding(tls, uintptr(0), ts+15628 /* "utf-8" */)
	interp = tcl.XTcl_CreateInterp(tls)
	Sqlite3_Init(tls, interp)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([32]int8{})), bp+32 /* &zArgc[0] */, ts+1333 /* "%d" */, libc.VaList(bp+8, argc-1))
	tcl.XTcl_SetVar2(tls, interp, ts+15634 /* "argc" */, uintptr(0), bp+32 /* &zArgc[0] */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+15639 /* "argv0" */, uintptr(0), *(*uintptr)(unsafe.Pointer(argv)), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+15645 /* "argv" */, uintptr(0), ts+584 /* "" */, TCL_GLOBAL_ONLY)
	for i = 1; i < argc; i++ {
		tcl.XTcl_SetVar2(tls, interp, ts+15645 /* "argv" */, uintptr(0), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), TCL_GLOBAL_ONLY|TCL_LIST_ELEMENT|TCL_APPEND_VALUE)
	}
	zScript = sqlite3TestInit(tls, interp)
	if zScript == uintptr(0) {
		zScript = tclsh_main_loop(tls)
	}
	if tcl.XTcl_GlobalEval(tls, interp, zScript) != TCL_OK {
		var zInfo uintptr = tcl.XTcl_GetVar2(tls, interp, ts+15650 /* "errorInfo" */, uintptr(0), TCL_GLOBAL_ONLY)
		if zInfo == uintptr(0) {
			zInfo = tcl.XTcl_GetStringResult(tls, interp)
		}
		libc.Xfprintf(tls, libc.X__stderrp, ts+15660 /* "%s: %s\n" */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv)), zInfo))
		return 1
	}
	return 0
}

// CAPI3REF: Dynamically Typed Value Object
// KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
//
// SQLite uses the sqlite3_value object to represent all values
// that can be stored in a database table. SQLite uses dynamic typing
// for the values it stores.  ^Values stored in sqlite3_value objects
// can be integers, floating point values, strings, BLOBs, or NULL.
//
// An sqlite3_value object may be either "protected" or "unprotected".
// Some interfaces require a protected sqlite3_value.  Other interfaces
// will accept either a protected or an unprotected sqlite3_value.
// Every interface that accepts sqlite3_value arguments specifies
// whether or not it requires a protected sqlite3_value.  The
// [sqlite3_value_dup()] interface can be used to construct a new
// protected sqlite3_value from an unprotected sqlite3_value.
//
// The terms "protected" and "unprotected" refer to whether or not
// a mutex is held.  An internal mutex is held for a protected
// sqlite3_value object but no mutex is held for an unprotected
// sqlite3_value object.  If SQLite is compiled to be single-threaded
// (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
// or if SQLite is run in one of reduced mutex modes
// [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
// then there is no distinction between protected and unprotected
// sqlite3_value objects and they can be used interchangeably.  However,
// for maximum code portability it is recommended that applications
// still make the distinction between protected and unprotected
// sqlite3_value objects even when not strictly required.
//
// ^The sqlite3_value objects that are passed as parameters into the
// implementation of [application-defined SQL functions] are protected.
// ^The sqlite3_value object returned by
// [sqlite3_column_value()] is unprotected.
// Unprotected sqlite3_value objects may only be used as arguments
// to [sqlite3_result_value()], [sqlite3_bind_value()], and
// [sqlite3_value_dup()].
// The [sqlite3_value_blob | sqlite3_value_type()] family of
// interfaces require protected sqlite3_value objects.
type sqlite3_value = sqlite3_value1 /* sqlite3.h:4354:30 */

// CAPI3REF: SQL Function Context Object
//
// The context in which an SQL function executes is stored in an
// sqlite3_context object.  ^A pointer to an sqlite3_context object
// is always first parameter to [application-defined SQL functions].
// The application-defined SQL function implementation will pass this
// pointer through into calls to [sqlite3_result_int | sqlite3_result()],
// [sqlite3_aggregate_context()], [sqlite3_user_data()],
// [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],
// and/or [sqlite3_set_auxdata()].
type sqlite3_context = sqlite3_context1 /* sqlite3.h:4368:32 */
type PreUpdate = PreUpdate1             /* sqliteInt.h:1184:26 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Header file for the Virtual DataBase Engine (VDBE)
//
// This header defines the interface to the virtual database engine
// or VDBE.  The VDBE implements an abstract machine that runs a
// simple program to access and modify the underlying database.
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Chris Torek.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdio.h	8.5 (Berkeley) 4/29/95
// $FreeBSD$

// A single VDBE is an opaque structure named "Vdbe".  Only routines
// in the source file sqliteVdbe.c are allowed to see the insides
// of this structure.
type Vdbe = Vdbe1 /* vdbe.h:27:21 */

// The names of the following types declared in vdbeInt.h are required
// for the VdbeOp definition.
type Mem = sqlite3_value1 /* vdbe.h:33:30 */

// 2003 September 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This is the header file for information that is private to the
// VDBE.  This information used to all be at the top of the single
// source code file "vdbe.c".  When that file became too big (over
// 6000 lines long) it was split up into several smaller files and
// this header information was factored out.

// The maximum number of times that a statement will try to reparse
// itself before giving up and returning SQLITE_SCHEMA.

// VDBE_DISPLAY_P4 is true or false depending on whether or not the
// "explain" P4 display logic is enabled.

// SQL is translated into a sequence of instructions to be
// executed by a virtual machine.  Each instruction is an instance
// of the following structure.
type Op = VdbeOp1 /* vdbeInt.h:46:23 */

// Boolean values
type Bool = uint32 /* vdbeInt.h:51:18 */

// Elements of the linked list at Vdbe.pAuxData
type AuxData1 = struct {
	FiAuxOp     int32
	FiAuxArg    int32
	FpAux       uintptr
	FxDeleteAux uintptr
	FpNextAux   uintptr
} /* sqlite3.h:4368:9 */

// Elements of the linked list at Vdbe.pAuxData
type AuxData = AuxData1 /* vdbeInt.h:57:24 */

// Types of VDBE cursors

// A VdbeCursor is an superclass (a wrapper) for various cursor objects:
//
//      * A b-tree cursor
//          -  In the main database or in an ephemeral database
//          -  On either an index or a table
//      * A sorter
//      * A virtual table
//      * A one-row "pseudotable" stored in a single register
type VdbeCursor1 = struct {
	FeCurType       u8
	FiDb            i8
	FnullRow        u8
	FdeferredMoveto u8
	FisTable        u8
	F__ccgo_pad1    [3]byte
	FisEphemeral    uint8 /* Bool isEphemeral: 1, Bool useRandomRowid: 1, Bool isOrdered: 1, Bool hasBeenDuped: 1 */
	F__ccgo_pad2    [1]byte
	FseekHit        u16
	F__ccgo_pad3    [4]byte
	FpBtx           uintptr
	FseqCount       i64
	FaAltMap        uintptr
	FcacheStatus    u32
	FseekResult     int32
	FpAltCursor     uintptr
	Fuc             struct{ FpCursor uintptr }
	FpKeyInfo       uintptr
	FiHdrOffset     u32
	FpgnoRoot       Pgno
	FnField         i16
	FnHdrParsed     u16
	F__ccgo_pad4    [4]byte
	FmovetoTarget   i64
	FaOffset        uintptr
	FaRow           uintptr
	FpayloadSize    u32
	FszRow          u32
	FaType          [1]u32
	F__ccgo_pad5    [4]byte
} /* sqlite3.h:4368:9 */

// Types of VDBE cursors

// A VdbeCursor is an superclass (a wrapper) for various cursor objects:
//
//      * A b-tree cursor
//          -  In the main database or in an ephemeral database
//          -  On either an index or a table
//      * A sorter
//      * A virtual table
//      * A one-row "pseudotable" stored in a single register
type VdbeCursor = VdbeCursor1 /* vdbeInt.h:75:27 */

// A value for VdbeCursor.cacheStatus that means the cache is always invalid.

// When a sub-program is executed (OP_Program), a structure of this type
// is allocated to store the current value of the program counter, as
// well as the current memory cell array and various other frame specific
// values stored in the Vdbe struct. When the sub-program is finished,
// these values are copied back to the Vdbe from the VdbeFrame structure,
// restoring the state of the VM to as it was before the sub-program
// began executing.
//
// The memory for a VdbeFrame object is allocated and managed by a memory
// cell in the parent (calling) frame. When the memory cell is deleted or
// overwritten, the VdbeFrame object is not freed immediately. Instead, it
// is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame
// list is deleted when the VM is reset in VdbeHalt(). The reason for doing
// this instead of deleting the VdbeFrame immediately is to avoid recursive
// calls to sqlite3VdbeMemRelease() when the memory cells belonging to the
// child frame are released.
//
// The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is
// set to NULL if the currently executing frame is the main program.
type VdbeFrame1 = struct {
	Fv         uintptr
	FpParent   uintptr
	FaOp       uintptr
	FanExec    uintptr
	FaMem      uintptr
	FapCsr     uintptr
	FaOnce     uintptr
	Ftoken     uintptr
	FlastRowid i64
	FpAuxData  uintptr
	FnCursor   int32
	Fpc        int32
	FnOp       int32
	FnMem      int32
	FnChildMem int32
	FnChildCsr int32
	FnChange   i64
	FnDbChange i64
} /* sqlite3.h:4368:9 */

// A value for VdbeCursor.cacheStatus that means the cache is always invalid.

// When a sub-program is executed (OP_Program), a structure of this type
// is allocated to store the current value of the program counter, as
// well as the current memory cell array and various other frame specific
// values stored in the Vdbe struct. When the sub-program is finished,
// these values are copied back to the Vdbe from the VdbeFrame structure,
// restoring the state of the VM to as it was before the sub-program
// began executing.
//
// The memory for a VdbeFrame object is allocated and managed by a memory
// cell in the parent (calling) frame. When the memory cell is deleted or
// overwritten, the VdbeFrame object is not freed immediately. Instead, it
// is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame
// list is deleted when the VM is reset in VdbeHalt(). The reason for doing
// this instead of deleting the VdbeFrame immediately is to avoid recursive
// calls to sqlite3VdbeMemRelease() when the memory cells belonging to the
// child frame are released.
//
// The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is
// set to NULL if the currently executing frame is the main program.
type VdbeFrame = VdbeFrame1 /* vdbeInt.h:162:26 */

// Magic number for sanity checking on VdbeFrame objects

// Return a pointer to the array of registers allocated for use
// by a VdbeFrame.

// Internally, the vdbe manipulates nearly all SQL values as Mem
// structures. Each Mem struct may cache multiple representations (string,
// integer etc.) of the same value.
type MemValue = struct{ Fr float64 } /* sqlite3.h:4354:9 */

// A bitfield type for use inside of structures.  Always follow with :N where
// N is the number of bits.
type bft = uint32 /* vdbeInt.h:345:18 */ // Bit Field Type

// The ScanStatus object holds a single value for the
// sqlite3_stmt_scanstatus() interface.
type ScanStatus1 = struct {
	FaddrExplain int32
	FaddrLoop    int32
	FaddrVisit   int32
	FiSelectID   int32
	FnEst        LogEst
	F__ccgo_pad1 [6]byte
	FzName       uintptr
} /* vdbeInt.h:350:9 */

// Bit Field Type

// The ScanStatus object holds a single value for the
// sqlite3_stmt_scanstatus() interface.
type ScanStatus = ScanStatus1 /* vdbeInt.h:350:27 */

// The DblquoteStr object holds the text of a double-quoted
// string for a prepared statement.  A linked list of these objects
// is constructed during statement parsing and is held on Vdbe.pDblStr.
// When computing a normalized SQL statement for an SQL statement, that
// list is consulted for each double-quoted identifier to see if the
// identifier should really be a string literal.
type DblquoteStr1 = struct {
	FpNextStr uintptr
	Fz        [8]int8
} /* vdbeInt.h:367:9 */

// The DblquoteStr object holds the text of a double-quoted
// string for a prepared statement.  A linked list of these objects
// is constructed during statement parsing and is held on Vdbe.pDblStr.
// When computing a normalized SQL statement for an SQL statement, that
// list is consulted for each double-quoted identifier to see if the
// identifier should really be a string literal.
type DblquoteStr = DblquoteStr1 /* vdbeInt.h:367:28 */

// Convert text generated by the "%p" conversion format back into
// a pointer.
func testHexToInt(tls *libc.TLS, h int32) int32 { /* test1.c:44:12: */
	if h >= '0' && h <= '9' {
		return h - '0'
	} else if h >= 'a' && h <= 'f' {
		return h - 'a' + 10
	} else {

		return h - 'A' + 10
	}
	return int32(0)
}

func sqlite3TestTextToPtr(tls *libc.TLS, z uintptr) uintptr { /* test1.c:54:6: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	// var p uintptr at bp, 8

	// var v u64 at bp+8, 8

	// var v2 u32 at bp+16, 4

	if int32(*(*int8)(unsafe.Pointer(z))) == '0' && int32(*(*int8)(unsafe.Pointer(z + 1))) == 'x' {
		z += uintptr(2)
	}
	*(*u64)(unsafe.Pointer(bp + 8 /* v */)) = uint64(0)
	for *(*int8)(unsafe.Pointer(z)) != 0 {
		*(*u64)(unsafe.Pointer(bp + 8 /* v */)) = *(*u64)(unsafe.Pointer(bp + 8))<<4 + u64(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(z)))))
		z++
	}
	if uint64(unsafe.Sizeof(uintptr(0))) == uint64(unsafe.Sizeof(u64(0))) {
		libc.Xmemcpy(tls, bp /* &p */, bp+8 /* &v */, uint64(unsafe.Sizeof(uintptr(0))))
	} else {

		*(*u32)(unsafe.Pointer(bp + 16 /* v2 */)) = u32(*(*u64)(unsafe.Pointer(bp + 8 /* v */)))
		libc.Xmemcpy(tls, bp /* &p */, bp+16 /* &v2 */, uint64(unsafe.Sizeof(uintptr(0))))
	}
	return *(*uintptr)(unsafe.Pointer(bp /* p */))
}

// A TCL command that returns the address of the sqlite* pointer
// for an sqlite connection instance.  Bad things happen if the
// input is not an sqlite connection.
func get_sqlite_pointer(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:82:26: */
	bp := tls.Alloc(212)
	defer tls.Free(212)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp+48, 64

	// var zBuf [100]int8 at bp+112, 100

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+15668 /* "SQLITE-CONNECTIO..." */)
		return TCL_ERROR
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15686, /* "command not foun..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0)))
		return TCL_ERROR
	}
	p = (*Tcl_CmdInfo)(unsafe.Pointer(bp + 48 /* &cmdInfo */)).FobjClientData
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+112 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp+24, (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+112 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Decode a pointer to an sqlite3 object.
func getDbPointer(tls *libc.TLS, interp uintptr, zA uintptr, ppDb uintptr) int32 { /* test1.c:109:5: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var p uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 64

	if tcl.XTcl_GetCommandInfo(tls, interp, zA, bp) != 0 {
		p = (*Tcl_CmdInfo)(unsafe.Pointer(bp /* &cmdInfo */)).FobjClientData
		*(*uintptr)(unsafe.Pointer(ppDb)) = (*struct{ Fdb uintptr })(unsafe.Pointer(p)).Fdb
	} else {
		*(*uintptr)(unsafe.Pointer(ppDb)) = sqlite3TestTextToPtr(tls, zA)
	}
	return TCL_OK
}

// Convert an sqlite3_stmt* into an sqlite3*.  This depends on the
// fact that the sqlite3* is the first field in the Vdbe structure.

// Check a return value to make sure it agrees with the results
// from sqlite3_errcode.
func sqlite3TestErrCode(tls *libc.TLS, interp uintptr, db uintptr, rc int32) int32 { /* test1.c:144:5: */
	bp := tls.Alloc(248)
	defer tls.Free(248)

	if sqlite3.Xsqlite3_threadsafe(tls) == 0 && rc != SQLITE_MISUSE && rc != SQLITE_OK &&
		sqlite3.Xsqlite3_errcode(tls, db) != rc {
		// var zBuf [200]int8 at bp+48, 200

		var r2 int32 = sqlite3.Xsqlite3_errcode(tls, db)
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+48, /* &zBuf[0] */
			ts+15706, /* "error code %s (%..." */
			libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), rc, sqlite3.Xsqlite3ErrName(tls, r2), r2))
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+48 /* &zBuf[0] */, 0))
		return 1
	}
	return 0
}

// Decode a pointer to an sqlite3_stmt object.
func getStmtPointer(tls *libc.TLS, interp uintptr, zArg uintptr, ppStmt uintptr) int32 { /* test1.c:162:12: */
	*(*uintptr)(unsafe.Pointer(ppStmt)) = sqlite3TestTextToPtr(tls, zArg)
	return TCL_OK
}

// Generate a text representation of a pointer that can be understood
// by the getDbPointer and getVmPointer routines above.
//
// The problem is, on some machines (Solaris) if you do a printf with
// "%p" you cannot turn around and do a scanf with the same "%p" and
// get your pointer back.  You have to prepend a "0x" before it will
// work.  Or at least that is what is reported to me (drh).  But this
// behavior varies from machine to machine.  The solution used her is
// to test the string right after it is generated to see if it can be
// understood by scanf, and if not, try prepending an "0x" to see if
// that helps.  If nothing works, a fatal error is generated.
func sqlite3TestMakePointerStr(tls *libc.TLS, interp uintptr, zPtr uintptr, p uintptr) int32 { /* test1.c:184:5: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, 100, zPtr, ts+10721 /* "%p" */, libc.VaList(bp, p))
	return TCL_OK
}

// The callback routine for sqlite3_exec_printf().
func exec_printf_cb(tls *libc.TLS, pArg uintptr, argc int32, argv uintptr, name uintptr) int32 { /* test1.c:192:12: */
	var str uintptr = pArg
	var i int32

	if (*Tcl_DString)(unsafe.Pointer(str)).Flength == 0 {
		for i = 0; i < argc; i++ {
			tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(name + uintptr(i)*8)) != 0 {
					return *(*uintptr)(unsafe.Pointer(name + uintptr(i)*8))
				}
				return ts + 5846 /* "NULL" */
			}())
		}
	}
	for i = 0; i < argc; i++ {
		tcl.XTcl_DStringAppendElement(tls, str, func() uintptr {
			if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) != 0 {
				return *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))
			}
			return ts + 5846 /* "NULL" */
		}())
	}
	return 0
}

// The I/O tracing callback.

// Usage:  io_trace FILENAME
//
// Turn I/O tracing on or off.  If FILENAME is not an empty string,
// I/O tracing begins going into FILENAME. If FILENAME is an empty
// string, I/O tracing is turned off.
func test_io_trace(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:228:26: */
	return TCL_OK
}

// Usage:  clang_sanitize_address
//
// Returns true if the program was compiled using clang with the
// -fsanitize=address switch on the command line. False otherwise.
//
// Also return true if the OMIT_MISUSE environment variable exists.
func clang_sanitize_address(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:269:26: */
	var res int32 = 0
	if res == 0 && libc.Xgetenv(tls, ts+15764) != uintptr(0) {
		res = 1
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return TCL_OK
}

// Usage:  sqlite3_exec_printf  DB  FORMAT  STRING
//
// Invoke the sqlite3_exec_printf() interface using the open database
// DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
func test_exec_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:296:26: */
	bp := tls.Alloc(310)
	defer tls.Free(310)

	// var db uintptr at bp+48, 8

	// var str Tcl_DString at bp+56, 216

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)) = uintptr(0)
	var zSql uintptr
	// var zBuf [30]int8 at bp+280, 30

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15802 /* " DB FORMAT STRIN..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+56 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 3*8))))
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+56 /* &str */, bp+272 /* &zErr */)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+280 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+280 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 56)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+56 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 272)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_exec_hex  DB  HEX
//
// Invoke the sqlite3_exec() on a string that is obtained by translating
// HEX into ASCII.  Most characters are translated as is.  %HH becomes
// a hex character.
func test_exec_hex(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:334:26: */
	bp := tls.Alloc(806)
	defer tls.Free(806)

	// var db uintptr at bp+40, 8

	// var str Tcl_DString at bp+552, 216

	var rc int32
	var i int32
	var j int32
	*(*uintptr)(unsafe.Pointer(bp + 768 /* zErr */)) = uintptr(0)
	var zHex uintptr
	// var zSql [501]int8 at bp+48, 501

	// var zBuf [30]int8 at bp+776, 30

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15820 /* " DB HEX" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+40) != 0 {
		return TCL_ERROR
	}
	zHex = *(*uintptr)(unsafe.Pointer(argv + 2*8))
	i = libc.AssignInt32(&j, 0)
__1:
	if !(uint64(i) < uint64(unsafe.Sizeof([501]int8{}))-uint64(1) && *(*int8)(unsafe.Pointer(zHex + uintptr(j))) != 0) {
		goto __3
	}
	{
		if int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j)))) == '%' && *(*int8)(unsafe.Pointer(zHex + uintptr(j+2))) != 0 && *(*int8)(unsafe.Pointer(zHex + uintptr(j+2))) != 0 {
			*(*int8)(unsafe.Pointer(bp + 48 /* &zSql[0] */ + uintptr(i))) = int8(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j+1)))))<<4 + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zHex + uintptr(j+2))))))
			j = j + 2
		} else {
			*(*int8)(unsafe.Pointer(bp + 48 /* &zSql[0] */ + uintptr(i))) = *(*int8)(unsafe.Pointer(zHex + uintptr(j)))
		}

	}
	goto __2
__2:
	i++
	j++
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(bp + 48 /* &zSql[0] */ + uintptr(i))) = int8(0)
	tcl.XTcl_DStringInit(tls, bp+552 /* &str */)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), bp+48 /* &zSql[0] */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+552 /* &str */, bp+768 /* &zErr */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+776 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+32, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+776 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 552)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 768 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+552 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 768)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 768 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 40)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  db_enter DB
//         db_leave DB
//
// Enter or leave the mutex on a database connection.
func db_enter(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:380:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	return TCL_OK
}

func db_leave(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:396:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	return TCL_OK
}

// Usage:  sqlite3_exec  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB
func test_exec(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:418:26: */
	bp := tls.Alloc(310)
	defer tls.Free(310)

	// var db uintptr at bp+48, 8

	// var str Tcl_DString at bp+56, 216

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)) = uintptr(0)
	var zSql uintptr
	var i int32
	var j int32
	// var zBuf [30]int8 at bp+280, 30

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15832 /* " DB SQL" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+56 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	for i = libc.AssignInt32(&j, 0); *(*int8)(unsafe.Pointer(zSql + uintptr(i))) != 0; {
		if int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i)))) == '%' {
			*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = int8(testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i+1)))))<<4 + testHexToInt(tls, int32(*(*int8)(unsafe.Pointer(zSql + uintptr(i+2))))))
			i = i + 3
		} else {
			*(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(zSql + uintptr(libc.PostIncInt32(&i, 1))))
		}
	}
	*(*int8)(unsafe.Pointer(zSql + uintptr(j))) = int8(0)
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{exec_printf_cb})), bp+56 /* &str */, bp+272 /* &zErr */)
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+280 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+280 /* &zBuf[0] */)
	tcl.XTcl_AppendElement(tls, interp, func() uintptr {
		if rc == SQLITE_OK {
			return (*Tcl_DString)(unsafe.Pointer(bp + 56)).Fstring
		}
		return *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */))
	}())
	tcl.XTcl_DStringFree(tls, bp+56 /* &str */)
	if *(*uintptr)(unsafe.Pointer(bp + 272)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 272 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_exec_nr  DB  SQL
//
// Invoke the sqlite3_exec interface using the open database DB.  Discard
// all results
func test_exec_nr(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:465:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var db uintptr at bp+32, 8

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 40 /* zErr */)) = uintptr(0)
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15832 /* " DB SQL" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_exec(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), uintptr(0), uintptr(0), bp+40 /* &zErr */)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_mprintf_z_test  SEPARATOR  ARG0  ARG1 ...
//
// Test the %z format of sqlite_mprintf().  Use multiple mprintf() calls to
// concatenate arg0 through argn using separator as the separator.
// Return the result.
func test_mprintf_z(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:492:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zResult uintptr = uintptr(0)
	var i int32

	for i = 2; i < argc && (i == 2 || zResult != 0); i++ {
		zResult = sqlite3.Xsqlite3_mprintf(tls, ts+15840 /* "%z%s%s" */, libc.VaList(bp, zResult, *(*uintptr)(unsafe.Pointer(argv + 1*8)), *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, zResult, 0))
	sqlite3.Xsqlite3_free(tls, zResult)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_n_test  STRING
//
// Test the %n format of sqlite_mprintf().  Return the length of the
// input string.
func test_mprintf_n(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:515:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var zStr uintptr
	*(*int32)(unsafe.Pointer(bp + 16 /* n */)) = 0
	zStr = sqlite3.Xsqlite3_mprintf(tls, ts+15847 /* "%s%n" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+16 /* &n */))
	sqlite3.Xsqlite3_free(tls, zStr)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16 /* n */))))
	return TCL_OK
}

// Usage:  sqlite3_snprintf_int  SIZE FORMAT  INT
//
// Test the of sqlite3_snprintf() routine.  SIZE is the size of the
// output buffer in bytes.  The maximum size is 100.  FORMAT is the
// format string.  INT is a single integer argument.  The FORMAT
// string must require no more than this one integer argument.  If
// You pass in a format string that requires more than one argument,
// bad things will happen.
func test_snprintf_int(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:539:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	// var zStr [100]int8 at bp+24, 100

	var n int32 = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	var zFormat uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*8))
	var a1 int32 = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))
	if uint64(n) > uint64(unsafe.Sizeof([100]int8{})) {
		n = int32(unsafe.Sizeof([100]int8{}))
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24 /* &zStr[0] */, ts+15852 /* "abcdefghijklmnop..." */, 0)
	sqlite3.Xsqlite3_snprintf(tls, n, bp+24 /* &zStr[0] */, zFormat, libc.VaList(bp, a1))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, bp+24 /* &zStr[0] */, 0))
	return TCL_OK
}

// Usage:  sqlite3_get_table_printf  DB  FORMAT  STRING  ?--no-counts?
//
// Invoke the sqlite3_get_table_printf() interface using the open database
// DB.  The SQL is the string FORMAT.  The format string should contain
// one %s or %q.  STRING is the value inserted into %s or %q.
func test_get_table_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:565:26: */
	bp := tls.Alloc(350)
	defer tls.Free(350)

	// var db uintptr at bp+72, 8

	// var str Tcl_DString at bp+80, 216

	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 304 /* zErr */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 312 /* nRow */)) = 0
	*(*int32)(unsafe.Pointer(bp + 316 /* nCol */)) = 0
	// var aResult uintptr at bp+296, 8

	var i int32
	// var zBuf [30]int8 at bp+320, 30

	var zSql uintptr
	*(*int32)(unsafe.Pointer(bp + 64 /* resCount */)) = -1
	if argc == 5 {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+64) != 0 {
			return TCL_ERROR
		}
	}
	if argc != 4 && argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15879 /* " DB FORMAT STRIN..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_DStringInit(tls, bp+80 /* &str */)
	zSql = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 3*8))))
	if argc == 5 {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* db */)), zSql, bp+296 /* &aResult */, uintptr(0), uintptr(0), bp+304 /* &zErr */)
	} else {
		rc = sqlite3.Xsqlite3_get_table(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* db */)), zSql, bp+296 /* &aResult */, bp+312 /* &nRow */, bp+316 /* &nCol */, bp+304 /* &zErr */)
		*(*int32)(unsafe.Pointer(bp + 64 /* resCount */)) = (*(*int32)(unsafe.Pointer(bp + 312)) + 1) * *(*int32)(unsafe.Pointer(bp + 316))
	}
	sqlite3.Xsqlite3_free(tls, zSql)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+320 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+40, rc))
	tcl.XTcl_AppendElement(tls, interp, bp+320 /* &zBuf[0] */)
	if rc == SQLITE_OK {
		if argc == 4 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+320 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 312 /* nRow */))))
			tcl.XTcl_AppendElement(tls, interp, bp+320 /* &zBuf[0] */)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+320 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+56, *(*int32)(unsafe.Pointer(bp + 316 /* nCol */))))
			tcl.XTcl_AppendElement(tls, interp, bp+320 /* &zBuf[0] */)
		}
		for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* resCount */)); i++ {
			tcl.XTcl_AppendElement(tls, interp, func() uintptr {
				if *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296)) + uintptr(i)*8)) != 0 {
					return *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296 /* aResult */)) + uintptr(i)*8))
				}
				return ts + 5846 /* "NULL" */
			}())
		}
	} else {
		tcl.XTcl_AppendElement(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 304 /* zErr */)))
	}
	sqlite3.Xsqlite3_free_table(tls, *(*uintptr)(unsafe.Pointer(bp + 296 /* aResult */)))
	if *(*uintptr)(unsafe.Pointer(bp + 304)) != 0 {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 304 /* zErr */)))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 72)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_last_insert_rowid DB
//
// Returns the integer ROWID of the most recent insert.
func test_last_rowid(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:628:26: */
	bp := tls.Alloc(94)
	defer tls.Free(94)

	// var db uintptr at bp+56, 8

	// var zBuf [30]int8 at bp+64, 30

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), ts+15905 /* " DB\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+56) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+64 /* &zBuf[0] */, ts+11723 /* "%lld" */, libc.VaList(bp+32, sqlite3.Xsqlite3_last_insert_rowid(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+64 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:  sqlite3_key DB KEY
//
// Set the codec key.
func test_key(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:652:26: */
	return TCL_OK
}

// Usage:  sqlite3_rekey DB KEY
//
// Change the codec key.
func test_rekey(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:666:26: */
	return TCL_OK
}

// Usage:  sqlite3_close DB
//
// Closes the database opened by sqlite3_open.
func sqlite_test_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:680:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15910 /* " FILENAME\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage:  sqlite3_close_v2 DB
//
// Closes the database opened by sqlite3_open.
func sqlite_test_close_v2(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:704:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15910 /* " FILENAME\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_close_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Implementation of the x_coalesce() function.
// Return the first argument non-NULL argument.
func t1_ifnullFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:727:13: */
	var i int32
	for i = 0; i < argc; i++ {
		if SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) {
			var n int32 = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))),
				n, libc.UintptrFromInt32(-1))
			break
		}
	}
}

// These are test functions.    hex8() interprets its argument as
// UTF8 and returns a hex encoding.  hex16le() interprets its argument
// as UTF16le and returns a hex encoding.
func hex8Func(tls *libc.TLS, p uintptr, argc int32, argv uintptr) { /* test1.c:748:13: */
	bp := tls.Alloc(208)
	defer tls.Free(208)

	var z uintptr
	var i int32
	// var zBuf [200]int8 at bp+8, 200

	z = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; uint64(i) < uint64(unsafe.Sizeof([200]int8{}))/uint64(2)-uint64(2) && *(*uint8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		sqlite3.Xsqlite3_snprintf(tls, int32(uint64(unsafe.Sizeof([200]int8{}))-uint64(i*2)), bp+8+uintptr(i*2), ts+15921 /* "%02x" */, libc.VaList(bp, int32(*(*uint8)(unsafe.Pointer(z + uintptr(i))))))
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zBuf[0] */ + uintptr(i*2))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, p, bp+8 /* zBuf */, -1, libc.UintptrFromInt32(-1))
}

func hex16Func(tls *libc.TLS, p uintptr, argc int32, argv uintptr) { /* test1.c:760:13: */
	bp := tls.Alloc(408)
	defer tls.Free(408)

	var z uintptr
	var i int32
	// var zBuf [400]int8 at bp+8, 400

	z = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; uint64(i) < uint64(unsafe.Sizeof([400]int8{}))/uint64(4)-uint64(4) && *(*uint16)(unsafe.Pointer(z + uintptr(i)*2)) != 0; i++ {
		sqlite3.Xsqlite3_snprintf(tls, int32(uint64(unsafe.Sizeof([400]int8{}))-uint64(i*4)), bp+8+uintptr(i*4), ts+15926 /* "%04x" */, libc.VaList(bp, int32(*(*uint16)(unsafe.Pointer(z + uintptr(i)*2)))&0xff))
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zBuf[0] */ + uintptr(i*4))) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, p, bp+8 /* zBuf */, -1, libc.UintptrFromInt32(-1))
}

// A structure into which to accumulate text.
type dstr = struct {
	FnAlloc int32
	FnUsed  int32
	Fz      uintptr
} /* test1.c:776:1 */

// Append text to a dstr
func dstrAppend(tls *libc.TLS, p uintptr, z uintptr, divider int32) { /* test1.c:785:13: */
	var n int32 = int32(libc.Xstrlen(tls, z))
	if (*dstr)(unsafe.Pointer(p)).FnUsed+n+2 > (*dstr)(unsafe.Pointer(p)).FnAlloc {
		var zNew uintptr
		(*dstr)(unsafe.Pointer(p)).FnAlloc = (*dstr)(unsafe.Pointer(p)).FnAlloc*2 + n + 200
		zNew = sqlite3.Xsqlite3_realloc(tls, (*dstr)(unsafe.Pointer(p)).Fz, (*dstr)(unsafe.Pointer(p)).FnAlloc)
		if zNew == uintptr(0) {
			sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(p)).Fz)
			libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(dstr{})))
			return
		}
		(*dstr)(unsafe.Pointer(p)).Fz = zNew
	}
	if divider != 0 && (*dstr)(unsafe.Pointer(p)).FnUsed > 0 {
		*(*int8)(unsafe.Pointer((*dstr)(unsafe.Pointer(p)).Fz + uintptr(libc.PostIncInt32(&(*dstr)(unsafe.Pointer(p)).FnUsed, 1)))) = int8(divider)
	}
	libc.Xmemcpy(tls, (*dstr)(unsafe.Pointer(p)).Fz+uintptr((*dstr)(unsafe.Pointer(p)).FnUsed), z, uint64(n+1))
	*(*int32)(unsafe.Pointer(p + 4)) += n
}

// Invoked for each callback from sqlite3ExecFunc
func execFuncCallback(tls *libc.TLS, pData uintptr, argc int32, argv uintptr, NotUsed uintptr) int32 { /* test1.c:808:12: */
	var p uintptr = pData
	var i int32
	for i = 0; i < argc; i++ {
		if *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)) == uintptr(0) {
			dstrAppend(tls, p, ts+5846 /* "NULL" */, ' ')
		} else {
			dstrAppend(tls, p, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), ' ')
		}
	}
	return 0
}

// Implementation of the x_sqlite_exec() function.  This function takes
// a single argument and attempts to execute that argument as SQL code.
// This is illegal and should set the SQLITE_MISUSE flag on the database.
//
// 2004-Jan-07:  We have changed this to make it legal to call sqlite3_exec()
// from within a function call.
//
// This routine simulates the effect of having two threads attempt to
// use the same database at the same time.
func sqlite3ExecFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:832:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var x dstr at bp, 16

	libc.Xmemset(tls, bp /* &x */, 0, uint64(unsafe.Sizeof(dstr{})))
	sqlite3.Xsqlite3_exec(tls, sqlite3.Xsqlite3_user_data(tls, context),
		sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
		}{execFuncCallback})), bp /* &x */, uintptr(0))
	sqlite3.Xsqlite3_result_text(tls, context, (*dstr)(unsafe.Pointer(bp /* &x */)).Fz, (*dstr)(unsafe.Pointer(bp /* &x */)).FnUsed, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_free(tls, (*dstr)(unsafe.Pointer(bp /* &x */)).Fz)
}

// Implementation of tkt2213func(), a scalar function that takes exactly
// one argument. It has two interesting features:
//
// * It calls sqlite3_value_text() 3 times on the argument sqlite3_value*.
//   If the three pointers returned are not the same an SQL error is raised.
//
// * Otherwise it returns a copy of the text representation of its
//   argument in such a way as the VDBE representation is a Mem* cell
//   with the MEM_Term flag clear.
//
// Ticket #2213 can therefore be tested by evaluating the following
// SQL expression:
//
//   tkt2213func(tkt2213func('a string'));
func tkt2213Function(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:862:13: */
	var nText int32
	var zText1 uintptr
	var zText2 uintptr
	var zText3 uintptr

	nText = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zText3 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))

	if zText1 != zText2 || zText2 != zText3 {
		sqlite3.Xsqlite3_result_error(tls, context, ts+15931 /* "tkt2213 is not f..." */, -1)
	} else {
		var zCopy uintptr = sqlite3.Xsqlite3_malloc(tls, nText)
		libc.Xmemcpy(tls, zCopy, zText1, uint64(nText))
		sqlite3.Xsqlite3_result_text(tls, context, zCopy, nText, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// The following SQL function takes 4 arguments.  The 2nd and
// 4th argument must be one of these strings:  'text', 'text16',
// or 'blob' corresponding to API functions
//
//      sqlite3_value_text()
//      sqlite3_value_text16()
//      sqlite3_value_blob()
//
// The third argument is a string, either 'bytes' or 'bytes16' or 'noop',
// corresponding to APIs:
//
//      sqlite3_value_bytes()
//      sqlite3_value_bytes16()
//      noop
//
// The APIs designated by the 2nd through 4th arguments are applied
// to the first argument in order.  If the pointers returned by the
// second and fourth are different, this routine returns 1.  Otherwise,
// this routine returns 0.
//
// This function is used to test to see when returned pointers from
// the _text(), _text16() and _blob() APIs become invalidated.
func ptrChngFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:910:13: */
	var p1 uintptr
	var p2 uintptr
	var zCmd uintptr
	if argc != 4 {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+13603) == 0 {
		p1 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+15952) == 0 {
		p1 = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+13608) == 0 {
		p1 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+15959) == 0 {
		sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+15965) == 0 {
		sqlite3.Xsqlite3_value_bytes16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+15973) == 0 {
		// do nothing
	} else {
		return
	}
	zCmd = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))
	if zCmd == uintptr(0) {
		return
	}
	if libc.Xstrcmp(tls, zCmd, ts+13603) == 0 {
		p2 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+15952) == 0 {
		p2 = sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else if libc.Xstrcmp(tls, zCmd, ts+13608) == 0 {
		p2 = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	} else {
		return
	}
	sqlite3.Xsqlite3_result_int(tls, context, libc.Bool32(p1 != p2))
}

// This SQL function returns a different answer each time it is called, even if
// the arguments are the same.
func nondeterministicFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:964:13: */
	sqlite3.Xsqlite3_result_int(tls, context, libc.PostIncInt32(&cnt, 1))
}

var cnt int32 = 0 /* test1.c:969:14 */

// This SQL function returns the integer value of its argument as a MEM_IntReal
// value.
func intrealFunction(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:977:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var v sqlite3_int64 = sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_int64(tls, context, v)
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_RESULT_INTREAL, libc.VaList(bp, context))
}

// Usage:  sqlite3_create_function DB
//
// Call the sqlite3_create_function API on the given database in order
// to create a function named "x_coalesce".  This function does the same thing
// as the "coalesce" function.  This function also registers an SQL function
// named "x_sqlite_exec" that invokes sqlite3_exec().  Invoking sqlite3_exec()
// in this way is illegal recursion and should raise an SQLITE_MISUSE error.
// The effect is similar to trying to use the same database connection from
// two threads at the same time.
//
// The original motivation for this routine was to be able to call the
// sqlite3_create_function function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.
func test_create_function(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1002:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32
	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15905 /* " DB\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+15978 /* "x_coalesce" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{t1_ifnullFunc})), uintptr(0), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+15989 /* "hex8" */, 1, SQLITE_UTF8|SQLITE_DETERMINISTIC,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{hex8Func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+15994 /* "hex16" */, 1, SQLITE_UTF16|SQLITE_DETERMINISTIC,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{hex16Func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16000 /* "tkt2213func" */, 1, SQLITE_ANY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{tkt2213Function})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16012 /* "pointer_change" */, 4, SQLITE_ANY, uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{ptrChngFunction})), uintptr(0), uintptr(0))
	}

	// Functions counter1() and counter2() have the same implementation - they
	// both return an ascending integer with each call.  But counter1() is marked
	// as non-deterministic and counter2() is marked as deterministic.
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16027 /* "counter1" */, -1, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16036 /* "counter2" */, -1, SQLITE_UTF8|SQLITE_DETERMINISTIC,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{nondeterministicFunction})), uintptr(0), uintptr(0))
	}

	// The intreal() function converts its argument to an integer and returns
	// it as a MEM_IntReal.
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16045 /* "intreal" */, 1, SQLITE_UTF8,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{intrealFunction})), uintptr(0), uintptr(0))
	}

	// Use the sqlite3_create_function16() API here. Mainly for fun, but also
	// because it is not tested anywhere else.
	if rc == SQLITE_OK {
		var zUtf16 uintptr
		var pVal uintptr
		sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
		pVal = sqlite3.Xsqlite3ValueNew(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, ts+16053 /* "x_sqlite_exec" */, uint8(SQLITE_UTF8), uintptr(0))
		zUtf16 = sqlite3.Xsqlite3ValueText(tls, pVal, uint8(SQLITE_UTF16LE))
		if (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).FmallocFailed != 0 {
			rc = SQLITE_NOMEM
		} else {
			rc = sqlite3.Xsqlite3_create_function16(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zUtf16,
				1, SQLITE_UTF16, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{sqlite3ExecFunc})), uintptr(0), uintptr(0))
		}
		sqlite3.Xsqlite3ValueFree(tls, pVal)
		sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
	}

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32)), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage:  sqlite3_drop_modules DB ?NAME ...?
//
// Invoke the sqlite3_drop_modules(D,L) interface on database
// connection DB, in order to drop all modules except those named in
// the argument.
func test_drop_modules(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1092:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15905 /* " DB\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_drop_modules(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), func() uintptr {
		if argc > 2 {
			return argv + uintptr(2)*8
		}
		return uintptr(0)
	}())
	return TCL_OK
}

// Routines to implement the x_count() aggregate function.
//
// x_count() counts the number of non-null arguments.  But there are
// some twists for testing purposes.
//
// If the argument to x_count() is 40 then a UTF-8 error is reported
// on the step function.  If x_count(41) is seen, then a UTF-16 error
// is reported on the step function.  If the total count is 42, then
// a UTF-8 error is reported on the finalize function.
type t1CountCtx1 = struct{ Fn int32 } /* test1.c:1123:9 */

// Routines to implement the x_count() aggregate function.
//
// x_count() counts the number of non-null arguments.  But there are
// some twists for testing purposes.
//
// If the argument to x_count() is 40 then a UTF-8 error is reported
// on the step function.  If x_count(41) is seen, then a UTF-16 error
// is reported on the step function.  If the total count is 42, then
// a UTF-8 error is reported on the finalize function.
type t1CountCtx = t1CountCtx1 /* test1.c:1123:27 */

func t1CountStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:1127:13: */
	bp := tls.Alloc(9)
	defer tls.Free(9)

	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if (argc == 0 || SQLITE_NULL != sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv)))) && p != 0 {
		(*t1CountCtx)(unsafe.Pointer(p)).Fn++
	}
	if argc > 0 {
		var v int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		if v == 40 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+16067 /* "value of 40 hand..." */, -1)
		} else if v == 41 {
			*(*[9]int8)(unsafe.Pointer(bp /* zUtf16ErrMsg */)) = [9]int8{int8(0), int8(0x61), int8(0), int8(0x62), int8(0), int8(0x63), int8(0), int8(0), int8(0)}
			sqlite3.Xsqlite3_result_error16(tls, context, bp+1, -1)
		}
	}
}

func t1CountFinalize(tls *libc.TLS, context uintptr) { /* test1.c:1149:13: */
	var p uintptr
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(t1CountCtx{})))
	if p != 0 {
		if (*t1CountCtx)(unsafe.Pointer(p)).Fn == 42 {
			sqlite3.Xsqlite3_result_error(tls, context, ts+16097 /* "x_count totals t..." */, -1)
		} else {
			sqlite3.Xsqlite3_result_int(tls, context, func() int32 {
				if p != 0 {
					return (*t1CountCtx)(unsafe.Pointer(p)).Fn
				}
				return 0
			}())
		}
	}
}

func legacyCountStep(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:1162:13: */
	// no-op
}

func legacyCountFinalize(tls *libc.TLS, context uintptr) { /* test1.c:1170:13: */
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_aggregate_count(tls, context))
}

// Usage:  sqlite3_create_aggregate DB
//
// Call the sqlite3_create_function API on the given database in order
// to create a function named "x_count".  This function is similar
// to the built-in count() function, with a few special quirks
// for testing the sqlite3_result_error() APIs.
//
// The original motivation for this routine was to be able to call the
// sqlite3_create_aggregate function while a query is in progress in order
// to test the SQLITE_MISUSE detection logic.  See misuse.test.
//
// This routine was later extended to test the use of sqlite3_result_error()
// within aggregate functions.
//
// Later: It is now also extended to register the aggregate function
// "legacy_count()" with the supplied database handle. This is used
// to test the deprecated sqlite3_aggregate_count() API.
func test_create_aggregate(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1194:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15910 /* " FILENAME\"" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16118 /* "x_count" */, 0, SQLITE_UTF8, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{t1CountFinalize})))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16118 /* "x_count" */, 1, SQLITE_UTF8, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{t1CountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{t1CountFinalize})))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+16126 /* "legacy_count" */, 0, SQLITE_ANY, uintptr(0), uintptr(0),
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr)
			}{legacyCountStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{legacyCountFinalize})))
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 32)), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage:  printf TEXT
//
// Send output to printf.  Use this rather than puts to merge the output
// in the correct sequence with debugging printfs inserted into C code.
// Puts uses a separate buffer and debugging statements will be out of
// sequence if it is used.
func test_printf(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1235:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16139 /* " TEXT\"" */, 0))
		return TCL_ERROR
	}
	libc.Xprintf(tls, ts+389 /* "%s\n" */, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 1*8))))
	return TCL_OK
}

// Usage:  sqlite3_mprintf_int FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three integer arguments
func sqlite3_mprintf_int(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1257:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var a [3]int32 at bp+72, 12

	var i int32
	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16146 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 1*4)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 2*4))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_int64 FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three 64-bit integer arguments
func sqlite3_mprintf_int64(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1284:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32
	// var a [3]sqlite_int64 at bp+88, 24

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16146 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if sqlite3.Xsqlite3Atoi64(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp+88+uintptr(i-2)*8, sqlite3.Xsqlite3Strlen30(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))), uint8(SQLITE_UTF8)) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+16167 /* "argument is not ..." */, 0))
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+48, *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + 1*8)), *(*sqlite_int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + 2*8))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_long FORMAT INTEGER INTEGER INTEGER
//
// Call mprintf with three long integer arguments.   This might be the
// same as sqlite3_mprintf_int or sqlite3_mprintf_int64, depending on
// platform.
func sqlite3_mprintf_long(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1317:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var i int32
	// var a [3]int64 at bp+88, 24

	// var b [3]int32 at bp+72, 12

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16146 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
		*(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + uintptr(i-2)*8)) = int64(*(*int32)(unsafe.Pointer(bp + 72 /* &b[0] */ + uintptr(i-2)*4)))
		*(*int64)(unsafe.Pointer(bp + 88 + uintptr(i-2)*8)) &= int64(u64(uint64(1))<<(uint64(unsafe.Sizeof(int32(0)))*uint64(8)) - uint64(1))
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+32, *(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */)), *(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + 1*8)), *(*int64)(unsafe.Pointer(bp + 88 /* &a[0] */ + 2*8))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_str FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
func sqlite3_mprintf_str(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1348:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var a [3]int32 at bp+72, 12

	var i int32
	var z uintptr
	if argc < 4 || argc > 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16206 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 1*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + 4*8))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_snprintf_str INTEGER FORMAT INTEGER INTEGER STRING
//
// Call mprintf with two integer arguments and one string argument
func sqlite3_snprintf_str(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1375:26: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	// var a [3]int32 at bp+92, 12

	var i int32
	// var n int32 at bp+88, 4

	var z uintptr
	if argc < 5 || argc > 6 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16232 /* " INT FORMAT INT ..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+88) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 88)) < 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+16262 /* "N must be non-ne..." */, 0))
		return TCL_ERROR
	}
	for i = 3; i < 5; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp+92+uintptr(i-3)*4) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 88))+1)
	sqlite3.Xsqlite3_snprintf(tls, *(*int32)(unsafe.Pointer(bp + 88 /* n */)), z, *(*uintptr)(unsafe.Pointer(argv + 2*8)), libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 92 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 92 /* &a[0] */ + 1*4)), func() uintptr {
		if argc > 4 {
			return *(*uintptr)(unsafe.Pointer(argv + 5*8))
		}
		return uintptr(0)
	}()))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_double FORMAT INTEGER INTEGER DOUBLE
//
// Call mprintf with two integer arguments and one double argument
func sqlite3_mprintf_double(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1409:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// var a [3]int32 at bp+72, 12

	var i int32
	// var r float64 at bp+88, 8

	var z uintptr
	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16285 /* " FORMAT INT INT ..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp+72+uintptr(i-2)*4) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+88) != 0 {
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */)), *(*int32)(unsafe.Pointer(bp + 72 /* &a[0] */ + 1*4)), *(*float64)(unsafe.Pointer(bp + 88 /* r */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_scaled FORMAT DOUBLE DOUBLE
//
// Call mprintf with a single double argument which is the product of the
// two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
func sqlite3_mprintf_scaled(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1440:26: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var i int32
	// var r [2]float64 at bp+56, 16

	var z uintptr
	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16309 /* " FORMAT DOUBLE D..." */, 0))
		return TCL_ERROR
	}
	for i = 2; i < 4; i++ {
		if tcl.XTcl_GetDouble(tls, interp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)), bp+56+uintptr(i-2)*8) != 0 {
			return TCL_ERROR
		}
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+32, *(*float64)(unsafe.Pointer(bp + 56))**(*float64)(unsafe.Pointer(bp + 56 + 1*8))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_stronly FORMAT STRING
//
// Call mprintf with a single double argument which is the product of the
// two arguments given above.  This is used to generate overflow and underflow
// doubles to test that they are converted properly.
func sqlite3_mprintf_stronly(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1470:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16332 /* " FORMAT STRING\"" */, 0))
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage:  sqlite3_mprintf_hexdouble FORMAT HEX
//
// Call mprintf with a single double argument which is derived from the
// hexadecimal encoding of an IEEE double.
func sqlite3_mprintf_hexdouble(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:1494:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	var z uintptr
	// var r float64 at bp+96, 8

	// var x1 uint32 at bp+92, 4

	// var x2 uint32 at bp+88, 4

	// var d sqlite_uint64 at bp+104, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16332 /* " FORMAT STRING\"" */, 0))
		return TCL_ERROR
	}
	if libc.Xsscanf(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)), ts+16348, libc.VaList(bp+32, bp+88, bp+92)) != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+16357 /* "2nd argument sho..." */, 0))
		return TCL_ERROR
	}
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) = sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 88 /* x2 */)))
	*(*sqlite_uint64)(unsafe.Pointer(bp + 104 /* d */)) = *(*sqlite_uint64)(unsafe.Pointer(bp + 104))<<32 + sqlite_uint64(*(*uint32)(unsafe.Pointer(bp + 92)))
	libc.Xmemcpy(tls, bp+96 /* &r */, bp+104 /* &d */, uint64(unsafe.Sizeof(float64(0))))
	z = sqlite3.Xsqlite3_mprintf(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), libc.VaList(bp+64, *(*float64)(unsafe.Pointer(bp + 96 /* r */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, z, 0))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage: sqlite3_enable_shared_cache ?BOOLEAN?
//
func test_enable_shared(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1527:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var enable int32 at bp, 4

	var ret int32 = 0

	if objc != 2 && objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16401 /* "?BOOLEAN?" */)
		return TCL_ERROR
	}
	ret = sqlite3.Xsqlite3Config.FsharedCacheEnabled

	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
			return TCL_ERROR
		}
		rc = sqlite3.Xsqlite3_enable_shared_cache(tls, *(*int32)(unsafe.Pointer(bp /* enable */)))
		if rc != SQLITE_OK {
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
			return TCL_ERROR
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(ret != 0)))
	return TCL_OK
}

// Usage: sqlite3_extended_result_codes   DB    BOOLEAN
//
func test_extended_result_codes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1564:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var enable int32 at bp+8, 4

	// var db uintptr at bp, 8

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16411 /* "DB BOOLEAN" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_extended_result_codes(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 8 /* enable */)))
	return TCL_OK
}

// Usage: sqlite3_libversion_number
//
func test_libversion_number(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1587:26: */
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_libversion_number(tls)))
	return TCL_OK
}

// Usage: sqlite3_table_column_metadata DB dbname tblname colname
//
func test_table_column_metadata(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1601:26: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	// var db uintptr at bp+16, 8

	var zDb uintptr
	var zTbl uintptr
	var zCol uintptr
	var rc int32
	var pRet uintptr
	// var zDatatype uintptr at bp+24, 8

	// var zCollseq uintptr at bp+32, 8

	// var notnull int32 at bp+40, 4

	// var primarykey int32 at bp+44, 4

	// var autoincrement int32 at bp+48, 4

	if objc != 5 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16422 /* "DB dbname tblnam..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	zTbl = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if objc == 5 {
		zCol = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))
	} else {
		zCol = uintptr(0)
	}

	if libc.Xstrlen(tls, zDb) == uint64(0) {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_table_column_metadata(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDb, zTbl, zCol,
		bp+24 /* &zDatatype */, bp+32 /* &zCollseq */, bp+40 /* &notnull */, bp+44 /* &primarykey */, bp+48 /* &autoincrement */)

	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))), 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* zDatatype */)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* zCollseq */)), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 40 /* notnull */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 44 /* primarykey */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 48 /* autoincrement */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

func blobHandleFromObj(tls *libc.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 { /* test1.c:1652:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	if *(*int32)(unsafe.Pointer(bp)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else {
		// var notUsed int32 at bp+4, 4

		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4 /* &notUsed */)
		if !(channel != 0) {
			return TCL_ERROR
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), SEEK_SET)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	}

	return TCL_OK
}

func test_blob_reopen(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1681:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var iRowid Tcl_WideInt at bp+8, 8

	// var pBlob uintptr at bp, 8

	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16448 /* "CHANNEL ROWID" */)
		return TCL_ERROR
	}

	if blobHandleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_blob_reopen(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iRowid */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

// Usage: sqlite3_create_collation_v2 DB-HANDLE NAME CMP-PROC DEL-PROC
//
//   This Tcl proc is used for testing the experimental
//   sqlite3_create_collation_v2() interface.
type TestCollationX1 = struct {
	Finterp uintptr
	FpCmp   uintptr
	FpDel   uintptr
} /* test1.c:1715:1 */

type TestCollationX = TestCollationX1 /* test1.c:1720:31 */

func testCreateCollationDel(tls *libc.TLS, pCtx uintptr) { /* test1.c:1721:13: */
	var p uintptr = pCtx

	var rc int32 = tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, (*TestCollationX)(unsafe.Pointer(p)).FpDel, TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpCmp
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = (*TestCollationX)(unsafe.Pointer(p)).FpDel
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func testCreateCollationCmp(tls *libc.TLS, pCtx uintptr, nLeft int32, zLeft uintptr, nRight int32, zRight uintptr) int32 { /* test1.c:1733:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pScript uintptr = tcl.XTcl_DuplicateObj(tls, (*TestCollationX)(unsafe.Pointer(p)).FpCmp)
	*(*int32)(unsafe.Pointer(bp /* iRes */)) = 0

	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zLeft, nLeft))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewStringObj(tls, zRight, nRight))

	if TCL_OK != tcl.XTcl_EvalObjEx(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, pScript, TCL_EVAL_DIRECT|TCL_EVAL_GLOBAL) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp), bp) {
		tcl.XTcl_BackgroundError(tls, (*TestCollationX)(unsafe.Pointer(p)).Finterp)
	}
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* iRes */))
}

func test_create_collation_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1757:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr
	// var db uintptr at bp+16, 8

	var rc int32

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16462 /* "DB-HANDLE NAME C..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 {
		return TCL_ERROR
	}

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TestCollationX{})))
	(*TestCollationX)(unsafe.Pointer(p)).FpCmp = *(*uintptr)(unsafe.Pointer(objv + 3*8))
	(*TestCollationX)(unsafe.Pointer(p)).FpDel = *(*uintptr)(unsafe.Pointer(objv + 4*8))
	(*TestCollationX)(unsafe.Pointer(p)).Finterp = interp
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpCmp)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestCollationX)(unsafe.Pointer(p)).FpDel)).FrefCount++

	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), 16,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testCreateCollationDel})))
	if rc != SQLITE_MISUSE {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp, ts+16495 /* "sqlite3_create_c..." */, uintptr(0)))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_collation_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), SQLITE_UTF8,
		p, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{testCreateCollationCmp})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testCreateCollationDel})))
	return TCL_OK
}

// USAGE: sqlite3_create_function_v2 DB NAME NARG ENC ?SWITCHES?
//
// Available switches are:
//
//   -func    SCRIPT
//   -step    SCRIPT
//   -final   SCRIPT
//   -destroy SCRIPT
type CreateFunctionV21 = struct {
	Finterp   uintptr
	FpFunc    uintptr
	FpStep    uintptr
	FpFinal   uintptr
	FpDestroy uintptr
} /* test1.c:1804:9 */

// USAGE: sqlite3_create_function_v2 DB NAME NARG ENC ?SWITCHES?
//
// Available switches are:
//
//   -func    SCRIPT
//   -step    SCRIPT
//   -final   SCRIPT
//   -destroy SCRIPT
type CreateFunctionV2 = CreateFunctionV21 /* test1.c:1804:33 */

func cf2Func(tls *libc.TLS, ctx uintptr, nArg int32, aArg uintptr) { /* test1.c:1812:13: */
}

func cf2Step(tls *libc.TLS, ctx uintptr, nArg int32, aArg uintptr) { /* test1.c:1814:13: */
}

func cf2Final(tls *libc.TLS, ctx uintptr) { /* test1.c:1816:13: */
}

func cf2Destroy(tls *libc.TLS, pUser uintptr) { /* test1.c:1818:13: */
	var p uintptr = pUser

	if (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp != 0 && (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		var rc int32 = tcl.XTcl_EvalObjEx(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy, 0)
		if rc != TCL_OK {
			tcl.XTcl_BackgroundError(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		for ok3 := true; ok3; ok3 = 0 != 0 {
			var _objPtr uintptr = (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func test_create_function_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1832:26: */
	bp := tls.Alloc(180)
	defer tls.Free(180)

	// var db uintptr at bp+16, 8

	var zFunc uintptr
	// var nArg int32 at bp+24, 4

	// var enc int32 at bp+128, 4

	var p uintptr
	var i int32
	var rc int32

	*(*[6]EncTable)(unsafe.Pointer(bp + 32 /* aEnc */)) = [6]EncTable{
		{FzEnc: ts + 16560 /* "utf8" */, Fenc: SQLITE_UTF8},
		{FzEnc: ts + 16565 /* "utf16" */, Fenc: SQLITE_UTF16},
		{FzEnc: ts + 16571 /* "utf16le" */, Fenc: SQLITE_UTF16LE},
		{FzEnc: ts + 16579 /* "utf16be" */, Fenc: SQLITE_UTF16BE},
		{FzEnc: ts + 13613 /* "any" */, Fenc: SQLITE_ANY},
		{FzEnc: ts + 15020 /* "0" */},
	}

	if objc < 5 || objc%2 == 0 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16587 /* "DB NAME NARG ENC..." */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 {
		return TCL_ERROR
	}
	zFunc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+24) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+32, int32(unsafe.Sizeof(EncTable{})),
		ts+16616, 0, bp+128) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 128 /* enc */)) = (*EncTable)(unsafe.Pointer(bp + 32 /* &aEnc */ + uintptr(*(*int32)(unsafe.Pointer(bp + 128 /* enc */)))*16)).Fenc

	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(CreateFunctionV2{})))

	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(CreateFunctionV2{})))
	(*CreateFunctionV2)(unsafe.Pointer(p)).Finterp = interp

	for i = 5; i < objc; i = i + 2 {
		// var iSwitch int32 at bp+176, 4

		*(*[5]uintptr)(unsafe.Pointer(bp + 136 /* azSwitch */)) = [5]uintptr{ts + 16625 /* "-func" */, ts + 16631 /* "-step" */, ts + 16637 /* "-final" */, ts + 16644 /* "-destroy" */, uintptr(0)}
		if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+136, int32(unsafe.Sizeof(uintptr(0))), ts+16653, 0, bp+176) != 0 {
			sqlite3.Xsqlite3_free(tls, p)
			return TCL_ERROR
		}

		switch *(*int32)(unsafe.Pointer(bp + 176 /* iSwitch */)) {
		case 0:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8))
			break
		case 1:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8))
			break
		case 2:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8))
			break
		case 3:
			(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8))
			break
		}
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpStep = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy = tcl.XTcl_DuplicateObj(tls, (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)
	}

	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpStep)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal)).FrefCount++
	}
	if (*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy != 0 {
		(*Tcl_Obj)(unsafe.Pointer((*CreateFunctionV2)(unsafe.Pointer(p)).FpDestroy)).FrefCount++
	}

	rc = sqlite3.Xsqlite3_create_function_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zFunc, *(*int32)(unsafe.Pointer(bp + 24 /* nArg */)), *(*int32)(unsafe.Pointer(bp + 128 /* enc */)), p,
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFunc != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{cf2Func}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpStep != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr)
				}{cf2Step}))
			}
			return uintptr(0)
		}(),
		func() uintptr {
			if (*CreateFunctionV2)(unsafe.Pointer(p)).FpFinal != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cf2Final}))
			}
			return uintptr(0)
		}(),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cf2Destroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

type EncTable = struct {
	FzEnc        uintptr
	Fenc         int32
	F__ccgo_pad1 [4]byte
} /* test1.c:1846:3 */

// Usage: sqlite3_load_extension DB-HANDLE FILE ?PROC?
func test_load_extension(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1920:26: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var cmdInfo Tcl_CmdInfo at bp+24, 64

	var db uintptr
	_ = db
	var rc int32
	var zDb uintptr
	var zFile uintptr
	_ = zFile
	var zProc uintptr = uintptr(0)
	_ = zProc
	var zErr uintptr = uintptr(0)

	if objc != 4 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16660 /* "DB-HANDLE FILE ?..." */)
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if objc == 4 {
		zProc = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	}

	// Extract the C database handle from the Tcl command name
	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+24) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15686 /* "command not foun..." */, zDb, uintptr(0)))
		return TCL_ERROR
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 24)).FobjClientData)).Fdb

	// Call the underlying C function. If an error occurs, set rc to
	// TCL_ERROR and load any error string into the interpreter. If no
	// error occurs, set rc to TCL_OK.
	rc = SQLITE_ERROR
	zErr = sqlite3.Xsqlite3_mprintf(tls, ts+16682 /* "this build omits..." */, 0)
	_ = zProc
	_ = zFile
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, func() uintptr {
			if zErr != 0 {
				return zErr
			}
			return ts + 584 /* "" */
		}(), uintptr(1))
		rc = TCL_ERROR
	} else {
		rc = TCL_OK
	}
	sqlite3.Xsqlite3_free(tls, zErr)

	return rc
}

// Usage: sqlite3_enable_load_extension DB-HANDLE ONOFF
func test_enable_load(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:1978:26: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	// var cmdInfo Tcl_CmdInfo at bp+32, 64

	var db uintptr
	_ = db
	var zDb uintptr
	// var onoff int32 at bp+96, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16724 /* "DB-HANDLE ONOFF" */)
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))

	// Extract the C database handle from the Tcl command name
	if !(tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+32) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15686 /* "command not foun..." */, zDb, uintptr(0)))
		return TCL_ERROR
	}
	db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 32)).FobjClientData)).Fdb

	// Get the onoff parameter
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+96) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+16682 /* "this build omits..." */))
	return TCL_ERROR
}

// Usage:  sqlite_abort
//
// Shutdown the process immediately.  This is not a clean shutdown.
// This command is used to test the recoverability of a database in
// the event of a program crash.
func sqlite_abort(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2024:26: */
	libc.Xexit(tls, 255)
	// This will always fail
	return TCL_OK
}

// The following routine is a user-defined SQL function whose purpose
// is to test the sqlite_set_result() API.
func testFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test1.c:2045:13: */
	var zArg0 uintptr
__1:
	if !(argc >= 2) {
		goto __2
	}
	zArg0 = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if !(zArg0 != 0) {
		goto __3
	}
	if !(0 == sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+2577)) {
		goto __5
	}
	sqlite3.Xsqlite3_result_int(tls, context, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))))
	goto __6
__5:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+3973) == 0) {
		goto __7
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))))
	goto __8
__7:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+16740) == 0) {
		goto __9
	}
	sqlite3.Xsqlite3_result_text(tls, context, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))), -1,
		libc.UintptrFromInt32(-1))
	goto __10
__9:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+2562) == 0) {
		goto __11
	}
	sqlite3.Xsqlite3_result_double(tls, context, sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))))
	goto __12
__11:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+7582) == 0) {
		goto __13
	}
	sqlite3.Xsqlite3_result_null(tls, context)
	goto __14
__13:
	if !(sqlite3.Xsqlite3StrICmp(tls, zArg0, ts+10845) == 0) {
		goto __15
	}
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv + uintptr(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))))*8)))
	goto __16
__15:
	goto error_out
__16:
	;
__14:
	;
__12:
	;
__10:
	;
__8:
	;
__6:
	;
	goto __4
__3:
	goto error_out
__4:
	;
	argc = argc - 2
	argv += 8 * uintptr(2)
	goto __1
__2:
	;
	return

error_out:
	sqlite3.Xsqlite3_result_error(tls, context,
		ts+16747 /* "first argument s..." */, -1)
}

// Usage:   sqlite_register_test_function  DB  NAME
//
// Register the test SQL function on the database DB under the name NAME.
func test_register_func(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2083:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 8

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16815 /* " DB FUNCTION-NAM..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testFunc})), uintptr(0), uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_finalize  STMT
//
// Finalize a statement handle.
func test_finalize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2112:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32
	var db uintptr = uintptr(0)

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16833 /* " <STMT>" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 32)) != 0 {
		db = sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if db != 0 && sqlite3TestErrCode(tls, interp, db, rc) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:  sqlite3_stmt_status  STMT  CODE  RESETFLAG
//
// Get the value of a status counter from a statement.
func test_stmt_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2144:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var iValue int32
	var i int32
	*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = 0
	// var resetFlag int32 at bp+12, 4

	var zOpName uintptr
	// var pStmt uintptr at bp, 8

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+16841 /* "STMT PARAMETER R..." */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	for i = 0; i < int32(uint64(unsafe.Sizeof(aOp))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fop          int32
		F__ccgo_pad1 [4]byte
	}{}))); i++ {
		if libc.Xstrcmp(tls, aOp[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = aOp[i].Fop
			break
		}
	}
	if i >= int32(uint64(unsafe.Sizeof(aOp))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fop          int32
		F__ccgo_pad1 [4]byte
	}{}))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+12) != 0 {
		return TCL_ERROR
	}
	iValue = sqlite3.Xsqlite3_stmt_status(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 8 /* op */)), *(*int32)(unsafe.Pointer(bp + 12 /* resetFlag */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iValue))
	return TCL_OK
}

var aOp = [7]struct {
	FzName       uintptr
	Fop          int32
	F__ccgo_pad1 [4]byte
}{
	{FzName: ts + 16866 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_FULLSCAN_STEP},
	{FzName: ts + 16898 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_SORT},
	{FzName: ts + 16921 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_AUTOINDEX},
	{FzName: ts + 16949 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_VM_STEP},
	{FzName: ts + 16975 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_REPREPARE},
	{FzName: ts + 17003 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_RUN},
	{FzName: ts + 17025 /* "SQLITE_STMTSTATU..." */, Fop: SQLITE_STMTSTATUS_MEMUSED},
} /* test1.c:2158:5 */

// Usage:  sqlite3_config_sorterref
//
// Set the SQLITE_CONFIG_SORTERREF_SIZE configuration option
func test_config_sorterref(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2285:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var iVal int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17051 /* "NBYTE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_SORTERREF_SIZE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* iVal */))))
	return TCL_OK
}

// Usage: vfs_current_time_int64
//
// Return the value returned by the default VFS's xCurrentTimeInt64 method.
func vfsCurrentTimeInt64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2306:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var t i64 at bp, 8

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}
	(*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTimeInt64})).f(tls, pVfs, bp /* &t */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, *(*i64)(unsafe.Pointer(bp /* t */))))
	return TCL_OK
}

// Usage: sqlite3_snapshot_get DB DBNAME
func test_snapshot_get(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2327:26: */
	bp := tls.Alloc(116)
	defer tls.Free(116)

	var rc int32
	// var db uintptr at bp, 8

	var zName uintptr
	*(*uintptr)(unsafe.Pointer(bp + 8 /* pSnapshot */)) = uintptr(0)

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17057 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))

	rc = sqlite3.Xsqlite3_snapshot_get(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, bp+8 /* &pSnapshot */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		// var zBuf [100]int8 at bp+16, 100

		if sqlite3TestMakePointerStr(tls, interp, bp+16, *(*uintptr)(unsafe.Pointer(bp + 8))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+16 /* &zBuf[0] */, -1))
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_recover DB DBNAME
func test_snapshot_recover(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2362:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var db uintptr at bp, 8

	var zName uintptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17057 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))

	rc = sqlite3.Xsqlite3_snapshot_recover(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_open DB DBNAME SNAPSHOT
func test_snapshot_open(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2394:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var db uintptr at bp, 8

	var zName uintptr
	var pSnapshot uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17067 /* "DB DBNAME SNAPSH..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	pSnapshot = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8))))

	rc = sqlite3.Xsqlite3_snapshot_open(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, pSnapshot)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_free SNAPSHOT
func test_snapshot_free(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2428:26: */
	var pSnapshot uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17086 /* "SNAPSHOT" */)
		return TCL_ERROR
	}
	pSnapshot = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	sqlite3.Xsqlite3_snapshot_free(tls, pSnapshot)
	return TCL_OK
}

// Usage: sqlite3_snapshot_cmp SNAPSHOT1 SNAPSHOT2
func test_snapshot_cmp(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2449:26: */
	var res int32
	var p1 uintptr
	var p2 uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17095 /* "SNAPSHOT1 SNAPSH..." */)
		return TCL_ERROR
	}
	p1 = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	p2 = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
	res = sqlite3.Xsqlite3_snapshot_cmp(tls, p1, p2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return TCL_OK
}

// Usage: sqlite3_snapshot_get_blob DB DBNAME
func test_snapshot_get_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2474:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var db uintptr at bp, 8

	var zName uintptr
	*(*uintptr)(unsafe.Pointer(bp + 8 /* pSnapshot */)) = uintptr(0)

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17057 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))

	rc = sqlite3.Xsqlite3_snapshot_get(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, bp+8 /* &pSnapshot */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	} else {
		tcl.XTcl_SetObjResult(tls, interp,
			tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pSnapshot */)), int32(unsafe.Sizeof(sqlite3_snapshot{}))))
		sqlite3.Xsqlite3_snapshot_free(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pSnapshot */)))
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_open_blob DB DBNAME SNAPSHOT
func test_snapshot_open_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2510:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var rc int32
	// var db uintptr at bp+16, 8

	var zName uintptr
	var pBlob uintptr
	// var nBlob int32 at bp+24, 4

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17067 /* "DB DBNAME SNAPSH..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	pBlob = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+24 /* &nBlob */)
	if uint64(*(*int32)(unsafe.Pointer(bp + 24))) != uint64(unsafe.Sizeof(sqlite3_snapshot{})) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+17115 /* "bad SNAPSHOT" */, 0))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_snapshot_open(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zName, pBlob)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage: sqlite3_snapshot_cmp_blob SNAPSHOT1 SNAPSHOT2
func test_snapshot_cmp_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2546:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var res int32
	var p1 uintptr
	var p2 uintptr
	// var n1 int32 at bp+16, 4

	// var n2 int32 at bp+20, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17095 /* "SNAPSHOT1 SNAPSH..." */)
		return TCL_ERROR
	}

	p1 = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16 /* &n1 */)
	p2 = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+20 /* &n2 */)

	if uint64(*(*int32)(unsafe.Pointer(bp + 16))) != uint64(unsafe.Sizeof(sqlite3_snapshot{})) || *(*int32)(unsafe.Pointer(bp + 16)) != *(*int32)(unsafe.Pointer(bp + 20)) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+17115 /* "bad SNAPSHOT" */, 0))
		return TCL_ERROR
	}

	res = sqlite3.Xsqlite3_snapshot_cmp(tls, p1, p2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, res))
	return TCL_OK
}

// in test_delete.c
func test_delete_database(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2581:26: */
	var rc int32
	var zFile uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17128 /* "FILE" */)
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	rc = sqlite3_delete_database(tls, zFile)

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

// Usage: atomic_batch_write PATH
func test_atomic_batch_write(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2603:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zFile uintptr = uintptr(0)                              // Path to file to test
	*(*uintptr)(unsafe.Pointer(bp + 16 /* db */)) = uintptr(0)  // Database handle
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pFd */)) = uintptr(0) // SQLite fd open on zFile
	var bRes int32 = 0                                          // Integer result of this command
	var dc int32 = 0                                            // Device-characteristics mask
	var rc int32                                                // sqlite3_open() return code

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17133 /* "PATH" */)
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))

	rc = sqlite3.Xsqlite3_open(tls, zFile, bp+16 /* &db */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */))), 0))
		sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)))
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp+24 /* &pFd */)
	dc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* pFd */)))).FpMethods)).FxDeviceCharacteristics})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pFd */)))
	if dc&SQLITE_IOCAP_BATCH_ATOMIC != 0 {
		bRes = 1
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, bRes))
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)))
	return TCL_OK
}

// Usage:  sqlite3_next_stmt  DB  STMT
//
// Return the next statment in sequence after STMT.
func test_next_stmt(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2645:26: */
	bp := tls.Alloc(114)
	defer tls.Free(114)

	// var pStmt uintptr at bp+56, 8

	*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)) = uintptr(0)
	// var zBuf [50]int8 at bp+64, 50

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17138 /* " DB STMT" */, 0))
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+56) != 0 {
		return TCL_ERROR
	}
	*(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)) = sqlite3.Xsqlite3_next_stmt(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*uintptr)(unsafe.Pointer(bp + 56 /* pStmt */)))
	if *(*uintptr)(unsafe.Pointer(bp + 56)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+64, *(*uintptr)(unsafe.Pointer(bp + 56))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+64 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage:  sqlite3_stmt_readonly  STMT
//
// Return true if STMT is a NULL pointer or a pointer to a statement
// that is guaranteed to leave the database unmodified.
func test_stmt_readonly(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2677:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17147 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(rc != 0)))
	return TCL_OK
}

// Usage:  sqlite3_stmt_isexplain  STMT
//
// Return 1, 2, or 0 respectively if STMT is an EXPLAIN statement, an
// EXPLAIN QUERY PLAN statement or an ordinary statement or NULL pointer.
func test_stmt_isexplain(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2704:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17147 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_isexplain(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Usage:  sqlite3_stmt_busy  STMT
//
// Return true if STMT is a non-NULL pointer to a statement
// that has been stepped but not to completion.
func test_stmt_busy(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2731:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17147 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_stmt_busy(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(rc != 0)))
	return TCL_OK
}

// Usage:  uses_stmt_journal  STMT
//
// Return true if STMT uses a statement journal.
func uses_stmt_journal(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2757:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17147 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_stmt_readonly(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(int32(*(*uint16)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)) + 208))&0x40>>6) != 0)))
	return TCL_OK
}

// Usage:  sqlite3_reset  STMT
//
// Reset a statement handle.
func test_reset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2783:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16833 /* " <STMT>" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_reset(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))
	if *(*uintptr)(unsafe.Pointer(bp + 32)) != 0 && sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	//
	//   if( rc ){
	//     return TCL_ERROR;
	//   }
	return TCL_OK
}

// Usage:  sqlite3_expired STMT
//
// Return TRUE if a recompilation of the statement is recommended.
func test_expired(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2818:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+16833 /* " <STMT>" */, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(sqlite3.Xsqlite3_expired(tls, *(*uintptr)(unsafe.Pointer(bp + 32))) != 0)))
	return TCL_OK
}

// Usage:  sqlite3_transfer_bindings FROMSTMT TOSTMT
//
// Transfer all bindings from FROMSTMT over to TOSTMT
func test_transfer_bind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2842:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var pStmt1 uintptr at bp+32, 8

	// var pStmt2 uintptr at bp+40, 8

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17153 /* " FROM-STMT TO-ST..." */, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+40) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_transfer_bindings(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt1 */)), *(*uintptr)(unsafe.Pointer(bp + 40 /* pStmt2 */)))))
	return TCL_OK
}

// Usage:  sqlite3_changes DB
//
// Return the number of changes made to the database by the last SQL
// execution.
func test_changes(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:2869:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_changes(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))))
	return TCL_OK
}

// This is the "static_bind_value" that variables are bound to when
// the FLAG option of sqlite3_bind is "static"
var sqlite_static_bind_value uintptr = uintptr(0) /* test1.c:2890:13 */
var sqlite_static_bind_nbyte int32 = 0            /* test1.c:2891:12 */

// Usage:  sqlite3_bind  VM  IDX  VALUE  FLAGS
//
// Sets the value of the IDX-th occurrence of "?" in the original SQL
// string.  VALUE is the new value.  If FLAGS=="null" then VALUE is
// ignored and the value is set to NULL.  If FLAGS=="static" then
// the value is set to the value of a static variable named
// "sqlite_static_bind_value".  If FLAGS=="normal" then a copy
// of the VALUE is made.  If FLAGS=="blob10" then a VALUE is ignored
// an a 10-byte blob "abc\000xyz\000pq" is inserted.
func test_bind(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:2904:26: */
	bp := tls.Alloc(142)
	defer tls.Free(142)

	// var pStmt uintptr at bp+80, 8

	var rc int32
	// var idx int32 at bp+88, 4

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+17172 /* " VM IDX VALUE (n..." */, 0))
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+80) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+88) != 0 {
		return TCL_ERROR
	}
	if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+7582) == 0 {
		rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+17208) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), sqlite_static_bind_value, -1, uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+17215) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), sqlite_static_bind_value,
			sqlite_static_bind_nbyte, uintptr(0))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+17229) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), *(*uintptr)(unsafe.Pointer(argv + 3*8)), -1, libc.UintptrFromInt32(-1))
	} else if libc.Xstrcmp(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)), ts+17236) == 0 {
		rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), ts+17243 /* "abc\x00xyz\x00pq" */, 10, uintptr(0))
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp+32, ts+17254 /* "4th argument sho..." */, 0))
		return TCL_ERROR
	}
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 80))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		// var zBuf [50]int8 at bp+92, 50

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+92 /* &zBuf[0] */, ts+17308 /* "(%d) " */, libc.VaList(bp+48, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+92 /* &zBuf[0] */, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage: add_test_collate <db ptr> <utf8> <utf16le> <utf16be>
//
// This function is used to test that SQLite selects the correct collation
// sequence callback when multiple versions (for different text encodings)
// are available.
//
// Calling this routine registers the collation sequence "test_collate"
// with database handle <db>. The second argument must be a list of three
// boolean values. If the first is true, then a version of test_collate is
// registered for UTF-8, if the second is true, a version is registered for
// UTF-16le, if the third is true, a UTF-16be version is available.
// Previous versions of test_collate are deleted.
//
// The collation sequence test_collate is implemented by calling the
// following TCL script:
//
//   "test_collate <enc> <lhs> <rhs>"
//
// The <lhs> and <rhs> are the two values being compared, encoded in UTF-8.
// The <enc> parameter is the encoding of the collation function that
// SQLite selected to call. The TCL test script implements the
// "test_collate" proc.
//
// Note that this will only work with one interpreter at a time, as the
// interp pointer to use when evaluating the TCL script is stored in
// pTestCollateInterp.
var pTestCollateInterp uintptr /* test1.c:2975:18: */

func test_collate_func(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 { /* test1.c:2976:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var i uintptr = pTestCollateInterp
	var encin int32 = int32(pCtx)
	// var res int32 at bp, 4

	var n int32
	var pVal uintptr
	var pX uintptr

	pX = tcl.XTcl_NewStringObj(tls, ts+17314 /* "test_collate" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++

	switch encin {
	case SQLITE_UTF8:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+17327 /* "UTF-8" */, -1))
		break
	case SQLITE_UTF16LE:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+17333 /* "UTF-16LE" */, -1))
		break
	case SQLITE_UTF16BE:
		tcl.XTcl_ListObjAppendElement(tls, i, pX, tcl.XTcl_NewStringObj(tls, ts+17342 /* "UTF-16BE" */, -1))
		break
	default:

	}

	sqlite3.Xsqlite3BeginBenignMalloc(tls)
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	if pVal != 0 {
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, nA, zA, uint8(encin), uintptr(0))
		n = sqlite3.Xsqlite3_value_bytes(tls, pVal)
		tcl.XTcl_ListObjAppendElement(tls, i, pX,
			tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pVal), n))
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, nB, zB, uint8(encin), uintptr(0))
		n = sqlite3.Xsqlite3_value_bytes(tls, pVal)
		tcl.XTcl_ListObjAppendElement(tls, i, pX,
			tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, pVal), n))
		sqlite3.Xsqlite3ValueFree(tls, pVal)
	}
	sqlite3.Xsqlite3EndBenignMalloc(tls)

	tcl.XTcl_EvalObjEx(tls, i, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_GetIntFromObj(tls, i, tcl.XTcl_GetObjResult(tls, i), bp /* &res */)
	return *(*int32)(unsafe.Pointer(bp /* res */))
}

func test_collate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3026:26: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	// var db uintptr at bp+48, 8

	// var val int32 at bp+56, 4

	var pVal uintptr
	var rc int32
	var zUtf16 uintptr

	if !(objc != 5) {
		goto __1
	}
	goto bad_args
__1:
	;
	pTestCollateInterp = interp
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+56)) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), ts+17314 /* "test_collate" */, SQLITE_UTF8,
		uintptr(SQLITE_UTF8), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 56)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
	if !(rc == SQLITE_OK) {
		goto __4
	}
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+56)) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), ts+17314 /* "test_collate" */, SQLITE_UTF16LE,
		uintptr(SQLITE_UTF16LE), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 56)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+56)) {
		goto __6
	}
	return TCL_ERROR
__6:
	;

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))).Fmutex)
	pVal = sqlite3.Xsqlite3ValueNew(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, ts+17314 /* "test_collate" */, uint8(SQLITE_UTF8), uintptr(0))
	zUtf16 = sqlite3.Xsqlite3ValueText(tls, pVal, uint8(SQLITE_UTF16LE))
	if !((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48)))).FmallocFailed != 0) {
		goto __7
	}
	rc = SQLITE_NOMEM
	goto __8
__7:
	rc = sqlite3.Xsqlite3_create_collation16(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zUtf16, SQLITE_UTF16BE,
		uintptr(SQLITE_UTF16BE), func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 56)) != 0 {
				return *(*uintptr)(unsafe.Pointer(&struct {
					f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
				}{test_collate_func}))
			}
			return uintptr(0)
		}())
__8:
	;
	sqlite3.Xsqlite3ValueFree(tls, pVal)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))).Fmutex)
__4:
	;
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0) {
		goto __9
	}
	return TCL_ERROR
__9:
	;

	if !(rc != SQLITE_OK) {
		goto __10
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_ERROR
__10:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+15776, /* "wrong # args: sh..." */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17351 /* " <DB> <utf8> <ut..." */, 0))
	return TCL_ERROR
}

// Usage: add_test_utf16bin_collate <db ptr>
//
// Add a utf-16 collation sequence named "utf16bin" to the database
// handle. This collation sequence compares arguments in the same way as the
// built-in collation "binary".
func test_utf16bin_collate_func(tls *libc.TLS, pCtx uintptr, nA int32, zA uintptr, nB int32, zB uintptr) int32 { /* test1.c:3090:12: */
	var nCmp int32 = func() int32 {
		if nA > nB {
			return nB
		}
		return nA
	}()
	var res int32 = libc.Xmemcmp(tls, zA, zB, uint64(nCmp))
	if res == 0 {
		res = nA - nB
	}
	return res
}

func test_utf16bin_collate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3100:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+17384 /* "utf16bin" */, SQLITE_UTF16, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{test_utf16bin_collate_func})))
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp)), rc) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
	return TCL_ERROR
}

// When the collation needed callback is invoked, record the name of
// the requested collating function here.  The recorded name is linked
// to a TCL variable and used to make sure that the requested collation
// name is correct.
var zNeededCollation [200]int8    /* test1.c:3129:13: */
var pzNeededCollation uintptr = 0 /* test1.c:3130:13 */

// Called when a collating sequence is needed.  Registered using
// sqlite3_collation_needed16().
func test_collate_needed_cb(tls *libc.TLS, pCtx uintptr, db uintptr, eTextRep int32, pName uintptr) { /* test1.c:3137:13: */
	var enc int32 = int32((*sqlite31)(unsafe.Pointer(db)).Fenc)
	var i int32
	var z uintptr
	z = pName
	i = 0
	for ; *(*int8)(unsafe.Pointer(z)) != 0 || *(*int8)(unsafe.Pointer(z + 1)) != 0; z++ {
		if *(*int8)(unsafe.Pointer(z)) != 0 {
			zNeededCollation[libc.PostIncInt32(&i, 1)] = *(*int8)(unsafe.Pointer(z))
		}
	}
	zNeededCollation[i] = int8(0)
	sqlite3.Xsqlite3_create_collation(tls,
		db, ts+17314 /* "test_collate" */, int32((*sqlite31)(unsafe.Pointer(db)).Fenc), uintptr(intptr_t(enc)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
		}{test_collate_func})))
}

// Usage: add_test_collate_needed DB
func test_collate_needed(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3157:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	rc = sqlite3.Xsqlite3_collation_needed16(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr)
	}{test_collate_needed_cb})))
	zNeededCollation[0] = int8(0)
	if !(sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp)), rc) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
	return TCL_ERROR
}

// tclcmd:   add_alignment_test_collations  DB
//
// Add two new collating sequences to the database DB
//
//     utf16_aligned
//     utf16_unaligned
//
// Both collating sequences use the same sort order as BINARY.
// The only difference is that the utf16_aligned collating
// sequence is declared with the SQLITE_UTF16_ALIGNED flag.
// Both collating functions increment the unaligned utf16 counter
// whenever they see a string that begins on an odd byte boundary.
var unaligned_string_counter int32 = 0 /* test1.c:3192:12 */

func alignmentCollFunc(tls *libc.TLS, NotUsed uintptr, nKey1 int32, pKey1 uintptr, nKey2 int32, pKey2 uintptr) int32 { /* test1.c:3193:12: */
	var rc int32
	var n int32
	if nKey1 < nKey2 {
		n = nKey1
	} else {
		n = nKey2
	}
	if nKey1 > 0 && 1 == 1&int32(pKey1) {
		unaligned_string_counter++
	}
	if nKey2 > 0 && 1 == 1&int32(pKey2) {
		unaligned_string_counter++
	}
	rc = libc.Xmemcmp(tls, pKey1, pKey2, uint64(n))
	if rc == 0 {
		rc = nKey1 - nKey2
	}
	return rc
}

func add_alignment_test_collations(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3208:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc >= 2 {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+17393 /* "utf16_unaligned" */, SQLITE_UTF16,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{alignmentCollFunc})))
		sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+17409 /* "utf16_aligned" */, SQLITE_UTF16_ALIGNED,
			uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32
			}{alignmentCollFunc})))
	}
	return SQLITE_OK
}

// Usage: add_test_function <db ptr> <utf8> <utf16le> <utf16be>
//
// This function is used to test that SQLite selects the correct user
// function callback when multiple versions (for different text encodings)
// are available.
//
// Calling this routine registers up to three versions of the user function
// "test_function" with database handle <db>.  If the second argument is
// true, then a version of test_function is registered for UTF-8, if the
// third is true, a version is registered for UTF-16le, if the fourth is
// true, a UTF-16be version is available.  Previous versions of
// test_function are deleted.
//
// The user function is implemented by calling the following TCL script:
//
//   "test_function <enc> <arg>"
//
// Where <enc> is one of UTF-8, UTF-16LE or UTF16BE, and <arg> is the
// single argument passed to the SQL function. The value returned by
// the TCL script is used as the return value of the SQL function. It
// is passed to SQLite using UTF-16BE for a UTF-8 test_function(), UTF-8
// for a UTF-16LE test_function(), and UTF-16LE for an implementation that
// prefers UTF-16BE.
func test_function_utf8(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test1.c:3252:13: */
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+17423 /* "test_function" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+17327 /* "UTF-8" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_result_text(tls, pCtx, tcl.XTcl_GetStringResult(tls, interp), -1, libc.UintptrFromInt32(-1))
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text16be(tls, pCtx, sqlite3.Xsqlite3_value_text16be(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function_utf16le(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test1.c:3276:13: */
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+17423 /* "test_function" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+17333 /* "UTF-16LE" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text(tls, pCtx, sqlite3.Xsqlite3_value_text(tls, pVal), -1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function_utf16be(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test1.c:3298:13: */
	var interp uintptr
	var pX uintptr
	var pVal uintptr
	interp = sqlite3.Xsqlite3_user_data(tls, pCtx)
	pX = tcl.XTcl_NewStringObj(tls, ts+17423 /* "test_function" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pX)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pX, tcl.XTcl_NewStringObj(tls, ts+17342 /* "UTF-16BE" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pX,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1))
	tcl.XTcl_EvalObjEx(tls, interp, pX, 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pX
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))
	sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, tcl.XTcl_GetStringResult(tls, interp),
		uint8(SQLITE_UTF8), uintptr(0))
	sqlite3.Xsqlite3_result_text16(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_result_text16be(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_result_text16le(tls, pCtx, sqlite3.Xsqlite3_value_text16le(tls, pVal),
		-1, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3ValueFree(tls, pVal)
}

func test_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3326:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var db uintptr at bp+32, 8

	// var val int32 at bp+40, 4

	if !(objc != 5) {
		goto __1
	}
	goto bad_args
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40)) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 40)) != 0) {
		goto __4
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+17423 /* "test_function" */, 1, SQLITE_UTF8,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf8})), uintptr(0), uintptr(0))
__4:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+40)) {
		goto __5
	}
	return TCL_ERROR
__5:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 40)) != 0) {
		goto __6
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+17423 /* "test_function" */, 1, SQLITE_UTF16LE,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf16le})), uintptr(0), uintptr(0))
__6:
	;
	if !(TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+40)) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 40)) != 0) {
		goto __8
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+17423 /* "test_function" */, 1, SQLITE_UTF16BE,
		interp, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_function_utf16be})), uintptr(0), uintptr(0))
__8:
	;

	return TCL_OK
bad_args:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
		tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17351 /* " <DB> <utf8> <ut..." */, 0))
	return TCL_ERROR
}

// Usage:         sqlite3_test_errstr <err code>
//
// Test that the english language string equivalents for sqlite error codes
// are sane. The parameter is an integer representing an sqlite error code.
// The result is a list of two elements, the string representation of the
// error code and the english language explanation.
func test_errstr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3371:26: */
	var zCode uintptr
	var i int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17437 /* "<error code>" */)
	}

	zCode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	for i = 0; i < 200; i++ {
		if 0 == libc.Xstrcmp(tls, sqlite3.Xsqlite3ErrName(tls, i), zCode) {
			break
		}
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, i), uintptr(0))
	return TCL_OK
}

// Usage:    breakpoint
//
// This routine exists for one purpose - to provide a place to put a
// breakpoint with GDB that can be triggered using TCL code.  The use
// for this is when a particular test fails on (say) the 1485th iteration.
// In the TCL test script, we can add code like this:
//
//     if {$i==1485} breakpoint
//
// Then run testfixture in the debugger and wait for the breakpoint to
// fire.  Then additional breakpoints can be set to trace down the bug.
func test_breakpoint(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:3404:26: */
	return TCL_OK // Do nothing
}

// Usage:   sqlite3_bind_zeroblob  STMT IDX N
//
// Test the sqlite3_bind_zeroblob interface.  STMT is a prepared statement.
// IDX is the index of a wildcard in the prepared statement.  This command
// binds a N-byte zero-filled BLOB to the wildcard.
func test_bind_zeroblob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3420:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pStmt uintptr at bp, 8

	// var idx int32 at bp+8, 4

	// var n int32 at bp+12, 4

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17450 /* "STMT IDX N" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+12) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 8 /* idx */)), *(*int32)(unsafe.Pointer(bp + 12 /* n */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_zeroblob64  STMT IDX N
//
// Test the sqlite3_bind_zeroblob64 interface.  STMT is a prepared statement.
// IDX is the index of a wildcard in the prepared statement.  This command
// binds a N-byte zero-filled BLOB to the wildcard.
func test_bind_zeroblob64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3456:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+16, 8

	// var idx int32 at bp+24, 4

	// var n Tcl_WideInt at bp+32, 8

	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17450 /* "STMT IDX N" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+24) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+32) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_zeroblob64(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 24 /* idx */)), uint64(*(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* n */))))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 16))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_int  STMT N VALUE
//
// Test the sqlite3_bind_int interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 32-bit integer VALUE to that wildcard.
func test_bind_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3493:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	// var value int32 at bp+44, 4

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17461 /* " STMT N VALUE" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+44) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_int(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)), *(*int32)(unsafe.Pointer(bp + 44 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   intarray_addr  INT  ...
//
// Return the address of a C-language array of 32-bit integers.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_intarray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3533:26: */
	var i int32

	sqlite3.Xsqlite3_free(tls, p)
	p = uintptr(0)
	if objc > 1 {
		p = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(int32(0)))*uint64(objc-1)))
		if p == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*8)), p+uintptr(i)*4) != 0 {
				sqlite3.Xsqlite3_free(tls, p)
				p = uintptr(0)
				return TCL_ERROR
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p)))
	return TCL_OK
}

var p uintptr = uintptr(0) /* test1.c:3540:14 */

// Usage:   intarray_addr  INT  ...
//
// Return the address of a C-language array of 32-bit integers.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_int64array_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3567:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	sqlite3.Xsqlite3_free(tls, p1)
	p1 = uintptr(0)
	if objc > 1 {
		p1 = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(sqlite3_int64(0)))*uint64(objc-1)))
		if p1 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			// var v Tcl_WideInt at bp, 8

			if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*8)), bp) != 0 {
				sqlite3.Xsqlite3_free(tls, p1)
				p1 = uintptr(0)
				return TCL_ERROR
			}
			*(*sqlite3_int64)(unsafe.Pointer(p1 + uintptr(i)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp /* v */))
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p1)))
	return TCL_OK
}

var p1 uintptr = uintptr(0) /* test1.c:3574:24 */

// Usage:   doublearray_addr  INT  ...
//
// Return the address of a C-language array of doubles.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_doublearray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3603:26: */
	var i int32

	sqlite3.Xsqlite3_free(tls, p2)
	p2 = uintptr(0)
	if objc > 1 {
		p2 = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(float64(0)))*uint64(objc-1)))
		if p2 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			if tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*8)), p2+uintptr(i)*8) != 0 {
				sqlite3.Xsqlite3_free(tls, p2)
				p2 = uintptr(0)
				return TCL_ERROR
			}
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p2)))
	return TCL_OK
}

var p2 uintptr = uintptr(0) /* test1.c:3610:17 */

// Usage:   textarray_addr  TEXT ...
//
// Return the address of a C-language array of strings.
//
// Space to hold the array is obtained from malloc().  Call this procedure once
// with no arguments in order to release memory.  Each call to this procedure
// overwrites the previous array.
func test_textarray_addr(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3637:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32

	for i = 0; i < n; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*8)))
	}
	sqlite3.Xsqlite3_free(tls, p3)
	p3 = uintptr(0)
	if objc > 1 {
		p3 = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(uintptr(0)))*uint64(objc-1)))
		if p3 == uintptr(0) {
			return TCL_ERROR
		}
		for i = 0; i < objc-1; i++ {
			*(*uintptr)(unsafe.Pointer(p3 + uintptr(i)*8)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(1+i)*8)))))
		}
	}
	n = objc - 1
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(p3)))
	return TCL_OK
}

var n int32 = 0             /* test1.c:3644:14 */
var p3 uintptr = uintptr(0) /* test1.c:3645:15 */

// Usage:   sqlite3_bind_int64  STMT N VALUE
//
// Test the sqlite3_bind_int64 interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
func test_bind_int64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3670:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	// var value Tcl_WideInt at bp+48, 8

	var rc int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17461 /* " STMT N VALUE" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+48) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 48 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_double  STMT N VALUE
//
// Test the sqlite3_bind_double interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a 64-bit integer VALUE to that wildcard.
func test_bind_double(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3708:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	*(*float64)(unsafe.Pointer(bp + 48 /* value */)) = float64(0)
	var rc int32
	var zVal uintptr
	var i int32

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17461 /* " STMT N VALUE" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	// Intercept the string "NaN" and generate a NaN value for it.
	// All other strings are passed through to Tcl_GetDoubleFromObj().
	// Tcl_GetDoubleFromObj() should understand "NaN" but some versions
	// contain a bug.
	zVal = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aSpecialFp))/uint64(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{})); i++ {
		if libc.Xstrcmp(tls, aSpecialFp[i].FzName, zVal) == 0 {
			// var x sqlite3_uint64 at bp+56, 8

			*(*sqlite3_uint64)(unsafe.Pointer(bp + 56 /* x */)) = sqlite3_uint64(aSpecialFp[i].FiUpper)
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 56 /* x */)) <<= 32
			*(*sqlite3_uint64)(unsafe.Pointer(bp + 56 /* x */)) |= sqlite3_uint64(aSpecialFp[i].FiLower)

			libc.Xmemcpy(tls, bp+48 /* &value */, bp+56 /* &x */, uint64(8))
			break
		}
	}
	if uint64(i) >= uint64(unsafe.Sizeof(aSpecialFp))/uint64(unsafe.Sizeof(struct {
		FzName  uintptr
		FiUpper uint32
		FiLower uint32
	}{})) && tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_bind_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)), *(*float64)(unsafe.Pointer(bp + 48 /* value */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

var aSpecialFp = [10]struct {
	FzName  uintptr
	FiUpper uint32
	FiLower uint32
}{
	{FzName: ts + 17475 /* "NaN" */, FiUpper: uint32(0x7fffffff), FiLower: 0xffffffff},
	{FzName: ts + 17479 /* "SNaN" */, FiUpper: uint32(0x7ff7ffff), FiLower: 0xffffffff},
	{FzName: ts + 17484 /* "-NaN" */, FiUpper: 0xffffffff, FiLower: 0xffffffff},
	{FzName: ts + 17489 /* "-SNaN" */, FiUpper: 0xfff7ffff, FiLower: 0xffffffff},
	{FzName: ts + 17495 /* "+Inf" */, FiUpper: uint32(0x7ff00000)},
	{FzName: ts + 17500 /* "-Inf" */, FiUpper: 0xfff00000},
	{FzName: ts + 17505 /* "Epsilon" */, FiLower: uint32(0x00000001)},
	{FzName: ts + 17513 /* "-Epsilon" */, FiUpper: 0x80000000, FiLower: uint32(0x00000001)},
	{FzName: ts + 17522 /* "NaN0" */, FiUpper: uint32(0x7ff80000)},
	{FzName: ts + 17527 /* "-NaN0" */, FiUpper: 0xfff80000},
} /* test1.c:3724:5 */

// Usage:   sqlite3_bind_null  STMT N
//
// Test the sqlite3_bind_null interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a NULL to the wildcard.
func test_bind_null(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3784:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var idx int32 at bp+40, 4

	var rc int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17533 /* " STMT N" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_null(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* idx */)))
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 32))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_text  STMT N STRING BYTES
//
// Test the sqlite3_bind_text interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-8 string STRING to the wildcard.  The string is BYTES bytes
// long.
func test_bind_text(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3820:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var pStmt uintptr at bp+64, 8

	// var idx int32 at bp+72, 4

	*(*int32)(unsafe.Pointer(bp + 76 /* trueLength */)) = 0
	// var bytes int32 at bp+80, 4

	var value uintptr
	var rc int32
	var toFree uintptr = uintptr(0)

	if objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17541 /* " STMT N VALUE BY..." */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+76 /* &trueLength */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+80) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 {
		toFree = libc.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 76))+1))
		if toFree == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+2069 /* "out of memory" */, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xmemcpy(tls, toFree, value, uint64(*(*int32)(unsafe.Pointer(bp + 76 /* trueLength */))))
		*(*int8)(unsafe.Pointer(toFree + uintptr(*(*int32)(unsafe.Pointer(bp + 76 /* trueLength */))))) = int8(0)
		value = toFree
	}
	rc = sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 72 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 80 /* bytes */)), libc.UintptrFromInt32(-1))
	libc.Xfree(tls, toFree)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_text16 ?-static? STMT N STRING BYTES
//
// Test the sqlite3_bind_text16 interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a UTF-16 string STRING to the wildcard.  The string is BYTES bytes
// long.
func test_bind_text16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3873:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	// var pStmt uintptr at bp+64, 8

	// var idx int32 at bp+72, 4

	// var bytes int32 at bp+80, 4

	var value uintptr
	var toFree uintptr = uintptr(0)
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 76 /* trueLength */)) = 0

	var xDel uintptr = func() uintptr {
		if objc == 6 {
			return uintptr(0)
		}
		return libc.UintptrFromInt32(-1)
	}()
	var oStmt uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-4)*8))
	var oN uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-3)*8))
	var oString uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*8))
	var oBytes uintptr = *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8))

	if objc != 5 && objc != 6 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17541 /* " STMT N VALUE BY..." */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, oStmt), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, oN, bp+72) != 0 {
		return TCL_ERROR
	}
	value = tcl.XTcl_GetByteArrayFromObj(tls, oString, bp+76 /* &trueLength */)
	if tcl.XTcl_GetIntFromObj(tls, interp, oBytes, bp+80) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 && xDel == libc.UintptrFromInt32(-1) {
		toFree = libc.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 76))+3))
		if toFree == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+2069 /* "out of memory" */, uintptr(0)))
			return TCL_ERROR
		}
		libc.Xmemcpy(tls, toFree, value, uint64(*(*int32)(unsafe.Pointer(bp + 76 /* trueLength */))))
		libc.Xmemset(tls, toFree+uintptr(*(*int32)(unsafe.Pointer(bp + 76))), 0, uint64(3))
		value = toFree
	}
	rc = sqlite3.Xsqlite3_bind_text16(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 72 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 80 /* bytes */)), xDel)
	libc.Xfree(tls, toFree)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}

	return TCL_OK
}

// Usage:   sqlite3_bind_blob ?-static? STMT N DATA BYTES
//
// Test the sqlite3_bind_blob interface.  STMT is a prepared statement.
// N is the index of a wildcard in the prepared statement.  This command
// binds a BLOB to the wildcard.  The BLOB is BYTES bytes in size.
func test_bind_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3933:26: */
	bp := tls.Alloc(284)
	defer tls.Free(284)

	// var pStmt uintptr at bp+64, 8

	// var len int32 at bp+76, 4

	// var idx int32 at bp+72, 4

	// var bytes int32 at bp+80, 4

	var value uintptr
	var rc int32
	var xDestructor sqlite3_destructor_type = libc.UintptrFromInt32(-1)

	if objc != 5 && objc != 6 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+17561 /* " STMT N DATA BYT..." */, 0))
		return TCL_ERROR
	}

	if objc == 6 {
		xDestructor = uintptr(0)
		objv += 8
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}

	value = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+76 /* &len */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+80) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 80)) > *(*int32)(unsafe.Pointer(bp + 76)) {
		// var zBuf [200]int8 at bp+84, 200

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+84, /* &zBuf[0] */
			ts+17580 /* "cannot use %d bl..." */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 80 /* bytes */)), *(*int32)(unsafe.Pointer(bp + 76 /* len */))))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+84 /* &zBuf[0] */, uintptr(0)))
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_bind_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 72 /* idx */)), value, *(*int32)(unsafe.Pointer(bp + 80 /* bytes */)), xDestructor)
	if sqlite3TestErrCode(tls, interp, sqlite3.Xsqlite3_db_handle(tls, *(*uintptr)(unsafe.Pointer(bp + 64))), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {
		return TCL_ERROR
	}

	return TCL_OK
}

// sqlite3_carray_bind [options...] STMT NAME VALUE ...
//
// Options:
//    -transient
//    -static
//    -int32
//    -int64
//    -double
//    -text
//
// Each call clears static data.  Called with no options does nothing
// but clear static data.
func test_carray_bind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:3996:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var pStmt uintptr at bp+80, 8

	var eType int32 // CARRAY_INT32
	var nData int32
	var aData uintptr
	var isTransient int32
	var isStatic int32
	// var idx int32 at bp+88, 4

	var i int32
	var j int32
	var rc int32
	var xDel uintptr
	var z uintptr
	// var v int32 at bp+92, 4
	// INT32
	var a uintptr
	// var v1 Tcl_WideInt at bp+96, 8
	// INT64
	var a1 uintptr
	// var v2 float64 at bp+104, 8
	// DOUBLE
	var a2 uintptr
	var v3 uintptr // TEXT
	var a3 uintptr
	eType = 0
	nData = 0
	aData = uintptr(0)
	isTransient = 0
	isStatic = 0
	xDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))

	if !(aStaticData != 0) {
		goto __1
	}
	// Always clear preexisting static data on every call
	if !(eStaticType == 3) {
		goto __2
	}
	i = 0
__3:
	if !(i < nStaticData) {
		goto __5
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(aStaticData + uintptr(i)*8)))
	goto __4
__4:
	i++
	goto __3
	goto __5
__5:
	;
__2:
	;
	sqlite3.Xsqlite3_free(tls, aStaticData)
	aStaticData = uintptr(0)
	nStaticData = 0
	eStaticType = 0
__1:
	;
	if !(objc == 1) {
		goto __6
	}
	return TCL_OK
__6:
	;

	i = 1
__7:
	if !(i < objc && int32(*(*int8)(unsafe.Pointer(tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))))) == '-') {
		goto __9
	}
	z = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
	if !(libc.Xstrcmp(tls, z, ts+17614) == 0) {
		goto __10
	}
	isTransient = 1
	xDel = libc.UintptrFromInt32(-1)
	goto __11
__10:
	if !(libc.Xstrcmp(tls, z, ts+17625) == 0) {
		goto __12
	}
	isStatic = 1
	xDel = uintptr(0)
	goto __13
__12:
	if !(libc.Xstrcmp(tls, z, ts+17633) == 0) {
		goto __14
	}
	eType = 0 // CARRAY_INT32
	goto __15
__14:
	if !(libc.Xstrcmp(tls, z, ts+17640) == 0) {
		goto __16
	}
	eType = 1 // CARRAY_INT64
	goto __17
__16:
	if !(libc.Xstrcmp(tls, z, ts+17647) == 0) {
		goto __18
	}
	eType = 2 // CARRAY_DOUBLE
	goto __19
__18:
	if !(libc.Xstrcmp(tls, z, ts+17655) == 0) {
		goto __20
	}
	eType = 3 // CARRAY_TEXT
	goto __21
__20:
	if !(libc.Xstrcmp(tls, z, ts+17661) == 0) {
		goto __22
	}
	goto __9
	goto __23
__22:

	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+13283 /* "unknown option: " */, z, uintptr(0)))
	return TCL_ERROR
__23:
	;
__21:
	;
__19:
	;
__17:
	;
__15:
	;
__13:
	;
__11:
	;
	goto __8
__8:
	i++
	goto __7
	goto __9
__9:
	;
	if !(eType == 3 && !(isStatic != 0) && !(isTransient != 0)) {
		goto __24
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+17664, /* "text data must b..." */
		uintptr(0)))
	return TCL_ERROR
__24:
	;
	if !(isStatic != 0 && isTransient != 0) {
		goto __25
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+17711, /* "cannot be both -..." */
		uintptr(0)))
	return TCL_ERROR
__25:
	;
	if !(objc-i < 2) {
		goto __26
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17749 /* "[OPTIONS] STMT I..." */)
	return TCL_ERROR
__26:
	;
	if !(getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8))), bp+80) != 0) {
		goto __27
	}
	return TCL_ERROR
__27:
	;
	i++
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+88) != 0) {
		goto __28
	}
	return TCL_ERROR
__28:
	;
	i++
	nData = objc - i
	switch eType + 4*libc.Bool32(nData <= 0) {
	case 0:
		goto __30
	case 1:
		goto __31
	case 2:
		goto __32
	case 3:
		goto __33
	case 4:
		goto __34
	}
	goto __29
__30: // INT32
	a = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(int32(0)))*uint64(nData)))
	if !(a == uintptr(0)) {
		goto __35
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__35:
	;
	j = 0
__36:
	if !(j < nData) {
		goto __38
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*8)), bp+92) != 0) {
		goto __39
	}
	sqlite3.Xsqlite3_free(tls, a)
	return TCL_ERROR
__39:
	;
	*(*int32)(unsafe.Pointer(a + uintptr(j)*4)) = *(*int32)(unsafe.Pointer(bp + 92 /* v */))
	goto __37
__37:
	j++
	goto __36
	goto __38
__38:
	;
	aData = a
	goto __29

__31: // INT64
	a1 = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(sqlite3_int64(0)))*uint64(nData)))
	if !(a1 == uintptr(0)) {
		goto __40
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__40:
	;
	j = 0
__41:
	if !(j < nData) {
		goto __43
	}
	if !(tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*8)), bp+96) != 0) {
		goto __44
	}
	sqlite3.Xsqlite3_free(tls, a1)
	return TCL_ERROR
__44:
	;
	*(*sqlite3_int64)(unsafe.Pointer(a1 + uintptr(j)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 96 /* v1 */))
	goto __42
__42:
	j++
	goto __41
	goto __43
__43:
	;
	aData = a1
	goto __29

__32: // DOUBLE
	a2 = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(float64(0)))*uint64(nData)))
	if !(a2 == uintptr(0)) {
		goto __45
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__45:
	;
	j = 0
__46:
	if !(j < nData) {
		goto __48
	}
	if !(tcl.XTcl_GetDoubleFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*8)), bp+104) != 0) {
		goto __49
	}
	sqlite3.Xsqlite3_free(tls, a2)
	return TCL_ERROR
__49:
	;
	*(*float64)(unsafe.Pointer(a2 + uintptr(j)*8)) = *(*float64)(unsafe.Pointer(bp + 104 /* v2 */))
	goto __47
__47:
	j++
	goto __46
	goto __48
__48:
	;
	aData = a2
	goto __29

__33: // TEXT
	a3 = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(uintptr(0)))*uint64(nData)))
	if !(a3 == uintptr(0)) {
		goto __50
	}
	rc = SQLITE_NOMEM
	goto carray_bind_done
__50:
	;
	j = 0
__51:
	if !(j < nData) {
		goto __53
	}
	v3 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+j)*8)))
	*(*uintptr)(unsafe.Pointer(a3 + uintptr(j)*8)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+56, v3))
	goto __52
__52:
	j++
	goto __51
	goto __53
__53:
	;
	aData = a3
	goto __29

__34: // nData==0
	aData = ts + 584 /* "" */
	xDel = uintptr(0)
	isTransient = 0
	isStatic = 0
	goto __29

__29:
	;
	if !(isStatic != 0) {
		goto __54
	}
	aStaticData = aData
	nStaticData = nData
	eStaticType = eType
__54:
	;
	rc = sqlite3_carray_bind(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 88 /* idx */)), aData, nData, eType, xDel)
	if !(isTransient != 0) {
		goto __55
	}
	if !(eType == 3) {
		goto __56
	}
	i = 0
__57:
	if !(i < nData) {
		goto __59
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(aData + uintptr(i)*8)))
	goto __58
__58:
	i++
	goto __57
	goto __59
__59:
	;
__56:
	;
	sqlite3.Xsqlite3_free(tls, aData)
__55:
	;
carray_bind_done:
	if !(rc != 0) {
		goto __60
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, sqlite3.Xsqlite3_errstr(tls, rc), uintptr(0)))
	return TCL_ERROR
__60:
	;
	return TCL_OK
}

var aStaticData uintptr = uintptr(0) /* test1.c:4012:15 */
var nStaticData int32 = 0            /* test1.c:4013:14 */
var eStaticType int32 = 0            /* test1.c:4014:14 */

// Usage:   sqlite3_bind_parameter_count  STMT
//
// Return the number of wildcards in the given statement.
func test_bind_parameter_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4174:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17778 /* "STMT" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_bind_parameter_count(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))))
	return TCL_OK
}

// Usage:   sqlite3_bind_parameter_name  STMT  N
//
// Return the name of the Nth wildcard.  The first wildcard is 1.
// An empty string is returned if N is out of range or if the wildcard
// is nameless.
func test_bind_parameter_name(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4198:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var pStmt uintptr at bp, 8

	// var i int32 at bp+8, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17783 /* "STMT N" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_bind_parameter_name(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 8 /* i */))), -1))
	return TCL_OK
}

// Usage:   sqlite3_bind_parameter_index  STMT  NAME
//
// Return the index of the wildcard called NAME.  Return 0 if there is
// no such wildcard.
func test_bind_parameter_index(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4225:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17790 /* "STMT NAME" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewIntObj(tls,
			sqlite3.Xsqlite3_bind_parameter_index(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))))
	return TCL_OK
}

// Usage:   sqlite3_clear_bindings STMT
//
func test_clear_bindings(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4250:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17778 /* "STMT" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_clear_bindings(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))))
	return TCL_OK
}

// Usage:   sqlite3_sleep MILLISECONDS
func test_sleep(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4270:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var ms int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+13956 /* "MILLISECONDS" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_sleep(tls, *(*int32)(unsafe.Pointer(bp /* ms */)))))
	return TCL_OK
}

// Usage: sqlite3_extended_errcode DB
//
// Return the string representation of the most recent sqlite3_* API
// error code. e.g. "SQLITE_ERROR".
func test_ex_errcode(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4295:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_extended_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

// Usage: sqlite3_errcode DB
//
// Return the string representation of the most recent sqlite3_* API
// error code. e.g. "SQLITE_ERROR".
func test_errcode(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4322:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var db uintptr at bp+48, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

// Usage:   sqlite3_errmsg DB
//
// Returns the UTF-8 representation of the error message string for the
// most recent sqlite3_* API call.
func test_errmsg(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4348:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var zErr uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}

	zErr = sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErr, -1))
	return TCL_OK
}

// Usage:   test_errmsg16 DB
//
// Returns the UTF-16 representation of the error message string for the
// most recent sqlite3_* API call. This is a byte array object at the TCL
// level, and it includes the 0x00 0x00 terminator bytes at the end of the
// UTF-16 string.
func test_errmsg16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4377:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var zErr uintptr
	var z uintptr
	var bytes int32 = 0

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}

	zErr = sqlite3.Xsqlite3_errmsg16(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	if zErr != 0 {
		z = zErr
		for bytes = 0; *(*int8)(unsafe.Pointer(z + uintptr(bytes))) != 0 || *(*int8)(unsafe.Pointer(z + uintptr(bytes+1))) != 0; bytes = bytes + 2 {
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, zErr, bytes))
	return TCL_OK
}

// Usage: sqlite3_prepare DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4414:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	// var bytes int32 at bp+88, 4

	*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17800 /* " DB sql bytes ?t..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+88) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+96 /* &pStmt */, func() uintptr {
		if objc >= 5 {
			return bp + 104 /* &zTail */
		}
		return uintptr(0)
	}())
	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if *(*uintptr)(unsafe.Pointer(bp + 104)) != 0 && objc >= 5 {
		if *(*int32)(unsafe.Pointer(bp + 88)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = *(*int32)(unsafe.Pointer(bp + 88)) - int32((int64(*(*uintptr)(unsafe.Pointer(bp + 104)))-int64(zSql))/1)
		}
		if int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 104)))) < *(*int32)(unsafe.Pointer(bp + 88)) {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */))))
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+17308 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 96)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112, *(*uintptr)(unsafe.Pointer(bp + 96))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage: sqlite3_prepare_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4471:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	var zCopy uintptr = uintptr(0) // malloc() copy of zSql
	// var bytes int32 at bp+88, 4

	*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17824 /* " DB sql bytes ta..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+88) != 0 {
		return TCL_ERROR
	}

	// Instead of using zSql directly, make a copy into a buffer obtained
	// directly from malloc(). The idea is to make it easier for valgrind
	// to spot buffer overreads.
	if *(*int32)(unsafe.Pointer(bp + 88)) >= 0 {
		zCopy = libc.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
		libc.Xmemcpy(tls, zCopy, zSql, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
	} else {
		var n int32 = int32(libc.Xstrlen(tls, zSql)) + 1
		zCopy = libc.Xmalloc(tls, uint64(n))
		libc.Xmemcpy(tls, zCopy, zSql, uint64(n))
	}
	if objc >= 5 {
		pzTail = bp + 96 /* &zTail */
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zCopy, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+104 /* &pStmt */, pzTail)
	if objc >= 5 {
		*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = zSql + uintptr((int64(*(*uintptr)(unsafe.Pointer(bp + 96)))-int64(zCopy))/1)
	}
	libc.Xfree(tls, zCopy)

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if rc == SQLITE_OK && objc >= 5 && *(*uintptr)(unsafe.Pointer(bp + 96)) != 0 {
		if *(*int32)(unsafe.Pointer(bp + 88)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = *(*int32)(unsafe.Pointer(bp + 88)) - int32((int64(*(*uintptr)(unsafe.Pointer(bp + 96)))-int64(zSql))/1)
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+17308 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 104)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112, *(*uintptr)(unsafe.Pointer(bp + 104))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage: sqlite3_prepare_v3 DB sql bytes flags ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB> and flags <flags>. The parameter <tailval> is
// the name of a global variable that is set to the unused portion of
// <sql> (if any). A STMT handle is returned.
func test_prepare_v3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4545:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	var zCopy uintptr = uintptr(0) // malloc() copy of zSql
	// var bytes int32 at bp+88, 4

	// var flags int32 at bp+92, 4

	*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = uintptr(0)
	var pzTail uintptr
	*(*uintptr)(unsafe.Pointer(bp + 104 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32

	if objc != 6 && objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17846 /* " DB sql bytes fl..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+88) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+92) != 0 {
		return TCL_ERROR
	}

	// Instead of using zSql directly, make a copy into a buffer obtained
	// directly from malloc(). The idea is to make it easier for valgrind
	// to spot buffer overreads.
	if *(*int32)(unsafe.Pointer(bp + 88)) >= 0 {
		zCopy = libc.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
		libc.Xmemcpy(tls, zCopy, zSql, uint64(*(*int32)(unsafe.Pointer(bp + 88 /* bytes */))))
	} else {
		var n int32 = int32(libc.Xstrlen(tls, zSql)) + 1
		zCopy = libc.Xmalloc(tls, uint64(n))
		libc.Xmemcpy(tls, zCopy, zSql, uint64(n))
	}
	if objc >= 6 {
		pzTail = bp + 96 /* &zTail */
	} else {
		pzTail = uintptr(0)
	}
	rc = sqlite3.Xsqlite3_prepare_v3(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zCopy, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), uint32(*(*int32)(unsafe.Pointer(bp + 92 /* flags */))), bp+104 /* &pStmt */, pzTail)
	libc.Xfree(tls, zCopy)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)) = zSql + uintptr((int64(*(*uintptr)(unsafe.Pointer(bp + 96)))-int64(zCopy))/1)

	tcl.XTcl_ResetResult(tls, interp)
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if rc == SQLITE_OK && *(*uintptr)(unsafe.Pointer(bp + 96)) != 0 && objc >= 6 {
		if *(*int32)(unsafe.Pointer(bp + 88)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = *(*int32)(unsafe.Pointer(bp + 88)) - int32((int64(*(*uintptr)(unsafe.Pointer(bp + 96)))-int64(zSql))/1)
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+17308 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 104)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112, *(*uintptr)(unsafe.Pointer(bp + 104))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage: sqlite3_prepare_tkt3134 DB
//
// Generate a prepared statement for a zero-byte string as a test
// for ticket #3134.  The string should be preceded by a zero byte.
func test_prepare_tkt3134(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4616:26: */
	bp := tls.Alloc(146)
	defer tls.Free(146)

	// var db uintptr at bp+80, 8

	*(*uintptr)(unsafe.Pointer(bp + 88 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+96, 50

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17824 /* " DB sql bytes ta..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+80) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), uintptr(unsafe.Pointer(&zSql))+1, 0, bp+88 /* &pStmt */, uintptr(0))

	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 80)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+96 /* &zBuf[0] */, ts+17308 /* "(%d) " */, libc.VaList(bp+32, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+96 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 88)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+96, *(*uintptr)(unsafe.Pointer(bp + 88))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+96 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

var zSql = *(*[10]int8)(unsafe.Pointer(ts + 17874 /* "\x00SELECT 1" */)) /* test1.c:4623:21 */

// Usage: sqlite3_prepare16 DB sql bytes tailvar
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4659:26: */
	bp := tls.Alloc(130)
	defer tls.Free(130)

	// var db uintptr at bp+48, 8

	var zSql uintptr
	*(*uintptr)(unsafe.Pointer(bp + 72 /* zTail */)) = uintptr(0)
	var pTail uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+80, 50

	var rc int32
	// var bytes int32 at bp+60, 4
	// The integer specified as arg 3
	// var objlen int32 at bp+56, 4
	// The byte-array length of arg 2

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17800 /* " DB sql bytes ?t..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+56 /* &objlen */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+60) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare16(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 60 /* bytes */)), bp+64 /* &pStmt */, func() uintptr {
		if objc >= 5 {
			return bp + 72 /* &zTail */
		}
		return uintptr(0)
	}())
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		return TCL_ERROR
	}

	if objc >= 5 {
		if *(*uintptr)(unsafe.Pointer(bp + 72)) != 0 {
			*(*int32)(unsafe.Pointer(bp + 56 /* objlen */)) = *(*int32)(unsafe.Pointer(bp + 56)) - int32((int64(*(*uintptr)(unsafe.Pointer(bp + 72)))-int64(zSql))/1)
		} else {
			*(*int32)(unsafe.Pointer(bp + 56 /* objlen */)) = 0
		}
		pTail = tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 56 /* objlen */)))
		(*Tcl_Obj)(unsafe.Pointer(pTail)).FrefCount++
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), uintptr(0), pTail, 0)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pTail
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if *(*uintptr)(unsafe.Pointer(bp + 64)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+80, *(*uintptr)(unsafe.Pointer(bp + 64))) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+80 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_prepare16_v2 DB sql bytes ?tailvar?
//
// Compile up to <bytes> bytes of the supplied SQL string <sql> using
// database handle <DB>. The parameter <tailval> is the name of a global
// variable that is set to the unused portion of <sql> (if any). A
// STMT handle is returned.
func test_prepare16_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4719:26: */
	bp := tls.Alloc(130)
	defer tls.Free(130)

	// var db uintptr at bp+48, 8

	var zSql uintptr
	*(*uintptr)(unsafe.Pointer(bp + 72 /* zTail */)) = uintptr(0)
	var pTail uintptr = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 64 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+80, 50

	var rc int32
	// var bytes int32 at bp+60, 4
	// The integer specified as arg 3
	// var objlen int32 at bp+56, 4
	// The byte-array length of arg 2

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17800 /* " DB sql bytes ?t..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+56 /* &objlen */)
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+60) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_prepare16_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 60 /* bytes */)), bp+64 /* &pStmt */, func() uintptr {
		if objc >= 5 {
			return bp + 72 /* &zTail */
		}
		return uintptr(0)
	}())
	if sqlite3TestErrCode(tls, interp, *(*uintptr)(unsafe.Pointer(bp + 48)), rc) != 0 {
		return TCL_ERROR
	}
	if rc != 0 {
		return TCL_ERROR
	}

	if objc >= 5 {
		if *(*uintptr)(unsafe.Pointer(bp + 72)) != 0 {
			*(*int32)(unsafe.Pointer(bp + 56 /* objlen */)) = *(*int32)(unsafe.Pointer(bp + 56)) - int32((int64(*(*uintptr)(unsafe.Pointer(bp + 72)))-int64(zSql))/1)
		} else {
			*(*int32)(unsafe.Pointer(bp + 56 /* objlen */)) = 0
		}
		pTail = tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 56 /* objlen */)))
		(*Tcl_Obj)(unsafe.Pointer(pTail)).FrefCount++
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), uintptr(0), pTail, 0)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pTail
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	if *(*uintptr)(unsafe.Pointer(bp + 64)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+80, *(*uintptr)(unsafe.Pointer(bp + 64))) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+80 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_open filename ?options-list?
func test_open(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4774:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	var zFilename uintptr
	// var db uintptr at bp+48, 8

	// var zBuf [100]int8 at bp+56, 100

	if objc != 3 && objc != 2 && objc != 1 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17884 /* " filename option..." */, 0))
		return TCL_ERROR
	}

	if objc > 1 {
		zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	} else {
		zFilename = uintptr(0)
	}
	sqlite3.Xsqlite3_open(tls, zFilename, bp+48 /* &db */)

	if sqlite3TestMakePointerStr(tls, interp, bp+56, *(*uintptr)(unsafe.Pointer(bp + 48))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+56 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_open_v2 FILENAME FLAGS VFS
func test_open_v2(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4801:26: */
	bp := tls.Alloc(484)
	defer tls.Free(484)

	var zFilename uintptr
	var zVfs uintptr
	var flags int32 = 0
	// var db uintptr at bp+376, 8

	var rc int32
	// var zBuf [100]int8 at bp+384, 100

	// var nFlag int32 at bp+16, 4

	// var apFlag uintptr at bp+24, 8

	var i int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17907 /* "FILENAME FLAGS V..." */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if int32(*(*int8)(unsafe.Pointer(zVfs))) == 0x00 {
		zVfs = uintptr(0)
	}

	rc = tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+16 /* &nFlag */, bp+24 /* &apFlag */)
	if rc != TCL_OK {
		return rc
	}
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 16 /* nFlag */)); i++ {
		// var iFlag int32 at bp+368, 4

		*(*[21]OpenFlag)(unsafe.Pointer(bp + 32 /* aFlag */)) = [21]OpenFlag{
			{FzFlag: ts + 17926 /* "SQLITE_OPEN_READ..." */, Fflag: SQLITE_OPEN_READONLY},
			{FzFlag: ts + 17947 /* "SQLITE_OPEN_READ..." */, Fflag: SQLITE_OPEN_READWRITE},
			{FzFlag: ts + 17969 /* "SQLITE_OPEN_CREA..." */, Fflag: SQLITE_OPEN_CREATE},
			{FzFlag: ts + 17988 /* "SQLITE_OPEN_DELE..." */, Fflag: SQLITE_OPEN_DELETEONCLOSE},
			{FzFlag: ts + 18014 /* "SQLITE_OPEN_EXCL..." */, Fflag: SQLITE_OPEN_EXCLUSIVE},
			{FzFlag: ts + 18036 /* "SQLITE_OPEN_AUTO..." */, Fflag: SQLITE_OPEN_AUTOPROXY},
			{FzFlag: ts + 18058 /* "SQLITE_OPEN_MAIN..." */, Fflag: SQLITE_OPEN_MAIN_DB},
			{FzFlag: ts + 18078 /* "SQLITE_OPEN_TEMP..." */, Fflag: SQLITE_OPEN_TEMP_DB},
			{FzFlag: ts + 18098 /* "SQLITE_OPEN_TRAN..." */, Fflag: SQLITE_OPEN_TRANSIENT_DB},
			{FzFlag: ts + 18123 /* "SQLITE_OPEN_MAIN..." */, Fflag: SQLITE_OPEN_MAIN_JOURNAL},
			{FzFlag: ts + 18148 /* "SQLITE_OPEN_TEMP..." */, Fflag: SQLITE_OPEN_TEMP_JOURNAL},
			{FzFlag: ts + 18173 /* "SQLITE_OPEN_SUBJ..." */, Fflag: SQLITE_OPEN_SUBJOURNAL},
			{FzFlag: ts + 18196 /* "SQLITE_OPEN_SUPE..." */, Fflag: SQLITE_OPEN_SUPER_JOURNAL},
			{FzFlag: ts + 18222 /* "SQLITE_OPEN_NOMU..." */, Fflag: SQLITE_OPEN_NOMUTEX},
			{FzFlag: ts + 18242 /* "SQLITE_OPEN_FULL..." */, Fflag: SQLITE_OPEN_FULLMUTEX},
			{FzFlag: ts + 18264 /* "SQLITE_OPEN_SHAR..." */, Fflag: SQLITE_OPEN_SHAREDCACHE},
			{FzFlag: ts + 18288 /* "SQLITE_OPEN_PRIV..." */, Fflag: SQLITE_OPEN_PRIVATECACHE},
			{FzFlag: ts + 18313 /* "SQLITE_OPEN_WAL" */, Fflag: SQLITE_OPEN_WAL},
			{FzFlag: ts + 18329 /* "SQLITE_OPEN_URI" */, Fflag: SQLITE_OPEN_URI},
			{FzFlag: ts + 18345 /* "SQLITE_OPEN_EXRE..." */, Fflag: SQLITE_OPEN_EXRESCODE},
			{},
		}
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* apFlag */)) + uintptr(i)*8)), bp+32 /* &aFlag[0] */, int32(unsafe.Sizeof(OpenFlag{})),
			ts+18367 /* "flag" */, 0, bp+368 /* &iFlag */)
		if rc != TCL_OK {
			return rc
		}
		flags = flags | (*OpenFlag)(unsafe.Pointer(bp+32+uintptr(*(*int32)(unsafe.Pointer(bp + 368)))*16)).Fflag
	}

	rc = sqlite3.Xsqlite3_open_v2(tls, zFilename, bp+376 /* &db */, flags, zVfs)
	if sqlite3TestMakePointerStr(tls, interp, bp+384, *(*uintptr)(unsafe.Pointer(bp + 376))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+384 /* &zBuf[0] */, 0))
	return TCL_OK
}

type OpenFlag = struct {
	FzFlag       uintptr
	Fflag        int32
	F__ccgo_pad1 [4]byte
} /* test1.c:4830:5 */

// Usage: sqlite3_open16 filename options
func test_open16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4872:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	var zFilename uintptr
	// var db uintptr at bp+48, 8

	// var zBuf [100]int8 at bp+56, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17884 /* " filename option..." */, 0))
		return TCL_ERROR
	}

	zFilename = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(0))
	sqlite3.Xsqlite3_open16(tls, zFilename, bp+48 /* &db */)

	if sqlite3TestMakePointerStr(tls, interp, bp+56, *(*uintptr)(unsafe.Pointer(bp + 48))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+56 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_complete16 <UTF-16 string>
//
// Return 1 if the supplied argument is a complete SQL statement, or zero
// otherwise.
func test_complete16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4904:26: */
	var zBuf uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18372 /* "<utf-16 sql>" */)
		return TCL_ERROR
	}

	zBuf = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_complete16(tls, zBuf)))
	return TCL_OK
}

// Usage: sqlite3_normalize SQL
//
// Return the normalized value for an SQL statement.
func test_normalize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4929:26: */
	var zSql uintptr
	var zNorm uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10367 /* "SQL" */)
		return TCL_ERROR
	}

	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zNorm = sqlite3_normalize(tls, zSql)
	if zNorm != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zNorm, -1))
		sqlite3.Xsqlite3_free(tls, zNorm)
	}
	return TCL_OK
}

// Usage: sqlite3_step STMT
//
// Advance the statement to the next row.
func test_step(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4958:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17147 /* " STMT" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))

	// if( rc!=SQLITE_DONE && rc!=SQLITE_ROW ) return TCL_ERROR;
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func test_sql(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4981:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17778 /* "STMT" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */))), uintptr(1))
	return TCL_OK
}

func test_ex_sql(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:4998:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pStmt uintptr at bp, 8

	var z uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17778 /* "STMT" */)
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	z = sqlite3.Xsqlite3_expanded_sql(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	tcl.XTcl_SetResult(tls, interp, z, uintptr(1))
	sqlite3.Xsqlite3_free(tls, z)
	return TCL_OK
}

// Usage: sqlite3_column_count STMT
//
// Return the number of columns returned by the sql statement STMT.
func test_column_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5043:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))))
	return TCL_OK
}

// Usage: sqlite3_column_type STMT column
//
// Return the type of the data in column 'column' of the current row.
func test_column_type(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5068:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var tp int32

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	tp = sqlite3.Xsqlite3_column_type(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	switch tp {
	case SQLITE_INTEGER:
		tcl.XTcl_SetResult(tls, interp, ts+2413 /* "INTEGER" */, uintptr(0))
		break
	case SQLITE_NULL:
		tcl.XTcl_SetResult(tls, interp, ts+5846 /* "NULL" */, uintptr(0))
		break
	case SQLITE_FLOAT:
		tcl.XTcl_SetResult(tls, interp, ts+18398 /* "FLOAT" */, uintptr(0))
		break
	case SQLITE_TEXT:
		tcl.XTcl_SetResult(tls, interp, ts+18404 /* "TEXT" */, uintptr(0))
		break
	case SQLITE_BLOB:
		tcl.XTcl_SetResult(tls, interp, ts+18409 /* "BLOB" */, uintptr(0))
		break
	default:

	}

	return TCL_OK
}

// Usage: sqlite3_column_int64 STMT column
//
// Return the data in column 'column' of the current row cast as an
// wide (64-bit) integer.
func test_column_int64(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5117:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var iVal i64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	iVal = sqlite3.Xsqlite3_column_int64(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, iVal))
	return TCL_OK
}

// Usage: sqlite3_column_blob STMT column
func test_column_blob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5144:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var len int32
	var pBlob uintptr

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	len = sqlite3.Xsqlite3_column_bytes(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	pBlob = sqlite3.Xsqlite3_column_blob(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, pBlob, len))
	return TCL_OK
}

// Usage: sqlite3_column_double STMT column
//
// Return the data in column 'column' of the current row cast as a double.
func test_column_double(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5176:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var rVal float64

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	rVal = sqlite3.Xsqlite3_column_double(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewDoubleObj(tls, rVal))
	return TCL_OK
}

// Usage: sqlite3_data_count STMT
//
// Return the number of columns returned by the sql statement STMT.
func test_data_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5205:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pStmt uintptr at bp+32, 8

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_data_count(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)))))
	return TCL_OK
}

// Usage: sqlite3_column_text STMT column
//
// Usage: sqlite3_column_decltype STMT column
//
// Usage: sqlite3_column_name STMT column
func test_stmt_utf8(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5232:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var xFunc uintptr
	var zRet uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}
	zRet = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{xFunc})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	if zRet != 0 {
		tcl.XTcl_SetResult(tls, interp, zRet, uintptr(0))
	}
	return TCL_OK
}

func test_global_recover(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5259:26: */
	var rc int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_global_recover(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite3_column_text STMT column
//
// Usage: sqlite3_column_decltype STMT column
//
// Usage: sqlite3_column_name STMT column
func test_stmt_utf16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5284:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var pRet uintptr
	var zName16 uintptr
	var xFunc uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	zName16 = (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{xFunc})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))
	if zName16 != 0 {
		var n int32
		var z uintptr = zName16
		for n = 0; *(*int8)(unsafe.Pointer(z + uintptr(n))) != 0 || *(*int8)(unsafe.Pointer(z + uintptr(n+1))) != 0; n = n + 2 {
		}
		pRet = tcl.XTcl_NewByteArrayObj(tls, zName16, n+2)
		tcl.XTcl_SetObjResult(tls, interp, pRet)
	}

	return TCL_OK
}

// Usage: sqlite3_column_int STMT column
//
// Usage: sqlite3_column_bytes STMT column
//
// Usage: sqlite3_column_bytes16 STMT column
//
func test_stmt_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5328:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pStmt uintptr at bp+32, 8

	// var col int32 at bp+40, 4

	var xFunc uintptr

	xFunc = clientData
	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+18385 /* " STMT column" */, 0))
		return TCL_ERROR
	}

	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{xFunc})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)), *(*int32)(unsafe.Pointer(bp + 40 /* col */)))))
	return TCL_OK
}

// Usage:  sqlite3_interrupt  DB
//
// Trigger an interrupt on DB
func test_interrupt(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5358:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_interrupt(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))
	return TCL_OK
}

// Usage: sqlite_delete_function DB function-name
//
// Delete the user function 'function-name' from database handle DB. It
// is assumed that the user function was created as UTF8, any number of
// arguments (the way the TCL interface does it).
func delete_function(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5381:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32
	// var db uintptr at bp+32, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+18414 /* " DB function-nam..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), -1, SQLITE_UTF8, uintptr(0), uintptr(0), uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite_delete_collation DB collation-name
//
// Delete the collation sequence 'collation-name' from database handle
// DB. It is assumed that the collation sequence was created as UTF8 (the
// way the TCL interface does it).
func delete_collation(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5407:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var rc int32
	// var db uintptr at bp+32, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+18414 /* " DB function-nam..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), *(*uintptr)(unsafe.Pointer(argv + 2*8)), SQLITE_UTF8, uintptr(0), uintptr(0))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite3_get_autocommit DB
//
// Return true if the database DB is currently in auto-commit mode.
// Return false if not.
func get_autocommit(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5432:26: */
	bp := tls.Alloc(94)
	defer tls.Free(94)

	// var zBuf [30]int8 at bp+64, 30

	// var db uintptr at bp+56, 8

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+56) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+64 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+32, sqlite3.Xsqlite3_get_autocommit(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+64 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: sqlite3_busy_timeout DB MS
//
// Set the busy timeout.  This is more easily done using the timeout
// method of the TCL interface.  But we need a way to test the case
// where it returns SQLITE_MISUSE.
func test_busy_timeout(tls *libc.TLS, clientData uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test1.c:5458:26: */
	bp := tls.Alloc(60)
	defer tls.Free(60)

	var rc int32
	// var ms int32 at bp+56, 4

	// var db uintptr at bp+48, 8

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+56) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_busy_timeout(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), *(*int32)(unsafe.Pointer(bp + 56 /* ms */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
	return TCL_OK
}

// Usage:  tcl_variable_type VARIABLENAME
//
// Return the name of the internal representation for the
// value of the given variable.
func tcl_variable_type(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5484:26: */
	var pVar uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18432 /* "VARIABLE" */)
		return TCL_ERROR
	}
	pVar = tcl.XTcl_GetVar2Ex(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0), TCL_LEAVE_ERR_MSG)
	if pVar == uintptr(0) {
		return TCL_ERROR
	}
	if (*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*Tcl_ObjType)(unsafe.Pointer((*Tcl_Obj)(unsafe.Pointer(pVar)).FtypePtr)).Fname, -1))
	}
	return TCL_OK
}

// Usage:  sqlite3_release_memory ?N?
//
// Attempt to release memory currently held but not actually required.
// The integer N is the number of bytes we are trying to release.  The
// return value is the amount of memory actually released.
func test_release_memory(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5510:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var N int32 at bp, 4

	var amt int32
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18441 /* "?N?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp /* N */)) = -1
	}
	amt = sqlite3.Xsqlite3_release_memory(tls, *(*int32)(unsafe.Pointer(bp /* N */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, amt))
	return TCL_OK
}

// Usage:  sqlite3_db_release_memory DB
//
// Attempt to release memory currently held by database DB.  Return the
// result code (which in the current implementation is always zero).
func test_db_release_memory(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5541:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_db_release_memory(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Usage:  sqlite3_db_cacheflush DB
//
// Attempt to flush any dirty pages to disk.
func test_db_cacheflush(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5564:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_db_cacheflush(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrStr(tls, rc), uintptr(0))
		return TCL_ERROR
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

// Usage:  sqlite3_system_errno DB
//
// Return the low-level system errno value.
func test_system_errno(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5592:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var iErrno int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	iErrno = sqlite3.Xsqlite3_system_errno(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iErrno))
	return TCL_OK
}

// Usage:  sqlite3_db_filename DB DBNAME
//
// Return the name of a file associated with a database.
func test_db_filename(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5615:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var db uintptr at bp+16, 8

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17057 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 {
		return TCL_ERROR
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3_db_filename(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDbName), uintptr(0)))
	return TCL_OK
}

// Usage:  sqlite3_db_readonly DB DBNAME
//
// Return 1 or 0 if DBNAME is readonly or not.  Return -1 if DBNAME does
// not exist.
func test_db_readonly(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5639:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var zDbName uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17057 /* "DB DBNAME" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_db_readonly(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbName)))
	return TCL_OK
}

// Usage:  sqlite3_soft_heap_limit ?N?
//
// Query or set the soft heap limit for the current thread.  The
// limit is only changed if the N is present.  The previous limit
// is returned.
func test_soft_heap_limit(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5664:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)) = int64(-1)
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18441 /* "?N?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
			return TCL_ERROR
		}
	}
	amt = sqlite3.Xsqlite3_soft_heap_limit64(tls, *(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, amt))
	return TCL_OK
}

// Usage:  sqlite3_hard_heap_limit ?N?
//
// Query or set the hard heap limit for the current thread.  The
// limit is only changed if the N is present.  The previous limit
// is returned.
func test_hard_heap_limit(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5691:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var amt sqlite3_int64
	*(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)) = int64(-1)
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18441 /* "?N?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
			return TCL_ERROR
		}
	}
	amt = sqlite3.Xsqlite3_hard_heap_limit64(tls, *(*Tcl_WideInt)(unsafe.Pointer(bp /* N */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, amt))
	return TCL_OK
}

// Usage:   sqlite3_thread_cleanup
//
// Call the sqlite3_thread_cleanup API.
func test_thread_cleanup(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5716:26: */
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return TCL_OK
}

// Usage:   sqlite3_pager_refcounts  DB
//
// Return a list of numbers which are the PagerRefcount for all
// pagers on each database connection.
func test_pager_refcounts(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5734:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	var i int32
	var v int32
	var a uintptr
	var pResult uintptr

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	pResult = tcl.XTcl_NewObj(tls)
	for i = 0; i < (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FnDb; i++ {
		if (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32)))).FaDb+uintptr(i)*32)).FpBt == uintptr(0) {
			v = -1
		} else {
			sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
			a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).FaDb+uintptr(i)*32)).FpBt))
			v = *(*int32)(unsafe.Pointer(a))
			sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* db */)))).Fmutex)
		}
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, v))
	}
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

// tclcmd:   working_64bit_int
//
// Some TCL builds (ex: cygwin) do not support 64-bit integers.  This
// leads to a number of test failures.  The present command checks the
// TCL build to see whether or not it supports 64-bit integers.  It
// returns TRUE if it does and FALSE if not.
//
// This command is used to warn users that their TCL build is defective
// and that the errors they are seeing in the test scripts might be
// a result of their defective TCL rather than problems in SQLite.
func working_64bit_int(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5780:26: */
	var pTestObj uintptr
	var working int32 = 0

	pTestObj = tcl.XTcl_NewWideIntObj(tls, int64(1000000)*int64(1234567890))
	working = libc.Bool32(libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, pTestObj), ts+18445) == 0)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pTestObj
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(working != 0)))
	return TCL_OK
}

// tclcmd:   vfs_unlink_test
//
// This TCL command unregisters the primary VFS and then registers
// it back again.  This is used to test the ability to register a
// VFS when none are previously registered, and the ability to
// unregister the only available VFS.  Ticket #2738
func vfs_unlink_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5805:26: */
	bp := tls.Alloc(496)
	defer tls.Free(496)

	var i int32
	var pMain uintptr
	// var apVfs [20]uintptr at bp+336, 160

	// var one sqlite3_vfs at bp, 168

	// var two sqlite3_vfs at bp+168, 168

	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(0))                        // Unregister of NULL is harmless
	(*sqlite3_vfs)(unsafe.Pointer(bp /* &one */)).FzName = ts + 18462       /* "__one" */
	(*sqlite3_vfs)(unsafe.Pointer(bp + 168 /* &two */)).FzName = ts + 18468 /* "__two" */

	// Calling sqlite3_vfs_register with 2nd argument of 0 does not
	// change the default VFS
	pMain = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 0)

	sqlite3.Xsqlite3_vfs_register(tls, bp+168 /* &two */, 0)

	// We can find a VFS by its name

	// Calling sqlite_vfs_register with non-zero second parameter changes the
	// default VFS, even if the 1st parameter is an existig VFS that is
	// previously registered as the non-default.
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 1)

	sqlite3.Xsqlite3_vfs_register(tls, bp+168 /* &two */, 1)

	if pMain != 0 {
		sqlite3.Xsqlite3_vfs_register(tls, pMain, 1)

	}

	// Unlink the default VFS.  Repeat until there are no more VFSes
	// registered.
	for i = 0; uint64(i) < uint64(unsafe.Sizeof([20]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
		*(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)) = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if *(*uintptr)(unsafe.Pointer(bp + 336 + uintptr(i)*8)) != 0 {

			sqlite3.Xsqlite3_vfs_unregister(tls, *(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)))

		}
	}

	// Register the main VFS as non-default (will be made default, since
	// it'll be the only one in existence).
	sqlite3.Xsqlite3_vfs_register(tls, pMain, 0)

	// Un-register the main VFS again to restore an empty VFS list
	sqlite3.Xsqlite3_vfs_unregister(tls, pMain)

	/* Relink all VFSes in reverse order. */
	for i = int32(uint64(unsafe.Sizeof([20]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0))) - uint64(1)); i >= 0; i-- {
		if *(*uintptr)(unsafe.Pointer(bp + 336 + uintptr(i)*8)) != 0 {
			sqlite3.Xsqlite3_vfs_register(tls, *(*uintptr)(unsafe.Pointer(bp + 336 /* &apVfs[0] */ + uintptr(i)*8)), 1)

		}
	}

	// Unregister out sample VFSes.
	sqlite3.Xsqlite3_vfs_unregister(tls, bp /* &one */)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+168 /* &two */)

	// Unregistering a VFS that is not currently registered is harmless
	sqlite3.Xsqlite3_vfs_unregister(tls, bp /* &one */)
	sqlite3.Xsqlite3_vfs_unregister(tls, bp+168 /* &two */)

	// We should be left with the original default VFS back as the
	// original

	return TCL_OK
}

// tclcmd:   vfs_initfail_test
//
// This TCL command attempts to vfs_find and vfs_register when the
// sqlite3_initialize() interface is failing.  All calls should fail.
func vfs_initfail_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5907:26: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var one sqlite3_vfs at bp, 168

	(*sqlite3_vfs)(unsafe.Pointer(bp /* &one */)).FzName = ts + 18462 /* "__one" */

	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 0)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_vfs_register(tls, bp /* &one */, 1)
	if sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Saved VFSes
var apVfs [20]uintptr /* test1.c:5927:20: */
var nVfs int32 = 0    /* test1.c:5928:12 */

// tclcmd:   vfs_unregister_all
//
// Unregister all VFSes.
func vfs_unregister_all(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5935:26: */
	var i int32
	for i = 0; i < int32(uint64(unsafe.Sizeof(apVfs))/uint64(unsafe.Sizeof(uintptr(0)))); i++ {
		apVfs[i] = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		if apVfs[i] == uintptr(0) {
			break
		}
		sqlite3.Xsqlite3_vfs_unregister(tls, apVfs[i])
	}
	nVfs = i
	return TCL_OK
}

// tclcmd:   vfs_reregister_all
//
// Restore all VFSes that were removed using vfs_unregister_all. Taking
// care to put the linked list back together in the same order as it was
// in before vfs_unregister_all was invoked.
func vfs_reregister_all(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5957:26: */
	var i int32
	for i = nVfs - 1; i >= 0; i-- {
		sqlite3.Xsqlite3_vfs_register(tls, apVfs[i], 1)
	}
	return TCL_OK
}

// tclcmd:   file_control_test DB
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the same.
func file_control_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:5977:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	*(*int32)(unsafe.Pointer(bp + 40 /* iArg */)) = 0
	// var db uintptr at bp+32, 8

	var rc int32
	_ = rc

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), uintptr(0), 0, bp+40 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+18474 /* "notadatabase" */, SQLITE_FCNTL_LOCKSTATE, bp+40 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+85 /* "main" */, -1, bp+40 /* &iArg */)

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), ts+8574 /* "temp" */, -1, bp+40 /* &iArg */)

	return TCL_OK
}

// tclcmd:   file_control_lasterrno_test DB
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_LAST_ERRNO verb.
func file_control_lasterrno_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6012:26: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	*(*int32)(unsafe.Pointer(bp + 72 /* iArg */)) = 0
	// var db uintptr at bp+64, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+15828 /* " DB" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+64) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), SQLITE_FCNTL_LAST_ERRNO, bp+72 /* &iArg */)
	if rc != 0 {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 72)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+18487, /* "Unexpected non-z..." */
			tcl.XTcl_GetStringFromObj(tls, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 72 /* iArg */))), uintptr(0)), ts+4894 /* " " */, 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// tclcmd:   file_control_data_version DB DBNAME
//
// This TCL command runs the sqlite3_file_control with the
// SQLITE_FCNTL_DATA_VERSION opcode, returning the result.
func file_control_data_version(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6049:26: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// var iVers uint32 at bp+16, 4
	// data version
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp+8, 8
	// Database handle
	var rc int32 // file_control() return code
	// var zBuf [100]int8 at bp+20, 100

	if objc != 3 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18515 /* "DB [DBNAME]" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+8) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	} else {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), zDb, SQLITE_FCNTL_DATA_VERSION, bp+16 /* &iVers */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	} else {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+20 /* &zBuf[0] */, ts+18527 /* "%u" */, libc.VaList(bp, *(*uint32)(unsafe.Pointer(bp + 16 /* iVers */))))
		tcl.XTcl_SetResult(tls, interp, bp+20 /* zBuf */, uintptr(1))
		return TCL_OK
	}
	return int32(0)
}

// tclcmd:   file_control_chunksize_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
func file_control_chunksize_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6088:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var nSize int32 at bp+8, 4
	// New chunk size
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp, 8
	// Database handle
	var rc int32 // file_control() return code

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18530 /* "DB DBNAME SIZE" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if int32(*(*int8)(unsafe.Pointer(zDb))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb, SQLITE_FCNTL_CHUNK_SIZE, bp+8 /* &nSize */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	return TCL_OK
}

// tclcmd:   file_control_sizehint_test DB DBNAME SIZE
//
// This TCL command runs the sqlite3_file_control interface
// with SQLITE_FCNTL_SIZE_HINT
func file_control_sizehint_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6125:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nSize Tcl_WideInt at bp+8, 8
	// Hinted size
	var zDb uintptr // Db name ("main", "temp" etc.)
	// var db uintptr at bp, 8
	// Database handle
	var rc int32 // file_control() return code

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18530 /* "DB DBNAME SIZE" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 ||
		tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if int32(*(*int8)(unsafe.Pointer(zDb))) == 0 {
		zDb = uintptr(0)
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb, SQLITE_FCNTL_SIZE_HINT, bp+8 /* &nSize */)
	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	return TCL_OK
}

// tclcmd:   file_control_lockproxy_test DB PWD
//
// This TCL command runs the sqlite3_file_control interface and
// verifies correct operation of the SQLITE_GET_LOCKPROXYFILE and
// SQLITE_SET_LOCKPROXYFILE verbs.
func file_control_lockproxy_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6163:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+18545 /* " DB PWD" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}

	return TCL_OK
}

// tclcmd:   file_control_persist_wal DB PERSIST-FLAG
//
// This TCL command runs the sqlite3_file_control interface with
// the SQLITE_FCNTL_PERSIST_WAL opcode.
func file_control_persist_wal(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6334:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	// var db uintptr at bp+64, 8

	var rc int32
	// var bPersist int32 at bp+72, 4

	// var z [100]int8 at bp+76, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+18553 /* " DB FLAG" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), SQLITE_FCNTL_PERSIST_WAL, bp+72 /* &bPersist */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76 /* &z[0] */, ts+18562 /* "%d %d" */, libc.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 72 /* bPersist */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+76 /* &z[0] */, uintptr(0)))
	return TCL_OK
}

// tclcmd:   file_control_powersafe_overwrite DB PSOW-FLAG
//
// This TCL command runs the sqlite3_file_control interface with
// the SQLITE_FCNTL_POWERSAFE_OVERWRITE opcode.
func file_control_powersafe_overwrite(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6366:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	// var db uintptr at bp+64, 8

	var rc int32
	// var b int32 at bp+72, 4

	// var z [100]int8 at bp+76, 100

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+18553 /* " DB FLAG" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), uintptr(0), SQLITE_FCNTL_POWERSAFE_OVERWRITE, bp+72 /* &b */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76 /* &z[0] */, ts+18562 /* "%d %d" */, libc.VaList(bp+32, rc, *(*int32)(unsafe.Pointer(bp + 72 /* b */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+76 /* &z[0] */, uintptr(0)))
	return TCL_OK
}

// tclcmd:   file_control_vfsname DB ?AUXDB?
//
// Return a string that describes the stack of VFSes.
func file_control_vfsname(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6398:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var db uintptr at bp+48, 8

	var zDbName uintptr = ts + 85 /* "main" */
	*(*uintptr)(unsafe.Pointer(bp + 56 /* zVfsName */)) = uintptr(0)

	if objc != 2 && objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+18568 /* " DB ?AUXDB?" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zDbName, SQLITE_FCNTL_VFSNAME, bp+56 /* &zVfsName */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 56 /* zVfsName */)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* zVfsName */)))
	return TCL_OK
}

// tclcmd:   file_control_reservebytes DB N
func file_control_reservebytes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6428:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var db uintptr at bp, 8

	var zDbName uintptr = ts + 85 /* "main" */
	*(*int32)(unsafe.Pointer(bp + 8 /* n */)) = 0
	var rc int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18580 /* "DB N" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbName, SQLITE_FCNTL_RESERVE_BYTES, bp+8 /* &n */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

// tclcmd:   file_control_tempfilename DB ?AUXDB?
//
// Return a string that is a temporary filename
func file_control_tempfilename(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6460:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	// var db uintptr at bp+48, 8

	var zDbName uintptr = ts + 85 /* "main" */
	*(*uintptr)(unsafe.Pointer(bp + 56 /* zTName */)) = uintptr(0)

	if objc != 2 && objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+18568 /* " DB ?AUXDB?" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	}
	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* db */)), zDbName, SQLITE_FCNTL_TEMPFILENAME, bp+56 /* &zTName */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 56 /* zTName */)), uintptr(0)))
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* zTName */)))
	return TCL_OK
}

// tclcmd:   file_control_external_reader DB ?AUXDB?
//
// Return a string that is a temporary filename
func file_control_external_reader(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6492:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var db uintptr at bp+32, 8

	var zName uintptr = ts + 85 /* "main" */
	*(*int32)(unsafe.Pointer(bp + 40 /* iRes */)) = 0
	var rc int32 = SQLITE_OK

	if objc != 2 && objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+18568 /* " DB ?AUXDB?" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	}
	rc = sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zName, SQLITE_FCNTL_EXTERNAL_READER, bp+40 /* &iRes */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 40 /* iRes */))))
	return TCL_OK
}

// tclcmd:   sqlite3_vfs_list
//
//   Return a tcl list containing the names of all registered vfs's.
func vfs_list(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6529:26: */
	var pVfs uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}
	for pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)); pVfs != 0; pVfs = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpNext {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// tclcmd:   sqlite3_limit DB ID VALUE
//
// This TCL command runs the sqlite3_limit interface and
// verifies correct operation of the same.
func test_limit(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6554:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	// var db uintptr at bp+56, 8

	var rc int32
	var i int32
	var id int32 = 0
	// var val int32 at bp+64, 4

	var zId uintptr

	if objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+18585 /* " DB ID VALUE" */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+56) != 0 {
		return TCL_ERROR
	}
	zId = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aId))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fid          int32
		F__ccgo_pad1 [4]byte
	}{})); i++ {
		if libc.Xstrcmp(tls, zId, aId[i].FzName) == 0 {
			id = aId[i].Fid
			break
		}
	}
	if uint64(i) >= uint64(unsafe.Sizeof(aId))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fid          int32
		F__ccgo_pad1 [4]byte
	}{})) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+18598 /* "unknown limit ty..." */, zId, uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+64) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), id, *(*int32)(unsafe.Pointer(bp + 64 /* val */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

var aId = [14]struct {
	FzName       uintptr
	Fid          int32
	F__ccgo_pad1 [4]byte
}{
	{FzName: ts + 18619 /* "SQLITE_LIMIT_LEN..." */},
	{FzName: ts + 18639 /* "SQLITE_LIMIT_SQL..." */, Fid: SQLITE_LIMIT_SQL_LENGTH},
	{FzName: ts + 18663 /* "SQLITE_LIMIT_COL..." */, Fid: SQLITE_LIMIT_COLUMN},
	{FzName: ts + 18683 /* "SQLITE_LIMIT_EXP..." */, Fid: SQLITE_LIMIT_EXPR_DEPTH},
	{FzName: ts + 18707 /* "SQLITE_LIMIT_COM..." */, Fid: SQLITE_LIMIT_COMPOUND_SELECT},
	{FzName: ts + 18736 /* "SQLITE_LIMIT_VDB..." */, Fid: SQLITE_LIMIT_VDBE_OP},
	{FzName: ts + 18757 /* "SQLITE_LIMIT_FUN..." */, Fid: SQLITE_LIMIT_FUNCTION_ARG},
	{FzName: ts + 18783 /* "SQLITE_LIMIT_ATT..." */, Fid: SQLITE_LIMIT_ATTACHED},
	{FzName: ts + 18805 /* "SQLITE_LIMIT_LIK..." */, Fid: SQLITE_LIMIT_LIKE_PATTERN_LENGTH},
	{FzName: ts + 18838 /* "SQLITE_LIMIT_VAR..." */, Fid: SQLITE_LIMIT_VARIABLE_NUMBER},
	{FzName: ts + 18867 /* "SQLITE_LIMIT_TRI..." */, Fid: SQLITE_LIMIT_TRIGGER_DEPTH},
	{FzName: ts + 18894 /* "SQLITE_LIMIT_WOR..." */, Fid: SQLITE_LIMIT_WORKER_THREADS},

	// Out of range test cases
	{FzName: ts + 18922 /* "SQLITE_LIMIT_TOO..." */, Fid: -1},
	{FzName: ts + 18944 /* "SQLITE_LIMIT_TOO..." */, Fid: SQLITE_LIMIT_WORKER_THREADS + 1},
} /* test1.c:6565:5 */

// tclcmd:  save_prng_state
//
// Save the state of the pseudo-random number generator.
// At the same time, verify that sqlite3_test_control works even when
// called with an out-of-range opcode.
func save_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6617:26: */
	var rc int32 = sqlite3.Xsqlite3_test_control(tls, 9999, 0)
	_ = rc

	rc = sqlite3.Xsqlite3_test_control(tls, -1, 0)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_SAVE, 0)
	return TCL_OK
}

// tclcmd:  restore_prng_state
func restore_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6633:26: */
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_RESTORE, 0)
	return TCL_OK
}

// tclcmd:  reset_prng_state
func reset_prng_state(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6645:26: */
	sqlite3.Xsqlite3_randomness(tls, 0, uintptr(0))
	return TCL_OK
}

// tclcmd:  prng_seed INT ?DB?
//
// Set up the SQLITE_TESTCTRL_PRNG_SEED pragma with parameter INT and DB.
// INT is an integer.  DB is a database connection, or a NULL pointer if
// omitted.
//
// When INT!=0 and DB!=0, set the PRNG seed to the value of the schema
// cookie for DB, or to INT if the schema cookie happens to be zero.
//
// When INT!=0 and DB==0, set the PRNG seed to just INT.
//
// If INT==0 and DB==0 then use the default procedure of calling the
// xRandomness method on the default VFS to get the PRNG seed.
func prng_seed(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6669:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*int32)(unsafe.Pointer(bp + 16 /* i */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* db */)) = uintptr(0)
	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18964 /* "SEED ?DB?" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	if objc == 3 && getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+24) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PRNG_SEED, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16 /* i */)), *(*uintptr)(unsafe.Pointer(bp + 24 /* db */))))
	return TCL_OK
}

// tclcmd:  extra_schema_checks BOOLEAN
//
// Enable or disable schema checks when parsing the sqlite_schema file.
// This is always enabled in production, but it is sometimes useful to
// disable the checks in order to make some internal error states reachable
// for testing.
func extra_schema_checks(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6697:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*int32)(unsafe.Pointer(bp + 8 /* i */)) = 0
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18974 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* i */))))
	return TCL_OK
}

// tclcmd:  database_may_be_corrupt
//
// Indicate that database files might be corrupt. In other words, set the normal
// state of operation.
func database_may_be_corrupt(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6719:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_NEVER_CORRUPT, libc.VaList(bp, 0))
	return TCL_OK
}

// tclcmd:  database_never_corrupt
//
// Indicate that database files are always well-formed. This enables
// extra assert() statements that test conditions that are always true
// for well-formed databases.
func database_never_corrupt(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6735:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_NEVER_CORRUPT, libc.VaList(bp, 1))
	return TCL_OK
}

// tclcmd:  pcache_stats
func test_pcache_stats(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6748:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nMin int32 at bp+8, 4

	// var nMax int32 at bp+4, 4

	// var nCurrent int32 at bp, 4

	// var nRecyclable int32 at bp+12, 4

	var pRet uintptr

	sqlite3.Xsqlite3PcacheStats(tls, bp /* &nCurrent */, bp+4 /* &nMax */, bp+8 /* &nMin */, bp+12 /* &nRecyclable */)

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+18982 /* "current" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp /* nCurrent */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+18990 /* "max" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 /* nMax */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+18994 /* "min" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8 /* nMin */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+18998 /* "recyclable" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12 /* nRecyclable */))))

	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

func test_unlock_notify_cb(tls *libc.TLS, aArg uintptr, nArg int32) { /* test1.c:6778:13: */
	var ii int32
	for ii = 0; ii < nArg; ii++ {
		tcl.XTcl_EvalEx(tls, *(*uintptr)(unsafe.Pointer(aArg + uintptr(ii)*8)), ts+14519 /* "unlock_notify" */, -1, TCL_EVAL_GLOBAL)
	}
}

// tclcmd:  sqlite3_unlock_notify db
func test_unlock_notify(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6790:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_unlock_notify(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{test_unlock_notify_cb})), interp)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd:  sqlite3_wal_checkpoint db ?NAME?
func test_wal_checkpoint(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6816:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var zDb uintptr = uintptr(0)
	// var db uintptr at bp, 8

	var rc int32

	if objc != 3 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19009 /* "DB ?NAME?" */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	}
	rc = sqlite3.Xsqlite3_wal_checkpoint(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd:  sqlite3_wal_checkpoint_v2 db MODE ?NAME?
//
// This command calls the wal_checkpoint_v2() function with the specified
// mode argument (passive, full or restart). If present, the database name
// NAME is passed as the second argument to wal_checkpoint_v2(). If it the
// NAME argument is not present, a NULL pointer is passed instead.
//
// If wal_checkpoint_v2() returns any value other than SQLITE_BUSY or
// SQLITE_OK, then this command returns TCL_ERROR. The Tcl result is set
// to the error message obtained from sqlite3_errmsg().
//
// Otherwise, this command returns a list of three integers. The first integer
// is 1 if SQLITE_BUSY was returned, or 0 otherwise. The following two integers
// are the values returned via the output parameters by wal_checkpoint_v2() -
// the number of frames in the log and the number of frames in the log
// that have been checkpointed.
func test_wal_checkpoint_v2(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6860:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var zDb uintptr = uintptr(0)
	// var db uintptr at bp+32, 8

	var rc int32
	// var eMode int32 at bp+40, 4

	*(*int32)(unsafe.Pointer(bp + 88 /* nLog */)) = -555
	*(*int32)(unsafe.Pointer(bp + 92 /* nCkpt */)) = -555
	var pRet uintptr

	*(*[5]uintptr)(unsafe.Pointer(bp + 48 /* aMode */)) = [5]uintptr{ts + 19019 /* "passive" */, ts + 19027 /* "full" */, ts + 19032 /* "restart" */, ts + 19040 /* "truncate" */, uintptr(0)}

	if objc != 3 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19049 /* "DB MODE ?NAME?" */)
		return TCL_ERROR
	}

	if objc == 4 {
		zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 || TCL_OK != tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) &&
		TCL_OK != tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+48, int32(unsafe.Sizeof(uintptr(0))), ts+19064, 0, bp+40) {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_wal_checkpoint_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zDb, *(*int32)(unsafe.Pointer(bp + 40 /* eMode */)), bp+88 /* &nLog */, bp+92 /* &nCkpt */)
	if rc != SQLITE_OK && rc != SQLITE_BUSY {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, zErrCode, ts+10477 /* " - " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */))), 0))
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, func() int32 {
		if rc == SQLITE_BUSY {
			return 1
		}
		return 0
	}()))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 88 /* nLog */))))
	tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 92 /* nCkpt */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)

	return TCL_OK
}

// tclcmd:  sqlite3_wal_autocheckpoint db VALUE
func test_wal_autocheckpoint(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6916:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var db uintptr at bp, 8

	var rc int32
	// var iVal int32 at bp+8, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19069 /* "DB VALUE" */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_wal_autocheckpoint(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 8 /* iVal */)))
	tcl.XTcl_ResetResult(tls, interp)
	if rc != SQLITE_OK {
		var zErrCode uintptr = sqlite3.Xsqlite3ErrName(tls, rc)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, zErrCode, -1))
		return TCL_ERROR
	}

	return TCL_OK
}

// tclcmd:  test_sqlite3_log ?SCRIPT?
type LogCallback = struct {
	FpInterp uintptr
	FpObj    uintptr
} /* test1.c:6953:8 */

// tclcmd:  test_sqlite3_log ?SCRIPT?
var logcallback = LogCallback{} /* test1.c:6956:3 */

func xLogcallback(tls *libc.TLS, unused uintptr, err int32, zMsg uintptr) { /* test1.c:6957:13: */
	var pNew uintptr = tcl.XTcl_DuplicateObj(tls, logcallback.FpObj)
	(*Tcl_Obj)(unsafe.Pointer(pNew)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls,
		uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, err), -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pNew, tcl.XTcl_NewStringObj(tls, zMsg, -1))
	tcl.XTcl_EvalObjEx(tls, logcallback.FpInterp, pNew, TCL_EVAL_GLOBAL|TCL_EVAL_DIRECT)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pNew
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func test_sqlite3_log(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6967:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+11019 /* "SCRIPT" */)
		return TCL_ERROR
	}
	if logcallback.FpObj != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = logcallback.FpObj
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		logcallback.FpObj = uintptr(0)
		logcallback.FpInterp = uintptr(0)
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp, uintptr(0), uintptr(0)))
	}
	if objc > 1 {
		logcallback.FpObj = *(*uintptr)(unsafe.Pointer(objv + 1*8))
		(*Tcl_Obj)(unsafe.Pointer(logcallback.FpObj)).FrefCount++
		logcallback.FpInterp = interp
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOG, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{xLogcallback})), uintptr(0)))
	}
	return TCL_OK
}

//     tcl_objproc COMMANDNAME ARGS...
//
// Run a TCL command using its objProc interface.  Throw an error if
// the command has no objProc interface.
func runAsObjProc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:6998:26: */
	bp := tls.Alloc(112)
	defer tls.Free(112)

	// var cmdInfo Tcl_CmdInfo at bp+48, 64

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19078 /* "COMMAND ..." */)
		return TCL_ERROR
	}
	if !(tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15686, /* "command not foun..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0)))
		return TCL_ERROR
	}
	if (*Tcl_CmdInfo)(unsafe.Pointer(bp+48)).FobjProc == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+19090, /* "command has no o..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0)))
		return TCL_ERROR
	}
	return (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*Tcl_CmdInfo)(unsafe.Pointer(bp + 48 /* &cmdInfo */)).FobjProc})).f(tls, (*Tcl_CmdInfo)(unsafe.Pointer(bp+48 /* &cmdInfo */)).FobjClientData, interp, objc-1, objv+uintptr(1)*8)
}

// WARNING: The following function, printExplainQueryPlan() is an exact
// copy of example code from eqp.in (eqp.html). If this code is modified,
// then the documentation copy needs to be modified as well.
// Argument pStmt is a prepared SQL statement. This function compiles
// an EXPLAIN QUERY PLAN command to report on the prepared statement,
// and prints the report to stdout using printf().
func printExplainQueryPlan(tls *libc.TLS, pStmt uintptr) int32 { /* test1.c:7033:5: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zSql uintptr     // Input SQL
	var zExplain uintptr // SQL with EXPLAIN QUERY PLAN prepended
	// var pExplain uintptr at bp+40, 8
	// Compiled EXPLAIN QUERY PLAN command
	var rc int32 // Return code from sqlite3_prepare_v2()

	zSql = sqlite3.Xsqlite3_sql(tls, pStmt)
	if zSql == uintptr(0) {
		return SQLITE_ERROR
	}

	zExplain = sqlite3.Xsqlite3_mprintf(tls, ts+330 /* "EXPLAIN QUERY PL..." */, libc.VaList(bp, zSql))
	if zExplain == uintptr(0) {
		return SQLITE_NOMEM
	}

	rc = sqlite3.Xsqlite3_prepare_v2(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt), zExplain, -1, bp+40 /* &pExplain */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zExplain)
	if rc != SQLITE_OK {
		return rc
	}

	for SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 40))) {
		var iSelectid int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 0)
		var iOrder int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 1)
		var iFrom int32 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 2)
		var zDetail uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)), 3)

		libc.Xprintf(tls, ts+19115 /* "%d %d %d %s\n" */, libc.VaList(bp+8, iSelectid, iOrder, iFrom, zDetail))
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* pExplain */)))
}

func test_print_eqp(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7061:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var pStmt uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17778 /* "STMT" */)
		return TCL_ERROR
	}
	if getStmtPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	rc = printExplainQueryPlan(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
	// This is needed on Windows so that a test case using this
	// function can open a read pipe and get the output of
	// printExplainQueryPlan() immediately.
	libc.Xfflush(tls, libc.X__stdoutp)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// sqlite3_test_control VERB ARGS...
func test_test_control(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7089:26: */
	bp := tls.Alloc(184)
	defer tls.Free(184)

	*(*[4]Verb)(unsafe.Pointer(bp + 64 /* aVerb */)) = [4]Verb{
		{FzName: ts + 19128 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_LOCALTIME_FAULT},
		{FzName: ts + 19160 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_SORTER_MMAP},
		{FzName: ts + 19188 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_IMPOSTER},
		{FzName: ts + 19213 /* "SQLITE_TESTCTRL_..." */, Fi: SQLITE_TESTCTRL_INTERNAL_FUNCTIONS},
	}
	// var iVerb int32 at bp+128, 4

	var iFlag int32
	var rc int32

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19248 /* "VERB ARGS..." */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+64 /* &aVerb[0] */, int32(unsafe.Sizeof(Verb{})), ts+19261 /* "VERB" */, 0, bp+128 /* &iVerb */)
	if rc != TCL_OK {
		return rc
	}

	iFlag = (*Verb)(unsafe.Pointer(bp + 64 /* &aVerb */ + uintptr(*(*int32)(unsafe.Pointer(bp + 128 /* iVerb */)))*16)).Fi
	switch iFlag {
	case SQLITE_TESTCTRL_INTERNAL_FUNCTIONS:
		{
			*(*uintptr)(unsafe.Pointer(bp + 136 /* db */)) = uintptr(0)
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+2050 /* "DB" */)
				return TCL_ERROR
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+136) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_INTERNAL_FUNCTIONS, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(bp + 136 /* db */))))
			break

		}
	case SQLITE_TESTCTRL_LOCALTIME_FAULT:
		{
			// var val int32 at bp+144, 4

			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19266 /* "ONOFF" */)
				return TCL_ERROR
			}
			if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+144) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, iFlag, libc.VaList(bp+8, *(*int32)(unsafe.Pointer(bp + 144 /* val */))))
			break

		}

	case SQLITE_TESTCTRL_SORTER_MMAP:
		{
			// var val int32 at bp+160, 4

			// var db uintptr at bp+152, 8

			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19272 /* "DB LIMIT" */)
				return TCL_ERROR
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+152) != 0 {
				return TCL_ERROR
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+160) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_SORTER_MMAP, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(bp + 152 /* db */)), *(*int32)(unsafe.Pointer(bp + 160 /* val */))))
			break

		}

	case SQLITE_TESTCTRL_IMPOSTER:
		{
			// var onOff int32 at bp+176, 4

			// var tnum int32 at bp+180, 4

			var zDbName uintptr
			// var db uintptr at bp+168, 8

			if objc != 6 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+19281 /* "DB dbName onOff ..." */)
				return TCL_ERROR
			}
			if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+168) != 0 {
				return TCL_ERROR
			}
			zDbName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+176) != 0 {
				return TCL_ERROR
			}
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*8)), bp+180) != 0 {
				return TCL_ERROR
			}
			sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_IMPOSTER, libc.VaList(bp+32, *(*uintptr)(unsafe.Pointer(bp + 168 /* db */)), zDbName, *(*int32)(unsafe.Pointer(bp + 176 /* onOff */)), *(*int32)(unsafe.Pointer(bp + 180 /* tnum */))))
			break

		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

type Verb = struct {
	FzName       uintptr
	Fi           int32
	F__ccgo_pad1 [4]byte
} /* test1.c:7095:3 */

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)resource.h	8.4 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Process priority specifications to get/setpriority.

// Resource utilization information.
//
// All fields are only modified by curthread and
// no locks are required to read.

type rusage = struct {
	Fru_utime struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
	Fru_stime struct {
		Ftv_sec  time_t
		Ftv_usec suseconds_t
	}
	Fru_maxrss   int64
	Fru_ixrss    int64
	Fru_idrss    int64
	Fru_isrss    int64
	Fru_minflt   int64
	Fru_majflt   int64
	Fru_nswap    int64
	Fru_inblock  int64
	Fru_oublock  int64
	Fru_msgsnd   int64
	Fru_msgrcv   int64
	Fru_nsignals int64
	Fru_nvcsw    int64
	Fru_nivcsw   int64
} /* resource.h:73:1 */

type __wrusage = struct {
	Fwru_self struct {
		Fru_utime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_stime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_maxrss   int64
		Fru_ixrss    int64
		Fru_idrss    int64
		Fru_isrss    int64
		Fru_minflt   int64
		Fru_majflt   int64
		Fru_nswap    int64
		Fru_inblock  int64
		Fru_oublock  int64
		Fru_msgsnd   int64
		Fru_msgrcv   int64
		Fru_nsignals int64
		Fru_nvcsw    int64
		Fru_nivcsw   int64
	}
	Fwru_children struct {
		Fru_utime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_stime struct {
			Ftv_sec  time_t
			Ftv_usec suseconds_t
		}
		Fru_maxrss   int64
		Fru_ixrss    int64
		Fru_idrss    int64
		Fru_isrss    int64
		Fru_minflt   int64
		Fru_majflt   int64
		Fru_nswap    int64
		Fru_inblock  int64
		Fru_oublock  int64
		Fru_msgsnd   int64
		Fru_msgrcv   int64
		Fru_nsignals int64
		Fru_nvcsw    int64
		Fru_nivcsw   int64
	}
} /* resource.h:95:1 */

// Resource limits

// Resource limit string identifiers

type rlimit = struct {
	Frlim_cur rlim_t
	Frlim_max rlim_t
} /* resource.h:151:1 */

type orlimit = struct {
	Frlim_cur int32
	Frlim_max int32
} /* resource.h:158:1 */

type loadavg = struct {
	Fldavg       [3]uint32
	F__ccgo_pad1 [4]byte
	Ffscale      int64
} /* resource.h:163:1 */

func test_getrusage(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7179:26: */
	bp := tls.Alloc(1216)
	defer tls.Free(1216)

	// var buf [1024]int8 at bp+192, 1024

	// var r rusage at bp+48, 144

	libc.Xmemset(tls, bp+48 /* &r */, 0, uint64(unsafe.Sizeof(rusage{})))
	libc.Xgetrusage(tls, RUSAGE_SELF, bp+48 /* &r */)

	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1024]int8{})), bp+192, /* &buf[0] */
		ts+19302, /* "ru_utime=%d.%06d..." */
		libc.VaList(bp, int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_utime.Ftv_sec), int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_utime.Ftv_usec),
			int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_stime.Ftv_sec), int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_stime.Ftv_usec),
			int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_minflt), int32((*rusage)(unsafe.Pointer(bp+48 /* &r */)).Fru_majflt)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+192 /* &buf[0] */, -1))
	return TCL_OK
}

//      optimization_control DB OPT BOOLEAN
//
// Enable or disable query optimizations using the sqlite3_test_control()
// interface.  Disable if BOOLEAN is false and enable if BOOLEAN is true.
// OPT is the name of the optimization to be disabled.
func optimization_control(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7459:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var i int32
	// var db uintptr at bp+56, 8

	var zOpt uintptr
	// var onoff int32 at bp+64, 4

	var mask int32 = 0

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19362 /* "DB OPT BOOLEAN" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+56) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+64) != 0 {
		return TCL_ERROR
	}
	zOpt = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aOpt))/uint64(unsafe.Sizeof(struct {
		FzOptName    uintptr
		Fmask        int32
		F__ccgo_pad1 [4]byte
	}{})); i++ {
		if libc.Xstrcmp(tls, zOpt, aOpt[i].FzOptName) == 0 {
			mask = aOpt[i].Fmask
			break
		}
	}
	if *(*int32)(unsafe.Pointer(bp + 64)) != 0 {
		mask = ^mask
	}
	if uint64(i) >= uint64(unsafe.Sizeof(aOpt))/uint64(unsafe.Sizeof(struct {
		FzOptName    uintptr
		Fmask        int32
		F__ccgo_pad1 [4]byte
	}{})) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19377, /* "unknown optimiza..." */
			uintptr(0)))
		for i = 0; uint64(i) < uint64(unsafe.Sizeof(aOpt))/uint64(unsafe.Sizeof(struct {
			FzOptName    uintptr
			Fmask        int32
			F__ccgo_pad1 [4]byte
		}{})); i++ {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+4894 /* " " */, aOpt[i].FzOptName, uintptr(0)))
		}
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_OPTIMIZATIONS, libc.VaList(bp+40, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), mask))
	return TCL_OK
}

var aOpt = [13]struct {
	FzOptName    uintptr
	Fmask        int32
	F__ccgo_pad1 [4]byte
}{
	{FzOptName: ts + 19418 /* "all" */, Fmask: libc.Int32FromUint32(SQLITE_AllOpts)},
	{FzOptName: ts + 19422 /* "none" */},
	{FzOptName: ts + 19427 /* "query-flattener" */, Fmask: SQLITE_QueryFlattener},
	{FzOptName: ts + 19443 /* "groupby-order" */, Fmask: SQLITE_GroupByOrder},
	{FzOptName: ts + 19457 /* "factor-constants" */, Fmask: SQLITE_FactorOutConst},
	{FzOptName: ts + 19474 /* "distinct-opt" */, Fmask: SQLITE_DistinctOpt},
	{FzOptName: ts + 19487 /* "cover-idx-scan" */, Fmask: SQLITE_CoverIdxScan},
	{FzOptName: ts + 19502 /* "order-by-idx-joi..." */, Fmask: SQLITE_OrderByIdxJoin},
	{FzOptName: ts + 19520 /* "transitive" */, Fmask: SQLITE_Transitive},
	{FzOptName: ts + 19531 /* "omit-noop-join" */, Fmask: SQLITE_OmitNoopJoin},
	{FzOptName: ts + 19546 /* "stat4" */, Fmask: SQLITE_Stat4},
	{FzOptName: ts + 19552 /* "skip-scan" */, Fmask: SQLITE_SkipScan},
	{FzOptName: ts + 19562 /* "push-down" */, Fmask: SQLITE_PushDown},
} /* test1.c:7473:5 */

//     load_static_extension DB NAME ...
//
// Load one or more statically linked extensions.
func tclLoadStaticExtensionCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7520:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var db uintptr at bp+64, 8

	var zName uintptr
	var i int32
	var j int32
	var rc int32
	*(*uintptr)(unsafe.Pointer(bp + 72 /* zErrMsg */)) = uintptr(0)
	if objc < 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19572 /* "DB NAME ..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+64) != 0 {
		return TCL_ERROR
	}
	for j = 2; j < objc; j++ {
		zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(j)*8)))
		for i = 0; i < int32(uint64(unsafe.Sizeof(aExtension))/uint64(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{}))); i++ {
			if libc.Xstrcmp(tls, zName, aExtension[i].FzExtName) == 0 {
				break
			}
		}
		if i >= int32(uint64(unsafe.Sizeof(aExtension))/uint64(unsafe.Sizeof(struct {
			FzExtName uintptr
			FpInit    uintptr
		}{}))) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19584 /* "no such extensio..." */, zName, uintptr(0)))
			return TCL_ERROR
		}
		if aExtension[i].FpInit != 0 {
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{aExtension[i].FpInit})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), bp+72 /* &zErrMsg */, uintptr(0))
		} else {
			rc = SQLITE_OK
		}
		if rc != SQLITE_OK && rc != SQLITE_OK|int32(1)<<8 || *(*uintptr)(unsafe.Pointer(bp + 72)) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+19604 /* "initialization o..." */, zName, ts+19623 /* " failed: " */, *(*uintptr)(unsafe.Pointer(bp + 72 /* zErrMsg */)),
				uintptr(0)))
			sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* zErrMsg */)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

var aExtension = [22]struct {
	FzExtName uintptr
	FpInit    uintptr
}{
	{FzExtName: ts + 19633 /* "amatch" */, FpInit: 0},
	{FzExtName: ts + 19640 /* "appendvfs" */, FpInit: 0},
	{FzExtName: ts + 4060 /* "carray" */, FpInit: 0},
	{FzExtName: ts + 19650 /* "closure" */, FpInit: 0},
	{FzExtName: ts + 4815 /* "csv" */, FpInit: 0},
	{FzExtName: ts + 4838 /* "decimal" */, FpInit: 0},
	{FzExtName: ts + 4896 /* "eval" */, FpInit: 0},
	{FzExtName: ts + 4974 /* "explain" */, FpInit: 0},
	{FzExtName: ts + 19658 /* "fileio" */, FpInit: 0},
	{FzExtName: ts + 5483 /* "fuzzer" */, FpInit: 0},
	{FzExtName: ts + 5507 /* "ieee754" */, FpInit: 0},
	{FzExtName: ts + 19665 /* "nextchar" */, FpInit: 0},
	{FzExtName: ts + 6087 /* "percentile" */, FpInit: 0},
	{FzExtName: ts + 6162 /* "prefixes" */, FpInit: 0},
	{FzExtName: ts + 6474 /* "regexp" */, FpInit: 0},
	{FzExtName: ts + 6489 /* "remember" */, FpInit: 0},
	{FzExtName: ts + 19674 /* "series" */, FpInit: 0},
	{FzExtName: ts + 19681 /* "spellfix" */, FpInit: 0},
	{FzExtName: ts + 19690 /* "totype" */, FpInit: 0},
	{FzExtName: ts + 8564 /* "unionvtab" */, FpInit: 0},
	{FzExtName: ts + 9106 /* "wholenumber" */, FpInit: 0},
	{FzExtName: ts + 9209 /* "zipfile" */, FpInit: 0},
} /* test1.c:7555:5 */

//     sorter_test_fakeheap BOOL
//
func sorter_test_fakeheap(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7620:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var bArg int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10984 /* "BOOL" */)
		return TCL_ERROR
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp)) != 0 {
		if sqlite3.Xsqlite3Config.FpHeap == uintptr(0) {
			sqlite3.Xsqlite3Config.FpHeap = libc.UintptrFromInt64(int64(-1))
		}
	} else {
		if sqlite3.Xsqlite3Config.FpHeap == libc.UintptrFromInt64(int64(-1)) {
			sqlite3.Xsqlite3Config.FpHeap = uintptr(0)
		}
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

//     sorter_test_sort4_helper DB SQL1 NSTEP SQL2
//
// Compile SQL statement $SQL1 and step it $NSTEP times. For each row,
// check that the leftmost and rightmost columns returned are both integers,
// and that both contain the same value.
//
// Then execute statement $SQL2. Check that the statement returns the same
// set of integers in the same order as in the previous step (using $SQL1).
func sorter_test_sort4_helper(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7660:26: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	var zSql1 uintptr
	var zSql2 uintptr
	// var nStep int32 at bp+64, 4

	var iStep int32
	var iCksum1 uint32
	var iCksum2 uint32
	var rc int32
	var iB int32
	// var db uintptr at bp+56, 8

	// var pStmt uintptr at bp+72, 8

	var a int32
	var a1 int32
	iCksum1 = uint32(0)
	iCksum2 = uint32(0)

	if !(objc != 5) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19697 /* "DB SQL1 NSTEP SQ..." */)
	return TCL_ERROR
__1:
	;

	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+56) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;
	zSql1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+64) != 0) {
		goto __3
	}
	return TCL_ERROR
__3:
	;
	zSql2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))

	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), zSql1, -1, bp+72 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __4
	}
	goto sql_error
__4:
	;

	iB = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 72))) - 1
	iStep = 0
__5:
	if !(iStep < *(*int32)(unsafe.Pointer(bp + 64)) && SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 72)))) {
		goto __7
	}
	a = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)), 0)
	if !(a != sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 72)), iB)) {
		goto __8
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+19716 /* "data error: (a!=..." */, 0))
	return TCL_ERROR
__8:
	;

	iCksum1 = iCksum1 + (iCksum1<<3 + uint32(a))
	goto __6
__6:
	iStep++
	goto __5
	goto __7
__7:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)))
	if !(rc != SQLITE_OK) {
		goto __9
	}
	goto sql_error
__9:
	;

	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */)), zSql2, -1, bp+72 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __10
	}
	goto sql_error
__10:
	;
	iStep = 0
__11:
	if !(SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 72)))) {
		goto __13
	}
	a1 = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)), 0)
	iCksum2 = iCksum2 + (iCksum2<<3 + uint32(a1))
	goto __12
__12:
	iStep++
	goto __11
	goto __13
__13:
	;
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 72 /* pStmt */)))
	if !(rc != SQLITE_OK) {
		goto __14
	}
	goto sql_error
__14:
	;

	if !(iCksum1 != iCksum2) {
		goto __15
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+19735 /* "checksum mismatc..." */, 0))
	return TCL_ERROR
__15:
	;

	return TCL_OK
sql_error:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+19753 /* "sql error: " */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 56 /* db */))), 0))
	return TCL_ERROR
}

// tclcmd: bad_behavior TYPE
//
// Do some things that should trigger a valgrind or -fsanitize=undefined
// warning.  This is used to verify that errors and warnings output by those
// tools are detected by the test scripts.
//
//       TYPE       BEHAVIOR
//       1          Overflow a signed integer
//       2          Jump based on an uninitialized variable
//       3          Read after free
//       4          Panic
func test_bad_behavior(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7863:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var iType int32 at bp, 4

	var xyz int32
	var i int32 = *(*int32)(unsafe.Pointer(clientData))
	var j int32
	// var w [10]int32 at bp+4, 40

	var a uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19765 /* "TYPE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	switch *(*int32)(unsafe.Pointer(bp /* iType */)) {
	case 1:
		{
			xyz = 0x7fffff00 - i
			xyz = xyz + 0x100
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, xyz))
			break

		}
	case 2:
		{
			*(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + 1*4)) = 5
			if *(*int32)(unsafe.Pointer(bp + 4 + uintptr(i)*4)) > 0 {
				*(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + 1*4))++
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 4 /* &w[0] */ + 1*4))))
			break

		}
	case 3:
		{
			a = libc.Xmalloc(tls, uint64(unsafe.Sizeof(int32(0)))*uint64(10))
			for j = 0; j < 10; j++ {
				*(*int32)(unsafe.Pointer(a + uintptr(j)*4)) = j
			}
			libc.Xfree(tls, a)
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
			break

		}
	case 4:
		{
			tcl.XTcl_Panic(tls, ts+19770 /* "Deliberate panic" */, 0)
			break

		}
	}
	return TCL_OK
}

// tclcmd:   register_dbstat_vtab DB
//
// Cause the dbstat virtual table to be available on the connection DB
func test_register_dbstat_vtab(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7913:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var zDb uintptr
	// var cmdInfo Tcl_CmdInfo at bp, 64

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}

	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp) != 0 {
		var db uintptr = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp)).FobjClientData)).Fdb
		sqlite3.Xsqlite3DbstatRegister(tls, db)
	}
	return TCL_OK
}

// tclcmd:   sqlite3_db_config DB SETTING VALUE
//
// Invoke sqlite3_db_config() for one of the setting values.
func test_sqlite3_db_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:7947:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var i int32
	*(*int32)(unsafe.Pointer(bp + 24 /* v */)) = 0
	var zSetting uintptr
	// var db uintptr at bp+16, 8

	if objc != 4 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+19787 /* "DB SETTING [VALU..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 {
		return TCL_ERROR
	}
	zSetting = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if sqlite3.Xsqlite3_strglob(tls, ts+19806, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+19815, zSetting) == 0 {
		zSetting += uintptr(9)
	}
	if sqlite3.Xsqlite3_strglob(tls, ts+19826, zSetting) == 0 {
		zSetting += uintptr(7)
	}
	for i = 0; i < int32(uint64(unsafe.Sizeof(aSetting))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		FeVal        int32
		F__ccgo_pad1 [4]byte
	}{}))); i++ {
		if libc.Xstrcmp(tls, zSetting, aSetting[i].FzName) == 0 {
			break
		}
	}
	if i >= int32(uint64(unsafe.Sizeof(aSetting))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		FeVal        int32
		F__ccgo_pad1 [4]byte
	}{}))) {
		tcl.XTcl_SetObjResult(tls, interp,
			tcl.XTcl_NewStringObj(tls, ts+19835 /* "unknown sqlite3_..." */, -1))
		return TCL_ERROR
	}
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+24) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 24 /* v */)) = -1
	}
	sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), aSetting[i].FeVal, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 24 /* v */)), bp+24 /* &v */))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 24 /* v */))))
	return TCL_OK
}

var aSetting = [14]struct {
	FzName       uintptr
	FeVal        int32
	F__ccgo_pad1 [4]byte
}{
	{FzName: ts + 19869 /* "FKEY" */, FeVal: SQLITE_DBCONFIG_ENABLE_FKEY},
	{FzName: ts + 19874 /* "TRIGGER" */, FeVal: SQLITE_DBCONFIG_ENABLE_TRIGGER},
	{FzName: ts + 19882 /* "FTS3_TOKENIZER" */, FeVal: SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER},
	{FzName: ts + 19897 /* "LOAD_EXTENSION" */, FeVal: SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION},
	{FzName: ts + 19912 /* "NO_CKPT_ON_CLOSE" */, FeVal: SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE},
	{FzName: ts + 19929 /* "QPSG" */, FeVal: SQLITE_DBCONFIG_ENABLE_QPSG},
	{FzName: ts + 19934 /* "TRIGGER_EQP" */, FeVal: SQLITE_DBCONFIG_TRIGGER_EQP},
	{FzName: ts + 19946 /* "RESET_DB" */, FeVal: SQLITE_DBCONFIG_RESET_DATABASE},
	{FzName: ts + 19955 /* "DEFENSIVE" */, FeVal: SQLITE_DBCONFIG_DEFENSIVE},
	{FzName: ts + 19965 /* "WRITABLE_SCHEMA" */, FeVal: SQLITE_DBCONFIG_WRITABLE_SCHEMA},
	{FzName: ts + 19981 /* "LEGACY_ALTER_TAB..." */, FeVal: SQLITE_DBCONFIG_LEGACY_ALTER_TABLE},
	{FzName: ts + 20000 /* "DQS_DML" */, FeVal: SQLITE_DBCONFIG_DQS_DML},
	{FzName: ts + 20008 /* "DQS_DDL" */, FeVal: SQLITE_DBCONFIG_DQS_DDL},
	{FzName: ts + 20016 /* "LEGACY_FILE_FORM..." */, FeVal: SQLITE_DBCONFIG_LEGACY_FILE_FORMAT},
} /* test1.c:7956:5 */

// tclcmd:   sqlite3_txn_state DB ?SCHEMA?
//
// Invoke sqlite3_txn_state(DB,SCHEMA) and return the
// numeric value that results.  Use NULL for SCHEMA if the 3 argument
// is omitted.
func test_sqlite3_txn_state(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8010:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var zSchema uintptr
	var iTxn int32

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20035 /* "DB ?SCHEMA?" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zSchema = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	} else {
		zSchema = uintptr(0)
	}
	iTxn = sqlite3.Xsqlite3_txn_state(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zSchema)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iTxn))
	return TCL_OK
}

// Change the name of the main database schema from "main" to "icecube".
func test_dbconfig_maindbname_icecube(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8034:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var db uintptr at bp+8, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	} else {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+8) != 0 {
			return TCL_ERROR
		}
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), SQLITE_DBCONFIG_MAINDBNAME, libc.VaList(bp, ts+20047 /* "icecube" */))
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
		return TCL_OK
	}
	return int32(0)
}

// Usage: sqlite3_mmap_warm DB DBNAME
func test_mmap_warm(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8057:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20055 /* "DB ?DBNAME?" */)
		return TCL_ERROR
	} else {
		var rc int32
		// var db uintptr at bp, 8

		var zDb uintptr = uintptr(0)
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
			return TCL_ERROR
		}
		if objc == 3 {
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
		}
		rc = sqlite3_mmap_warm(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDb)
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_OK
	}
	return int32(0)
}

// Usage:  test_write_db DB OFFSET DATA
//
// Obtain the sqlite3_file* object for the database file for the "main" db
// of handle DB. Then invoke its xWrite method to write data DATA to offset
// OFFSET.
func test_write_db(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8090:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)
	*(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iOff */)) = int64(0)
	var aData uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 16 /* nData */)) = 0
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pFile */)) = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20067 /* "DB OFFSET DATA" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	aData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+16 /* &nData */)

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp+24 /* &pFile */)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 24 /* pFile */)))).FpMethods)).FxWrite})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pFile */)), aData, *(*int32)(unsafe.Pointer(bp + 16 /* nData */)), *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* iOff */)))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// Usage:  sqlite3_register_cksumvfs
//
func test_register_cksumvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8122:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	} else {
		var rc int32 = sqlite3_register_cksumvfs(tls, uintptr(0))
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	return TCL_OK
}

// Usage:  sqlite3_unregister_cksumvfs
//
func test_unregister_cksumvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8143:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	} else {
		var rc int32 = sqlite3_unregister_cksumvfs(tls)
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	return TCL_OK
}

// Usage:  decode_hexdb TEXT
//
// Example:   db deserialize [decode_hexdb $output_of_dbtotxt]
//
// This routine returns a byte-array for an SQLite database file that
// is constructed from a text input which is the output of the "dbtotxt"
// utility.
func test_decode_hexdb(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8169:26: */
	bp := tls.Alloc(296)
	defer tls.Free(296)

	var zIn uintptr = uintptr(0)
	var a uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 216 /* n */)) = 0
	var lineno int32 = 0
	var i int32
	var iNext int32
	var iOffset int32 = 0
	// var j int32 at bp+224, 4

	// var k int32 at bp+228, 4

	var rc int32
	// var x [16]uint32 at bp+232, 64

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20082 /* "HEXDB" */)
		return TCL_ERROR
	}
	zIn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	for i = 0; *(*int8)(unsafe.Pointer(zIn + uintptr(i))) != 0; i = iNext {
		lineno++
		for iNext = i; *(*int8)(unsafe.Pointer(zIn + uintptr(iNext))) != 0 && int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) != '\n'; iNext++ {
		}
		if int32(*(*int8)(unsafe.Pointer(zIn + uintptr(iNext)))) == '\n' {
			iNext++
		}
		for int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == ' ' || int32(*(*int8)(unsafe.Pointer(zIn + uintptr(i)))) == '\t' {
			i++
		}
		if a == uintptr(0) {
			// var pgsz int32 at bp+220, 4

			rc = libc.Xsscanf(tls, zIn+uintptr(i), ts+20088 /* "| size %d pagesi..." */, libc.VaList(bp, bp+216 /* &n */, bp+220 /* &pgsz */))
			if rc != 2 {
				continue
			}
			if *(*int32)(unsafe.Pointer(bp + 220)) < 512 || *(*int32)(unsafe.Pointer(bp + 220)) > 65536 || *(*int32)(unsafe.Pointer(bp + 220))&(*(*int32)(unsafe.Pointer(bp + 220))-1) != 0 {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+20110 /* "bad 'pagesize' f..." */, uintptr(0)))
				return TCL_ERROR
			}
			*(*int32)(unsafe.Pointer(bp + 216 /* n */)) = (*(*int32)(unsafe.Pointer(bp + 216)) + *(*int32)(unsafe.Pointer(bp + 220)) - 1) & ^(*(*int32)(unsafe.Pointer(bp + 220)) - 1) // Round n up to the next multiple of pgsz
			if *(*int32)(unsafe.Pointer(bp + 216)) < 512 {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+20131 /* "bad 'size' field" */, uintptr(0)))
				return TCL_ERROR
			}
			a = libc.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 216 /* n */))))
			if a == uintptr(0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+2069 /* "out of memory" */, uintptr(0)))
				return TCL_ERROR
			}
			libc.Xmemset(tls, a, 0, uint64(*(*int32)(unsafe.Pointer(bp + 216 /* n */))))
			continue
		}
		rc = libc.Xsscanf(tls, zIn+uintptr(i), ts+20148 /* "| page %d offset..." */, libc.VaList(bp+64, bp+224 /* &j */, bp+228 /* &k */))
		if rc == 2 {
			iOffset = *(*int32)(unsafe.Pointer(bp + 228 /* k */))
			continue
		}
		rc = libc.Xsscanf(tls, zIn+uintptr(i), ts+20168, /* "| %d: %x %x %x %..." */
			libc.VaList(bp+80, bp+224 /* &j */, bp+232, bp+232+1*4, bp+232+2*4, bp+232+3*4, bp+232+4*4, bp+232+5*4, bp+232+6*4, bp+232+7*4,
				bp+232+8*4, bp+232+9*4, bp+232+10*4, bp+232+11*4, bp+232+12*4, bp+232+13*4, bp+232+14*4, bp+232+15*4))
		if rc == 17 {
			*(*int32)(unsafe.Pointer(bp + 228 /* k */)) = iOffset + *(*int32)(unsafe.Pointer(bp + 224))
			if *(*int32)(unsafe.Pointer(bp + 228))+16 <= *(*int32)(unsafe.Pointer(bp + 216)) {
				var ii int32
				for ii = 0; ii < 16; ii++ {
					*(*uint8)(unsafe.Pointer(a + uintptr(*(*int32)(unsafe.Pointer(bp + 228))+ii))) = uint8(*(*uint32)(unsafe.Pointer(bp + 232 + uintptr(ii)*4)) & uint32(0xff))
				}
			}
			continue
		}
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, a, *(*int32)(unsafe.Pointer(bp + 216 /* n */))))
	libc.Xfree(tls, a)
	return TCL_OK
}

// Client data for the autovacuum_pages callback.
type AutovacPageData1 = struct {
	Finterp  uintptr
	FzScript uintptr
} /* test1.c:8240:1 */

type AutovacPageData = AutovacPageData1 /* test1.c:8244:32 */

// Callback functions for sqlite3_autovacuum_pages
func test_autovacuum_pages_callback(tls *libc.TLS, pClientData uintptr, zSchema uintptr, nFilePages uint32, nFreePages uint32, nBytePerPage uint32) uint32 { /* test1.c:8249:21: */
	bp := tls.Alloc(344)
	defer tls.Free(344)

	var pData uintptr = pClientData
	// var str Tcl_DString at bp+24, 216

	// var x uint32 at bp+340, 4

	// var zBuf [100]int8 at bp+240, 100

	tcl.XTcl_DStringInit(tls, bp+24 /* &str */)
	tcl.XTcl_DStringAppend(tls, bp+24 /* &str */, (*AutovacPageData)(unsafe.Pointer(pData)).FzScript, -1)
	tcl.XTcl_DStringAppendElement(tls, bp+24 /* &str */, zSchema)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+240 /* &zBuf[0] */, ts+18527 /* "%u" */, libc.VaList(bp, nFilePages))
	tcl.XTcl_DStringAppendElement(tls, bp+24 /* &str */, bp+240 /* &zBuf[0] */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+240 /* &zBuf[0] */, ts+18527 /* "%u" */, libc.VaList(bp+8, nFreePages))
	tcl.XTcl_DStringAppendElement(tls, bp+24 /* &str */, bp+240 /* &zBuf[0] */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+240 /* &zBuf[0] */, ts+18527 /* "%u" */, libc.VaList(bp+16, nBytePerPage))
	tcl.XTcl_DStringAppendElement(tls, bp+24 /* &str */, bp+240 /* &zBuf[0] */)
	tcl.XTcl_ResetResult(tls, (*AutovacPageData)(unsafe.Pointer(pData)).Finterp)
	tcl.XTcl_Eval(tls, (*AutovacPageData)(unsafe.Pointer(pData)).Finterp, (*Tcl_DString)(unsafe.Pointer(bp+24)).Fstring)
	tcl.XTcl_DStringFree(tls, bp+24 /* &str */)
	*(*uint32)(unsafe.Pointer(bp + 340 /* x */)) = nFreePages
	tcl.XTcl_GetIntFromObj(tls, uintptr(0), tcl.XTcl_GetObjResult(tls, (*AutovacPageData)(unsafe.Pointer(pData)).Finterp), bp+340 /* &x */)
	return *(*uint32)(unsafe.Pointer(bp + 340 /* x */))
}

// Usage:  sqlite3_autovacuum_pages DB SCRIPT
//
// Add an autovacuum-pages callback to database connection DB.  The callback
// will invoke SCRIPT, after appending parameters.
//
// If SCRIPT is an empty string or is omitted, then the callback is
// cancelled.
func test_autovacuum_pages(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test1.c:8286:26: */
	bp := tls.Alloc(1048)
	defer tls.Free(1048)

	var pData uintptr
	// var db uintptr at bp+40, 8

	var rc int32
	var zScript uintptr
	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+20222 /* "DB ?SCRIPT?" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+40) != 0 {
		return TCL_ERROR
	}
	if objc == 3 {
		zScript = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	} else {
		zScript = uintptr(0)
	}
	if zScript != 0 {
		var nScript size_t = libc.Xstrlen(tls, zScript)
		pData = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(AutovacPageData{}))+nScript+uint64(1)))
		if pData == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+2069 /* "out of memory" */, uintptr(0)))
			return TCL_ERROR
		}
		(*AutovacPageData)(unsafe.Pointer(pData)).Finterp = interp
		(*AutovacPageData)(unsafe.Pointer(pData)).FzScript = pData + 1*16
		libc.Xmemcpy(tls, (*AutovacPageData)(unsafe.Pointer(pData)).FzScript, zScript, nScript+uint64(1))
		rc = sqlite3.Xsqlite3_autovacuum_pages(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uint32, uint32, uint32) uint32
		}{test_autovacuum_pages_callback})),
			pData, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		rc = sqlite3.Xsqlite3_autovacuum_pages(tls, *(*uintptr)(unsafe.Pointer(bp + 40 /* db */)), uintptr(0), uintptr(0), uintptr(0))
	}
	if rc != 0 {
		// var zBuf [1000]int8 at bp+48, 1000

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+48, /* &zBuf[0] */
			ts+20234 /* "sqlite3_autovacu..." */, libc.VaList(bp+16, rc))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, bp+48 /* &zBuf[0] */, uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest1_Init(tls *libc.TLS, interp uintptr) int32 { /* test1.c:8331:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd1))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd1[i].FzName, aCmd1[i].FxProc, uintptr(0), uintptr(0))
	}
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd1))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd1[i].FzName,
			aObjCmd1[i].FxProc, aObjCmd1[i].FclientData, uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+20272, /* "sqlite_search_co..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_search_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20292, /* "sqlite_found_cou..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_found_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20311, /* "sqlite_sort_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sort_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20329, /* "sqlite3_max_blob..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_max_blobsize)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20350, /* "sqlite_like_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_like_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20368, /* "sqlite_interrupt..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_interrupt_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20391, /* "sqlite_open_file..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_open_file_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20414, /* "sqlite_current_t..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_current_time)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20434, /* "sqlite3_xferopt_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_xferopt_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20456, /* "sqlite3_pager_re..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_readdb_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20483, /* "sqlite3_pager_wr..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writedb_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20511, /* "sqlite3_pager_wr..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_pager_writej_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20538, /* "unaligned_string..." */
		uintptr(unsafe.Pointer(&unaligned_string_counter)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20563, /* "sqlite_last_need..." */
		uintptr(unsafe.Pointer(&pzNeededCollation)), TCL_LINK_STRING|TCL_LINK_READ_ONLY)
	{
		tcl.XTcl_LinkVar(tls, interp, ts+20592, /* "sqlite_query_pla..." */
			uintptr(unsafe.Pointer(&query_plan)), TCL_LINK_STRING|TCL_LINK_READ_ONLY)

	}
	tcl.XTcl_LinkVar(tls, interp, ts+20610, /* "sqlite_opentemp_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_opentemp_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20632, /* "sqlite_static_bi..." */
		uintptr(unsafe.Pointer(&sqlite_static_bind_value)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+20657, /* "sqlite_static_bi..." */
		uintptr(unsafe.Pointer(&sqlite_static_bind_nbyte)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20682, /* "sqlite_temp_dire..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_temp_directory)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+20704, /* "sqlite_data_dire..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_data_directory)), TCL_LINK_STRING)
	tcl.XTcl_LinkVar(tls, interp, ts+20726, /* "bitmask_size" */
		uintptr(unsafe.Pointer(&bitmask_size)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	tcl.XTcl_LinkVar(tls, interp, ts+20739, /* "longdouble_size" */
		uintptr(unsafe.Pointer(&longdouble_size)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	tcl.XTcl_LinkVar(tls, interp, ts+20755, /* "sqlite_sync_coun..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_sync_count)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+20773, /* "sqlite_fullsync_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_fullsync_count)), TCL_LINK_INT)
	return TCL_OK
}

var iZero int32 = 0 /* test1.c:8344:14 */
var aCmd1 = [39]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 20795 /* "db_enter" */, FxProc: 0},
	{FzName: ts + 20804 /* "db_leave" */, FxProc: 0},
	{FzName: ts + 20813 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 20833 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 20855 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 20876 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 20896 /* "sqlite3_snprintf..." */, FxProc: 0},
	{FzName: ts + 20917 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 20941 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 20964 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 20987 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 21013 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 21036 /* "sqlite3_mprintf_..." */, FxProc: 0},
	{FzName: ts + 21059 /* "sqlite3_snprintf..." */, FxProc: 0},
	{FzName: ts + 21080 /* "sqlite3_last_ins..." */, FxProc: 0},
	{FzName: ts + 21106 /* "sqlite3_exec_pri..." */, FxProc: 0},
	{FzName: ts + 21126 /* "sqlite3_exec_hex" */, FxProc: 0},
	{FzName: ts + 21143 /* "sqlite3_exec" */, FxProc: 0},
	{FzName: ts + 21156 /* "sqlite3_exec_nr" */, FxProc: 0},
	{FzName: ts + 21172 /* "sqlite3_get_tabl..." */, FxProc: 0},
	{FzName: ts + 21197 /* "sqlite3_close" */, FxProc: 0},
	{FzName: ts + 21211 /* "sqlite3_close_v2" */, FxProc: 0},
	{FzName: ts + 21228 /* "sqlite3_create_f..." */, FxProc: 0},
	{FzName: ts + 21252 /* "sqlite3_create_a..." */, FxProc: 0},
	{FzName: ts + 21277 /* "sqlite3_drop_mod..." */, FxProc: 0},
	{FzName: ts + 21298 /* "sqlite_register_..." */, FxProc: 0},
	{FzName: ts + 21328 /* "sqlite_abort" */, FxProc: 0},
	{FzName: ts + 21341 /* "sqlite_bind" */, FxProc: 0},
	{FzName: ts + 21353 /* "breakpoint" */, FxProc: 0},
	{FzName: ts + 21364 /* "sqlite3_key" */, FxProc: 0},
	{FzName: ts + 21376 /* "sqlite3_rekey" */, FxProc: 0},
	{FzName: ts + 21390 /* "sqlite3_interrup..." */, FxProc: 0},
	{FzName: ts + 21408 /* "sqlite_delete_fu..." */, FxProc: 0},
	{FzName: ts + 21431 /* "sqlite_delete_co..." */, FxProc: 0},
	{FzName: ts + 21455 /* "sqlite3_get_auto..." */, FxProc: 0},
	{FzName: ts + 21478 /* "sqlite3_busy_tim..." */, FxProc: 0},
	{FzName: ts + 21499 /* "printf" */, FxProc: 0},
	{FzName: ts + 21506 /* "sqlite3IoTrace" */, FxProc: 0},
	{FzName: ts + 21521 /* "clang_sanitize_a..." */, FxProc: 0},
} /* test1.c:8348:5 */
var aObjCmd1 = [162]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 21544 /* "sqlite3_db_confi..." */, FxProc: 0},
	{FzName: ts + 21562 /* "sqlite3_txn_stat..." */, FxProc: 0},
	{FzName: ts + 21580 /* "bad_behavior" */, FxProc: 0, FclientData: 0},
	{FzName: ts + 21593 /* "register_dbstat_..." */, FxProc: 0},
	{FzName: ts + 21614 /* "sqlite3_connecti..." */, FxProc: 0},
	{FzName: ts + 21641 /* "intarray_addr" */, FxProc: 0},
	{FzName: ts + 21655 /* "int64array_addr" */, FxProc: 0},
	{FzName: ts + 21671 /* "doublearray_addr" */, FxProc: 0},
	{FzName: ts + 21688 /* "textarray_addr" */, FxProc: 0},
	{FzName: ts + 21703 /* "sqlite3_bind_int" */, FxProc: 0},
	{FzName: ts + 21720 /* "sqlite3_bind_zer..." */, FxProc: 0},
	{FzName: ts + 21742 /* "sqlite3_bind_zer..." */, FxProc: 0},
	{FzName: ts + 21766 /* "sqlite3_bind_int..." */, FxProc: 0},
	{FzName: ts + 21785 /* "sqlite3_bind_dou..." */, FxProc: 0},
	{FzName: ts + 21805 /* "sqlite3_bind_nul..." */, FxProc: 0},
	{FzName: ts + 21823 /* "sqlite3_bind_tex..." */, FxProc: 0},
	{FzName: ts + 21841 /* "sqlite3_bind_tex..." */, FxProc: 0},
	{FzName: ts + 21861 /* "sqlite3_bind_blo..." */, FxProc: 0},
	{FzName: ts + 21879 /* "sqlite3_carray_b..." */, FxProc: 0},
	{FzName: ts + 21899 /* "sqlite3_bind_par..." */, FxProc: 0},
	{FzName: ts + 21928 /* "sqlite3_bind_par..." */, FxProc: 0},
	{FzName: ts + 21956 /* "sqlite3_bind_par..." */, FxProc: 0},
	{FzName: ts + 21985 /* "sqlite3_clear_bi..." */, FxProc: 0},
	{FzName: ts + 22008 /* "sqlite3_sleep" */, FxProc: 0},
	{FzName: ts + 22022 /* "sqlite3_errcode" */, FxProc: 0},
	{FzName: ts + 22038 /* "sqlite3_extended..." */, FxProc: 0},
	{FzName: ts + 22063 /* "sqlite3_errmsg" */, FxProc: 0},
	{FzName: ts + 22078 /* "sqlite3_errmsg16" */, FxProc: 0},
	{FzName: ts + 22095 /* "sqlite3_open" */, FxProc: 0},
	{FzName: ts + 22108 /* "sqlite3_open16" */, FxProc: 0},
	{FzName: ts + 22123 /* "sqlite3_open_v2" */, FxProc: 0},
	{FzName: ts + 22139 /* "sqlite3_complete..." */, FxProc: 0},
	{FzName: ts + 22158 /* "sqlite3_normaliz..." */, FxProc: 0},

	{FzName: ts + 22176 /* "sqlite3_prepare" */, FxProc: 0},
	{FzName: ts + 22192 /* "sqlite3_prepare1..." */, FxProc: 0},
	{FzName: ts + 22210 /* "sqlite3_prepare_..." */, FxProc: 0},
	{FzName: ts + 22229 /* "sqlite3_prepare_..." */, FxProc: 0},
	{FzName: ts + 22248 /* "sqlite3_prepare_..." */, FxProc: 0},
	{FzName: ts + 22272 /* "sqlite3_prepare1..." */, FxProc: 0},
	{FzName: ts + 22293 /* "sqlite3_finalize" */, FxProc: 0},
	{FzName: ts + 22310 /* "sqlite3_stmt_sta..." */, FxProc: 0},
	{FzName: ts + 22330 /* "sqlite3_reset" */, FxProc: 0},
	{FzName: ts + 22344 /* "sqlite3_expired" */, FxProc: 0},
	{FzName: ts + 22360 /* "sqlite3_transfer..." */, FxProc: 0},
	{FzName: ts + 22386 /* "sqlite3_changes" */, FxProc: 0},
	{FzName: ts + 22402 /* "sqlite3_step" */, FxProc: 0},
	{FzName: ts + 22415 /* "sqlite3_sql" */, FxProc: 0},
	{FzName: ts + 22427 /* "sqlite3_expanded..." */, FxProc: 0},
	{FzName: ts + 22448 /* "sqlite3_next_stm..." */, FxProc: 0},
	{FzName: ts + 22466 /* "sqlite3_stmt_rea..." */, FxProc: 0},
	{FzName: ts + 22488 /* "sqlite3_stmt_ise..." */, FxProc: 0},
	{FzName: ts + 22511 /* "sqlite3_stmt_bus..." */, FxProc: 0},
	{FzName: ts + 22529 /* "uses_stmt_journa..." */, FxProc: 0},

	{FzName: ts + 22547 /* "sqlite3_release_..." */, FxProc: 0},
	{FzName: ts + 22570 /* "sqlite3_db_relea..." */, FxProc: 0},
	{FzName: ts + 22596 /* "sqlite3_db_cache..." */, FxProc: 0},
	{FzName: ts + 22618 /* "sqlite3_system_e..." */, FxProc: 0},
	{FzName: ts + 22639 /* "sqlite3_db_filen..." */, FxProc: 0},
	{FzName: ts + 22659 /* "sqlite3_db_reado..." */, FxProc: 0},
	{FzName: ts + 22679 /* "sqlite3_soft_hea..." */, FxProc: 0},
	{FzName: ts + 22703 /* "sqlite3_soft_hea..." */, FxProc: 0},
	{FzName: ts + 22729 /* "sqlite3_hard_hea..." */, FxProc: 0},
	{FzName: ts + 22755 /* "sqlite3_thread_c..." */, FxProc: 0},
	{FzName: ts + 22778 /* "sqlite3_pager_re..." */, FxProc: 0},

	{FzName: ts + 22802 /* "sqlite3_load_ext..." */, FxProc: 0},
	{FzName: ts + 22825 /* "sqlite3_enable_l..." */, FxProc: 0},
	{FzName: ts + 22855 /* "sqlite3_extended..." */, FxProc: 0},
	{FzName: ts + 22885 /* "sqlite3_limit" */, FxProc: 0},
	{FzName: ts + 22899 /* "dbconfig_maindbn..." */, FxProc: 0},

	{FzName: ts + 22927 /* "save_prng_state" */, FxProc: 0},
	{FzName: ts + 22943 /* "restore_prng_sta..." */, FxProc: 0},
	{FzName: ts + 22962 /* "reset_prng_state" */, FxProc: 0},
	{FzName: ts + 22979 /* "prng_seed" */, FxProc: 0},
	{FzName: ts + 22989 /* "extra_schema_che..." */, FxProc: 0},
	{FzName: ts + 23009 /* "database_never_c..." */, FxProc: 0},
	{FzName: ts + 23032 /* "database_may_be_..." */, FxProc: 0},
	{FzName: ts + 23056 /* "optimization_con..." */, FxProc: 0},
	{FzName: ts + 23077 /* "tcl_objproc" */, FxProc: 0},

	// sqlite3_column_*() API
	{FzName: ts + 23089 /* "sqlite3_column_c..." */, FxProc: 0},
	{FzName: ts + 23110 /* "sqlite3_data_cou..." */, FxProc: 0},
	{FzName: ts + 23129 /* "sqlite3_column_t..." */, FxProc: 0},
	{FzName: ts + 23149 /* "sqlite3_column_b..." */, FxProc: 0},
	{FzName: ts + 23169 /* "sqlite3_column_d..." */, FxProc: 0},
	{FzName: ts + 23191 /* "sqlite3_column_i..." */, FxProc: 0},
	{FzName: ts + 23212 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23232 /* "sqlite3_column_n..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23252 /* "sqlite3_column_i..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23271 /* "sqlite3_column_b..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23292 /* "sqlite3_column_d..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23316 /* "sqlite3_column_d..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23345 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23371 /* "sqlite3_column_o..." */, FxProc: 0, FclientData: 0},

	{FzName: ts + 23398 /* "sqlite3_column_b..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23421 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23443 /* "sqlite3_column_n..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23465 /* "add_alignment_te..." */, FxProc: 0},
	{FzName: ts + 23495 /* "sqlite3_column_d..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23521, /* "sqlite3_column_d..." */
		FxProc: 0, FclientData: 0},
	{FzName: ts + 23552 /* "sqlite3_column_t..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23580 /* "sqlite3_column_o..." */, FxProc: 0, FclientData: 0},
	{FzName: ts + 23609 /* "sqlite3_create_c..." */, FxProc: 0},
	{FzName: ts + 23637 /* "sqlite3_global_r..." */, FxProc: 0},
	{FzName: ts + 23660 /* "working_64bit_in..." */, FxProc: 0},
	{FzName: ts + 23678 /* "vfs_unlink_test" */, FxProc: 0},
	{FzName: ts + 23694 /* "vfs_initfail_tes..." */, FxProc: 0},
	{FzName: ts + 23712 /* "vfs_unregister_a..." */, FxProc: 0},
	{FzName: ts + 23731 /* "vfs_reregister_a..." */, FxProc: 0},
	{FzName: ts + 23750 /* "file_control_tes..." */, FxProc: 0},
	{FzName: ts + 23768 /* "file_control_las..." */, FxProc: 0},
	{FzName: ts + 23796 /* "file_control_loc..." */, FxProc: 0},
	{FzName: ts + 23824 /* "file_control_chu..." */, FxProc: 0},
	{FzName: ts + 23852 /* "file_control_siz..." */, FxProc: 0},
	{FzName: ts + 23879 /* "file_control_dat..." */, FxProc: 0},
	{FzName: ts + 23905 /* "file_control_per..." */, FxProc: 0},
	{FzName: ts + 23930 /* "file_control_pow..." */, FxProc: 0},
	{FzName: ts + 23963 /* "file_control_vfs..." */, FxProc: 0},
	{FzName: ts + 23984 /* "file_control_res..." */, FxProc: 0},
	{FzName: ts + 24010 /* "file_control_tem..." */, FxProc: 0},
	{FzName: ts + 24036 /* "file_control_ext..." */, FxProc: 0},
	{FzName: ts + 24065 /* "sqlite3_vfs_list" */, FxProc: 0},
	{FzName: ts + 24082 /* "sqlite3_create_f..." */, FxProc: 0},

	// Functions from os.h
	{FzName: ts + 24109 /* "add_test_collate" */, FxProc: 0},
	{FzName: ts + 24126 /* "add_test_collate..." */, FxProc: 0},
	{FzName: ts + 24150 /* "add_test_functio..." */, FxProc: 0},
	{FzName: ts + 24168 /* "add_test_utf16bi..." */, FxProc: 0},
	{FzName: ts + 24194 /* "sqlite3_test_err..." */, FxProc: 0},
	{FzName: ts + 24214 /* "tcl_variable_typ..." */, FxProc: 0},
	{FzName: ts + 24232 /* "sqlite3_enable_s..." */, FxProc: 0},
	{FzName: ts + 24260 /* "sqlite3_shared_c..." */, FxProc: 0},
	{FzName: ts + 24288 /* "sqlite3_libversi..." */, FxProc: 0},
	{FzName: ts + 24314 /* "sqlite3_table_co..." */, FxProc: 0},
	{FzName: ts + 24344 /* "sqlite3_blob_reo..." */, FxProc: 0},
	{FzName: ts + 24364 /* "pcache_stats" */, FxProc: 0},
	{FzName: ts + 24377 /* "sqlite3_unlock_n..." */, FxProc: 0},
	{FzName: ts + 24399 /* "sqlite3_wal_chec..." */, FxProc: 0},
	{FzName: ts + 24422 /* "sqlite3_wal_chec..." */, FxProc: 0},
	{FzName: ts + 24448 /* "sqlite3_wal_auto..." */, FxProc: 0},
	{FzName: ts + 24475 /* "test_sqlite3_log" */, FxProc: 0},
	{FzName: ts + 24492 /* "print_explain_qu..." */, FxProc: 0},
	{FzName: ts + 24517 /* "sqlite3_test_con..." */, FxProc: 0},
	{FzName: ts + 24538 /* "getrusage" */, FxProc: 0},
	{FzName: ts + 24548 /* "load_static_exte..." */, FxProc: 0},
	{FzName: ts + 24570 /* "sorter_test_fake..." */, FxProc: 0},
	{FzName: ts + 24591 /* "sorter_test_sort..." */, FxProc: 0},
	{FzName: ts + 24616 /* "vfs_current_time..." */, FxProc: 0},
	{FzName: ts + 24639 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24660 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24682 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24704 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24725 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24750 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24776 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24803 /* "sqlite3_snapshot..." */, FxProc: 0},
	{FzName: ts + 24829 /* "sqlite3_delete_d..." */, FxProc: 0},
	{FzName: ts + 24853 /* "atomic_batch_wri..." */, FxProc: 0},
	{FzName: ts + 24872 /* "sqlite3_mmap_war..." */, FxProc: 0},
	{FzName: ts + 24890 /* "sqlite3_config_s..." */, FxProc: 0},
	{FzName: ts + 24915 /* "sqlite3_autovacu..." */, FxProc: 0},
	{FzName: ts + 24940 /* "decode_hexdb" */, FxProc: 0},
	{FzName: ts + 24953 /* "test_write_db" */, FxProc: 0},
	{FzName: ts + 24967 /* "sqlite3_register..." */, FxProc: 0},
	{FzName: ts + 24993 /* "sqlite3_unregist..." */, FxProc: 0},
}                                                                             /* test1.c:8395:5 */
var bitmask_size int32 = int32(uint64(unsafe.Sizeof(Bitmask(0))) * uint64(8)) /* test1.c:8624:14 */
var longdouble_size int32 = int32(unsafe.Sizeof(float64(0)))                  /* test1.c:8625:14 */
var query_plan uintptr = ts + 25021                                           /* "*** OBSOLETE VAR..." */ /* test1.c:8697:23 */

// Page size and reserved size used for testing.
var test_pagesize int32 = 1024 /* test2.c:31:12 */

// Dummy page reinitializer
func pager_test_reiniter(tls *libc.TLS, pNotUsed uintptr) { /* test2.c:36:13: */
	return
}

// Usage:   pager_open FILENAME N-PAGE
//
// Open a new pager
func pager_open(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:45:26: */
	bp := tls.Alloc(192)
	defer tls.Free(192)

	// var pageSize u32 at bp+88, 4

	// var pPager uintptr at bp+80, 8

	// var nPage int32 at bp+72, 4

	var rc int32
	// var zBuf [100]int8 at bp+92, 100

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25047 /* " FILENAME N-PAGE..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerOpen(tls, sqlite3.Xsqlite3_vfs_find(tls, uintptr(0)), bp+80 /* &pPager */, *(*uintptr)(unsafe.Pointer(argv + 1*8)), 0, 0,
		SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_MAIN_DB,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{pager_test_reiniter})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3PagerSetCachesize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPager */)), *(*int32)(unsafe.Pointer(bp + 72 /* nPage */)))
	*(*u32)(unsafe.Pointer(bp + 88 /* pageSize */)) = u32(test_pagesize)
	sqlite3.Xsqlite3PagerSetPagesize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPager */)), bp+88 /* &pageSize */, -1)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+92 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPager */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+92 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   pager_close ID
//
// Close the given pager.
func pager_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:82:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3PagerClose(tls, pPager, uintptr(0))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_rollback ID
//
// Rollback changes
func pager_rollback(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:109:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3PagerRollback(tls, pPager)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_commit ID
//
// Commit all changes
func pager_commit(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:136:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3PagerCommitPhaseOne(tls, pPager, uintptr(0), 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerCommitPhaseTwo(tls, pPager)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stmt_begin ID
//
// Start a new checkpoint.
func pager_stmt_begin(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:168:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3PagerOpenSavepoint(tls, pPager, 1)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stmt_rollback ID
//
// Rollback changes to a checkpoint
func pager_stmt_rollback(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:195:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_ROLLBACK, 0)
	sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_RELEASE, 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stmt_commit ID
//
// Commit changes to a checkpoint
func pager_stmt_commit(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:223:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPager uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3PagerSavepoint(tls, pPager, SAVEPOINT_RELEASE, 0)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   pager_stats ID
//
// Return pager statistics.
func pager_stats(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:250:26: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pPager uintptr
	var i int32
	var a uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	a = sqlite3.Xsqlite3PagerStats(tls, pPager)
	for i = 0; i < 9; i++ {
		// var zBuf [100]int8 at bp+40, 100

		tcl.XTcl_AppendElement(tls, interp, zName[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40 /* &zBuf[0] */)
	}
	return TCL_OK
}

var zName = [9]uintptr{
	ts + 25070 /* "ref" */, ts + 25074 /* "page" */, ts + 18990 /* "max" */, ts + 12648 /* "size" */, ts + 10390 /* "state" */, ts + 25079, /* "err" */
	ts + 25083 /* "hit" */, ts + 25087 /* "miss" */, ts + 25092, /* "ovfl" */
} /* test2.c:266:17 */

// Usage:   pager_pagecount ID
//
// Return the size of the database file.
func pager_pagecount(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:283:26: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr
	// var zBuf [100]int8 at bp+60, 100

	// var nPage int32 at bp+56, 4

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3PagerPagecount(tls, pPager, bp+56 /* &nPage */)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 56 /* nPage */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_get ID PGNO
//
// Return a pointer to a page from the database.
func page_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:309:26: */
	bp := tls.Alloc(188)
	defer tls.Free(188)

	var pPager uintptr
	// var zBuf [100]int8 at bp+88, 100

	*(*uintptr)(unsafe.Pointer(bp + 80 /* pPage */)) = uintptr(0)
	// var pgno int32 at bp+72, 4

	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25097 /* " ID PGNO\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3PagerSharedLock(tls, pPager)
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3PagerGet(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 72 /* pgno */))), bp+80 /* &pPage */, 0)
	}
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+88 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 80 /* pPage */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+88 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_lookup ID PGNO
//
// Return a pointer to a page if the page is already in cache.
// If not in cache, return an empty string.
func page_lookup(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:346:26: */
	bp := tls.Alloc(160)
	defer tls.Free(160)

	var pPager uintptr
	// var zBuf [100]int8 at bp+60, 100

	var pPage uintptr
	// var pgno int32 at bp+56, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25097 /* " ID PGNO\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+56) != 0 {
		return TCL_ERROR
	}
	pPage = sqlite3.Xsqlite3PagerLookup(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 56 /* pgno */))))
	if pPage != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+60 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp+32, pPage))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+60 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

// Usage:   pager_truncate ID PGNO
func pager_truncate(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:374:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var pPager uintptr
	// var pgno int32 at bp+32, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25097 /* " ID PGNO\"" */, 0))
		return TCL_ERROR
	}
	pPager = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3PagerTruncateImage(tls, pPager, uint32(*(*int32)(unsafe.Pointer(bp + 32 /* pgno */))))
	return TCL_OK
}

// Usage:   page_unref PAGE
//
// Drop a pointer to a page.
func page_unref(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:399:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25107 /* " PAGE\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3PagerUnref(tls, pPage)
	return TCL_OK
}

// Usage:   page_read PAGE
//
// Return the content of a page
func page_read(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:421:26: */
	bp := tls.Alloc(148)
	defer tls.Free(148)

	// var zBuf [100]int8 at bp+48, 100

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25107 /* " PAGE\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	libc.Xmemcpy(tls, bp+48 /* &zBuf[0] */, sqlite3.Xsqlite3PagerGetData(tls, pPage), uint64(unsafe.Sizeof([100]int8{})))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+48 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_number PAGE
//
// Return the page number for a page.
func page_number(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:445:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	// var zBuf [100]int8 at bp+56, 100

	var pPage uintptr
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25107 /* " PAGE\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+56 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+32, sqlite3.Xsqlite3PagerPagenumber(tls, pPage)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   page_write PAGE DATA
//
// Write something into a page.
func page_write(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:469:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pPage uintptr
	var pData uintptr
	var rc int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25114 /* " PAGE DATA\"" */, 0))
		return TCL_ERROR
	}
	pPage = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3PagerWrite(tls, pPage)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	pData = sqlite3.Xsqlite3PagerGetData(tls, pPage)
	libc.Xstrncpy(tls, pData, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uint64(test_pagesize-1))
	*(*int8)(unsafe.Pointer(pData + uintptr(test_pagesize-1))) = int8(0)
	return TCL_OK
}

// Usage:   fake_big_file  N  FILENAME
//
// Write a few bytes at the N megabyte point of FILENAME.  This will
// create a large file.  If the file was a valid SQLite database, then
// the next time the database is opened, SQLite will begin allocating
// new pages after N.  If N is 2096 or bigger, this will test the
// ability of SQLite to write to large files.
func fake_big_file(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:505:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var pVfs uintptr
	*(*uintptr)(unsafe.Pointer(bp + 88 /* fd */)) = uintptr(0)
	var rc int32
	// var n int32 at bp+80, 4

	var offset i64
	var zFile uintptr
	var nFile int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25126 /* " N-MEGABYTES FIL..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+80) != 0 {
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nFile = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	zFile = sqlite3.Xsqlite3_malloc(tls, nFile+2)
	if zFile == uintptr(0) {
		return TCL_ERROR
	}
	libc.Xmemcpy(tls, zFile, *(*uintptr)(unsafe.Pointer(argv + 2*8)), uint64(nFile+1))
	*(*int8)(unsafe.Pointer(zFile + uintptr(nFile+1))) = int8(0)
	rc = sqlite3.Xsqlite3OsOpenMalloc(tls, pVfs, zFile, bp+88, /* &fd */
		SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_DB, uintptr(0))
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+25145 /* "open failed: " */, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		sqlite3.Xsqlite3_free(tls, zFile)
		return TCL_ERROR
	}
	offset = i64(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))
	offset = offset * int64(1024*1024)
	rc = sqlite3.Xsqlite3OsWrite(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* fd */)), ts+25159 /* "Hello, World!" */, 14, offset)
	sqlite3.Xsqlite3OsCloseFree(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* fd */)))
	sqlite3.Xsqlite3_free(tls, zFile)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, ts+25173 /* "write failed: " */, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// test_control_pending_byte  PENDING_BYTE
//
// Set the PENDING_BYTE using the sqlite3_test_control() interface.
func testPendingByte(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:558:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	// var pbyte int32 at bp+40, 4

	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25188 /* " PENDING-BYTE\"" */, uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+40) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_PENDING_BYTE, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 40 /* pbyte */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// The sqlite3FaultSim() callback:
var faultSimInterp uintptr = uintptr(0) /* test2.c:580:19 */
var faultSimScriptSize int32 = 0        /* test2.c:581:12 */
var faultSimScript uintptr              /* test2.c:582:13: */

func faultSimCallback(tls *libc.TLS, x int32) int32 { /* test2.c:583:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	// var zInt [30]int8 at bp+8, 30

	var i int32
	var isNeg int32
	var rc int32
	if x == 0 {
		libc.Xmemcpy(tls, faultSimScript+uintptr(faultSimScriptSize), ts+15020 /* "0" */, uint64(2))
	} else {
		// Convert x to text without using any sqlite3 routines
		if x < 0 {
			isNeg = 1
			x = -x
		} else {
			isNeg = 0
		}
		*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + 29)) = int8(0)
		i = int32(uint64(unsafe.Sizeof([30]int8{})) - uint64(2))
	__1:
		if !(i > 0 && x > 0) {
			goto __3
		}
		{
			*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + uintptr(i))) = int8(x%10 + '0')

		}
		goto __2
	__2:
		i--
		x = x / 10
		goto __1
		goto __3
	__3:
		;
		if isNeg != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zInt[0] */ + uintptr(libc.PostDecInt32(&i, 1)))) = int8('-')
		}
		libc.Xmemcpy(tls, faultSimScript+uintptr(faultSimScriptSize), bp+8+uintptr(i)+uintptr(1), uint64(unsafe.Sizeof([30]int8{}))-uint64(i))
	}
	rc = tcl.XTcl_Eval(tls, faultSimInterp, faultSimScript)
	if rc != 0 {
		libc.Xfprintf(tls, libc.X__stderrp, ts+25203 /* "fault simulator ..." */, libc.VaList(bp, faultSimScript))
		rc = SQLITE_ERROR
	} else {
		rc = libc.Xatoi(tls, tcl.XTcl_GetStringResult(tls, faultSimInterp))
	}
	tcl.XTcl_ResetResult(tls, faultSimInterp)
	return rc
}

// sqlite3_test_control_fault_install SCRIPT
//
// Arrange to invoke SCRIPT with the integer argument to sqlite3FaultSim()
// appended, whenever sqlite3FaultSim() is called.  Or, if SCRIPT is the
// empty string, cancel the sqlite3FaultSim() callback.
func faultInstallCmd(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:623:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var zScript uintptr
	var nScript int32
	var rc int32
	if argc != 1 && argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25239 /* " SCRIPT\"" */, uintptr(0)))
	}
	if argc == 2 {
		zScript = *(*uintptr)(unsafe.Pointer(argv + 1*8))
	} else {
		zScript = ts + 584 /* "" */
	}
	nScript = int32(libc.Xstrlen(tls, zScript))
	if faultSimScript != 0 {
		libc.Xfree(tls, faultSimScript)
		faultSimScript = uintptr(0)
	}
	if nScript == 0 {
		rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_FAULT_INSTALL, libc.VaList(bp+32, 0))
	} else {
		faultSimScript = libc.Xmalloc(tls, uint64(nScript+100))
		if faultSimScript == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+2069 /* "out of memory" */, uintptr(0)))
			return SQLITE_ERROR
		}
		libc.Xmemcpy(tls, faultSimScript, zScript, uint64(nScript))
		*(*int8)(unsafe.Pointer(faultSimScript + uintptr(nScript))) = int8(' ')
		faultSimScriptSize = nScript + 1
		faultSimInterp = interp
		rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_FAULT_INSTALL, libc.VaList(bp+56, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{faultSimCallback}))))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return SQLITE_OK
}

// sqlite3BitvecBuiltinTest SIZE PROGRAM
//
// Invoke the SQLITE_TESTCTRL_BITVEC_TEST operator on test_control.
// See comments on sqlite3BitvecBuiltinTest() for additional information.
func testBitvecBuiltinTest(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test2.c:666:26: */
	bp := tls.Alloc(452)
	defer tls.Free(452)

	// var sz int32 at bp+48, 4

	var rc int32
	var nProg int32 = 0
	// var aProg [100]int32 at bp+52, 400

	var z uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25248 /* " SIZE PROGRAM\"" */, uintptr(0)))
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+48) != 0 {
		return TCL_ERROR
	}
	z = *(*uintptr)(unsafe.Pointer(argv + 2*8))
	for nProg < 99 && *(*int8)(unsafe.Pointer(z)) != 0 {
		for *(*int8)(unsafe.Pointer(z)) != 0 && !(int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x04 != 0) {
			z++
		}
		if int32(*(*int8)(unsafe.Pointer(z))) == 0 {
			break
		}
		*(*int32)(unsafe.Pointer(bp + 52 /* &aProg[0] */ + uintptr(libc.PostIncInt32(&nProg, 1))*4)) = libc.Xatoi(tls, z)
		for int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x04 != 0 {
			z++
		}
	}
	*(*int32)(unsafe.Pointer(bp + 52 /* &aProg[0] */ + uintptr(nProg)*4)) = 0
	rc = sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BITVEC_TEST, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(bp + 48 /* sz */)), bp+52 /* &aProg[0] */))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest2_Init(tls *libc.TLS, interp uintptr) int32 { /* test2.c:697:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd2))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd2[i].FzName, aCmd2[i].FxProc, uintptr(0), uintptr(0))
	}
	tcl.XTcl_LinkVar(tls, interp, ts+25263, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_pending)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+25287, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_persist)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+25311, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hit)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+25331, /* "sqlite_io_error_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_io_error_hardhit)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+25355, /* "sqlite_diskfull_..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull_pending)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+25379, /* "sqlite_diskfull" */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3_diskfull)), TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+25395, /* "sqlite_pending_b..." */
		uintptr(unsafe.Pointer(&sqlite3.Xsqlite3PendingByte)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	return TCL_OK
}

var aCmd2 = [20]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 25415 /* "pager_open" */, FxProc: 0},
	{FzName: ts + 25426 /* "pager_close" */, FxProc: 0},
	{FzName: ts + 25438 /* "pager_commit" */, FxProc: 0},
	{FzName: ts + 25451 /* "pager_rollback" */, FxProc: 0},
	{FzName: ts + 25466 /* "pager_stmt_begin" */, FxProc: 0},
	{FzName: ts + 25483 /* "pager_stmt_commi..." */, FxProc: 0},
	{FzName: ts + 25501 /* "pager_stmt_rollb..." */, FxProc: 0},
	{FzName: ts + 25521 /* "pager_stats" */, FxProc: 0},
	{FzName: ts + 25533 /* "pager_pagecount" */, FxProc: 0},
	{FzName: ts + 25549 /* "page_get" */, FxProc: 0},
	{FzName: ts + 25558 /* "page_lookup" */, FxProc: 0},
	{FzName: ts + 25570 /* "page_unref" */, FxProc: 0},
	{FzName: ts + 25581 /* "page_read" */, FxProc: 0},
	{FzName: ts + 25591 /* "page_write" */, FxProc: 0},
	{FzName: ts + 25602 /* "page_number" */, FxProc: 0},
	{FzName: ts + 25614 /* "pager_truncate" */, FxProc: 0},
	{FzName: ts + 25629 /* "fake_big_file" */, FxProc: 0},
	{FzName: ts + 25643 /* "sqlite3BitvecBui..." */, FxProc: 0},
	{FzName: ts + 25668 /* "sqlite3_test_con..." */, FxProc: 0},
	{FzName: ts + 25702 /* "sqlite3_test_con..." */, FxProc: 0},
} /* test2.c:707:5 */

// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the sqlite B-Tree file
// subsystem.  See comments in the source code for a detailed description
// of what each interface routine does.

// TODO: This definition is just included so other modules compile. It
// needs to be revisited.

// If defined as non-zero, auto-vacuum is enabled by default. Otherwise
// it must be turned on for each database using "PRAGMA auto_vacuum = 1".

// Forward declarations of structure
type Btree = Btree1       /* btree.h:39:22 */
type BtCursor = BtCursor1 /* btree.h:40:25 */
type BtShared = BtShared1 /* btree.h:41:25 */

// 2004 April 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file implements an external (disk-based) database using BTrees.
// For a detailed discussion of BTrees, refer to
//
//     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:
//     "Sorting And Searching", pages 473-480. Addison-Wesley
//     Publishing Company, Reading, Massachusetts.
//
// The basic idea is that each page of the file contains N database
// entries and N+1 pointers to subpages.
//
//   ----------------------------------------------------------------
//   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |
//   ----------------------------------------------------------------
//
// All of the keys on the page that Ptr(0) points to have values less
// than Key(0).  All of the keys on page Ptr(1) and its subpages have
// values greater than Key(0) and less than Key(1).  All of the keys
// on Ptr(N) and its subpages have values greater than Key(N-1).  And
// so forth.
//
// Finding a particular key requires reading O(log(M)) pages from the
// disk where M is the number of entries in the tree.
//
// In this implementation, a single file can hold one or more separate
// BTrees.  Each BTree is identified by the index of its root page.  The
// key and data for any entry are combined to form the "payload".  A
// fixed amount of payload can be carried directly on the database
// page.  If the payload is larger than the preset amount then surplus
// bytes are stored on overflow pages.  The payload for an entry
// and the preceding pointer are combined to form a "Cell".  Each
// page has a small header which contains the Ptr(N) pointer and other
// information such as the size of key and data.
//
// FORMAT DETAILS
//
// The file is divided into pages.  The first page is called page 1,
// the second is page 2, and so forth.  A page number of zero indicates
// "no such page".  The page size can be any power of 2 between 512 and 65536.
// Each page can be either a btree page, a freelist page, an overflow
// page, or a pointer-map page.
//
// The first page is always a btree page.  The first 100 bytes of the first
// page contain a special header (the "file header") that describes the file.
// The format of the file header is as follows:
//
//   OFFSET   SIZE    DESCRIPTION
//      0      16     Header string: "SQLite format 3\000"
//     16       2     Page size in bytes.  (1 means 65536)
//     18       1     File format write version
//     19       1     File format read version
//     20       1     Bytes of unused space at the end of each page
//     21       1     Max embedded payload fraction (must be 64)
//     22       1     Min embedded payload fraction (must be 32)
//     23       1     Min leaf payload fraction (must be 32)
//     24       4     File change counter
//     28       4     Reserved for future use
//     32       4     First freelist page
//     36       4     Number of freelist pages in the file
//     40      60     15 4-byte meta values passed to higher layers
//
//     40       4     Schema cookie
//     44       4     File format of schema layer
//     48       4     Size of page cache
//     52       4     Largest root-page (auto/incr_vacuum)
//     56       4     1=UTF-8 2=UTF16le 3=UTF16be
//     60       4     User version
//     64       4     Incremental vacuum mode
//     68       4     Application-ID
//     72      20     unused
//     92       4     The version-valid-for number
//     96       4     SQLITE_VERSION_NUMBER
//
// All of the integer values are big-endian (most significant byte first).
//
// The file change counter is incremented when the database is changed
// This counter allows other processes to know when the file has changed
// and thus when they need to flush their cache.
//
// The max embedded payload fraction is the amount of the total usable
// space in a page that can be consumed by a single cell for standard
// B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
// is to limit the maximum cell size so that at least 4 cells will fit
// on one page.  Thus the default max embedded payload fraction is 64.
//
// If the payload for a cell is larger than the max payload, then extra
// payload is spilled to overflow pages.  Once an overflow page is allocated,
// as many bytes as possible are moved into the overflow pages without letting
// the cell size drop below the min embedded payload fraction.
//
// The min leaf payload fraction is like the min embedded payload fraction
// except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
// payload fraction for a LEAFDATA tree is always 100% (or 255) and it
// not specified in the header.
//
// Each btree pages is divided into three sections:  The header, the
// cell pointer array, and the cell content area.  Page 1 also has a 100-byte
// file header that occurs before the page header.
//
//      |----------------|
//      | file header    |   100 bytes.  Page 1 only.
//      |----------------|
//      | page header    |   8 bytes for leaves.  12 bytes for interior nodes
//      |----------------|
//      | cell pointer   |   |  2 bytes per cell.  Sorted order.
//      | array          |   |  Grows downward
//      |                |   v
//      |----------------|
//      | unallocated    |
//      | space          |
//      |----------------|   ^  Grows upwards
//      | cell content   |   |  Arbitrary order interspersed with freeblocks.
//      | area           |   |  and free space fragments.
//      |----------------|
//
// The page headers looks like this:
//
//   OFFSET   SIZE     DESCRIPTION
//      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
//      1       2      byte offset to the first freeblock
//      3       2      number of cells on this page
//      5       2      first byte of the cell content area
//      7       1      number of fragmented free bytes
//      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
//
// The flags define the format of this btree page.  The leaf flag means that
// this page has no children.  The zerodata flag means that this page carries
// only keys and no data.  The intkey flag means that the key is an integer
// which is stored in the key size entry of the cell header rather than in
// the payload area.
//
// The cell pointer array begins on the first byte after the page header.
// The cell pointer array contains zero or more 2-byte numbers which are
// offsets from the beginning of the page to the cell content in the cell
// content area.  The cell pointers occur in sorted order.  The system strives
// to keep free space after the last cell pointer so that new cells can
// be easily added without having to defragment the page.
//
// Cell content is stored at the very end of the page and grows toward the
// beginning of the page.
//
// Unused space within the cell content area is collected into a linked list of
// freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
// to the first freeblock is given in the header.  Freeblocks occur in
// increasing order.  Because a freeblock must be at least 4 bytes in size,
// any group of 3 or fewer unused bytes in the cell content area cannot
// exist on the freeblock chain.  A group of 3 or fewer free bytes is called
// a fragment.  The total number of bytes in all fragments is recorded.
// in the page header at offset 7.
//
//    SIZE    DESCRIPTION
//      2     Byte offset of the next freeblock
//      2     Bytes in this freeblock
//
// Cells are of variable length.  Cells are stored in the cell content area at
// the end of the page.  Pointers to the cells are in the cell pointer array
// that immediately follows the page header.  Cells is not necessarily
// contiguous or in order, but cell pointers are contiguous and in order.
//
// Cell content makes use of variable length integers.  A variable
// length integer is 1 to 9 bytes where the lower 7 bits of each
// byte are used.  The integer consists of all bytes that have bit 8 set and
// the first byte with bit 8 clear.  The most significant byte of the integer
// appears first.  A variable-length integer may not be more than 9 bytes long.
// As a special case, all 8 bytes of the 9th byte are used as data.  This
// allows a 64-bit integer to be encoded in 9 bytes.
//
//    0x00                      becomes  0x00000000
//    0x7f                      becomes  0x0000007f
//    0x81 0x00                 becomes  0x00000080
//    0x82 0x00                 becomes  0x00000100
//    0x80 0x7f                 becomes  0x0000007f
//    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
//    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
//
// Variable length integers are used for rowids and to hold the number of
// bytes of key and data in a btree cell.
//
// The content of a cell looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of the left child. Omitted if leaf flag is set.
//     var    Number of bytes of data. Omitted if the zerodata flag is set.
//     var    Number of bytes of key. Or the key itself if intkey flag is set.
//      *     Payload
//      4     First page of the overflow chain.  Omitted if no overflow
//
// Overflow pages form a linked list.  Each page except the last is completely
// filled with data (pagesize - 4 bytes).  The last page can have as little
// as 1 byte of data.
//
//    SIZE    DESCRIPTION
//      4     Page number of next overflow page
//      *     Data
//
// Freelist pages come in two subtypes: trunk pages and leaf pages.  The
// file header points to the first in a linked list of trunk page.  Each trunk
// page points to multiple leaf pages.  The content of a leaf page is
// unspecified.  A trunk page looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of next trunk page
//      4     Number of leaf pointers on this page
//      *     zero or more pages numbers of leaves
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Internal interface definitions for SQLite.
//

// The following value is the maximum cell size assuming a maximum page
// size give above.

// The maximum number of cells on a single page of the database.  This
// assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
// plus 2 bytes for the index to the cell in the page header).  Such
// small cells will be rare, but they are possible.

// Forward declarations
type MemPage1 = struct {
	FisInit          u8
	FintKey          u8
	FintKeyLeaf      u8
	F__ccgo_pad1     [1]byte
	Fpgno            Pgno
	Fleaf            u8
	FhdrOffset       u8
	FchildPtrSize    u8
	Fmax1bytePayload u8
	FnOverflow       u8
	F__ccgo_pad2     [1]byte
	FmaxLocal        u16
	FminLocal        u16
	FcellOffset      u16
	FnFree           int32
	FnCell           u16
	FmaskPage        u16
	FaiOvfl          [4]u16
	F__ccgo_pad3     [4]byte
	FapOvfl          [4]uintptr
	FpBt             uintptr
	FaData           uintptr
	FaDataEnd        uintptr
	FaCellIdx        uintptr
	FaDataOfst       uintptr
	FpDbPage         uintptr
	FxCellSize       uintptr
	FxParseCell      uintptr
} /* btree.h:39:9 */

// 2004 April 6
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file implements an external (disk-based) database using BTrees.
// For a detailed discussion of BTrees, refer to
//
//     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:
//     "Sorting And Searching", pages 473-480. Addison-Wesley
//     Publishing Company, Reading, Massachusetts.
//
// The basic idea is that each page of the file contains N database
// entries and N+1 pointers to subpages.
//
//   ----------------------------------------------------------------
//   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |
//   ----------------------------------------------------------------
//
// All of the keys on the page that Ptr(0) points to have values less
// than Key(0).  All of the keys on page Ptr(1) and its subpages have
// values greater than Key(0) and less than Key(1).  All of the keys
// on Ptr(N) and its subpages have values greater than Key(N-1).  And
// so forth.
//
// Finding a particular key requires reading O(log(M)) pages from the
// disk where M is the number of entries in the tree.
//
// In this implementation, a single file can hold one or more separate
// BTrees.  Each BTree is identified by the index of its root page.  The
// key and data for any entry are combined to form the "payload".  A
// fixed amount of payload can be carried directly on the database
// page.  If the payload is larger than the preset amount then surplus
// bytes are stored on overflow pages.  The payload for an entry
// and the preceding pointer are combined to form a "Cell".  Each
// page has a small header which contains the Ptr(N) pointer and other
// information such as the size of key and data.
//
// FORMAT DETAILS
//
// The file is divided into pages.  The first page is called page 1,
// the second is page 2, and so forth.  A page number of zero indicates
// "no such page".  The page size can be any power of 2 between 512 and 65536.
// Each page can be either a btree page, a freelist page, an overflow
// page, or a pointer-map page.
//
// The first page is always a btree page.  The first 100 bytes of the first
// page contain a special header (the "file header") that describes the file.
// The format of the file header is as follows:
//
//   OFFSET   SIZE    DESCRIPTION
//      0      16     Header string: "SQLite format 3\000"
//     16       2     Page size in bytes.  (1 means 65536)
//     18       1     File format write version
//     19       1     File format read version
//     20       1     Bytes of unused space at the end of each page
//     21       1     Max embedded payload fraction (must be 64)
//     22       1     Min embedded payload fraction (must be 32)
//     23       1     Min leaf payload fraction (must be 32)
//     24       4     File change counter
//     28       4     Reserved for future use
//     32       4     First freelist page
//     36       4     Number of freelist pages in the file
//     40      60     15 4-byte meta values passed to higher layers
//
//     40       4     Schema cookie
//     44       4     File format of schema layer
//     48       4     Size of page cache
//     52       4     Largest root-page (auto/incr_vacuum)
//     56       4     1=UTF-8 2=UTF16le 3=UTF16be
//     60       4     User version
//     64       4     Incremental vacuum mode
//     68       4     Application-ID
//     72      20     unused
//     92       4     The version-valid-for number
//     96       4     SQLITE_VERSION_NUMBER
//
// All of the integer values are big-endian (most significant byte first).
//
// The file change counter is incremented when the database is changed
// This counter allows other processes to know when the file has changed
// and thus when they need to flush their cache.
//
// The max embedded payload fraction is the amount of the total usable
// space in a page that can be consumed by a single cell for standard
// B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default
// is to limit the maximum cell size so that at least 4 cells will fit
// on one page.  Thus the default max embedded payload fraction is 64.
//
// If the payload for a cell is larger than the max payload, then extra
// payload is spilled to overflow pages.  Once an overflow page is allocated,
// as many bytes as possible are moved into the overflow pages without letting
// the cell size drop below the min embedded payload fraction.
//
// The min leaf payload fraction is like the min embedded payload fraction
// except that it applies to leaf nodes in a LEAFDATA tree.  The maximum
// payload fraction for a LEAFDATA tree is always 100% (or 255) and it
// not specified in the header.
//
// Each btree pages is divided into three sections:  The header, the
// cell pointer array, and the cell content area.  Page 1 also has a 100-byte
// file header that occurs before the page header.
//
//      |----------------|
//      | file header    |   100 bytes.  Page 1 only.
//      |----------------|
//      | page header    |   8 bytes for leaves.  12 bytes for interior nodes
//      |----------------|
//      | cell pointer   |   |  2 bytes per cell.  Sorted order.
//      | array          |   |  Grows downward
//      |                |   v
//      |----------------|
//      | unallocated    |
//      | space          |
//      |----------------|   ^  Grows upwards
//      | cell content   |   |  Arbitrary order interspersed with freeblocks.
//      | area           |   |  and free space fragments.
//      |----------------|
//
// The page headers looks like this:
//
//   OFFSET   SIZE     DESCRIPTION
//      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf
//      1       2      byte offset to the first freeblock
//      3       2      number of cells on this page
//      5       2      first byte of the cell content area
//      7       1      number of fragmented free bytes
//      8       4      Right child (the Ptr(N) value).  Omitted on leaves.
//
// The flags define the format of this btree page.  The leaf flag means that
// this page has no children.  The zerodata flag means that this page carries
// only keys and no data.  The intkey flag means that the key is an integer
// which is stored in the key size entry of the cell header rather than in
// the payload area.
//
// The cell pointer array begins on the first byte after the page header.
// The cell pointer array contains zero or more 2-byte numbers which are
// offsets from the beginning of the page to the cell content in the cell
// content area.  The cell pointers occur in sorted order.  The system strives
// to keep free space after the last cell pointer so that new cells can
// be easily added without having to defragment the page.
//
// Cell content is stored at the very end of the page and grows toward the
// beginning of the page.
//
// Unused space within the cell content area is collected into a linked list of
// freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset
// to the first freeblock is given in the header.  Freeblocks occur in
// increasing order.  Because a freeblock must be at least 4 bytes in size,
// any group of 3 or fewer unused bytes in the cell content area cannot
// exist on the freeblock chain.  A group of 3 or fewer free bytes is called
// a fragment.  The total number of bytes in all fragments is recorded.
// in the page header at offset 7.
//
//    SIZE    DESCRIPTION
//      2     Byte offset of the next freeblock
//      2     Bytes in this freeblock
//
// Cells are of variable length.  Cells are stored in the cell content area at
// the end of the page.  Pointers to the cells are in the cell pointer array
// that immediately follows the page header.  Cells is not necessarily
// contiguous or in order, but cell pointers are contiguous and in order.
//
// Cell content makes use of variable length integers.  A variable
// length integer is 1 to 9 bytes where the lower 7 bits of each
// byte are used.  The integer consists of all bytes that have bit 8 set and
// the first byte with bit 8 clear.  The most significant byte of the integer
// appears first.  A variable-length integer may not be more than 9 bytes long.
// As a special case, all 8 bytes of the 9th byte are used as data.  This
// allows a 64-bit integer to be encoded in 9 bytes.
//
//    0x00                      becomes  0x00000000
//    0x7f                      becomes  0x0000007f
//    0x81 0x00                 becomes  0x00000080
//    0x82 0x00                 becomes  0x00000100
//    0x80 0x7f                 becomes  0x0000007f
//    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678
//    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081
//
// Variable length integers are used for rowids and to hold the number of
// bytes of key and data in a btree cell.
//
// The content of a cell looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of the left child. Omitted if leaf flag is set.
//     var    Number of bytes of data. Omitted if the zerodata flag is set.
//     var    Number of bytes of key. Or the key itself if intkey flag is set.
//      *     Payload
//      4     First page of the overflow chain.  Omitted if no overflow
//
// Overflow pages form a linked list.  Each page except the last is completely
// filled with data (pagesize - 4 bytes).  The last page can have as little
// as 1 byte of data.
//
//    SIZE    DESCRIPTION
//      4     Page number of next overflow page
//      *     Data
//
// Freelist pages come in two subtypes: trunk pages and leaf pages.  The
// file header points to the first in a linked list of trunk page.  Each trunk
// page points to multiple leaf pages.  The content of a leaf page is
// unspecified.  A trunk page looks like this:
//
//    SIZE    DESCRIPTION
//      4     Page number of next trunk page
//      4     Number of leaf pointers on this page
//      *     zero or more pages numbers of leaves
// 2001 September 15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// Internal interface definitions for SQLite.
//

// The following value is the maximum cell size assuming a maximum page
// size give above.

// The maximum number of cells on a single page of the database.  This
// assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself
// plus 2 bytes for the index to the cell in the page header).  Such
// small cells will be rare, but they are possible.

// Forward declarations
type MemPage = MemPage1 /* btreeInt.h:232:24 */
type BtLock1 = struct {
	FpBtree      uintptr
	FiTable      Pgno
	FeLock       u8
	F__ccgo_pad1 [3]byte
	FpNext       uintptr
} /* btree.h:39:9 */

type BtLock = BtLock1 /* btreeInt.h:233:23 */
type CellInfo1 = struct {
	FnKey     i64
	FpPayload uintptr
	FnPayload u32
	FnLocal   u16
	FnSize    u16
} /* btree.h:39:9 */

type CellInfo = CellInfo1 /* btreeInt.h:234:25 */

// Legal values for BtCursor.curFlags

// Potential values for BtCursor.eState.
//
// CURSOR_INVALID:
//   Cursor does not point to a valid entry. This can happen (for example)
//   because the table is empty or because BtreeCursorFirst() has not been
//   called.
//
// CURSOR_VALID:
//   Cursor points to a valid entry. getPayload() etc. may be called.
//
// CURSOR_SKIPNEXT:
//   Cursor is valid except that the Cursor.skipNext field is non-zero
//   indicating that the next sqlite3BtreeNext() or sqlite3BtreePrevious()
//   operation should be a no-op.
//
// CURSOR_REQUIRESEEK:
//   The table that this cursor was opened on still exists, but has been
//   modified since the cursor was last used. The cursor position is saved
//   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in
//   this state, restoreCursorPosition() can be called to attempt to
//   seek the cursor to the saved position.
//
// CURSOR_FAULT:
//   An unrecoverable error (an I/O error or a malloc failure) has occurred
//   on a different connection that shares the BtShared cache with this
//   cursor.  The error has left the cache in an inconsistent state.
//   Do nothing else with this cursor.  Any attempt to use the cursor
//   should return the error code stored in BtCursor.skipNext

// The database page the PENDING_BYTE occupies. This page is never used.

// These macros define the location of the pointer-map entry for a
// database page. The first argument to each is the number of usable
// bytes on each page of the database (often 1024). The second is the
// page number to look up in the pointer map.
//
// PTRMAP_PAGENO returns the database page number of the pointer-map
// page that stores the required pointer. PTRMAP_PTROFFSET returns
// the offset of the requested map entry.
//
// If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
// then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be
// used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
// this test.

// The pointer map is a lookup table that identifies the parent page for
// each child page in the database file.  The parent page is the page that
// contains a pointer to the child.  Every page in the database contains
// 0 or 1 parent pages.  (In this context 'database page' refers
// to any page that is not part of the pointer map itself.)  Each pointer map
// entry consists of a single byte 'type' and a 4 byte parent page number.
// The PTRMAP_XXX identifiers below are the valid types.
//
// The purpose of the pointer map is to facility moving pages from one
// position in the file to another as part of autovacuum.  When a page
// is moved, the pointer in its parent must be updated to point to the
// new location.  The pointer map is used to locate the parent page quickly.
//
// PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
//                  used in this case.
//
// PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number
//                  is not used in this case.
//
// PTRMAP_OVERFLOW1: The database page is the first page in a list of
//                   overflow pages. The page number identifies the page that
//                   contains the cell with a pointer to this overflow page.
//
// PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
//                   overflow pages. The page-number identifies the previous
//                   page in the overflow page list.
//
// PTRMAP_BTREE: The database page is a non-root btree page. The page number
//               identifies the parent page in the btree.

// A bunch of assert() statements to check the transaction state variables
// of handle p (type Btree*) are internally consistent.

// The ISAUTOVACUUM macro is used within balance_nonroot() to determine
// if the database supports auto-vacuum or not. Because it is used
// within an expression that is an argument to another macro
// (sqliteMallocRaw), it is not possible to use conditional compilation.
// So, this macro is defined instead.

// This structure is passed around through all the sanity checking routines
// in order to keep track of some global state information.
//
// The aRef[] array is allocated so that there is 1 bit for each page in
// the database. As the integrity-check proceeds, for each page used in
// the database the corresponding bit is set. This allows integrity-check to
// detect pages that are used twice and orphaned pages (both of which
// indicate corruption).
type IntegrityCk1 = struct {
	FpBt       uintptr
	FpPager    uintptr
	FaPgRef    uintptr
	FnPage     Pgno
	FmxErr     int32
	FnErr      int32
	FbOomFault int32
	FzPfx      uintptr
	Fv1        Pgno
	Fv2        int32
	FerrMsg    StrAccum
	Fheap      uintptr
	Fdb        uintptr
} /* btreeInt.h:691:9 */

// Legal values for BtCursor.curFlags

// Potential values for BtCursor.eState.
//
// CURSOR_INVALID:
//   Cursor does not point to a valid entry. This can happen (for example)
//   because the table is empty or because BtreeCursorFirst() has not been
//   called.
//
// CURSOR_VALID:
//   Cursor points to a valid entry. getPayload() etc. may be called.
//
// CURSOR_SKIPNEXT:
//   Cursor is valid except that the Cursor.skipNext field is non-zero
//   indicating that the next sqlite3BtreeNext() or sqlite3BtreePrevious()
//   operation should be a no-op.
//
// CURSOR_REQUIRESEEK:
//   The table that this cursor was opened on still exists, but has been
//   modified since the cursor was last used. The cursor position is saved
//   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in
//   this state, restoreCursorPosition() can be called to attempt to
//   seek the cursor to the saved position.
//
// CURSOR_FAULT:
//   An unrecoverable error (an I/O error or a malloc failure) has occurred
//   on a different connection that shares the BtShared cache with this
//   cursor.  The error has left the cache in an inconsistent state.
//   Do nothing else with this cursor.  Any attempt to use the cursor
//   should return the error code stored in BtCursor.skipNext

// The database page the PENDING_BYTE occupies. This page is never used.

// These macros define the location of the pointer-map entry for a
// database page. The first argument to each is the number of usable
// bytes on each page of the database (often 1024). The second is the
// page number to look up in the pointer map.
//
// PTRMAP_PAGENO returns the database page number of the pointer-map
// page that stores the required pointer. PTRMAP_PTROFFSET returns
// the offset of the requested map entry.
//
// If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,
// then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be
// used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements
// this test.

// The pointer map is a lookup table that identifies the parent page for
// each child page in the database file.  The parent page is the page that
// contains a pointer to the child.  Every page in the database contains
// 0 or 1 parent pages.  (In this context 'database page' refers
// to any page that is not part of the pointer map itself.)  Each pointer map
// entry consists of a single byte 'type' and a 4 byte parent page number.
// The PTRMAP_XXX identifiers below are the valid types.
//
// The purpose of the pointer map is to facility moving pages from one
// position in the file to another as part of autovacuum.  When a page
// is moved, the pointer in its parent must be updated to point to the
// new location.  The pointer map is used to locate the parent page quickly.
//
// PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not
//                  used in this case.
//
// PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number
//                  is not used in this case.
//
// PTRMAP_OVERFLOW1: The database page is the first page in a list of
//                   overflow pages. The page number identifies the page that
//                   contains the cell with a pointer to this overflow page.
//
// PTRMAP_OVERFLOW2: The database page is the second or later page in a list of
//                   overflow pages. The page-number identifies the previous
//                   page in the overflow page list.
//
// PTRMAP_BTREE: The database page is a non-root btree page. The page number
//               identifies the parent page in the btree.

// A bunch of assert() statements to check the transaction state variables
// of handle p (type Btree*) are internally consistent.

// The ISAUTOVACUUM macro is used within balance_nonroot() to determine
// if the database supports auto-vacuum or not. Because it is used
// within an expression that is an argument to another macro
// (sqliteMallocRaw), it is not possible to use conditional compilation.
// So, this macro is defined instead.

// This structure is passed around through all the sanity checking routines
// in order to keep track of some global state information.
//
// The aRef[] array is allocated so that there is 1 bit for each page in
// the database. As the integrity-check proceeds, for each page used in
// the database the corresponding bit is set. This allows integrity-check to
// detect pages that are used twice and orphaned pages (both of which
// indicate corruption).
type IntegrityCk = IntegrityCk1 /* btreeInt.h:691:28 */

// A bogus sqlite3 connection structure for use in the btree
// tests.
var sDb sqlite31          /* test3.c:32:16: */
var nRefSqlite3 int32 = 0 /* test3.c:33:12 */

// Usage:   btree_open FILENAME NCACHE
//
// Open a new database
func btree_open(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:40:26: */
	bp := tls.Alloc(188)
	defer tls.Free(188)

	// var pBt uintptr at bp+80, 8

	var rc int32
	// var nCache int32 at bp+72, 4

	// var zBuf [100]int8 at bp+88, 100

	var n int32
	var zFilename uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25737 /* " FILENAME NCACHE..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	nRefSqlite3++
	if nRefSqlite3 == 1 {
		sDb.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		sDb.Fmutex = sqlite3.Xsqlite3MutexAlloc(tls, SQLITE_MUTEX_RECURSIVE)
		sqlite3.Xsqlite3_mutex_enter(tls, sDb.Fmutex)
	}
	n = int32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))))
	zFilename = sqlite3.Xsqlite3_malloc(tls, n+2)
	if zFilename == uintptr(0) {
		return TCL_ERROR
	}
	libc.Xmemcpy(tls, zFilename, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uint64(n+1))
	*(*int8)(unsafe.Pointer(zFilename + uintptr(n+1))) = int8(0)
	rc = sqlite3.Xsqlite3BtreeOpen(tls, sDb.FpVfs, zFilename, uintptr(unsafe.Pointer(&sDb)), bp+80 /* &pBt */, 0,
		SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_MAIN_DB)
	sqlite3.Xsqlite3_free(tls, zFilename)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pBt */)), *(*int32)(unsafe.Pointer(bp + 72 /* nCache */)))
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+88 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(bp + 80 /* pBt */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+88 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage:   btree_close ID
//
// Close the given database.
func btree_close(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:86:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	rc = sqlite3.Xsqlite3BtreeClose(tls, pBt)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	nRefSqlite3--
	if nRefSqlite3 == 0 {
		sqlite3.Xsqlite3_mutex_leave(tls, sDb.Fmutex)
		sqlite3.Xsqlite3_mutex_free(tls, sDb.Fmutex)
		sDb.Fmutex = uintptr(0)
		sDb.FpVfs = uintptr(0)
	}
	return TCL_OK
}

// Usage:   btree_begin_transaction ID
//
// Start a new transaction
func btree_begin_transaction(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:121:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pBt uintptr
	var rc int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeBeginTrans(tls, pBt, 1, uintptr(0))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:   btree_pager_stats ID
//
// Returns pager statistics
func btree_pager_stats(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:150:26: */
	bp := tls.Alloc(140)
	defer tls.Free(140)

	var pBt uintptr
	var i int32
	var a uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))

	// Normally in this file, with a b-tree handle opened using the
	// [btree_open] command it is safe to call sqlite3BtreeEnter() directly.
	// But this function is sometimes called with a btree handle obtained
	// from an open SQLite connection (using [btree_from_db]). In this case
	// we need to obtain the mutex for the controlling SQLite handle before
	// it is safe to call sqlite3BtreeEnter().
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)

	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	a = sqlite3.Xsqlite3PagerStats(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	for i = 0; i < 11; i++ {
		// var zBuf [100]int8 at bp+40, 100

		tcl.XTcl_AppendElement(tls, interp, zName1[i])
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+40 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+32, *(*int32)(unsafe.Pointer(a + uintptr(i)*4))))
		tcl.XTcl_AppendElement(tls, interp, bp+40 /* &zBuf[0] */)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)

	// Release the mutex on the SQLite handle that controls this b-tree
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return TCL_OK
}

var zName1 = [11]uintptr{
	ts + 25070 /* "ref" */, ts + 25074 /* "page" */, ts + 18990 /* "max" */, ts + 12648 /* "size" */, ts + 10390 /* "state" */, ts + 25079, /* "err" */
	ts + 25083 /* "hit" */, ts + 25087 /* "miss" */, ts + 25092 /* "ovfl" */, ts + 25761 /* "read" */, ts + 25766, /* "write" */
} /* test3.c:179:17 */

// Usage:   btree_cursor ID TABLENUM WRITEABLE
//
// Create a new cursor.  Return the ID for the cursor.
func btree_cursor(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:200:26: */
	bp := tls.Alloc(110)
	defer tls.Free(110)

	var pBt uintptr
	// var iTable int32 at bp+72, 4

	var pCur uintptr
	var rc int32 = SQLITE_OK
	// var wrFlag int32 at bp+76, 4

	// var zBuf [30]int8 at bp+80, 30

	if argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25772 /* " ID TABLENUM WRI..." */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetBoolean(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+76) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 76)) != 0 {
		*(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)) = BTREE_WRCSR
	}
	pCur = tcl.XTcl_Alloc(tls, uint32(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	libc.Xmemset(tls, pCur, 0, uint64(sqlite3.Xsqlite3BtreeCursorSize(tls)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	rc = sqlite3.Xsqlite3BtreeLockTable(tls, pBt, *(*int32)(unsafe.Pointer(bp + 72 /* iTable */)), libc.BoolUint8(!!(*(*int32)(unsafe.Pointer(bp + 76)) != 0)))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3BtreeCursor(tls, pBt, uint32(*(*int32)(unsafe.Pointer(bp + 72 /* iTable */))), *(*int32)(unsafe.Pointer(bp + 76 /* wrFlag */)), uintptr(0), pCur)
	}
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	if rc != 0 {
		tcl.XTcl_Free(tls, pCur)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+80 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp+48, pCur))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+80 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_close_cursor ID
//
// Close a cursor opened using btree_cursor.
func btree_close_cursor(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:249:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pCur uintptr
	var rc int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	{
		var pBt uintptr = (*BtCursor)(unsafe.Pointer(pCur)).FpBtree
		sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
		sqlite3.Xsqlite3BtreeEnter(tls, pBt)
		rc = sqlite3.Xsqlite3BtreeCloseCursor(tls, pCur)
		sqlite3.Xsqlite3BtreeLeave(tls, pBt)
		sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)

	}
	tcl.XTcl_Free(tls, pCur)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	return SQLITE_OK
}

// Usage:   btree_next ID
//
// Move the cursor to the next entry in the table.  Return 0 on success
// or 1 if the cursor was already on the last entry in the table or if
// the table is empty.
func btree_next(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:291:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var pCur uintptr
	var rc int32
	var res int32 = 0
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeNext(tls, pCur, 0)
	if rc == SQLITE_DONE {
		res = 1
		rc = SQLITE_OK
	}
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+48, res))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_first ID
//
// Move the cursor to the first entry in the table.  Return 0 if the
// cursor was left point to something and 1 if the table is empty.
func btree_first(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:330:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var pCur uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp + 72 /* res */)) = 0
	// var zBuf [100]int8 at bp+76, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeFirst(tls, pCur, bp+72 /* &res */)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc), 0))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+76 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+48, *(*int32)(unsafe.Pointer(bp + 72 /* res */))))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+76 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_eof ID
//
// Return TRUE if the given cursor is not pointing at a valid entry.
// Return FALSE if the cursor does point to a valid entry.
func btree_eof(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:365:26: */
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var rc int32
	// var zBuf [50]int8 at bp+56, 50

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	rc = sqlite3.Xsqlite3BtreeEof(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+32, rc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// Usage:   btree_payload_size ID
//
// Return the number of bytes of payload
func btree_payload_size(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:394:26: */
	bp := tls.Alloc(106)
	defer tls.Free(106)

	var pCur uintptr
	var n u32
	// var zBuf [50]int8 at bp+56, 50

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pCur = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	n = sqlite3.Xsqlite3BtreePayloadSize(tls, pCur)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+56 /* &zBuf[0] */, ts+18527 /* "%u" */, libc.VaList(bp+32, n))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+56 /* &zBuf[0] */, 0))
	return SQLITE_OK
}

// usage:   varint_test  START  MULTIPLIER  COUNT  INCREMENT
//
// This command tests the putVarint() and getVarint()
// routines, both for accuracy and for speed.
//
// An integer is written using putVarint() and read back with
// getVarint() and varified to be unchanged.  This repeats COUNT
// times.  The first integer is START*MULTIPLIER.  Each iteration
// increases the integer by INCREMENT.
//
// This command returns nothing if it works.  It returns an error message
// if something goes wrong.
func btree_varint_test(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:432:26: */
	bp := tls.Alloc(516)
	defer tls.Free(516)

	// var start u32 at bp+184, 4

	// var mult u32 at bp+188, 4

	// var count u32 at bp+192, 4

	// var incr u32 at bp+196, 4

	var in u64
	// var out u64 at bp+504, 8

	var n1 int32
	var n2 int32
	var i int32
	var j int32
	// var zBuf [100]uint8 at bp+200, 100

	if argc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25796 /* " START MULTIPLIE..." */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+184) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+188) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 3*8)), bp+192) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 4*8)), bp+196) != 0 {
		return TCL_ERROR
	}
	in = u64(*(*u32)(unsafe.Pointer(bp + 184 /* start */)))
	in = in * u64(*(*u32)(unsafe.Pointer(bp + 188)))
	for i = 0; i < int32(*(*u32)(unsafe.Pointer(bp + 192 /* count */))); i++ {
		// var zErr [200]int8 at bp+300, 200

		n1 = sqlite3.Xsqlite3PutVarint(tls, bp+200 /* &zBuf[0] */, in)
		if n1 > 9 || n1 < 1 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+25831 /* "putVarint return..." */, libc.VaList(bp+32, n1))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+300 /* &zErr[0] */, 0))
			return TCL_ERROR
		}
		n2 = int32(sqlite3.Xsqlite3GetVarint(tls, bp+200 /* &zBuf[0] */, bp+504 /* &out */))
		if n1 != n2 {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+25881 /* "putVarint return..." */, libc.VaList(bp+56, n1, n2))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, bp+300 /* &zErr[0] */, 0))
			return TCL_ERROR
		}
		if in != *(*u64)(unsafe.Pointer(bp + 504)) {
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
				ts+25929 /* "Wrote 0x%016llx ..." */, libc.VaList(bp+88, in, *(*u64)(unsafe.Pointer(bp + 504 /* out */))))
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+104, bp+300 /* &zErr[0] */, 0))
			return TCL_ERROR
		}
		if in&uint64(0xffffffff) == in {
			// var out32 u32 at bp+512, 4

			n2 = int32(func() uint8 {
				if int32(*(*uint8)(unsafe.Pointer(bp + 200))) < int32(u8(0x80)) {
					return uint8(func() int32 { *(*u32)(unsafe.Pointer(bp + 512)) = u32(*(*uint8)(unsafe.Pointer(bp + 200))); return 1 }())
				}
				return sqlite3.Xsqlite3GetVarint32(tls, bp+200, bp+512)
			}())
			*(*u64)(unsafe.Pointer(bp + 504 /* out */)) = u64(*(*u32)(unsafe.Pointer(bp + 512 /* out32 */)))
			if n1 != n2 {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
					ts+25968, /* "putVarint return..." */
					libc.VaList(bp+120, n1, n2))
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+136, bp+300 /* &zErr[0] */, 0))
				return TCL_ERROR
			}
			if in != *(*u64)(unsafe.Pointer(bp + 504)) {
				sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([200]int8{})), bp+300, /* &zErr[0] */
					ts+26018, /* "Wrote 0x%016llx ..." */
					libc.VaList(bp+152, in, *(*u64)(unsafe.Pointer(bp + 504 /* out */))))
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+168, bp+300 /* &zErr[0] */, 0))
				return TCL_ERROR
			}
		}

		// In order to get realistic timings, run getVarint 19 more times.
		// This is because getVarint is called about 20 times more often
		// than putVarint.
		for j = 0; j < 19; j++ {
			sqlite3.Xsqlite3GetVarint(tls, bp+200 /* &zBuf[0] */, bp+504 /* &out */)
		}
		in = in + u64(*(*u32)(unsafe.Pointer(bp + 196)))
	}
	return TCL_OK
}

// usage:   btree_from_db  DB-HANDLE
//
// This command returns the btree handle for the main database associated
// with the database-handle passed as the argument. Example usage:
//
// sqlite3 db test.db
// set bt [btree_from_db db]
func btree_from_db(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:516:26: */
	bp := tls.Alloc(236)
	defer tls.Free(236)

	// var zBuf [100]int8 at bp+136, 100

	// var info Tcl_CmdInfo at bp+72, 64

	var db uintptr
	var pBt uintptr
	var iDb int32 = 0

	if argc != 2 && argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26074 /* " DB-HANDLE ?N?\"" */, 0))
		return TCL_ERROR
	}

	if 1 != tcl.XTcl_GetCommandInfo(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)), bp+72) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26090 /* "No such db-handl..." */, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+12784 /* "\"" */, 0))
		return TCL_ERROR
	}
	if argc == 3 {
		iDb = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	}

	db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 72)).FobjClientData))

	pBt = (*Db)(unsafe.Pointer((*sqlite31)(unsafe.Pointer(db)).FaDb + uintptr(iDb)*32)).FpBt
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+136 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp+64, pBt))
	tcl.XTcl_SetResult(tls, interp, bp+136 /* &zBuf[0] */, uintptr(1))
	return TCL_OK
}

// Usage:   btree_ismemdb ID
//
// Return true if the B-Tree is currently stored entirely in memory.
func btree_ismemdb(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:556:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pBt uintptr
	var res int32
	var pFile uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+25065 /* " ID\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	pFile = sqlite3.Xsqlite3PagerFile(tls, sqlite3.Xsqlite3BtreePager(tls, pBt))
	res = libc.Bool32((*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods == uintptr(0))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(res != 0)))
	return SQLITE_OK
}

// usage:   btree_set_cache_size ID NCACHE
//
// Set the size of the cache used by btree $ID.
func btree_set_cache_size(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test3.c:587:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	// var nCache int32 at bp+32, 4

	var pBt uintptr

	if argc != 3 {
		tcl.XTcl_AppendResult(tls,
			interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)), ts+26111 /* " BT NCACHE\"" */, 0))
		return TCL_ERROR
	}
	pBt = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+32) != 0 {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, pBt)
	sqlite3.Xsqlite3BtreeSetCacheSize(tls, pBt, *(*int32)(unsafe.Pointer(bp + 32 /* nCache */)))
	sqlite3.Xsqlite3BtreeLeave(tls, pBt)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer(pBt)).Fdb)).Fmutex)
	return TCL_OK
}

// usage:   btree_insert CSR ?KEY? VALUE
//
// Set the size of the cache used by btree $ID.
func btree_insert(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test3.c:617:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var pCur uintptr
	// var rc int32 at bp+64, 4

	// var x BtreePayload at bp+16, 48

	if objc != 4 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+26123 /* "?-intkey? CSR KE..." */)
		return TCL_ERROR
	}

	libc.Xmemset(tls, bp+16 /* &x */, 0, uint64(unsafe.Sizeof(BtreePayload{})))
	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+64) != 0 {
			return TCL_ERROR
		}
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 64 /* rc */)))
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FpData = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+16+36)
	} else {
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FpKey = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+64 /* &rc */)
		(*BtreePayload)(unsafe.Pointer(bp + 16 /* &x */)).FnKey = sqlite3_int64(*(*int32)(unsafe.Pointer(bp + 64 /* rc */)))
	}
	pCur = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))

	sqlite3.Xsqlite3_mutex_enter(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)
	sqlite3.Xsqlite3BtreeEnter(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = sqlite3.Xsqlite3BtreeInsert(tls, pCur, bp+16 /* &x */, 0, 0)
	sqlite3.Xsqlite3BtreeLeave(tls, (*BtCursor)(unsafe.Pointer(pCur)).FpBtree)
	sqlite3.Xsqlite3_mutex_leave(tls, (*sqlite31)(unsafe.Pointer((*Btree)(unsafe.Pointer((*BtCursor)(unsafe.Pointer(pCur)).FpBtree)).Fdb)).Fmutex)

	tcl.XTcl_ResetResult(tls, interp)
	if *(*int32)(unsafe.Pointer(bp + 64)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, *(*int32)(unsafe.Pointer(bp + 64 /* rc */))), 0))
		return TCL_ERROR
	}
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest3_Init(tls *libc.TLS, interp uintptr) int32 { /* test3.c:661:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd3))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd3[i].FzName, aCmd3[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_CreateObjCommand(tls, interp, ts+26147 /* "btree_insert" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{btree_insert})), uintptr(0), uintptr(0))

	return TCL_OK
}

var aCmd3 = [14]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 26160 /* "btree_open" */, FxProc: 0},
	{FzName: ts + 26171 /* "btree_close" */, FxProc: 0},
	{FzName: ts + 26183 /* "btree_begin_tran..." */, FxProc: 0},
	{FzName: ts + 26207 /* "btree_pager_stat..." */, FxProc: 0},
	{FzName: ts + 26225 /* "btree_cursor" */, FxProc: 0},
	{FzName: ts + 26238 /* "btree_close_curs..." */, FxProc: 0},
	{FzName: ts + 26257 /* "btree_next" */, FxProc: 0},
	{FzName: ts + 26268 /* "btree_eof" */, FxProc: 0},
	{FzName: ts + 26278 /* "btree_payload_si..." */, FxProc: 0},
	{FzName: ts + 26297 /* "btree_first" */, FxProc: 0},
	{FzName: ts + 26309 /* "btree_varint_tes..." */, FxProc: 0},
	{FzName: ts + 26327 /* "btree_from_db" */, FxProc: 0},
	{FzName: ts + 26341 /* "btree_ismemdb" */, FxProc: 0},
	{FzName: ts + 26355 /* "btree_set_cache_..." */, FxProc: 0},
} /* test3.c:665:5 */

// -
// SPDX-License-Identifier: (BSD-4-Clause AND BSD-2-Clause-FreeBSD)
//
// Copyright (c) 1996, 1997
//      HD Associates, Inc.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. All advertising materials mentioning features or use of this software
//    must display the following acknowledgement:
//      This product includes software developed by HD Associates, Inc
//      and Jukka Antero Ukkonen.
// 4. Neither the name of the author nor the names of any co-contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY HD ASSOCIATES AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL HD ASSOCIATES OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

// -
// Copyright (c) 2002-2008, Jeffrey Roberson <jeff@freebsd.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice unmodified, this list of conditions, and the following
//    disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
// $FreeBSD$

// POSIX 1003.1b Process Scheduling

// POSIX scheduling policies

type sched_param = struct{ Fsched_priority int32 } /* sched.h:240:1 */

type _pthread_cleanup_info = struct{ Fpthread_cleanup_pad [8]uint64 } /* pthread.h:143:1 */

// Each thread is controlled by an instance of the following
// structure.
type Thread = struct {
	FzFilename   uintptr
	FxOp         uintptr
	FzArg        uintptr
	Fopnum       int32
	Fbusy        int32
	Fcompleted   int32
	F__ccgo_pad1 [4]byte
	Fdb          uintptr
	FpStmt       uintptr
	FzErr        uintptr
	FzStaticErr  uintptr
	Frc          int32
	Fargc        int32
	Fargv        [100]uintptr
	Fcolv        [100]uintptr
} /* test4.c:33:23 */

// There can be as many as 26 threads running at once.  Each is named
// by a capital letter: A, B, C, ..., Y, Z.
var threadset [26]Thread /* test4.c:61:15: */

// The main loop for a thread.  Threads use busy waiting.
func test_thread_main(tls *libc.TLS, pArg uintptr) uintptr { /* test4.c:67:13: */
	var p uintptr = pArg
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
	}
	sqlite3.Xsqlite3_open(tls, (*Thread)(unsafe.Pointer(p)).FzFilename, p+40)
	if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*Thread)(unsafe.Pointer(p)).Fdb) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.Xstrdup(tls, sqlite3.Xsqlite3_errmsg(tls, (*Thread)(unsafe.Pointer(p)).Fdb))
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fcompleted = 1
	for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
		libc.Xsched_yield(tls)
	}
	for (*Thread)(unsafe.Pointer(p)).FxOp != 0 {
		if (*Thread)(unsafe.Pointer(p)).FzErr != 0 && (*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr {
			sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
			(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Thread)(unsafe.Pointer(p)).FxOp})).f(tls, p)
		(*Thread)(unsafe.Pointer(p)).Fcompleted++
		for (*Thread)(unsafe.Pointer(p)).Fopnum <= (*Thread)(unsafe.Pointer(p)).Fcompleted {
			libc.Xsched_yield(tls)
		}
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	if (*Thread)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3.Xsqlite3_close(tls, (*Thread)(unsafe.Pointer(p)).Fdb)
		(*Thread)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	if (*Thread)(unsafe.Pointer(p)).FzErr != 0 && (*Thread)(unsafe.Pointer(p)).FzErr != (*Thread)(unsafe.Pointer(p)).FzStaticErr {
		sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzErr)
		(*Thread)(unsafe.Pointer(p)).FzErr = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).Fcompleted++
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return uintptr(0)
}

// Get a thread ID which is an upper case letter.  Return the index.
// If the argument is not a valid thread ID put an error message in
// the interpreter and return -1.
func parse_thread_id(tls *libc.TLS, interp uintptr, zArg uintptr) int32 { /* test4.c:114:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if zArg == uintptr(0) || int32(*(*int8)(unsafe.Pointer(zArg))) == 0 || int32(*(*int8)(unsafe.Pointer(zArg + 1))) != 0 || !(__sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zArg)))), uint64(X_CTYPE_U)) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+26376 /* "thread ID must b..." */, 0))
		return -1
	}
	return int32(*(*int8)(unsafe.Pointer(zArg))) - 'A'
}

// Usage:    thread_create NAME  FILENAME
//
// NAME should be an upper case letter.  Start the thread running with
// an open connection to the given database.
func tcl_thread_create(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:128:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var i int32
	// var x pthread_t at bp+88, 8

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26415 /* " ID FILENAME" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if threadset[i].Fbusy != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26428 /* "thread " */, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+26436 /* " is already runn..." */, 0))
		return TCL_ERROR
	}
	threadset[i].Fbusy = 1
	sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
	threadset[i].FzFilename = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	threadset[i].Fopnum = 1
	threadset[i].Fcompleted = 0
	rc = libc.Xpthread_create(tls, bp+88 /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{test_thread_main})), uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+26456 /* "failed to create..." */, 0))
		sqlite3.Xsqlite3_free(tls, threadset[i].FzFilename)
		threadset[i].Fbusy = 0
		return TCL_ERROR
	}
	libc.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp + 88 /* x */)))
	return TCL_OK
}

// Wait for a thread to reach its idle state.
func test_thread_wait(tls *libc.TLS, p uintptr) { /* test4.c:168:13: */
	for (*Thread)(unsafe.Pointer(p)).Fopnum > (*Thread)(unsafe.Pointer(p)).Fcompleted {
		libc.Xsched_yield(tls)
	}
}

// Usage:  thread_wait ID
//
// Wait on thread ID to reach its idle state.
func tcl_thread_wait(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:177:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	return TCL_OK
}

// Stop a thread.
func test_stop_thread(tls *libc.TLS, p uintptr) { /* test4.c:203:13: */
	test_thread_wait(tls, p)
	(*Thread)(unsafe.Pointer(p)).FxOp = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fopnum++
	test_thread_wait(tls, p)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzArg)
	(*Thread)(unsafe.Pointer(p)).FzArg = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*Thread)(unsafe.Pointer(p)).FzFilename)
	(*Thread)(unsafe.Pointer(p)).FzFilename = uintptr(0)
	(*Thread)(unsafe.Pointer(p)).Fbusy = 0
}

// Usage:  thread_halt ID
//
// Cause a thread to shut itself down.  Wait for the shutdown to be
// completed.  If ID is "*" then stop all threads.
func tcl_thread_halt(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:221:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*8))))) == '*' && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*8)) + 1))) == 0 {
		for i = 0; i < N_THREAD; i++ {
			if threadset[i].Fbusy != 0 {
				test_stop_thread(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
			}
		}
	} else {
		i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		if i < 0 {
			return TCL_ERROR
		}
		if !(threadset[i].Fbusy != 0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
			return TCL_ERROR
		}
		test_stop_thread(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	}
	return TCL_OK
}

// Usage: thread_argc  ID
//
// Wait on the most recent thread_step to complete, then return the
// number of columns in the result set.
func tcl_thread_argc(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:256:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var i int32
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+48, threadset[i].Fargc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: thread_argv  ID   N
//
// Wait on the most recent thread_step to complete, then return the
// value of the N-th columns in the result set.
func tcl_thread_argv(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:288:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26503 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+80) != 0 {
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 || *(*int32)(unsafe.Pointer(bp + 80)) >= threadset[i].Fargc {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+26509 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680 + 80 + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*8)), 0))
	return TCL_OK
}

// Usage: thread_colname  ID   N
//
// Wait on the most recent thread_step to complete, then return the
// name of the N-th columns in the result set.
func tcl_thread_colname(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:324:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26503 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+80) != 0 {
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 || *(*int32)(unsafe.Pointer(bp + 80)) >= threadset[i].Fargc {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+26509 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&threadset)) + uintptr(i)*1680 + 880 + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*8)), 0))
	return TCL_OK
}

// Usage: thread_result  ID
//
// Wait on the most recent operation to complete, then return the
// result code from that operation.
func tcl_thread_result(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:360:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var zName uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	zName = sqlite3.Xsqlite3ErrName(tls, threadset[i].Frc)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, zName, 0))
	return TCL_OK
}

// Usage: thread_error  ID
//
// Wait on the most recent operation to complete, then return the
// error string.
func tcl_thread_error(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:392:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, threadset[i].FzErr, 0))
	return TCL_OK
}

// This procedure runs in the thread to compile an SQL statement.
func do_compile(tls *libc.TLS, p uintptr) { /* test4.c:419:13: */
	if (*Thread)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+64, ts+26536 /* "no database is o..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	if (*Thread)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_prepare(tls, (*Thread)(unsafe.Pointer(p)).Fdb, (*Thread)(unsafe.Pointer(p)).FzArg, -1, p+48, uintptr(0))
}

// Usage: thread_compile ID SQL
//
// Compile a new virtual machine.
func tcl_thread_compile(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:437:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26556 /* " ID SQL" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_compile}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	threadset[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to step the virtual machine.
func do_step(tls *libc.TLS, p uintptr) { /* test4.c:466:13: */
	var i int32
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+64, ts+26564 /* "no virtual machi..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_step(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	if (*Thread)(unsafe.Pointer(p)).Frc == SQLITE_ROW {
		(*Thread)(unsafe.Pointer(p)).Fargc = sqlite3.Xsqlite3_column_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
		for i = 0; i < sqlite3.Xsqlite3_data_count(tls, (*Thread)(unsafe.Pointer(p)).FpStmt); i++ {
			*(*uintptr)(unsafe.Pointer(p + 80 + uintptr(i)*8)) = sqlite3.Xsqlite3_column_text(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
		for i = 0; i < (*Thread)(unsafe.Pointer(p)).Fargc; i++ {
			*(*uintptr)(unsafe.Pointer(p + 880 + uintptr(i)*8)) = sqlite3.Xsqlite3_column_name(tls, (*Thread)(unsafe.Pointer(p)).FpStmt, i)
		}
	}
}

// Usage: thread_step ID
//
// Advance the virtual machine by one step
func tcl_thread_step(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:490:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26593 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_step}))
	threadset[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to finalize a virtual machine.
func do_finalize(tls *libc.TLS, p uintptr) { /* test4.c:517:13: */
	if (*Thread)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+64, ts+26564 /* "no virtual machi..." */)
		(*Thread)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread)(unsafe.Pointer(p)).Frc = sqlite3.Xsqlite3_finalize(tls, (*Thread)(unsafe.Pointer(p)).FpStmt)
	(*Thread)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

// Usage: thread_finalize ID
//
// Finalize the virtual machine.
func tcl_thread_finalize(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:532:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26593 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	threadset[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_finalize}))
	sqlite3.Xsqlite3_free(tls, threadset[i].FzArg)
	threadset[i].FzArg = uintptr(0)
	threadset[i].Fopnum++
	return TCL_OK
}

// Usage: thread_swap ID ID
//
// Interchange the sqlite* pointer between two threads.
func tcl_thread_swap(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:563:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var j int32
	var temp uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26598 /* " ID1 ID2" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	j = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	if j < 0 {
		return TCL_ERROR
	}
	if !(threadset[j].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(j)*1680)
	temp = threadset[i].Fdb
	threadset[i].Fdb = threadset[j].Fdb
	threadset[j].Fdb = temp
	return TCL_OK
}

// Usage: thread_db_get ID
//
// Return the database connection pointer for the given thread.  Then
// remove the pointer from the thread itself.  Afterwards, the thread
// can be stopped and the connection can be used by the main thread.
func tcl_thread_db_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:603:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32
	// var zBuf [100]int8 at bp+64, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	sqlite3TestMakePointerStr(tls, interp, bp+64 /* &zBuf[0] */, threadset[i].Fdb)
	threadset[i].Fdb = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+64 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// Usage: thread_db_put ID DB
//
func tcl_thread_db_put(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:634:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26607 /* " ID DB" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)

	threadset[i].Fdb = sqlite3TestTextToPtr(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	return TCL_OK
}

// Usage: thread_stmt_get ID
//
// Return the database stmt pointer for the given thread.  Then
// remove the pointer from the thread itself.
func tcl_thread_stmt_get(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test4.c:666:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	var i int32
	// var zBuf [100]int8 at bp+64, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_thread_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	test_thread_wait(tls, uintptr(unsafe.Pointer(&threadset))+uintptr(i)*1680)
	sqlite3TestMakePointerStr(tls, interp, bp+64 /* &zBuf[0] */, threadset[i].FpStmt)
	threadset[i].FpStmt = uintptr(0)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, bp+64 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest4_Init(tls *libc.TLS, interp uintptr) int32 { /* test4.c:696:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd4))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd4[i].FzName, aCmd4[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aCmd4 = [15]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 26614 /* "thread_create" */, FxProc: 0},
	{FzName: ts + 26628 /* "thread_wait" */, FxProc: 0},
	{FzName: ts + 26640 /* "thread_halt" */, FxProc: 0},
	{FzName: ts + 26652 /* "thread_argc" */, FxProc: 0},
	{FzName: ts + 26664 /* "thread_argv" */, FxProc: 0},
	{FzName: ts + 26676 /* "thread_colname" */, FxProc: 0},
	{FzName: ts + 26691 /* "thread_result" */, FxProc: 0},
	{FzName: ts + 26705 /* "thread_error" */, FxProc: 0},
	{FzName: ts + 26718 /* "thread_compile" */, FxProc: 0},
	{FzName: ts + 26733 /* "thread_step" */, FxProc: 0},
	{FzName: ts + 26745 /* "thread_finalize" */, FxProc: 0},
	{FzName: ts + 26761 /* "thread_swap" */, FxProc: 0},
	{FzName: ts + 26773 /* "thread_db_get" */, FxProc: 0},
	{FzName: ts + 26787 /* "thread_db_put" */, FxProc: 0},
	{FzName: ts + 26801 /* "thread_stmt_get" */, FxProc: 0},
} /* test4.c:700:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// The first argument is a TCL UTF-8 string. Return the byte array
// object with the encoded representation of the string, including
// the NULL terminator.
func binarize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:33:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var len int32 at bp, 4

	var bytes uintptr
	var pRet uintptr

	bytes = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &len */)
	pRet = tcl.XTcl_NewByteArrayObj(tls, bytes, *(*int32)(unsafe.Pointer(bp))+1)
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// Usage: test_value_overhead <repeat-count> <do-calls>.
//
// This routine is used to test the overhead of calls to
// sqlite3_value_text(), on a value that contains a UTF-8 string. The idea
// is to figure out whether or not it is a problem to use sqlite3_value
// structures with collation sequence functions.
//
// If <do-calls> is 0, then the calls to sqlite3_value_text() are not
// actually made.
func test_value_overhead(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:61:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	// var do_calls int32 at bp+36, 4

	// var repeat_count int32 at bp+32, 4

	var i int32
	// var val Mem at bp+40, 56

	if objc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)), ts+26817 /* " <repeat-count> ..." */, 0))
		return TCL_ERROR
	}

	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+32) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+36) != 0 {
		return TCL_ERROR
	}

	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fflags = u16(MEM_Str | MEM_Term | MEM_Static)
	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fz = ts + 26844 /* "hello world" */
	(*Mem)(unsafe.Pointer(bp + 40 /* &val */)).Fenc = u8(SQLITE_UTF8)

	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 32 /* repeat_count */)); i++ {
		if *(*int32)(unsafe.Pointer(bp + 36)) != 0 {
			sqlite3.Xsqlite3_value_text(tls, bp+40 /* &val */)
		}
	}

	return TCL_OK
}

func name_to_enc(tls *libc.TLS, interp uintptr, pObj uintptr) u8 { /* test5.c:94:11: */
	bp := tls.Alloc(104)
	defer tls.Free(104)

	*(*[5]EncName)(unsafe.Pointer(bp + 24 /* encnames */)) = [5]EncName{
		{FzName: ts + 26856 /* "UTF8" */, Fenc: u8(SQLITE_UTF8)},
		{FzName: ts + 26861 /* "UTF16LE" */, Fenc: u8(SQLITE_UTF16LE)},
		{FzName: ts + 26869 /* "UTF16BE" */, Fenc: u8(SQLITE_UTF16BE)},
		{FzName: ts + 26877 /* "UTF16" */, Fenc: u8(SQLITE_UTF16)},
		{},
	}
	var pEnc uintptr
	var z uintptr = tcl.XTcl_GetString(tls, pObj)
	for pEnc = bp + 24; (*EncName)(unsafe.Pointer(pEnc)).FzName != 0; pEnc += 16 {
		if 0 == sqlite3.Xsqlite3StrICmp(tls, z, (*EncName)(unsafe.Pointer(pEnc)).FzName) {
			break
		}
	}
	if !(int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+26883 /* "No such encoding..." */, z, 0))
	}
	if int32((*EncName)(unsafe.Pointer(pEnc)).Fenc) == SQLITE_UTF16 {
		return u8(SQLITE_UTF16LE)
	}
	return (*EncName)(unsafe.Pointer(pEnc)).Fenc
}

type EncName = struct {
	FzName       uintptr
	Fenc         u8
	F__ccgo_pad1 [7]byte
} /* test5.c:95:3 */

// Usage:   test_translate <string/blob> <from enc> <to enc> ?<transient>?
//
func test_translate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:125:26: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var enc_from u8
	var enc_to u8
	var pVal uintptr
	var z uintptr
	// var len int32 at bp+40, 4

	var xDel uintptr = uintptr(0)

	if objc != 4 && objc != 5 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv)), uintptr(0)),
			ts+26902 /* " <string/blob> <..." */, 0))
		return TCL_ERROR
	}
	if objc == 5 {
		xDel = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free}))
	}

	enc_from = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if !(enc_from != 0) {
		return TCL_ERROR
	}
	enc_to = name_to_enc(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if !(enc_to != 0) {
		return TCL_ERROR
	}

	pVal = sqlite3.Xsqlite3ValueNew(tls, uintptr(0))

	if int32(enc_from) == SQLITE_UTF8 {
		z = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
		if objc == 5 {
			z = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+32, z))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	} else {
		z = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+40 /* &len */)
		if objc == 5 {
			var zTmp uintptr = z
			z = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 40 /* len */)))
			libc.Xmemcpy(tls, z, zTmp, uint64(*(*int32)(unsafe.Pointer(bp + 40 /* len */))))
		}
		sqlite3.Xsqlite3ValueSetStr(tls, pVal, -1, z, enc_from, xDel)
	}

	z = sqlite3.Xsqlite3ValueText(tls, pVal, enc_to)
	*(*int32)(unsafe.Pointer(bp + 40 /* len */)) = sqlite3.Xsqlite3ValueBytes(tls, pVal, enc_to) + func() int32 {
		if int32(enc_to) == SQLITE_UTF8 {
			return 1
		}
		return 2
	}()
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, z, *(*int32)(unsafe.Pointer(bp + 40 /* len */))))

	sqlite3.Xsqlite3ValueFree(tls, pVal)

	return TCL_OK
}

func test_translate_selftest(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test5.c:189:26: */
	sqlite3.Xsqlite3UtfSelfTest(tls)
	return SQLITE_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest5_Init(tls *libc.TLS, interp uintptr) int32 { /* test5.c:205:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd5))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd5[i].FzName, aCmd5[i].FxProc, uintptr(0), uintptr(0))
	}
	return SQLITE_OK
}

var aCmd5 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 26937 /* "binarize" */, FxProc: 0},
	{FzName: ts + 26946 /* "test_value_overh..." */, FxProc: 0},
	{FzName: ts + 26966 /* "test_translate" */, FxProc: 0},
	{FzName: ts + 26981 /* "translate_selfte..." */, FxProc: 0},
} /* test5.c:209:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// #define TRACE_CRASHTEST

type CrashFile1 = struct {
	FpMethod     uintptr
	FpRealFile   uintptr
	FzName       uintptr
	Fflags       int32
	F__ccgo_pad1 [4]byte
	FzData       uintptr
	FnData       int32
	F__ccgo_pad2 [4]byte
	FiSize       i64
} /* test6.c:29:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// #define TRACE_CRASHTEST

type CrashFile = CrashFile1 /* test6.c:29:26 */
type CrashGlobal1 = struct {
	FpWriteList             uintptr
	FpWriteListEnd          uintptr
	FiSectorSize            int32
	FiDeviceCharacteristics int32
	FiCrash                 int32
	FzCrashFile             [500]int8
} /* test6.c:30:9 */

type CrashGlobal = CrashGlobal1 /* test6.c:30:28 */
type WriteBuffer1 = struct {
	FiOffset     i64
	FnBuf        int32
	F__ccgo_pad1 [4]byte
	FzBuf        uintptr
	FpFile       uintptr
	FpNext       uintptr
} /* test6.c:30:9 */

type WriteBuffer = WriteBuffer1 /* test6.c:31:28 */

var g = CrashGlobal{FiSectorSize: SQLITE_DEFAULT_SECTOR_SIZE} /* test6.c:156:20 */

// Set this global variable to 1 to enable crash testing.
var sqlite3CrashTestEnable int32 = 0 /* test6.c:161:12 */

func crash_malloc(tls *libc.TLS, nByte int32) uintptr { /* test6.c:163:13: */
	return tcl.XTcl_AttemptAlloc(tls, uint32(size_t(nByte)))
}

func crash_free(tls *libc.TLS, p uintptr) { /* test6.c:166:13: */
	tcl.XTcl_Free(tls, p)
}

func crash_realloc(tls *libc.TLS, p uintptr, n int32) uintptr { /* test6.c:169:13: */
	return tcl.XTcl_AttemptRealloc(tls, p, uint32(size_t(n)))
}

// Wrapper around the sqlite3OsWrite() function that avoids writing to the
// 512 byte block begining at offset PENDING_BYTE.
func writeDbFile(tls *libc.TLS, p uintptr, z uintptr, iAmt i64, iOff i64) int32 { /* test6.c:177:12: */
	var rc int32 = SQLITE_OK
	var iSkip int32 = 0
	if iAmt-i64(iSkip) > int64(0) {
		rc = sqlite3.Xsqlite3OsWrite(tls, (*CrashFile)(unsafe.Pointer(p)).FpRealFile, z+uintptr(iSkip), int32(iAmt-i64(iSkip)), iOff+i64(iSkip))
	}
	return rc
}

// Flush the write-list as if xSync() had been called on file handle
// pFile. If isCrash is true, simulate a crash.
func writeListSync(tls *libc.TLS, pFile uintptr, isCrash int32) int32 { /* test6.c:190:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = SQLITE_OK
	var iDc int32 = g.FiDeviceCharacteristics
	var pWrite uintptr
	var ppPtr uintptr

	// If this is not a crash simulation, set pFinal to point to the
	// last element of the write-list that is associated with file handle
	// pFile.
	//
	// If this is a crash simulation, set pFinal to an arbitrarily selected
	// element of the write-list.
	var pFinal uintptr = uintptr(0)
	if !(isCrash != 0) {
		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			if (*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile {
				pFinal = pWrite
			}
		}
	} else if iDc&(SQLITE_IOCAP_SEQUENTIAL|SQLITE_IOCAP_SAFE_APPEND) != 0 {
		var nWrite int32 = 0
		// var iFinal int32 at bp, 4

		for pWrite = g.FpWriteList; pWrite != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			nWrite++
		}
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp /* &iFinal */)
		*(*int32)(unsafe.Pointer(bp /* iFinal */)) = func() int32 {
			if *(*int32)(unsafe.Pointer(bp)) < 0 {
				return -1 * *(*int32)(unsafe.Pointer(bp))
			}
			return *(*int32)(unsafe.Pointer(bp))
		}() % nWrite
		for pWrite = g.FpWriteList; *(*int32)(unsafe.Pointer(bp /* iFinal */)) > 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
			*(*int32)(unsafe.Pointer(bp /* iFinal */))--
		}
		pFinal = pWrite
	}

	ppPtr = uintptr(unsafe.Pointer(&g))
	for pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)); rc == SQLITE_OK && pWrite != 0; pWrite = *(*uintptr)(unsafe.Pointer(ppPtr)) {
		var pRealFile uintptr = (*CrashFile)(unsafe.Pointer((*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile)).FpRealFile

		// (eAction==1)      -> write block out normally,
		// (eAction==2)      -> do nothing,
		// (eAction==3)      -> trash sectors.
		var eAction int32 = 0
		if !(isCrash != 0) {
			eAction = 2
			if (*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile == pFile || iDc&SQLITE_IOCAP_SEQUENTIAL != 0 {
				eAction = 1
			}
		} else {
			// var random int8 at bp+4, 1

			sqlite3.Xsqlite3_randomness(tls, 1, bp+4 /* &random */)

			// Do not select option 3 (sector trashing) if the IOCAP_ATOMIC flag
			// is set or this is an OsTruncate(), not an Oswrite().
			if iDc&SQLITE_IOCAP_ATOMIC != 0 || (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf == uintptr(0) {
				*(*int8)(unsafe.Pointer(bp + 4 /* random */)) &= int8(0x01)
			}

			// If IOCAP_SEQUENTIAL is set and this is not the final entry
			// in the truncated write-list, always select option 1 (write
			// out correctly).
			if iDc&SQLITE_IOCAP_SEQUENTIAL != 0 && pWrite != pFinal {
				*(*int8)(unsafe.Pointer(bp + 4 /* random */)) = int8(0)
			}

			// If IOCAP_SAFE_APPEND is set and this OsWrite() operation is
			// an append (first byte of the written region is 1 byte past the
			// current EOF), always select option 1 (write out correctly).
			if iDc&SQLITE_IOCAP_SAFE_APPEND != 0 && (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0 {
				// var iSize i64 at bp+8, 8

				sqlite3.Xsqlite3OsFileSize(tls, pRealFile, bp+8 /* &iSize */)
				if *(*i64)(unsafe.Pointer(bp + 8)) == (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset {
					*(*int8)(unsafe.Pointer(bp + 4 /* random */)) = int8(0)
				}
			}

			if int32(*(*int8)(unsafe.Pointer(bp + 4)))&0x06 == 0x06 {
				eAction = 3
			} else {
				eAction = func() int32 {
					if int32(*(*int8)(unsafe.Pointer(bp + 4)))&0x01 != 0 {
						return 2
					}
					return 1
				}()
			}
		}

		switch eAction {
		case 1:
			{ // Write out correctly
				if (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf != 0 {
					rc = writeDbFile(tls,
						(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FzBuf, int64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf), (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				} else {
					rc = sqlite3.Xsqlite3OsTruncate(tls, pRealFile, (*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset)
				}
				*(*uintptr)(unsafe.Pointer(ppPtr)) = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext
				crash_free(tls, pWrite)
				break

			}
		case 2:
			{ // Do nothing
				ppPtr = pWrite + 32
				break

			}
		case 3:
			{ // Trash sectors
				var zGarbage uintptr
				var iFirst int32 = int32((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset / i64(g.FiSectorSize))
				var iLast int32 = int32(((*WriteBuffer)(unsafe.Pointer(pWrite)).FiOffset + i64((*WriteBuffer)(unsafe.Pointer(pWrite)).FnBuf) - int64(1)) / i64(g.FiSectorSize))

				zGarbage = crash_malloc(tls, g.FiSectorSize)
				if zGarbage != 0 {
					var i sqlite3_int64
					for i = sqlite3_int64(iFirst); rc == SQLITE_OK && i <= sqlite3_int64(iLast); i++ {
						sqlite3.Xsqlite3_randomness(tls, g.FiSectorSize, zGarbage)
						rc = writeDbFile(tls,
							(*WriteBuffer)(unsafe.Pointer(pWrite)).FpFile, zGarbage, int64(g.FiSectorSize), i*sqlite3_int64(g.FiSectorSize))
					}
					crash_free(tls, zGarbage)
				} else {
					rc = SQLITE_NOMEM
				}

				ppPtr = pWrite + 32
				break

			}

		default:

		}

		if pWrite == pFinal {
			break
		}
	}

	if rc == SQLITE_OK && isCrash != 0 {
		libc.Xexit(tls, -1)
	}

	for pWrite = g.FpWriteList; pWrite != 0 && (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext != 0; pWrite = (*WriteBuffer)(unsafe.Pointer(pWrite)).FpNext {
	}
	g.FpWriteListEnd = pWrite

	return rc
}

// Add an entry to the end of the write-list.
func writeListAppend(tls *libc.TLS, pFile uintptr, iOffset sqlite3_int64, zBuf uintptr, nBuf int32) int32 { /* test6.c:362:12: */
	var pNew uintptr

	pNew = crash_malloc(tls, int32(uint64(unsafe.Sizeof(WriteBuffer{}))+uint64(nBuf)))
	if pNew == uintptr(0) {
		libc.Xfprintf(tls, libc.X__stderrp, ts+27000 /* "out of memory in..." */, 0)
	}
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(WriteBuffer{}))+uint64(nBuf))
	(*WriteBuffer)(unsafe.Pointer(pNew)).FiOffset = iOffset
	(*WriteBuffer)(unsafe.Pointer(pNew)).FnBuf = nBuf
	(*WriteBuffer)(unsafe.Pointer(pNew)).FpFile = pFile
	if zBuf != 0 {
		(*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf = pNew + 1*40
		libc.Xmemcpy(tls, (*WriteBuffer)(unsafe.Pointer(pNew)).FzBuf, zBuf, uint64(nBuf))
	}

	if g.FpWriteList != 0 {

		(*WriteBuffer)(unsafe.Pointer(g.FpWriteListEnd)).FpNext = pNew
	} else {
		g.FpWriteList = pNew
	}
	g.FpWriteListEnd = pNew

	return SQLITE_OK
}

// Close a crash-file.
func cfClose(tls *libc.TLS, pFile uintptr) int32 { /* test6.c:399:12: */
	var pCrash uintptr = pFile
	writeListSync(tls, pCrash, 0)
	sqlite3.Xsqlite3OsClose(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FpRealFile)
	return SQLITE_OK
}

// Read data from a crash-file.
func cfRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test6.c:409:12: */
	var pCrash uintptr = pFile
	var nCopy int32 = func() int32 {
		if i64(iAmt) < (*CrashFile)(unsafe.Pointer(pCrash)).FiSize-iOfst {
			return int32(i64(iAmt))
		}
		return int32((*CrashFile)(unsafe.Pointer(pCrash)).FiSize - iOfst)
	}()

	if nCopy > 0 {
		libc.Xmemcpy(tls, zBuf, (*CrashFile)(unsafe.Pointer(pCrash)).FzData+uintptr(iOfst), uint64(nCopy))
	}

	// Check the file-size to see if this is a short-read
	if nCopy < iAmt {
		return SQLITE_IOERR | int32(2)<<8
	}

	return SQLITE_OK
}

// Write data to a crash-file.
func cfWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test6.c:433:12: */
	var pCrash uintptr = pFile
	if sqlite_int64(iAmt)+iOfst > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(sqlite_int64(iAmt) + iOfst))
	}
	for (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > i64((*CrashFile)(unsafe.Pointer(pCrash)).FnData) {
		var zNew uintptr
		var nNew int32 = (*CrashFile)(unsafe.Pointer(pCrash)).FnData*2 + 4096
		zNew = crash_realloc(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FzData, nNew)
		if !(zNew != 0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, zNew+uintptr((*CrashFile)(unsafe.Pointer(pCrash)).FnData), 0, uint64(nNew-(*CrashFile)(unsafe.Pointer(pCrash)).FnData))
		(*CrashFile)(unsafe.Pointer(pCrash)).FnData = nNew
		(*CrashFile)(unsafe.Pointer(pCrash)).FzData = zNew
	}
	libc.Xmemcpy(tls, (*CrashFile)(unsafe.Pointer(pCrash)).FzData+uintptr(iOfst), zBuf, uint64(iAmt))
	return writeListAppend(tls, pFile, iOfst, zBuf, iAmt)
}

// Truncate a crash-file.
func cfTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test6.c:461:12: */
	var pCrash uintptr = pFile

	if (*CrashFile)(unsafe.Pointer(pCrash)).FiSize > size {
		(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(size))
	}
	return writeListAppend(tls, pFile, size, uintptr(0), 0)
}

// Sync a crash-file.
func cfSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test6.c:473:12: */
	var pCrash uintptr = pFile
	var isCrash int32 = 0

	var zName uintptr = (*CrashFile)(unsafe.Pointer(pCrash)).FzName
	var zCrashFile uintptr = uintptr(unsafe.Pointer(&g)) + 28
	var nName int32 = int32(libc.Xstrlen(tls, zName))
	var nCrashFile int32 = int32(libc.Xstrlen(tls, zCrashFile))

	if nCrashFile > 0 && int32(*(*int8)(unsafe.Pointer(zCrashFile + uintptr(nCrashFile-1)))) == '*' {
		nCrashFile--
		if nName > nCrashFile {
			nName = nCrashFile
		}
	}

	if nName == nCrashFile && 0 == libc.Xmemcmp(tls, zName, zCrashFile, uint64(nName)) {
		if libc.PreDecInt32(&g.FiCrash, 1) == 0 {
			isCrash = 1
		}
	}

	return writeListSync(tls, pCrash, isCrash)
}

// Return the current file-size of the crash-file.
func cfFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test6.c:505:12: */
	var pCrash uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = (*CrashFile)(unsafe.Pointer(pCrash)).FiSize
	return SQLITE_OK
}

// Calls related to file-locks are passed on to the real file handle.
func cfLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test6.c:514:12: */
	return sqlite3.Xsqlite3OsLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}

func cfUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test6.c:517:12: */
	return sqlite3.Xsqlite3OsUnlock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, eLock)
}

func cfCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test6.c:520:12: */
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, pResOut)
}

func cfFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test6.c:523:12: */
	if op == SQLITE_FCNTL_SIZE_HINT {
		var pCrash uintptr = pFile
		var nByte i64 = *(*i64)(unsafe.Pointer(pArg))
		if nByte > (*CrashFile)(unsafe.Pointer(pCrash)).FiSize {
			if SQLITE_OK == writeListAppend(tls, pFile, nByte, uintptr(0), 0) {
				(*CrashFile)(unsafe.Pointer(pCrash)).FiSize = i64(int32(nByte))
			}
		}
		return SQLITE_OK
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile, op, pArg)
}

// The xSectorSize() and xDeviceCharacteristics() functions return
// the global values configured by the [sqlite_crashparams] tcl
//  interface.
func cfSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test6.c:542:12: */
	return g.FiSectorSize
}

func cfDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test6.c:545:12: */
	return g.FiDeviceCharacteristics
}

// Pass-throughs for WAL support.
func cfShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test6.c:552:12: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmLock})).f(tls, pReal, ofst, n, flags)
}

func cfShmBarrier(tls *libc.TLS, pFile uintptr) { /* test6.c:556:13: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmBarrier})).f(tls, pReal)
}

func cfShmUnmap(tls *libc.TLS, pFile uintptr, delFlag int32) int32 { /* test6.c:560:12: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmUnmap})).f(tls, pReal, delFlag)
}

func cfShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, sz int32, w int32, pp uintptr) int32 { /* test6.c:564:12: */
	var pReal uintptr = (*CrashFile)(unsafe.Pointer(pFile)).FpRealFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmMap})).f(tls, pReal, iRegion, sz, w, pp)
}

var CrashFileVtab = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test6.c:575:33 */

// Application data for the crash VFS
type crashAppData = struct{ FpOrig uintptr } /* test6.c:598:1 */

// Open a crash-file file handle.
//
// The caller will have allocated pVfs->szOsFile bytes of space
// at pFile. This file uses this space for the CrashFile structure
// and allocates space for the "real" file structure using
// sqlite3_malloc(). The assumption here is (pVfs->szOsFile) is
// equal or greater than sizeof(CrashFile).
func cfOpen(tls *libc.TLS, pCfVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test6.c:611:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	var rc int32
	var pWrapper uintptr = pFile
	var pReal uintptr = pWrapper + 1*56

	libc.Xmemset(tls, pWrapper, 0, uint64(unsafe.Sizeof(CrashFile{})))
	rc = sqlite3.Xsqlite3OsOpen(tls, pVfs, zName, pReal, flags, pOutFlags)

	if rc == SQLITE_OK {
		// var iSize i64 at bp, 8

		(*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod = uintptr(unsafe.Pointer(&CrashFileVtab))
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzName = zName
		(*CrashFile)(unsafe.Pointer(pWrapper)).FpRealFile = pReal
		rc = sqlite3.Xsqlite3OsFileSize(tls, pReal, bp /* &iSize */)
		(*CrashFile)(unsafe.Pointer(pWrapper)).FiSize = i64(int32(*(*i64)(unsafe.Pointer(bp /* iSize */))))
		(*CrashFile)(unsafe.Pointer(pWrapper)).Fflags = flags
	}
	if rc == SQLITE_OK {
		(*CrashFile)(unsafe.Pointer(pWrapper)).FnData = int32(int64(4096) + (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize)
		(*CrashFile)(unsafe.Pointer(pWrapper)).FzData = crash_malloc(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FnData)
		if (*CrashFile)(unsafe.Pointer(pWrapper)).FzData != 0 {
			// os_unix.c contains an assert() that fails if the caller attempts
			// to read data from the 512-byte locking region of a file opened
			// with the SQLITE_OPEN_MAIN_DB flag. This region of a database file
			// never contains valid data anyhow. So avoid doing such a read here.
			//
			// UPDATE: It also contains an assert() verifying that each call
			// to the xRead() method reads less than 128KB of data.
			var iOff i64

			libc.Xmemset(tls, (*CrashFile)(unsafe.Pointer(pWrapper)).FzData, 0, uint64((*CrashFile)(unsafe.Pointer(pWrapper)).FnData))
			for iOff = int64(0); iOff < (*CrashFile)(unsafe.Pointer(pWrapper)).FiSize; iOff = iOff + int64(512) {
				var nRead int32 = int32((*CrashFile)(unsafe.Pointer(pWrapper)).FiSize - iOff)
				if nRead > 512 {
					nRead = 512
				}
				rc = sqlite3.Xsqlite3OsRead(tls, pReal, (*CrashFile)(unsafe.Pointer(pWrapper)).FzData+uintptr(iOff), nRead, iOff)
			}
		} else {
			rc = SQLITE_NOMEM
		}
	}
	if rc != SQLITE_OK && (*CrashFile)(unsafe.Pointer(pWrapper)).FpMethod != 0 {
		sqlite3.Xsqlite3OsClose(tls, pFile)
	}
	return rc
}

func cfDelete(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test6.c:665:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDelete})).f(tls, pVfs, zPath, dirSync)
}

func cfAccess(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test6.c:669:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxAccess})).f(tls, pVfs, zPath, flags, pResOut)
}

func cfFullPathname(tls *libc.TLS, pCfVfs uintptr, zPath uintptr, nPathOut int32, zPathOut uintptr) int32 { /* test6.c:678:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxFullPathname})).f(tls, pVfs, zPath, nPathOut, zPathOut)
}

func cfDlOpen(tls *libc.TLS, pCfVfs uintptr, zPath uintptr) uintptr { /* test6.c:687:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlOpen})).f(tls, pVfs, zPath)
}

func cfDlError(tls *libc.TLS, pCfVfs uintptr, nByte int32, zErrMsg uintptr) { /* test6.c:691:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlError})).f(tls, pVfs, nByte, zErrMsg)
}

func cfDlSym(tls *libc.TLS, pCfVfs uintptr, pH uintptr, zSym uintptr) uintptr { /* test6.c:695:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlSym})).f(tls, pVfs, pH, zSym)
}

func cfDlClose(tls *libc.TLS, pCfVfs uintptr, pHandle uintptr) { /* test6.c:699:13: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxDlClose})).f(tls, pVfs, pHandle)
}

func cfRandomness(tls *libc.TLS, pCfVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test6.c:703:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxRandomness})).f(tls, pVfs, nByte, zBufOut)
}

func cfSleep(tls *libc.TLS, pCfVfs uintptr, nMicro int32) int32 { /* test6.c:707:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSleep})).f(tls, pVfs, nMicro)
}

func cfCurrentTime(tls *libc.TLS, pCfVfs uintptr, pTimeOut uintptr) int32 { /* test6.c:711:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxCurrentTime})).f(tls, pVfs, pTimeOut)
}

func cfGetLastError(tls *libc.TLS, pCfVfs uintptr, n int32, z uintptr) int32 { /* test6.c:715:12: */
	var pVfs uintptr = (*sqlite3_vfs)(unsafe.Pointer(pCfVfs)).FpAppData
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetLastError})).f(tls, pVfs, n, z)
}

func processDevSymArgs(tls *libc.TLS, interp uintptr, objc int32, objv uintptr, piDeviceChar uintptr, piSectorSize uintptr) int32 { /* test6.c:720:12: */
	bp := tls.Alloc(316)
	defer tls.Free(316)

	*(*[14]DeviceFlag)(unsafe.Pointer(bp + 88 /* aFlag */)) = [14]DeviceFlag{
		{FzName: ts + 27038 /* "atomic" */, FiValue: SQLITE_IOCAP_ATOMIC},
		{FzName: ts + 27045 /* "atomic512" */, FiValue: SQLITE_IOCAP_ATOMIC512},
		{FzName: ts + 27055 /* "atomic1k" */, FiValue: SQLITE_IOCAP_ATOMIC1K},
		{FzName: ts + 27064 /* "atomic2k" */, FiValue: SQLITE_IOCAP_ATOMIC2K},
		{FzName: ts + 27073 /* "atomic4k" */, FiValue: SQLITE_IOCAP_ATOMIC4K},
		{FzName: ts + 27082 /* "atomic8k" */, FiValue: SQLITE_IOCAP_ATOMIC8K},
		{FzName: ts + 27091 /* "atomic16k" */, FiValue: SQLITE_IOCAP_ATOMIC16K},
		{FzName: ts + 27101 /* "atomic32k" */, FiValue: SQLITE_IOCAP_ATOMIC32K},
		{FzName: ts + 27111 /* "atomic64k" */, FiValue: SQLITE_IOCAP_ATOMIC64K},
		{FzName: ts + 27121 /* "sequential" */, FiValue: SQLITE_IOCAP_SEQUENTIAL},
		{FzName: ts + 27132 /* "safe_append" */, FiValue: SQLITE_IOCAP_SAFE_APPEND},
		{FzName: ts + 27144 /* "powersafe_overwr..." */, FiValue: SQLITE_IOCAP_POWERSAFE_OVERWRITE},
		{FzName: ts + 27164 /* "batch-atomic" */, FiValue: SQLITE_IOCAP_BATCH_ATOMIC},
		{},
	}
	var i int32
	var iDc int32 = 0
	*(*int32)(unsafe.Pointer(bp + 68 /* iSectorSize */)) = 0
	var setSectorsize int32 = 0
	var setDeviceChar int32 = 0

	for i = 0; i < objc; i = i + 2 {
		// var nOpt int32 at bp+64, 4

		var zOpt uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp+64 /* &nOpt */)

		if (*(*int32)(unsafe.Pointer(bp + 64)) > 11 || *(*int32)(unsafe.Pointer(bp + 64)) < 2 || libc.Xstrncmp(tls, ts+27177, zOpt, uint64(*(*int32)(unsafe.Pointer(bp + 64)))) != 0) &&
			(*(*int32)(unsafe.Pointer(bp + 64)) > 16 || *(*int32)(unsafe.Pointer(bp + 64)) < 2 || libc.Xstrncmp(tls, ts+27189, zOpt, uint64(*(*int32)(unsafe.Pointer(bp + 64)))) != 0) {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+27206 /* "Bad option: \"" */, zOpt,
					ts+27220 /* "\" - must be \"-ch..." */, 0))
			return TCL_ERROR
		}
		if i == objc-1 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+27268 /* "Option requires ..." */, zOpt, ts+12784 /* "\"" */, 0))
			return TCL_ERROR
		}

		if int32(*(*int8)(unsafe.Pointer(zOpt + 1))) == 's' {
			if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+68) != 0 {
				return TCL_ERROR
			}
			setSectorsize = 1
		} else {
			var j int32
			// var apObj uintptr at bp+80, 8

			// var nObj int32 at bp+72, 4

			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+72, bp+80) != 0 {
				return TCL_ERROR
			}
			for j = 0; j < *(*int32)(unsafe.Pointer(bp + 72 /* nObj */)); j++ {
				var rc int32
				// var iChoice int32 at bp+312, 4

				var pFlag uintptr = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80 /* apObj */)) + uintptr(j)*8)))
				(*Tcl_Obj)(unsafe.Pointer(pFlag)).FrefCount++
				tcl.XTcl_UtfToLower(tls, tcl.XTcl_GetString(tls, pFlag))

				rc = tcl.XTcl_GetIndexFromObjStruct(tls,
					interp, pFlag, bp+88 /* &aFlag[0] */, int32(unsafe.Sizeof(DeviceFlag{})), ts+27299 /* "no such flag" */, 0, bp+312 /* &iChoice */)
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = pFlag
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				if rc != 0 {
					return TCL_ERROR
				}

				iDc = iDc | (*DeviceFlag)(unsafe.Pointer(bp+88+uintptr(*(*int32)(unsafe.Pointer(bp + 312)))*16)).FiValue
			}
			setDeviceChar = 1
		}
	}

	if setDeviceChar != 0 {
		*(*int32)(unsafe.Pointer(piDeviceChar)) = iDc
	}
	if setSectorsize != 0 {
		*(*int32)(unsafe.Pointer(piSectorSize)) = *(*int32)(unsafe.Pointer(bp + 68 /* iSectorSize */))
	}

	return TCL_OK
}

type DeviceFlag = struct {
	FzName       uintptr
	FiValue      int32
	F__ccgo_pad1 [4]byte
} /* test6.c:727:3 */

// tclcmd:   sqlite3_crash_now
//
// Simulate a crash immediately. This function does not return
// (writeListSync() calls exit(-1)).
func crashNowCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:820:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}
	writeListSync(tls, uintptr(0), 1)

	return TCL_OK
}

// tclcmd:   sqlite_crash_enable ENABLE ?DEFAULT?
//
// Parameter ENABLE must be a boolean value. If true, then the "crash"
// vfs is added to the system. If false, it is removed.
func crashEnableCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:841:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var isEnable int32 at bp, 4

	*(*int32)(unsafe.Pointer(bp + 4 /* isDefault */)) = 0

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+27312 /* "ENABLE ?DEFAULT?" */)
		return TCL_ERROR
	}

	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	if objc == 3 && tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp)) != 0 && crashVfs.FpAppData != 0 || !(*(*int32)(unsafe.Pointer(bp)) != 0) && !(int32(crashVfs.FpAppData) != 0) {
		return TCL_OK
	}

	if crashVfs.FpAppData == uintptr(0) {
		var pOriginalVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		crashVfs.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FmxPathname
		crashVfs.FpAppData = pOriginalVfs
		crashVfs.FszOsFile = int32(uint64(unsafe.Sizeof(CrashFile{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pOriginalVfs)).FszOsFile))
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&crashVfs)), *(*int32)(unsafe.Pointer(bp + 4 /* isDefault */)))
	} else {
		crashVfs.FpAppData = uintptr(0)
		sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&crashVfs)))
	}

	return TCL_OK
}

var crashVfs = sqlite3_vfs{
	FiVersion: 2,          // pNext
	FzName:    ts + 27329, /* "crash" */ // pAppData

	FxOpen:         0, // xOpen
	FxDelete:       0, // xDelete
	FxAccess:       0, // xAccess
	FxFullPathname: 0, // xFullPathname
	FxDlOpen:       0, // xDlOpen
	FxDlError:      0, // xDlError
	FxDlSym:        0, // xDlSym
	FxDlClose:      0, // xDlClose
	FxRandomness:   0, // xRandomness
	FxSleep:        0, // xSleep
	FxCurrentTime:  0, // xCurrentTime
	FxGetLastError: 0, // xCurrentTimeInt64
} /* test6.c:849:22 */

// tclcmd:   sqlite_crashparams ?OPTIONS? DELAY CRASHFILE
//
// This procedure implements a TCL command that enables crash testing
// in testfixture.  Once enabled, crash testing cannot be disabled.
//
// Available options are "-characteristics" and "-sectorsize". Both require
// an argument. For -sectorsize, this is the simulated sector size in
// bytes. For -characteristics, the argument must be a list of io-capability
// flags to simulate. Valid flags are "atomic", "atomic512", "atomic1K",
// "atomic2K", "atomic4K", "atomic8K", "atomic16K", "atomic32K",
// "atomic64K", "sequential" and "safe_append".
//
// Example:
//
//   sqlite_crashparams -sect 1024 -char {atomic sequential} ./test.db 1
//
func crashParamsObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:920:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var iDelay int32 at bp+36, 4

	var zCrashFile uintptr
	// var nCrashFile int32 at bp+32, 4

	// var iDc int32 at bp+40, 4

	// var iSectorSize int32 at bp+44, 4

	*(*int32)(unsafe.Pointer(bp + 40 /* iDc */)) = -1
	*(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */)) = -1

	if !(objc < 3) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+27335 /* "?OPTIONS? DELAY ..." */)
	goto error
__1:
	;

	zCrashFile = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-1)*8)), bp+32 /* &nCrashFile */)
	if !(uint64(*(*int32)(unsafe.Pointer(bp + 32))) >= uint64(unsafe.Sizeof([500]int8{}))) {
		goto __2
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+27361 /* "Filename is too ..." */, zCrashFile, ts+12784 /* "\"" */, 0))
	goto error
__2:
	;
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(objc-2)*8)), bp+36) != 0) {
		goto __3
	}
	goto error
__3:
	;

	if !(processDevSymArgs(tls, interp, objc-3, objv+1*8, bp+40, bp+44) != 0) {
		goto __4
	}
	return TCL_ERROR
__4:
	;

	if !(*(*int32)(unsafe.Pointer(bp + 40)) >= 0) {
		goto __5
	}
	g.FiDeviceCharacteristics = *(*int32)(unsafe.Pointer(bp + 40 /* iDc */))
__5:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 44)) >= 0) {
		goto __6
	}
	g.FiSectorSize = *(*int32)(unsafe.Pointer(bp + 44 /* iSectorSize */))
__6:
	;

	g.FiCrash = *(*int32)(unsafe.Pointer(bp + 36 /* iDelay */))
	libc.Xmemcpy(tls, uintptr(unsafe.Pointer(&g))+28, zCrashFile, uint64(*(*int32)(unsafe.Pointer(bp + 32))+1))
	sqlite3CrashTestEnable = 1
	return TCL_OK

error:
	return TCL_ERROR
}

func devSymObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:967:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp /* iDc */)) = -1
	*(*int32)(unsafe.Pointer(bp + 4 /* iSectorSize */)) = -1

	if processDevSymArgs(tls, interp, objc-1, objv+1*8, bp, bp+4) != 0 {
		return TCL_ERROR
	}
	devsym_register(tls, *(*int32)(unsafe.Pointer(bp /* iDc */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSectorSize */)))

	return TCL_OK
}

// tclcmd: sqlite3_crash_on_write N
func writeCrashObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:989:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* nWrite */)) = 0

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+27385 /* "NWRITE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}

	devsym_crash_on_write(tls, *(*int32)(unsafe.Pointer(bp /* nWrite */)))
	return TCL_OK
}

// tclcmd: unregister_devsim
func dsUnregisterObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1013:26: */

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	devsym_unregister(tls)
	return TCL_OK
}

// tclcmd: register_jt_vfs ?-default? PARENT-VFS
func jtObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1033:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var zParent uintptr = uintptr(0)

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+27392 /* "?-default? PAREN..." */)
		return TCL_ERROR
	}
	zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if objc == 3 {
		if libc.Xstrcmp(tls, zParent, ts+27414) != 0 {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+12690 /* "bad option \"" */, zParent, ts+27423 /* "\": must be -defa..." */, 0))
			return TCL_ERROR
		}
		zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	}

	if !(int32(*(*int8)(unsafe.Pointer(zParent))) != 0) {
		zParent = uintptr(0)
	}
	if jt_register(tls, zParent, libc.Bool32(objc == 3)) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+27443 /* "Error in jt_regi..." */, 0))
		return TCL_ERROR
	}

	return TCL_OK
}

// tclcmd: unregister_jt_vfs
func jtUnregisterObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test6.c:1071:26: */

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	jt_unregister(tls)
	return TCL_OK
}

// This procedure registers the TCL procedures defined in this file.
func Sqlitetest6_Init(tls *libc.TLS, interp uintptr) int32 { /* test6.c:1093:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27464 /* "sqlite3_crash_en..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashEnableCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27485 /* "sqlite3_crashpar..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashParamsObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27505 /* "sqlite3_crash_no..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{crashNowCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27523 /* "sqlite3_simulate..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{devSymObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27547 /* "sqlite3_crash_on..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{writeCrashObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27570 /* "unregister_devsi..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{dsUnregisterObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27588 /* "register_jt_vfs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtObjCmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+27604 /* "unregister_jt_vf..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{jtUnregisterObjCmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Each thread is controlled by an instance of the following
// structure.
type Thread1 = struct {
	FzFilename   uintptr
	FxOp         uintptr
	FzArg        uintptr
	Fopnum       int32
	Fbusy        int32
	Fcompleted   int32
	F__ccgo_pad1 [4]byte
	Fdb          uintptr
	FpStmt       uintptr
	FzErr        uintptr
	FzStaticErr  uintptr
	Frc          int32
	Fargc        int32
	Fargv        [100]uintptr
	Fcolv        [100]uintptr
	FnServer     int32
	F__ccgo_pad2 [4]byte
} /* test7.c:53:23 */

// There can be as many as 26 threads running at once.  Each is named
// by a capital letter: A, B, C, ..., Y, Z.
var threadset1 [26]Thread1 /* test7.c:90:15: */

// The main loop for a thread.  Threads use busy waiting.
func client_main(tls *libc.TLS, pArg uintptr) uintptr { /* test7.c:95:13: */
	var p uintptr = pArg
	if (*Thread1)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3_client_close(tls, (*Thread1)(unsafe.Pointer(p)).Fdb)
	}
	sqlite3_client_open(tls, (*Thread1)(unsafe.Pointer(p)).FzFilename, p+40)
	if SQLITE_OK != sqlite3.Xsqlite3_errcode(tls, (*Thread1)(unsafe.Pointer(p)).Fdb) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.Xstrdup(tls, sqlite3.Xsqlite3_errmsg(tls, (*Thread1)(unsafe.Pointer(p)).Fdb))
		sqlite3_client_close(tls, (*Thread1)(unsafe.Pointer(p)).Fdb)
		(*Thread1)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	(*Thread1)(unsafe.Pointer(p)).Fcompleted = 1
	for (*Thread1)(unsafe.Pointer(p)).Fopnum <= (*Thread1)(unsafe.Pointer(p)).Fcompleted {
		libc.Xsched_yield(tls)
	}
	for (*Thread1)(unsafe.Pointer(p)).FxOp != 0 {
		if (*Thread1)(unsafe.Pointer(p)).FzErr != 0 && (*Thread1)(unsafe.Pointer(p)).FzErr != (*Thread1)(unsafe.Pointer(p)).FzStaticErr {
			sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzErr)
			(*Thread1)(unsafe.Pointer(p)).FzErr = uintptr(0)
		}
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*Thread1)(unsafe.Pointer(p)).FxOp})).f(tls, p)
		(*Thread1)(unsafe.Pointer(p)).Fcompleted++
		for (*Thread1)(unsafe.Pointer(p)).Fopnum <= (*Thread1)(unsafe.Pointer(p)).Fcompleted {
			libc.Xsched_yield(tls)
		}
	}
	if (*Thread1)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3_client_finalize(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
		(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	if (*Thread1)(unsafe.Pointer(p)).Fdb != 0 {
		sqlite3_client_close(tls, (*Thread1)(unsafe.Pointer(p)).Fdb)
		(*Thread1)(unsafe.Pointer(p)).Fdb = uintptr(0)
	}
	if (*Thread1)(unsafe.Pointer(p)).FzErr != 0 && (*Thread1)(unsafe.Pointer(p)).FzErr != (*Thread1)(unsafe.Pointer(p)).FzStaticErr {
		sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzErr)
		(*Thread1)(unsafe.Pointer(p)).FzErr = uintptr(0)
	}
	(*Thread1)(unsafe.Pointer(p)).Fcompleted++
	sqlite3.Xsqlite3_thread_cleanup(tls)
	return uintptr(0)
}

// Get a thread ID which is an upper case letter.  Return the index.
// If the argument is not a valid thread ID put an error message in
// the interpreter and return -1.
func parse_client_id(tls *libc.TLS, interp uintptr, zArg uintptr) int32 { /* test7.c:142:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	if zArg == uintptr(0) || int32(*(*int8)(unsafe.Pointer(zArg))) == 0 || int32(*(*int8)(unsafe.Pointer(zArg + 1))) != 0 || !(__sbistype(tls, int32(uint8(*(*int8)(unsafe.Pointer(zArg)))), uint64(X_CTYPE_U)) != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+26376 /* "thread ID must b..." */, 0))
		return -1
	}
	return int32(*(*int8)(unsafe.Pointer(zArg))) - 'A'
}

// Usage:    client_create NAME  FILENAME
//
// NAME should be an upper case letter.  Start the thread running with
// an open connection to the given database.
func tcl_client_create(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:156:26: */
	bp := tls.Alloc(96)
	defer tls.Free(96)

	var i int32
	// var x pthread_t at bp+88, 8

	var rc int32

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26415 /* " ID FILENAME" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if threadset1[i].Fbusy != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26428 /* "thread " */, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+26436 /* " is already runn..." */, 0))
		return TCL_ERROR
	}
	threadset1[i].Fbusy = 1
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzFilename)
	threadset1[i].FzFilename = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	threadset1[i].Fopnum = 1
	threadset1[i].Fcompleted = 0
	rc = libc.Xpthread_create(tls, bp+88 /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{client_main})), uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	if rc != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+26456 /* "failed to create..." */, 0))
		sqlite3.Xsqlite3_free(tls, threadset1[i].FzFilename)
		threadset1[i].Fbusy = 0
		return TCL_ERROR
	}
	libc.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp + 88 /* x */)))
	if threadset1[i].FnServer == 0 {
		threadset1[i].FnServer = 1
		sqlite3_server_start2(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688+1680)
	}
	return TCL_OK
}

// Wait for a thread to reach its idle state.
func client_wait(tls *libc.TLS, p uintptr) { /* test7.c:200:13: */
	for (*Thread1)(unsafe.Pointer(p)).Fopnum > (*Thread1)(unsafe.Pointer(p)).Fcompleted {
		libc.Xsched_yield(tls)
	}
}

// Usage:  client_wait ID
//
// Wait on thread ID to reach its idle state.
func tcl_client_wait(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:209:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	return TCL_OK
}

// Stop a thread.
func stop_thread(tls *libc.TLS, p uintptr) { /* test7.c:235:13: */
	client_wait(tls, p)
	(*Thread1)(unsafe.Pointer(p)).FxOp = uintptr(0)
	(*Thread1)(unsafe.Pointer(p)).Fopnum++
	client_wait(tls, p)
	sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzArg)
	(*Thread1)(unsafe.Pointer(p)).FzArg = uintptr(0)
	sqlite3.Xsqlite3_free(tls, (*Thread1)(unsafe.Pointer(p)).FzFilename)
	(*Thread1)(unsafe.Pointer(p)).FzFilename = uintptr(0)
	(*Thread1)(unsafe.Pointer(p)).Fbusy = 0
}

// Usage:  client_halt ID
//
// Cause a client thread to shut itself down.  Wait for the shutdown to be
// completed.  If ID is "*" then stop all client threads.
func tcl_client_halt(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:253:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*8))))) == '*' && int32(*(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(argv + 1*8)) + 1))) == 0 {
		for i = 0; i < N_THREAD; i++ {
			if threadset1[i].Fbusy != 0 {
				stop_thread(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
			}
		}
	} else {
		i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		if i < 0 {
			return TCL_ERROR
		}
		if !(threadset1[i].Fbusy != 0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
			return TCL_ERROR
		}
		stop_thread(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	}

	// If no client threads are still running, also stop the server
	for i = 0; i < N_THREAD && threadset1[i].Fbusy == 0; i++ {
	}
	if i >= N_THREAD {
		sqlite3_server_stop(tls)
		for 1 != 0 {
			for i = 0; i < N_THREAD && threadset1[i].FnServer == 0; i++ {
			}
			if i == N_THREAD {
				break
			}
			libc.Xsched_yield(tls)
		}
	}
	return TCL_OK
}

// Usage: client_argc  ID
//
// Wait on the most recent client_step to complete, then return the
// number of columns in the result set.
func tcl_client_argc(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:301:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	var i int32
	// var zBuf [100]int8 at bp+72, 100

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+72 /* &zBuf[0] */, ts+1333 /* "%d" */, libc.VaList(bp+48, threadset1[i].Fargc))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+56, bp+72 /* &zBuf[0] */, 0))
	return TCL_OK
}

// Usage: client_argv  ID   N
//
// Wait on the most recent client_step to complete, then return the
// value of the N-th columns in the result set.
func tcl_client_argv(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:333:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26503 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+80) != 0 {
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 || *(*int32)(unsafe.Pointer(bp + 80)) >= threadset1[i].Fargc {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+26509 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*1688 + 80 + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*8)), 0))
	return TCL_OK
}

// Usage: client_colname  ID   N
//
// Wait on the most recent client_step to complete, then return the
// name of the N-th columns in the result set.
func tcl_client_colname(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:369:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var i int32
	// var n int32 at bp+80, 4

	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26503 /* " ID N" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	if tcl.XTcl_GetInt(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)), bp+80) != 0 {
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	if *(*int32)(unsafe.Pointer(bp + 80)) < 0 || *(*int32)(unsafe.Pointer(bp + 80)) >= threadset1[i].Fargc {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+26509 /* "column number ou..." */, 0))
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&threadset1)) + uintptr(i)*1688 + 880 + uintptr(*(*int32)(unsafe.Pointer(bp + 80 /* n */)))*8)), 0))
	return TCL_OK
}

// Usage: client_result  ID
//
// Wait on the most recent operation to complete, then return the
// result code from that operation.
func tcl_client_result(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:407:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var zName uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	zName = sqlite3.Xsqlite3ErrName(tls, threadset1[i].Frc)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, zName, 0))
	return TCL_OK
}

// Usage: client_error  ID
//
// Wait on the most recent operation to complete, then return the
// error string.
func tcl_client_error(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:439:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26484 /* " ID" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, threadset1[i].FzErr, 0))
	return TCL_OK
}

// This procedure runs in the thread to compile an SQL statement.
func do_compile1(tls *libc.TLS, p uintptr) { /* test7.c:466:13: */
	if (*Thread1)(unsafe.Pointer(p)).Fdb == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+64, ts+26536 /* "no database is o..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	if (*Thread1)(unsafe.Pointer(p)).FpStmt != 0 {
		sqlite3_client_finalize(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
		(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_prepare(tls, (*Thread1)(unsafe.Pointer(p)).Fdb, (*Thread1)(unsafe.Pointer(p)).FzArg, -1, p+48, uintptr(0))
}

// Usage: client_compile ID SQL
//
// Compile a new virtual machine.
func tcl_client_compile(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:484:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	var i int32
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26556 /* " ID SQL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_compile1}))
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzArg)
	threadset1[i].FzArg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+48, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	threadset1[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to step the virtual machine.
func do_step1(tls *libc.TLS, p uintptr) { /* test7.c:513:13: */
	var i int32
	if (*Thread1)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+64, ts+26564 /* "no virtual machi..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_step(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
	if (*Thread1)(unsafe.Pointer(p)).Frc == SQLITE_ROW {
		(*Thread1)(unsafe.Pointer(p)).Fargc = sqlite3.Xsqlite3_column_count(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
		for i = 0; i < sqlite3.Xsqlite3_data_count(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt); i++ {
			*(*uintptr)(unsafe.Pointer(p + 80 + uintptr(i)*8)) = sqlite3.Xsqlite3_column_text(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt, i)
		}
		for i = 0; i < (*Thread1)(unsafe.Pointer(p)).Fargc; i++ {
			*(*uintptr)(unsafe.Pointer(p + 880 + uintptr(i)*8)) = sqlite3.Xsqlite3_column_name(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt, i)
		}
	}
}

// Usage: client_step ID
//
// Advance the virtual machine by one step
func tcl_client_step(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:537:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26593 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_step1}))
	threadset1[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to finalize a virtual machine.
func do_finalize1(tls *libc.TLS, p uintptr) { /* test7.c:564:13: */
	if (*Thread1)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+64, ts+26564 /* "no virtual machi..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_finalize(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
	(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

// Usage: client_finalize ID
//
// Finalize the virtual machine.
func tcl_client_finalize(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:579:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26593 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_finalize1}))
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzArg)
	threadset1[i].FzArg = uintptr(0)
	threadset1[i].Fopnum++
	return TCL_OK
}

// This procedure runs in the thread to reset a virtual machine.
func do_reset(tls *libc.TLS, p uintptr) { /* test7.c:608:13: */
	if (*Thread1)(unsafe.Pointer(p)).FpStmt == uintptr(0) {
		(*Thread1)(unsafe.Pointer(p)).FzErr = libc.AssignPtrUintptr(p+64, ts+26564 /* "no virtual machi..." */)
		(*Thread1)(unsafe.Pointer(p)).Frc = SQLITE_ERROR
		return
	}
	(*Thread1)(unsafe.Pointer(p)).Frc = sqlite3_client_reset(tls, (*Thread1)(unsafe.Pointer(p)).FpStmt)
	(*Thread1)(unsafe.Pointer(p)).FpStmt = uintptr(0)
}

// Usage: client_reset ID
//
// Finalize the virtual machine.
func tcl_client_reset(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:623:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var i int32
	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26593 /* " IDL" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	threadset1[i].FxOp = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{do_reset}))
	sqlite3.Xsqlite3_free(tls, threadset1[i].FzArg)
	threadset1[i].FzArg = uintptr(0)
	threadset1[i].Fopnum++
	return TCL_OK
}

// Usage: client_swap ID ID
//
// Interchange the sqlite* pointer between two threads.
func tcl_client_swap(tls *libc.TLS, NotUsed uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test7.c:654:26: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var i int32
	var j int32
	var temp uintptr
	if argc != 3 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+26598 /* " ID1 ID2" */, 0))
		return TCL_ERROR
	}
	i = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if i < 0 {
		return TCL_ERROR
	}
	if !(threadset1[i].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(i)*1688)
	j = parse_client_id(tls, interp, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
	if j < 0 {
		return TCL_ERROR
	}
	if !(threadset1[j].Fbusy != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+26488 /* "no such thread" */, 0))
		return TCL_ERROR
	}
	client_wait(tls, uintptr(unsafe.Pointer(&threadset1))+uintptr(j)*1688)
	temp = threadset1[i].Fdb
	threadset1[i].Fdb = threadset1[j].Fdb
	threadset1[j].Fdb = temp
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest7_Init(tls *libc.TLS, interp uintptr) int32 { /* test7.c:690:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd6))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateCommand(tls, interp, aCmd6[i].FzName, aCmd6[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aCmd6 = [13]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 27622 /* "client_create" */, FxProc: 0},
	{FzName: ts + 27636 /* "client_wait" */, FxProc: 0},
	{FzName: ts + 27648 /* "client_halt" */, FxProc: 0},
	{FzName: ts + 27660 /* "client_argc" */, FxProc: 0},
	{FzName: ts + 27672 /* "client_argv" */, FxProc: 0},
	{FzName: ts + 27684 /* "client_colname" */, FxProc: 0},
	{FzName: ts + 27699 /* "client_result" */, FxProc: 0},
	{FzName: ts + 27713 /* "client_error" */, FxProc: 0},
	{FzName: ts + 27726 /* "client_compile" */, FxProc: 0},
	{FzName: ts + 27741 /* "client_step" */, FxProc: 0},
	{FzName: ts + 27753 /* "client_reset" */, FxProc: 0},
	{FzName: ts + 27766 /* "client_finalize" */, FxProc: 0},
	{FzName: ts + 27782 /* "client_swap" */, FxProc: 0},
} /* test7.c:694:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

type echo_vtab1 = struct {
	Fbase          sqlite3_vtab
	Finterp        uintptr
	Fdb            uintptr
	FisPattern     int32
	FinTransaction int32
	FzThis         uintptr
	FzTableName    uintptr
	FzLogName      uintptr
	FnCol          int32
	F__ccgo_pad1   [4]byte
	FaIndex        uintptr
	FaCol          uintptr
} /* test8.c:27:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

type echo_vtab = echo_vtab1 /* test8.c:27:26 */
type echo_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
} /* test8.c:28:9 */

type echo_cursor = echo_cursor1 /* test8.c:28:28 */

func simulateVtabError(tls *libc.TLS, p uintptr, zMethod uintptr) int32 { /* test8.c:97:12: */
	bp := tls.Alloc(152)
	defer tls.Free(152)

	var zErr uintptr
	// var zVarname [128]int8 at bp+24, 128

	*(*int8)(unsafe.Pointer(bp + 24 /* &zVarname[0] */ + 127)) = int8(0)
	sqlite3.Xsqlite3_snprintf(tls, 127, bp+24 /* &zVarname[0] */, ts+27794 /* "echo_module_fail..." */, libc.VaList(bp, zMethod, (*echo_vtab)(unsafe.Pointer(p)).FzTableName))
	zErr = tcl.XTcl_GetVar2(tls, (*echo_vtab)(unsafe.Pointer(p)).Finterp, bp+24 /* &zVarname[0] */, uintptr(0), TCL_GLOBAL_ONLY)
	if zErr != 0 {
		(*echo_vtab)(unsafe.Pointer(p)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+27818 /* "echo-vtab-error:..." */, libc.VaList(bp+16, zErr))
	}
	return libc.Bool32(zErr != uintptr(0))
}

// Convert an SQL-style quoted string into a normal string by removing
// the quote characters.  The conversion is done in-place.  If the
// input does not begin with a quote character, then this routine
// is a no-op.
//
// Examples:
//
//     "abc"   becomes   abc
//     'xyz'   becomes   xyz
//     [pqr]   becomes   pqr
//     `mno`   becomes   mno
func dequoteString(tls *libc.TLS, z uintptr) { /* test8.c:122:13: */
	var quote int32
	var i int32
	var j int32
	if z == uintptr(0) {
		return
	}
	quote = int32(*(*int8)(unsafe.Pointer(z)))
	switch quote {
	case '\'':
		break
	case '"':
		break
	case '`':
		break // For MySQL compatibility
	case '[':
		quote = ']'
		break // For MS SqlServer compatibility
	default:
		return
	}
	i = 1
	j = 0
	for ; *(*int8)(unsafe.Pointer(z + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == quote {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(i+1)))) == quote {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(quote)
				i++
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = int8(0)
				break
			}
		} else {
			*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&j, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(i)))
		}
	}
}

// Retrieve the column names for the table named zTab via database
// connection db. SQLITE_OK is returned on success, or an sqlite error
// code otherwise.
//
// If successful, the number of columns is written to *pnCol. *paCol is
// set to point at sqlite3_malloc()'d space containing the array of
// nCol column names. The caller is responsible for calling sqlite3_free
// on *paCol.
func getColumnNames(tls *libc.TLS, db uintptr, zTab uintptr, paCol uintptr, pnCol uintptr) int32 { /* test8.c:159:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var aCol uintptr
	var zSql uintptr
	// var pStmt uintptr at bp+16, 8

	var rc int32
	var nCol int32
	var zName uintptr
	var ii int32
	var nBytes int32
	var zSpace uintptr
	aCol = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) = uintptr(0)
	rc = SQLITE_OK
	nCol = 0

	// Prepare the statement "SELECT * FROM <tbl>". The column names
	// of the result set of the compiled SELECT will be the same as
	// the column names of table <tbl>.
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+27838 /* "SELECT * FROM %Q" */, libc.VaList(bp, zTab))
	if !!(zSql != 0) {
		goto __1
	}
	rc = SQLITE_NOMEM
	goto out
__1:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	if !(rc == SQLITE_OK) {
		goto __2
	}
	nCol = sqlite3.Xsqlite3_column_count(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))

	// Figure out how much space to allocate for the array of column names
	// (including space for the strings themselves). Then allocate it.
	nBytes = int32(uint64(unsafe.Sizeof(uintptr(0))) * uint64(nCol))
	ii = 0
__3:
	if !(ii < nCol) {
		goto __5
	}
	zName = sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), ii)
	if !!(zName != 0) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto out
__6:
	;
	nBytes = nBytes + (int32(libc.Xstrlen(tls, zName)) + 1)
	goto __4
__4:
	ii++
	goto __3
	goto __5
__5:
	;
	aCol = sqlite3.Xsqlite3MallocZero(tls, uint64(nBytes))
	if !!(aCol != 0) {
		goto __7
	}
	rc = SQLITE_NOMEM
	goto out
__7:
	;

	// Copy the column names into the allocated space and set up the
	// pointers in the aCol[] array.
	zSpace = aCol + uintptr(nCol)*8
	ii = 0
__8:
	if !(ii < nCol) {
		goto __10
	}
	*(*uintptr)(unsafe.Pointer(aCol + uintptr(ii)*8)) = zSpace
	sqlite3.Xsqlite3_snprintf(tls, nBytes, zSpace, ts /* "%s" */, libc.VaList(bp+8, sqlite3.Xsqlite3_column_name(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), ii)))
	zSpace += uintptr(int32(libc.Xstrlen(tls, zSpace)) + 1)
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;

__2:
	;

	*(*uintptr)(unsafe.Pointer(paCol)) = aCol
	*(*int32)(unsafe.Pointer(pnCol)) = nCol

out:
	sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))
	return rc
}

// Parameter zTab is the name of a table in database db with nCol
// columns. This function allocates an array of integers nCol in
// size and populates it according to any implicit or explicit
// indices on table zTab.
//
// If successful, SQLITE_OK is returned and *paIndex set to point
// at the allocated array. Otherwise, an error code is returned.
//
// See comments associated with the member variable aIndex above
// "struct echo_vtab" for details of the contents of the array.
func getIndexArray(tls *libc.TLS, db uintptr, zTab uintptr, nCol int32, paIndex uintptr) int32 { /* test8.c:239:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var pStmt uintptr at bp+16, 8

	var aIndex uintptr
	var rc int32
	var zSql uintptr
	var cid int32
	var zIdx uintptr
	// var pStmt2 uintptr at bp+24, 8

	var rc2 int32
	*(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)) = uintptr(0)
	aIndex = uintptr(0)

	// Allocate space for the index array
	aIndex = sqlite3.Xsqlite3MallocZero(tls, uint64(uint64(unsafe.Sizeof(int32(0)))*uint64(nCol)))
	if !!(aIndex != 0) {
		goto __1
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__1:
	;

	// Compile an sqlite pragma to loop through all indices on table zTab
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+27855 /* "PRAGMA index_lis..." */, libc.VaList(bp, zTab))
	if !!(zSql != 0) {
		goto __2
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__2:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+16 /* &pStmt */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)

	// For each index, figure out the left-most column and set the
	// corresponding entry in aIndex[] to 1.
__3:
	if !(*(*uintptr)(unsafe.Pointer(bp + 16)) != 0 && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 16))) == SQLITE_ROW) {
		goto __4
	}
	zIdx = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)), 1)
	*(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)) = uintptr(0)
	if !(zIdx == uintptr(0)) {
		goto __5
	}
	goto __3
__5:
	;
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+27877 /* "PRAGMA index_inf..." */, libc.VaList(bp+8, zIdx))
	if !!(zSql != 0) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto get_index_array_out
__6:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, db, zSql, -1, bp+24 /* &pStmt2 */, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) != 0 && sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 24))) == SQLITE_ROW) {
		goto __7
	}
	cid = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)), 1)

	*(*int32)(unsafe.Pointer(aIndex + uintptr(cid)*4)) = 1
__7:
	;
	if !(*(*uintptr)(unsafe.Pointer(bp + 24)) != 0) {
		goto __8
	}
	rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pStmt2 */)))
__8:
	;
	if !(rc != SQLITE_OK) {
		goto __9
	}
	goto get_index_array_out
__9:
	;
	goto __3
__4:
	;

get_index_array_out:
	if !(*(*uintptr)(unsafe.Pointer(bp + 16)) != 0) {
		goto __10
	}
	rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pStmt */)))
	if !(rc == SQLITE_OK) {
		goto __11
	}
	rc = rc2
__11:
	;
__10:
	;
	if !(rc != SQLITE_OK) {
		goto __12
	}
	sqlite3.Xsqlite3_free(tls, aIndex)
	aIndex = uintptr(0)
__12:
	;
	*(*uintptr)(unsafe.Pointer(paIndex)) = aIndex
	return rc
}

// Global Tcl variable $echo_module is a list. This routine appends
// the string element zArg to that list in interpreter interp.
func appendToEchoModule(tls *libc.TLS, interp uintptr, zArg uintptr) { /* test8.c:313:13: */
	var flags int32 = TCL_APPEND_VALUE | TCL_LIST_ELEMENT | TCL_GLOBAL_ONLY
	tcl.XTcl_SetVar2(tls, interp, ts+27899 /* "echo_module" */, uintptr(0), func() uintptr {
		if zArg != 0 {
			return zArg
		}
		return ts + 584
	}(), flags)
}

// This function is called from within the echo-modules xCreate and
// xConnect methods. The argc and argv arguments are copies of those
// passed to the calling method. This function is responsible for
// calling sqlite3_declare_vtab() to declare the schema of the virtual
// table being created or connected.
//
// If the constructor was passed just one argument, i.e.:
//
//   CREATE TABLE t1 AS echo(t2);
//
// Then t2 is assumed to be the name of a *real* database table. The
// schema of the virtual table is declared by passing a copy of the
// CREATE TABLE statement for the real table to sqlite3_declare_vtab().
// Hence, the virtual table should have exactly the same column names and
// types as the real table.
func echoDeclareVtab(tls *libc.TLS, pVtab uintptr, db uintptr) int32 { /* test8.c:335:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK

	if (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0 {
		*(*uintptr)(unsafe.Pointer(bp /* pStmt */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_prepare(tls, db,
			ts+27911, /* "SELECT sql FROM ..." */
			-1, bp /* &pStmt */, uintptr(0))
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_bind_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 1, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, -1, uintptr(0))
			if sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp))) == SQLITE_ROW {
				var rc2 int32
				var zCreateTable uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
				rc = sqlite3.Xsqlite3_declare_vtab(tls, db, zCreateTable)
				rc2 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				if rc == SQLITE_OK {
					rc = rc2
				}
			} else {
				rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
				if rc == SQLITE_OK {
					rc = SQLITE_ERROR
				}
			}
			if rc == SQLITE_OK {
				rc = getColumnNames(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, pVtab+88, pVtab+72)
			}
			if rc == SQLITE_OK {
				rc = getIndexArray(tls, db, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName, (*echo_vtab)(unsafe.Pointer(pVtab)).FnCol, pVtab+80)
			}
		}
	}

	return rc
}

// This function frees all runtime structures associated with the virtual
// table pVtab.
func echoDestructor(tls *libc.TLS, pVtab uintptr) int32 { /* test8.c:378:12: */
	var p uintptr = pVtab
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaIndex)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FaCol)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzTableName)
	sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(p)).FzLogName)
	sqlite3.Xsqlite3_free(tls, p)
	return 0
}

type EchoModule1 = struct {
	Finterp uintptr
	Fdb     uintptr
} /* test8.c:389:9 */

type EchoModule = EchoModule1 /* test8.c:389:27 */

// This function is called to do the work of the xConnect() method -
// to allocate the required in-memory structures for a newly connected
// virtual table.
func echoConstructor(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:400:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var i int32
	var pVtab uintptr

	// Allocate the sqlite3_vtab/echo_vtab structure itself
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_vtab{})))
	if !(pVtab != 0) {
		return SQLITE_NOMEM
	}
	(*echo_vtab)(unsafe.Pointer(pVtab)).Finterp = (*EchoModule)(unsafe.Pointer(pAux)).Finterp
	(*echo_vtab)(unsafe.Pointer(pVtab)).Fdb = db

	// Allocate echo_vtab.zThis
	(*echo_vtab)(unsafe.Pointer(pVtab)).FzThis = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 2*8))))
	if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzThis) != 0) {
		echoDestructor(tls, pVtab)
		return SQLITE_NOMEM
	}

	// Allocate echo_vtab.zTableName
	if argc > 3 {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, *(*uintptr)(unsafe.Pointer(argv + 3*8))))
		dequoteString(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
		if (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName != 0 && int32(*(*int8)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))) == '*' {
			var z uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+27975 /* "%s%s" */, libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(argv + 2*8)), (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName+1))
			sqlite3.Xsqlite3_free(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName)
			(*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName = z
			(*echo_vtab)(unsafe.Pointer(pVtab)).FisPattern = 1
		}
		if !(int32((*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) != 0) {
			echoDestructor(tls, pVtab)
			return SQLITE_NOMEM
		}
	}

	// Log the arguments to this function to Tcl var ::echo_module
	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}

	// Invoke sqlite3_declare_vtab and set up other members of the echo_vtab
	// structure. If an error occurs, delete the sqlite3_vtab structure and
	// return an error code.
	rc = echoDeclareVtab(tls, pVtab, db)
	if rc != SQLITE_OK {
		echoDestructor(tls, pVtab)
		return rc
	}

	// Success. Set *ppVtab and return
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return SQLITE_OK
}

// Echo virtual table module xCreate method.
func echoCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:465:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+27980 /* "xCreate" */)
	rc = echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)

	// If there were two arguments passed to the module at the SQL level
	// (i.e. "CREATE VIRTUAL TABLE tbl USING echo(arg1, arg2)"), then
	// the second argument is used as a table name. Attempt to create
	// such a table with a single column, "logmsg". This table will
	// be used to log calls to the xUpdate method. It will be deleted
	// when the virtual table is DROPed.
	//
	// Note: The main point of this is to test that we can drop tables
	// from within an xDestroy method call.
	if rc == SQLITE_OK && argc == 5 {
		var zSql uintptr
		var pVtab uintptr = *(*uintptr)(unsafe.Pointer(ppVtab))
		(*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 4*8))))
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+27988 /* "CREATE TABLE %Q(..." */, libc.VaList(bp+8, (*echo_vtab)(unsafe.Pointer(pVtab)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
		if rc != SQLITE_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, sqlite3.Xsqlite3_errmsg(tls, db)))
		}
	}

	if *(*uintptr)(unsafe.Pointer(ppVtab)) != 0 && rc != SQLITE_OK {
		echoDestructor(tls, *(*uintptr)(unsafe.Pointer(ppVtab)))
		*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	}

	if rc == SQLITE_OK {
		(*echo_vtab)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(ppVtab)))).FinTransaction = 1
	}

	return rc
}

// Echo virtual table module xConnect method.
func echoConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test8.c:513:12: */
	appendToEchoModule(tls, (*EchoModule)(unsafe.Pointer(pAux)).Finterp, ts+28012 /* "xConnect" */)
	return echoConstructor(tls, db, pAux, argc, argv, ppVtab, pzErr)
}

// Echo virtual table module xDisconnect method.
func echoDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test8.c:527:12: */
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+28021 /* "xDisconnect" */)
	return echoDestructor(tls, pVtab)
}

// Echo virtual table module xDestroy method.
func echoDestroy(tls *libc.TLS, pVtab uintptr) int32 { /* test8.c:535:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = SQLITE_OK
	var p uintptr = pVtab
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+28033 /* "xDestroy" */)

	// Drop the "log" table, if one exists (see echoCreate() for details)
	if p != 0 && (*echo_vtab)(unsafe.Pointer(p)).FzLogName != 0 {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+28042 /* "DROP TABLE %Q" */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzLogName))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	if rc == SQLITE_OK {
		rc = echoDestructor(tls, pVtab)
	}
	return rc
}

// Echo virtual table module xOpen method.
func echoOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test8.c:557:12: */
	var pCur uintptr
	if simulateVtabError(tls, pVTab, ts+28056) != 0 {
		return SQLITE_ERROR
	}
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(echo_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return func() int32 {
		if pCur != 0 {
			return SQLITE_OK
		}
		return SQLITE_NOMEM
	}()
}

// Echo virtual table module xClose method.
func echoClose(tls *libc.TLS, cur uintptr) int32 { /* test8.c:570:12: */
	var rc int32
	var pCur uintptr = cur
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
	sqlite3.Xsqlite3_free(tls, pCur)
	rc = sqlite3.Xsqlite3_finalize(tls, pStmt)
	return rc
}

// Return non-zero if the cursor does not currently point to a valid record
// (i.e if the scan has finished), or zero otherwise.
func echoEof(tls *libc.TLS, cur uintptr) int32 { /* test8.c:584:12: */
	return func() int32 {
		if (*echo_cursor)(unsafe.Pointer(cur)).FpStmt != 0 {
			return 0
		}
		return 1
	}()
}

// Echo virtual table module xNext method.
func echoNext(tls *libc.TLS, cur uintptr) int32 { /* test8.c:591:12: */
	var rc int32 = SQLITE_OK
	var pCur uintptr = cur

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+28062) != 0 {
		return SQLITE_ERROR
	}

	if (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt != 0 {
		rc = sqlite3.Xsqlite3_step(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
		if rc == SQLITE_ROW {
			rc = SQLITE_OK
		} else {
			rc = sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
			(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)
		}
	}

	return rc
}

// Echo virtual table module xColumn method.
func echoColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test8.c:615:12: */
	var iCol int32 = i + 1
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+28068) != 0 {
		return SQLITE_ERROR
	}

	if !(pStmt != 0) {
		sqlite3.Xsqlite3_result_null(tls, ctx)
	} else {

		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, pStmt, iCol))
	}
	return SQLITE_OK
}

// Echo virtual table module xRowid method.
func echoRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test8.c:635:12: */
	var pStmt uintptr = (*echo_cursor)(unsafe.Pointer(cur)).FpStmt

	if simulateVtabError(tls, (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab, ts+2304) != 0 {
		return SQLITE_ERROR
	}

	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, pStmt, 0)
	return SQLITE_OK
}

// Compute a simple hash of the null terminated string zString.
//
// This module uses only sqlite3_index_info.idxStr, not
// sqlite3_index_info.idxNum. So to test idxNum, when idxStr is set
// in echoBestIndex(), idxNum is set to the corresponding hash value.
// In echoFilter(), code assert()s that the supplied idxNum value is
// indeed the hash of the supplied idxStr.
func hashString(tls *libc.TLS, zString uintptr) int32 { /* test8.c:655:12: */
	var val u32 = u32(0)
	var ii int32
	for ii = 0; *(*int8)(unsafe.Pointer(zString + uintptr(ii))) != 0; ii++ {
		val = val<<3 + u32(int32(*(*int8)(unsafe.Pointer(zString + uintptr(ii)))))
	}
	return int32(val & u32(0x7fffffff))
}

// Echo virtual table module xFilter method.
func echoFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test8.c:667:12: */
	var rc int32
	var i int32

	var pCur uintptr = pVtabCursor
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb

	if simulateVtabError(tls, pVtab, ts+28076) != 0 {
		return SQLITE_ERROR
	}

	// Check that idxNum matches idxStr

	// Log arguments to the ::echo_module Tcl variable
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+28076 /* "xFilter" */)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, idxStr)
	for i = 0; i < argc; i++ {
		appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))))
	}

	sqlite3.Xsqlite3_finalize(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt)
	(*echo_cursor)(unsafe.Pointer(pCur)).FpStmt = uintptr(0)

	// Prepare the SQL statement created by echoBestIndex and bind the
	// runtime parameters passed to this function to it.
	rc = sqlite3.Xsqlite3_prepare(tls, db, idxStr, -1, pCur+8, uintptr(0))

	for i = 0; rc == SQLITE_OK && i < argc; i++ {
		rc = sqlite3.Xsqlite3_bind_value(tls, (*echo_cursor)(unsafe.Pointer(pCur)).FpStmt, i+1, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
	}

	// If everything was successful, advance to the first row of the scan
	if rc == SQLITE_OK {
		rc = echoNext(tls, pVtabCursor)
	}

	return rc
}

// A helper function used by echoUpdate() and echoBestIndex() for
// manipulating strings in concert with the sqlite3_mprintf() function.
//
// Parameter pzStr points to a pointer to a string allocated with
// sqlite3_mprintf. The second parameter, zAppend, points to another
// string. The two strings are concatenated together and *pzStr
// set to point at the result. The initial buffer pointed to by *pzStr
// is deallocated via sqlite3_free().
//
// If the third argument, doFree, is true, then sqlite3_free() is
// also called to free the buffer pointed to by zAppend.
func string_concat(tls *libc.TLS, pzStr uintptr, zAppend uintptr, doFree int32, pRc uintptr) { /* test8.c:727:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zIn uintptr = *(*uintptr)(unsafe.Pointer(pzStr))
	if !(zAppend != 0) && doFree != 0 && *(*int32)(unsafe.Pointer(pRc)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
	}
	if *(*int32)(unsafe.Pointer(pRc)) != SQLITE_OK {
		sqlite3.Xsqlite3_free(tls, zIn)
		zIn = uintptr(0)
	} else {
		if zIn != 0 {
			var zTemp uintptr = zIn
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts+27975 /* "%s%s" */, libc.VaList(bp, zIn, zAppend))
			sqlite3.Xsqlite3_free(tls, zTemp)
		} else {
			zIn = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, zAppend))
		}
		if !(zIn != 0) {
			*(*int32)(unsafe.Pointer(pRc)) = SQLITE_NOMEM
		}
	}
	*(*uintptr)(unsafe.Pointer(pzStr)) = zIn
	if doFree != 0 {
		sqlite3.Xsqlite3_free(tls, zAppend)
	}
}

// This function returns a pointer to an sqlite3_malloc()ed buffer
// containing the select-list (the thing between keywords SELECT and FROM)
// to query the underlying real table with for the scan described by
// argument pIdxInfo.
//
// If the current SQLite version is earlier than 3.10.0, this is just "*"
// (select all columns). Or, for version 3.10.0 and greater, the list of
// columns identified by the pIdxInfo->colUsed mask.
func echoSelectList(tls *libc.TLS, pTab uintptr, pIdxInfo uintptr) uintptr { /* test8.c:763:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var zRet uintptr = uintptr(0)
	if sqlite3.Xsqlite3_libversion_number(tls) < 3010000 {
		zRet = sqlite3.Xsqlite3_mprintf(tls, ts+28084 /* ", *" */, 0)
	} else {
		var i int32
		for i = 0; i < (*echo_vtab)(unsafe.Pointer(pTab)).FnCol; i++ {
			if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed&(sqlite3_uint64(uint64(1))<<func() int32 {
				if i >= 63 {
					return 63
				}
				return i
			}()) != 0 {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+28088 /* "%z, %s" */, libc.VaList(bp, zRet, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pTab)).FaCol + uintptr(i)*8))))
			} else {
				zRet = sqlite3.Xsqlite3_mprintf(tls, ts+28095 /* "%z, NULL" */, libc.VaList(bp+16, zRet))
			}
			if !(zRet != 0) {
				break
			}
		}
	}
	return zRet
}

// The echo module implements the subset of query constraints and sort
// orders that may take advantage of SQLite indices on the underlying
// real table. For example, if the real table is declared as:
//
//     CREATE TABLE real(a, b, c);
//     CREATE INDEX real_index ON real(b);
//
// then the echo module handles WHERE or ORDER BY clauses that refer
// to the column "b", but not "a" or "c". If a multi-column index is
// present, only its left most column is considered.
//
// This xBestIndex method encodes the proposed search strategy as
// an SQL query on the real table underlying the virtual echo module
// table and stores the query in sqlite3_index_info.idxStr. The SQL
// statement is of the form:
//
//   SELECT rowid, * FROM <real-table> ?<where-clause>? ?<order-by-clause>?
//
// where the <where-clause> and <order-by-clause> are determined
// by the contents of the structure pointed to by the pIdxInfo argument.
func echoBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test8.c:803:12: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	var ii int32
	*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) = uintptr(0)
	var zCol uintptr = uintptr(0)
	var zNew uintptr
	var nArg int32 = 0
	var zSep uintptr = ts + 9035 /* "WHERE" */
	var pVtab uintptr = tab
	*(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)) = uintptr(0)
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp

	var nRow int32 = 0
	var useIdx int32 = 0
	*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = SQLITE_OK
	var useCost int32 = 0
	var cost float64 = float64(0)
	var isIgnoreUsable int32 = 0
	if tcl.XTcl_GetVar2(tls, interp, ts+28104, uintptr(0), TCL_GLOBAL_ONLY) != 0 {
		isIgnoreUsable = 1
	}

	if simulateVtabError(tls, pVtab, ts+28130) != 0 {
		return SQLITE_ERROR
	}

	// Determine the number of rows in the table and store this value in local
	// variable nRow. The 'estimated-cost' of the scan will be the number of
	// rows in the table for a linear scan, or the log (base 2) of the
	// number of rows if the proposed scan uses an index.
	if tcl.XTcl_GetVar2(tls, interp, ts+28141, uintptr(0), TCL_GLOBAL_ONLY) != 0 {
		cost = libc.Xatof(tls, tcl.XTcl_GetVar2(tls, interp, ts+28141 /* "echo_module_cost" */, uintptr(0), TCL_GLOBAL_ONLY))
		useCost = 1
	} else {
		*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) = sqlite3.Xsqlite3_mprintf(tls, ts+28158 /* "SELECT count(*) ..." */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 88)) != 0) {
			return SQLITE_NOMEM
		}
		*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = sqlite3.Xsqlite3_prepare(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)), -1, bp+80 /* &pStmt */, uintptr(0))
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)))
		if *(*int32)(unsafe.Pointer(bp + 96)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
		}
		sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
		nRow = sqlite3.Xsqlite3_column_int(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)), 0)
		*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pStmt */)))
		if *(*int32)(unsafe.Pointer(bp + 96)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
		}
	}

	zCol = echoSelectList(tls, pVtab, pIdxInfo)
	if !(zCol != 0) {
		return SQLITE_NOMEM
	}
	*(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)) = sqlite3.Xsqlite3_mprintf(tls, ts+28182 /* "SELECT rowid%z F..." */, libc.VaList(bp+8, zCol, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if !(*(*uintptr)(unsafe.Pointer(bp + 88)) != 0) {
		return SQLITE_NOMEM
	}

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pConstraint uintptr
		var pUsage uintptr
		var iCol int32

		pConstraint = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8

		if !(isIgnoreUsable != 0) && !(int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fusable) != 0) {
			continue
		}

		iCol = (*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).FiColumn
		if iCol < 0 || *(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr(iCol)*4)) != 0 {
			var zNewCol uintptr
			if iCol >= 0 {
				zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*8))
			} else {
				zNewCol = ts + 28205 /* "rowid" */
			}
			var zOp uintptr = uintptr(0)
			useIdx = 1
			switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pConstraint)).Fop) {
			case SQLITE_INDEX_CONSTRAINT_EQ:
				zOp = ts + 28211 /* "=" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LT:
				zOp = ts + 28213 /* "<" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GT:
				zOp = ts + 28215 /* ">" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LE:
				zOp = ts + 28217 /* "<=" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GE:
				zOp = ts + 28220 /* ">=" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_MATCH:
				// Purposely translate the MATCH operator into a LIKE, which
				// will be used by the next block of code to construct a new
				// query.  It should also be noted here that the next block
				// of code requires the first letter of this operator to be
				// in upper-case to trigger the special MATCH handling (i.e.
				// wrapping the bound parameter with literal '%'s).
				zOp = ts + 28223 /* "LIKE" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_LIKE:
				zOp = ts + 28228 /* "like" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_GLOB:
				zOp = ts + 28233 /* "glob" */
				break
				fallthrough
			case SQLITE_INDEX_CONSTRAINT_REGEXP:
				zOp = ts + 6474 /* "regexp" */
				break
			}
			if zOp != 0 {
				if int32(*(*int8)(unsafe.Pointer(zOp))) == 'L' {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+28238, /* " %s %s LIKE (SEL..." */
						libc.VaList(bp+24, zSep, zNewCol))
				} else {
					zNew = sqlite3.Xsqlite3_mprintf(tls, ts+28273 /* " %s %s %s ?" */, libc.VaList(bp+40, zSep, zNewCol, zOp))
				}
				string_concat(tls, bp+88 /* &zQuery */, zNew, 1, bp+96 /* &rc */)
				zSep = ts + 9062 /* "AND" */
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&nArg, 1)
				(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			}
		}
	}

	// If there is only one term in the ORDER BY clause, and it is
	// on a column that this virtual table has an index for, then consume
	// the ORDER BY clause.
	if (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy == 1 && ((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn < 0 || *(*int32)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaIndex + uintptr((*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn)*4)) != 0) {
		var iCol int32 = (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).FiColumn
		var zNewCol uintptr
		if iCol >= 0 {
			zNewCol = *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(iCol)*8))
		} else {
			zNewCol = ts + 28205 /* "rowid" */
		}
		var zDir uintptr
		if (*sqlite3_index_orderby)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy)).Fdesc != 0 {
			zDir = ts + 28285 /* "DESC" */
		} else {
			zDir = ts + 28290 /* "ASC" */
		}
		zNew = sqlite3.Xsqlite3_mprintf(tls, ts+28294 /* " ORDER BY %s %s" */, libc.VaList(bp+64, zNewCol, zDir))
		string_concat(tls, bp+88 /* &zQuery */, zNew, 1, bp+96 /* &rc */)
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).ForderByConsumed = 1
	}

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, ts+28130 /* "xBestIndex" */)

	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)))

	if !(*(*uintptr)(unsafe.Pointer(bp + 88)) != 0) {
		return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = hashString(tls, *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */)))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = *(*uintptr)(unsafe.Pointer(bp + 88 /* zQuery */))
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
	if useCost != 0 {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = cost
	} else if useIdx != 0 {
		// Approximation of log2(nRow).
		for ii = 0; uint64(ii) < uint64(unsafe.Sizeof(int32(0)))*uint64(8)-uint64(1); ii++ {
			if nRow&(int32(1)<<ii) != 0 {
				(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(ii)
			}
		}
	} else {
		(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = float64(nRow)
	}
	return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
}

// The xUpdate method for echo module virtual tables.
//
//    apData[0]  apData[1]  apData[2..]
//
//    INTEGER                              DELETE
//
//    INTEGER    NULL       (nCol args)    UPDATE (do not set rowid)
//    INTEGER    INTEGER    (nCol args)    UPDATE (with SET rowid = <arg1>)
//
//    NULL       NULL       (nCol args)    INSERT INTO (automatic rowid value)
//    NULL       INTEGER    (nCol args)    INSERT (incl. rowid value)
//
func echoUpdate(tls *libc.TLS, tab uintptr, nData int32, apData uintptr, pRowid uintptr) int32 { /* test8.c:969:5: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var pVtab uintptr = tab
	var db uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Fdb
	*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_OK

	*(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = uintptr(0) // SQL statement to execute
	var bindArgZero int32 = 0                                 // True to bind apData[0] to sql var no. nData
	var bindArgOne int32 = 0                                  // True to bind apData[1] to sql var no. 1
	var i int32                                               // Counter variable used by for loops

	// Ticket #3083 - make sure we always start a transaction prior to
	// making any changes to a virtual table

	if simulateVtabError(tls, pVtab, ts+28310) != 0 {
		return SQLITE_ERROR
	}

	// If apData[0] is an integer and nData>1 then do an UPDATE
	if nData > 1 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_INTEGER {
		var zSep uintptr = ts + 28318 /* " SET" */
		*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = sqlite3.Xsqlite3_mprintf(tls, ts+28323 /* "UPDATE %Q" */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_NOMEM
		}

		bindArgOne = libc.Bool32(*(*uintptr)(unsafe.Pointer(apData + 1*8)) != 0 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + 1*8))) == SQLITE_INTEGER)
		bindArgZero = 1

		if bindArgOne != 0 {
			string_concat(tls, bp+96 /* &z */, ts+28333 /* " SET rowid=?1 " */, 0, bp+104 /* &rc */)
			zSep = ts + 4758 /* "," */
		}
		for i = 2; i < nData; i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*8)) == uintptr(0) {
				continue
			}
			string_concat(tls, bp+96 /* &z */, sqlite3.Xsqlite3_mprintf(tls,
				ts+28348 /* "%s %Q=?%d" */, libc.VaList(bp+8, zSep, *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(i-2)*8)), i)), 1, bp+104 /* &rc */)
			zSep = ts + 4758 /* "," */
		}
		string_concat(tls, bp+96 /* &z */, sqlite3.Xsqlite3_mprintf(tls, ts+28358 /* " WHERE rowid=?%d" */, libc.VaList(bp+32, nData)), 1, bp+104 /* &rc */)
	} else if nData == 1 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_INTEGER {
		*(*uintptr)(unsafe.Pointer(bp + 96 /* z */)) = sqlite3.Xsqlite3_mprintf(tls, ts+28375 /* "DELETE FROM %Q W..." */, libc.VaList(bp+40, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 96)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_NOMEM
		}
		bindArgZero = 1
	} else if nData > 2 && sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData))) == SQLITE_NULL {
		var ii int32
		*(*uintptr)(unsafe.Pointer(bp + 112 /* zInsert */)) = uintptr(0)
		*(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)) = uintptr(0)

		*(*uintptr)(unsafe.Pointer(bp + 112 /* zInsert */)) = sqlite3.Xsqlite3_mprintf(tls, ts+28407 /* "INSERT INTO %Q (" */, libc.VaList(bp+48, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
		if !(*(*uintptr)(unsafe.Pointer(bp + 112)) != 0) {
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = SQLITE_NOMEM
		}
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apData + 1*8))) == SQLITE_INTEGER {
			bindArgOne = 1
			*(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)) = sqlite3.Xsqlite3_mprintf(tls, ts+3405 /* "?" */, 0)
			string_concat(tls, bp+112 /* &zInsert */, ts+28205 /* "rowid" */, 0, bp+104 /* &rc */)
		}

		for ii = 2; ii < nData; ii++ {
			string_concat(tls, bp+112, /* &zInsert */
				sqlite3.Xsqlite3_mprintf(tls, ts+28424 /* "%s%Q" */, libc.VaList(bp+56, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 120)) != 0 {
						return ts + 97 /* ", " */
					}
					return ts + 584 /* "" */
				}(), *(*uintptr)(unsafe.Pointer((*echo_vtab)(unsafe.Pointer(pVtab)).FaCol + uintptr(ii-2)*8)))), 1, bp+104 /* &rc */)
			string_concat(tls, bp+120, /* &zValues */
				sqlite3.Xsqlite3_mprintf(tls, ts+28429 /* "%s?%d" */, libc.VaList(bp+72, func() uintptr {
					if *(*uintptr)(unsafe.Pointer(bp + 120)) != 0 {
						return ts + 97 /* ", " */
					}
					return ts + 584 /* "" */
				}(), ii)), 1, bp+104 /* &rc */)
		}

		string_concat(tls, bp+96 /* &z */, *(*uintptr)(unsafe.Pointer(bp + 112 /* zInsert */)), 1, bp+104 /* &rc */)
		string_concat(tls, bp+96 /* &z */, ts+28435 /* ") VALUES(" */, 0, bp+104 /* &rc */)
		string_concat(tls, bp+96 /* &z */, *(*uintptr)(unsafe.Pointer(bp + 120 /* zValues */)), 1, bp+104 /* &rc */)
		string_concat(tls, bp+96 /* &z */, ts+585 /* ")" */, 0, bp+104 /* &rc */)
	} else {

		return SQLITE_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 104)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = sqlite3.Xsqlite3_prepare(tls, db, *(*uintptr)(unsafe.Pointer(bp + 96 /* z */)), -1, bp+128 /* &pStmt */, uintptr(0))
	}

	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 96 /* z */)))
	if *(*int32)(unsafe.Pointer(bp + 104)) == SQLITE_OK {
		if bindArgZero != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)), nData, *(*uintptr)(unsafe.Pointer(apData)))
		}
		if bindArgOne != 0 {
			sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)), 1, *(*uintptr)(unsafe.Pointer(apData + 1*8)))
		}
		for i = 2; i < nData && *(*int32)(unsafe.Pointer(bp + 104 /* rc */)) == SQLITE_OK; i++ {
			if *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*8)) != 0 {
				*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = sqlite3.Xsqlite3_bind_value(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)), i, *(*uintptr)(unsafe.Pointer(apData + uintptr(i)*8)))
			}
		}
		if *(*int32)(unsafe.Pointer(bp + 104)) == SQLITE_OK {
			sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)))
			*(*int32)(unsafe.Pointer(bp + 104 /* rc */)) = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)))
		} else {
			sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 128 /* pStmt */)))
		}
	}

	if pRowid != 0 && *(*int32)(unsafe.Pointer(bp + 104)) == SQLITE_OK {
		*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_last_insert_rowid(tls, db)
	}
	if *(*int32)(unsafe.Pointer(bp + 104)) != SQLITE_OK {
		(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+27818 /* "echo-vtab-error:..." */, libc.VaList(bp+88, sqlite3.Xsqlite3_errmsg(tls, db)))
	}

	return *(*int32)(unsafe.Pointer(bp + 104 /* rc */))
}

// xBegin, xSync, xCommit and xRollback callbacks for echo module
// virtual tables. Do nothing other than add the name of the callback
// to the $::echo_module Tcl variable.
func echoTransactionCall(tls *libc.TLS, tab uintptr, zCall uintptr) int32 { /* test8.c:1102:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	var pVtab uintptr = tab
	z = sqlite3.Xsqlite3_mprintf(tls, ts+28445 /* "echo(%s)" */, libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName))
	if z == uintptr(0) {
		return SQLITE_NOMEM
	}
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, zCall)
	appendToEchoModule(tls, (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp, z)
	sqlite3.Xsqlite3_free(tls, z)
	return SQLITE_OK
}

func echoBegin(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1112:12: */
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	// Ticket #3083 - do not start a transaction if we are already in
	// a transaction

	if simulateVtabError(tls, pVtab, ts+28454) != 0 {
		return SQLITE_ERROR
	}

	rc = echoTransactionCall(tls, tab, ts+28454 /* "xBegin" */)

	if rc == SQLITE_OK {
		// Check if the $::echo_module_begin_fail variable is defined. If it is,
		// and it is set to the name of the real table underlying this virtual
		// echo module table, then cause this xSync operation to fail.
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+28461 /* "echo_module_begi..." */, uintptr(0), TCL_GLOBAL_ONLY)
		if zVal != 0 && 0 == libc.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) {
			rc = SQLITE_ERROR
		}
	}
	if rc == SQLITE_OK {
		(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 1
	}
	return rc
}

func echoSync(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1143:12: */
	var rc int32
	var pVtab uintptr = tab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	var zVal uintptr

	// Ticket #3083 - Only call xSync if we have previously started a
	// transaction

	if simulateVtabError(tls, pVtab, ts+28484) != 0 {
		return SQLITE_ERROR
	}

	rc = echoTransactionCall(tls, tab, ts+28484 /* "xSync" */)

	if rc == SQLITE_OK {
		// Check if the $::echo_module_sync_fail variable is defined. If it is,
		// and it is set to the name of the real table underlying this virtual
		// echo module table, then cause this xSync operation to fail.
		zVal = tcl.XTcl_GetVar2(tls, interp, ts+28490 /* "echo_module_sync..." */, uintptr(0), TCL_GLOBAL_ONLY)
		if zVal != 0 && 0 == libc.Xstrcmp(tls, zVal, (*echo_vtab)(unsafe.Pointer(pVtab)).FzTableName) {
			rc = -1
		}
	}
	return rc
}

func echoCommit(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1171:12: */
	var pVtab uintptr = tab
	var rc int32

	// Ticket #3083 - Only call xCommit if we have previously started
	// a transaction

	if simulateVtabError(tls, pVtab, ts+28512) != 0 {
		return SQLITE_ERROR
	}

	sqlite3.Xsqlite3BeginBenignMalloc(tls)
	rc = echoTransactionCall(tls, tab, ts+28512 /* "xCommit" */)
	sqlite3.Xsqlite3EndBenignMalloc(tls)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}

func echoRollback(tls *libc.TLS, tab uintptr) int32 { /* test8.c:1189:12: */
	var rc int32
	var pVtab uintptr = tab

	// Ticket #3083 - Only call xRollback if we have previously started
	// a transaction

	rc = echoTransactionCall(tls, tab, ts+28520 /* "xRollback" */)
	(*echo_vtab)(unsafe.Pointer(pVtab)).FinTransaction = 0
	return rc
}

// Implementation of "GLOB" function on the echo module.  Pass
// all arguments to the ::echo_glob_overload procedure of TCL
// and return the result of that procedure as a string.
func overloadedGlobFunction(tls *libc.TLS, pContext uintptr, nArg int32, apArg uintptr) { /* test8.c:1207:13: */
	bp := tls.Alloc(216)
	defer tls.Free(216)

	var interp uintptr = sqlite3.Xsqlite3_user_data(tls, pContext)
	// var str Tcl_DString at bp, 216

	var i int32
	var rc int32
	tcl.XTcl_DStringInit(tls, bp /* &str */)
	tcl.XTcl_DStringAppendElement(tls, bp /* &str */, ts+28530 /* "::echo_glob_over..." */)
	for i = 0; i < nArg; i++ {
		tcl.XTcl_DStringAppendElement(tls, bp /* &str */, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))))
	}
	rc = tcl.XTcl_Eval(tls, interp, (*Tcl_DString)(unsafe.Pointer(bp)).Fstring)
	tcl.XTcl_DStringFree(tls, bp /* &str */)
	if rc != 0 {
		sqlite3.Xsqlite3_result_error(tls, pContext, tcl.XTcl_GetStringResult(tls, interp), -1)
	} else {
		sqlite3.Xsqlite3_result_text(tls, pContext, tcl.XTcl_GetStringResult(tls, interp),
			-1, libc.UintptrFromInt32(-1))
	}
	tcl.XTcl_ResetResult(tls, interp)
}

// This is the xFindFunction implementation for the echo module.
// SQLite calls this routine when the first argument of a function
// is a column of an echo virtual table.  This routine can optionally
// override the implementation of that function.  It will choose to
// do so if the function is named "glob", and a TCL command named
// ::echo_glob_overload exists.
func echoFindFunction(tls *libc.TLS, vtab uintptr, nArg int32, zFuncName uintptr, pxFunc uintptr, ppArg uintptr) int32 { /* test8.c:1240:12: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var pVtab uintptr = vtab
	var interp uintptr = (*echo_vtab)(unsafe.Pointer(pVtab)).Finterp
	// var info Tcl_CmdInfo at bp, 64

	if libc.Xstrcmp(tls, zFuncName, ts+28233) != 0 {
		return 0
	}
	if tcl.XTcl_GetCommandInfo(tls, interp, ts+28530, bp) == 0 {
		return 0
	}
	*(*uintptr)(unsafe.Pointer(pxFunc)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{overloadedGlobFunction}))
	*(*uintptr)(unsafe.Pointer(ppArg)) = interp
	return 1
}

func echoRename(tls *libc.TLS, vtab uintptr, zNewName uintptr) int32 { /* test8.c:1261:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32 = SQLITE_OK
	var p uintptr = vtab

	if simulateVtabError(tls, p, ts+28551) != 0 {
		return SQLITE_ERROR
	}

	if (*echo_vtab)(unsafe.Pointer(p)).FisPattern != 0 {
		var nThis int32 = int32(libc.Xstrlen(tls, (*echo_vtab)(unsafe.Pointer(p)).FzThis))
		var zSql uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+28559, /* "ALTER TABLE %s R..." */
			libc.VaList(bp, (*echo_vtab)(unsafe.Pointer(p)).FzTableName, zNewName, (*echo_vtab)(unsafe.Pointer(p)).FzTableName+uintptr(nThis)))
		rc = sqlite3.Xsqlite3_exec(tls, (*echo_vtab)(unsafe.Pointer(p)).Fdb, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}

	return rc
}

func echoSavepoint(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1281:12: */

	return SQLITE_OK
}

func echoRelease(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1286:12: */

	return SQLITE_OK
}

func echoRollbackTo(tls *libc.TLS, pVTab uintptr, iSavepoint int32) int32 { /* test8.c:1291:12: */

	return SQLITE_OK
}

// A virtual table module that merely "echos" the contents of another
// table (like an SQL VIEW).
var echoModule = sqlite3_module{
	FiVersion:      1, // iVersion
	FxCreate:       0,
	FxConnect:      0,
	FxBestIndex:    0,
	FxDisconnect:   0,
	FxDestroy:      0,
	FxOpen:         0, // xOpen - open a cursor
	FxClose:        0, // xClose - close a cursor
	FxFilter:       0, // xFilter - configure scan constraints
	FxNext:         0, // xNext - advance a cursor
	FxEof:          0, // xEof
	FxColumn:       0, // xColumn - read data
	FxRowid:        0, // xRowid - read data
	FxUpdate:       0, // xUpdate - write data
	FxBegin:        0, // xBegin - begin transaction
	FxSync:         0, // xSync - sync transaction
	FxCommit:       0, // xCommit - commit transaction
	FxRollback:     0, // xRollback - rollback transaction
	FxFindFunction: 0, // xFindFunction - function overloading
	FxRename:       0, // xRename - rename the table
} /* test8.c:1300:23 */

var echoModuleV2 = sqlite3_module{
	FiVersion:      2, // iVersion
	FxCreate:       0,
	FxConnect:      0,
	FxBestIndex:    0,
	FxDisconnect:   0,
	FxDestroy:      0,
	FxOpen:         0, // xOpen - open a cursor
	FxClose:        0, // xClose - close a cursor
	FxFilter:       0, // xFilter - configure scan constraints
	FxNext:         0, // xNext - advance a cursor
	FxEof:          0, // xEof
	FxColumn:       0, // xColumn - read data
	FxRowid:        0, // xRowid - read data
	FxUpdate:       0, // xUpdate - write data
	FxBegin:        0, // xBegin - begin transaction
	FxSync:         0, // xSync - sync transaction
	FxCommit:       0, // xCommit - commit transaction
	FxRollback:     0, // xRollback - rollback transaction
	FxFindFunction: 0, // xFindFunction - function overloading
	FxRename:       0, // xRename - rename the table
	FxSavepoint:    0,
	FxRelease:      0,
	FxRollbackTo:   0,
} /* test8.c:1323:23 */

func moduleDestroy(tls *libc.TLS, p uintptr) { /* test8.c:1355:13: */
	var pMod uintptr = p
	sqlite3.Xsqlite3_create_function(tls, (*EchoModule)(unsafe.Pointer(pMod)).Fdb, ts+28589, /* "function_that_do..." */
		SQLITE_ANY, 1, uintptr(0), uintptr(0), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_free(tls, p)
}

// Register the echo virtual table module.
func register_echo_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test8.c:1365:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32
	// var db uintptr at bp, 8

	var pMod uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}

	// Virtual table module "echo"
	pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
	(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
	(*EchoModule)(unsafe.Pointer(pMod)).Fdb = *(*uintptr)(unsafe.Pointer(bp /* db */))
	rc = sqlite3.Xsqlite3_create_module_v2(tls,
		*(*uintptr)(unsafe.Pointer(bp /* db */)), ts+28627 /* "echo" */, uintptr(unsafe.Pointer(&echoModule)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{moduleDestroy})))

	// Virtual table module "echo_v2"
	if rc == SQLITE_OK {
		pMod = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(EchoModule{})))
		(*EchoModule)(unsafe.Pointer(pMod)).Finterp = interp
		(*EchoModule)(unsafe.Pointer(pMod)).Fdb = *(*uintptr)(unsafe.Pointer(bp /* db */))
		rc = sqlite3.Xsqlite3_create_module_v2(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+28632, /* "echo_v2" */
			uintptr(unsafe.Pointer(&echoModuleV2)), pMod, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{moduleDestroy})))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Tcl interface to sqlite3_declare_vtab, invoked as follows from Tcl:
//
// sqlite3_declare_vtab DB SQL
func declare_vtab(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test8.c:1407:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10893 /* "DB SQL" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_declare_vtab(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp /* db */))), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest8_Init(tls *libc.TLS, interp uintptr) int32 { /* test8.c:1433:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd2))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd2[i].FzName,
			aObjCmd2[i].FxProc, aObjCmd2[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd2 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 28640 /* "register_echo_mo..." */, FxProc: 0},
	{FzName: ts + 28661 /* "sqlite3_declare_..." */, FxProc: 0},
} /* test8.c:1439:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// c_collation_test
func c_collation_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:29:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var zErrFunction uintptr
	// var db uintptr at bp+24, 8

	var rc int32
	zErrFunction = ts + 28682 /* "N/A" */
	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
	return TCL_ERROR
__1:
	;

	// Open a database.
	rc = sqlite3.Xsqlite3_open(tls, ts+1757 /* ":memory:" */, bp+24 /* &db */)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	zErrFunction = ts + 22095 /* "sqlite3_open" */
	goto error_out
__2:
	;

	rc = sqlite3.Xsqlite3_create_collation(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), ts+14241 /* "collate" */, 456, uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	zErrFunction = ts + 28686 /* "sqlite3_create_c..." */
	goto error_out
__3:
	;

	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+28711 /* "Error testing fu..." */, zErrFunction, 0))
	return TCL_ERROR
}

// c_realloc_test
func c_realloc_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:70:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var p uintptr
	var zErrFunction uintptr
	zErrFunction = ts + 28682 /* "N/A" */

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
	return TCL_ERROR
__1:
	;

	p = sqlite3.Xsqlite3_malloc(tls, 5)
	if !!(p != 0) {
		goto __2
	}
	zErrFunction = ts + 28736 /* "sqlite3_malloc" */
	goto error_out
__2:
	;

	// Test that realloc()ing a block of memory to a negative size is
	// the same as free()ing that memory.
	p = sqlite3.Xsqlite3_realloc(tls, p, -1)
	if !(p != 0) {
		goto __3
	}
	zErrFunction = ts + 28751 /* "sqlite3_realloc" */
	goto error_out
__3:
	;

	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+28711 /* "Error testing fu..." */, zErrFunction, 0))
	return TCL_ERROR
}

// c_misuse_test
func c_misuse_test(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test9.c:111:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var zErrFunction uintptr
	// var db uintptr at bp+24, 8

	// var pStmt uintptr at bp+32, 8

	var rc int32
	zErrFunction = ts + 28682 /* "N/A" */
	*(*uintptr)(unsafe.Pointer(bp + 24 /* db */)) = uintptr(0)

	if !(objc != 1) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
	return TCL_ERROR
__1:
	;

	// Open a database. Then close it again. We need to do this so that
	// we have a "closed database handle" to pass to various API functions.
	rc = sqlite3.Xsqlite3_open(tls, ts+1757 /* ":memory:" */, bp+24 /* &db */)
	if !(rc != SQLITE_OK) {
		goto __2
	}
	zErrFunction = ts + 22095 /* "sqlite3_open" */
	goto error_out
__2:
	;
	sqlite3.Xsqlite3_close(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))

	rc = sqlite3.Xsqlite3_errcode(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	zErrFunction = ts + 22022 /* "sqlite3_errcode" */
	goto error_out
__3:
	;

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+32 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	zErrFunction = ts + 22176 /* "sqlite3_prepare" */
	goto error_out
__4:
	;
	// Verify that pStmt is zeroed even on a MISUSE error

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+32 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	zErrFunction = ts + 22210 /* "sqlite3_prepare_..." */
	goto error_out
__5:
	;

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare16(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+32 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	zErrFunction = ts + 22192 /* "sqlite3_prepare1..." */
	goto error_out
__6:
	;

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pStmt */)) = uintptr(1234)
	rc = sqlite3.Xsqlite3_prepare16_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* db */)), uintptr(0), 0, bp+32 /* &pStmt */, uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __7
	}
	zErrFunction = ts + 22272 /* "sqlite3_prepare1..." */
	goto error_out
__7:
	;

	return TCL_OK

error_out:
	tcl.XTcl_ResetResult(tls, interp)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+28711 /* "Error testing fu..." */, zErrFunction, 0))
	return TCL_ERROR
}

// Register commands with the TCL interpreter.
func Sqlitetest9_Init(tls *libc.TLS, interp uintptr) int32 { /* test9.c:188:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd3))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd3[i].FzName,
			aObjCmd3[i].FxProc, aObjCmd3[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd3 = [3]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 28767 /* "c_misuse_test" */, FxProc: 0},
	{FzName: ts + 28781 /* "c_realloc_test" */, FxProc: 0},
	{FzName: ts + 28796 /* "c_collation_test" */, FxProc: 0},
} /* test9.c:193:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitetestasync_Init(tls *libc.TLS, interp uintptr) int32 { /* test_async.c:238:5: */
	return TCL_OK
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// tclcmd:   sqlite3_reset_auto_extension
//
// Reset all auto-extensions
func resetAutoExtObjCmd(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_autoext.c:196:26: */
	sqlite3.Xsqlite3_reset_auto_extension(tls)
	return SQLITE_OK
}

// This procedure registers the TCL procs defined in this file.
func Sqlitetest_autoext_Init(tls *libc.TLS, interp uintptr) int32 { /* test_autoext.c:210:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+28813, /* "sqlite3_reset_au..." */
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{resetAutoExtObjCmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

func backupTestCmd(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_backup.c:33:26: */
	bp := tls.Alloc(196)
	defer tls.Free(196)

	*(*[5]BackupSubCommand)(unsafe.Pointer(bp /* aSub */)) = [5]BackupSubCommand{
		{FzCmd: ts + 10317 /* "step" */, FnArg: 1, FzArg: ts + 28842 /* "npage" */},
		{FzCmd: ts + 28848 /* "finish" */, FeCmd: uint32(1) /* BACKUP_FINISH */, FzArg: ts + 584 /* "" */},
		{FzCmd: ts + 28855 /* "remaining" */, FeCmd: uint32(2) /* BACKUP_REMAINING */, FzArg: ts + 584 /* "" */},
		{FzCmd: ts + 28865 /* "pagecount" */, FeCmd: uint32(3) /* BACKUP_PAGECOUNT */, FzArg: ts + 584 /* "" */},
		{},
	}

	var p uintptr = clientData
	// var iCmd int32 at bp+120, 4

	var rc int32

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &aSub[0] */, int32(unsafe.Sizeof(BackupSubCommand{})), ts+12530 /* "option" */, 0, bp+120 /* &iCmd */)
	if rc != TCL_OK {
		return rc
	}
	if objc != 2+(*BackupSubCommand)(unsafe.Pointer(bp+uintptr(*(*int32)(unsafe.Pointer(bp + 120)))*24)).FnArg {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ +uintptr(*(*int32)(unsafe.Pointer(bp + 120 /* iCmd */)))*24)).FzArg)
		return TCL_ERROR
	}

	switch (*BackupSubCommand)(unsafe.Pointer(bp /* &aSub */ + uintptr(*(*int32)(unsafe.Pointer(bp + 120 /* iCmd */)))*24)).FeCmd {

	case uint32(1) /* BACKUP_FINISH */ :
		{
			var zCmdName uintptr
			// var cmdInfo Tcl_CmdInfo at bp+128, 64

			zCmdName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv)))
			tcl.XTcl_GetCommandInfo(tls, interp, zCmdName, bp+128 /* &cmdInfo */)
			(*Tcl_CmdInfo)(unsafe.Pointer(bp + 128 /* &cmdInfo */)).FdeleteProc = uintptr(0)
			tcl.XTcl_SetCommandInfo(tls, interp, zCmdName, bp+128 /* &cmdInfo */)
			tcl.XTcl_DeleteCommand(tls, interp, zCmdName)

			rc = sqlite3.Xsqlite3_backup_finish(tls, p)
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break

		}

	case uint32(0) /* BACKUP_STEP */ :
		{
			// var nPage int32 at bp+192, 4

			if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+192) {
				return TCL_ERROR
			}
			rc = sqlite3.Xsqlite3_backup_step(tls, p, *(*int32)(unsafe.Pointer(bp + 192 /* nPage */)))
			tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
			break

		}

	case uint32(2) /* BACKUP_REMAINING */ :
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_remaining(tls, p)))
		break

	case uint32(3) /* BACKUP_PAGECOUNT */ :
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_backup_pagecount(tls, p)))
		break
	}

	return TCL_OK
}

type BackupSubCommand = struct {
	FzCmd uintptr
	FeCmd uint32
	FnArg int32
	FzArg uintptr
} /* test_backup.c:42:3 */

func backupTestFinish(tls *libc.TLS, clientData ClientData) { /* test_backup.c:108:27: */
	var pBackup uintptr = clientData
	sqlite3.Xsqlite3_backup_finish(tls, pBackup)
}

//     sqlite3_backup CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME
//
func backupTestInit(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_backup.c:117:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var pBackup uintptr
	// var pDestDb uintptr at bp+16, 8

	// var pSrcDb uintptr at bp+24, 8

	var zDestName uintptr
	var zSrcName uintptr
	var zCmd uintptr

	if objc != 6 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+28875 /* "CMDNAME DESTHAND..." */)
		return TCL_ERROR
	}

	zCmd = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), bp+16 /* &pDestDb */)
	zDestName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8))), bp+24 /* &pSrcDb */)
	zSrcName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 5*8)))

	pBackup = sqlite3.Xsqlite3_backup_init(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pDestDb */)), zDestName, *(*uintptr)(unsafe.Pointer(bp + 24 /* pSrcDb */)), zSrcName)
	if !(pBackup != 0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+28921 /* "sqlite3_backup_i..." */, 0))
		return TCL_ERROR
	}

	tcl.XTcl_CreateObjCommand(tls, interp, zCmd, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestCmd})), pBackup, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{backupTestFinish})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	return TCL_OK
}

func Sqlitetestbackup_Init(tls *libc.TLS, interp uintptr) int32 { /* test_backup.c:154:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+28950 /* "sqlite3_backup" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{backupTestInit})), uintptr(0), uintptr(0))
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type tcl_vtab1 = struct {
	Fbase   sqlite3_vtab
	Finterp uintptr
	FpCmd   uintptr
	Fdb     uintptr
} /* test_bestindex.c:104:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type tcl_vtab = tcl_vtab1 /* test_bestindex.c:104:25 */
type tcl_cursor1 = struct {
	Fbase  sqlite3_vtab_cursor
	FpStmt uintptr
} /* test_bestindex.c:105:9 */

type tcl_cursor = tcl_cursor1 /* test_bestindex.c:105:27 */

// Dequote string z in place.
func tclDequote(tls *libc.TLS, z uintptr) { /* test_bestindex.c:126:13: */
	var q int8 = *(*int8)(unsafe.Pointer(z))

	// Set stack variable q to the close-quote character
	if int32(q) == '[' || int32(q) == '\'' || int32(q) == '"' || int32(q) == '`' {
		var iIn int32 = 1
		var iOut int32 = 0
		if int32(q) == '[' {
			q = int8(']')
		}

		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(q) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(q) {
					// Character iIn was the close quote.
					iIn++
					break
				} else {
					// Character iIn and iIn+1 form an escaped quote character. Skip
					// the input cursor past both and copy a single quote character
					// to the output buffer.
					iIn = iIn + 2
					*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = q
				}
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}

		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// This function is the implementation of both the xConnect and xCreate
// methods of the fs virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func tclConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_bestindex.c:168:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var interp uintptr = pAux
	var pTab uintptr = uintptr(0)
	var zCmd uintptr = uintptr(0)
	var pScript uintptr = uintptr(0)
	var rc int32 = SQLITE_OK

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+28965 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}

	zCmd = sqlite3.Xsqlite3_malloc64(tls, uint64(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))+uint64(1)))
	pTab = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(tcl_vtab{})))
	if zCmd != 0 && pTab != 0 {
		libc.Xmemcpy(tls, zCmd, *(*uintptr)(unsafe.Pointer(argv + 3*8)), libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))+uint64(1))
		tclDequote(tls, zCmd)
		libc.Xmemset(tls, pTab, 0, uint64(unsafe.Sizeof(tcl_vtab{})))

		(*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd = tcl.XTcl_NewStringObj(tls, zCmd, -1)
		(*tcl_vtab)(unsafe.Pointer(pTab)).Finterp = interp
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fdb = db
		(*Tcl_Obj)(unsafe.Pointer((*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)).FrefCount++

		pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+28012 /* "xConnect" */, -1))

		rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
		if rc != TCL_OK {
			*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, tcl.XTcl_GetStringResult(tls, interp)))
			rc = SQLITE_ERROR
		} else {
			rc = sqlite3.Xsqlite3_declare_vtab(tls, db, tcl.XTcl_GetStringResult(tls, interp))
		}

		if rc != SQLITE_OK {
			sqlite3.Xsqlite3_free(tls, pTab)
			pTab = uintptr(0)
		}
	} else {
		rc = SQLITE_NOMEM
	}

	sqlite3.Xsqlite3_free(tls, zCmd)
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	return rc
}

// The xDisconnect and xDestroy methods are also the same
func tclDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_bestindex.c:224:12: */
	var pTab uintptr = pVtab
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	sqlite3.Xsqlite3_free(tls, pTab)
	return SQLITE_OK
}

// Open a new tcl cursor.
func tclOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_bestindex.c:234:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(tcl_cursor{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(tcl_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Close a tcl cursor.
func tclClose(tls *libc.TLS, cur uintptr) int32 { /* test_bestindex.c:246:12: */
	var pCur uintptr = cur
	if pCur != 0 {
		sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCur)).FpStmt)
		sqlite3.Xsqlite3_free(tls, pCur)
	}
	return SQLITE_OK
}

func tclNext(tls *libc.TLS, pVtabCursor uintptr) int32 { /* test_bestindex.c:255:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pCsr uintptr = pVtabCursor
	if (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt != 0 {
		var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
		var rc int32 = sqlite3.Xsqlite3_step(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
		if rc != SQLITE_ROW {
			var zErr uintptr
			rc = sqlite3.Xsqlite3_finalize(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt)
			(*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
			if rc != SQLITE_OK {
				zErr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
				(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zErr))
			}
		}
	}
	return SQLITE_OK
}

func tclFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_bestindex.c:273:12: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pScript uintptr
	var pArg uintptr
	var ii int32
	var rc int32

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+28076 /* "xFilter" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewIntObj(tls, idxNum))
	if idxStr != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, idxStr, -1))
	} else {
		tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+584 /* "" */, -1))
	}

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < argc; ii++ {
		var zVal uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(ii)*8)))
		var pVal uintptr
		if zVal == uintptr(0) {
			pVal = tcl.XTcl_NewObj(tls)
		} else {
			pVal = tcl.XTcl_NewStringObj(tls, zVal, -1)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pArg, pVal)
	}
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, pArg)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = SQLITE_ERROR
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zErr))
	} else {
		// Analyze the scripts return value. The return value should be a tcl
		// list object with an even number of elements. The first element of each
		// pair must be one of:
		//
		//   "sql"          (SQL statement to return data)
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 40 /* apElem */)) = uintptr(0)
		// var nElem int32 at bp+32, 4

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+32 /* &nElem */, bp+40 /* &apElem */)
		if rc != TCL_OK {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = SQLITE_ERROR
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zErr))
		} else {
			for ii = 0; rc == SQLITE_OK && ii < *(*int32)(unsafe.Pointer(bp + 32 /* nElem */)); ii = ii + 2 {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* apElem */)) + uintptr(ii)*8)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 40 /* apElem */)) + uintptr(ii+1)*8))
				if sqlite3.Xsqlite3_stricmp(tls, ts+1947, zCmd) == 0 {
					var zSql uintptr = tcl.XTcl_GetString(tls, p)
					rc = sqlite3.Xsqlite3_prepare_v2(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, pCsr+8, uintptr(0))
					if rc != SQLITE_OK {
						var zErr uintptr = sqlite3.Xsqlite3_errmsg(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).Fdb)
						(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+28991 /* "unexpected: %s" */, libc.VaList(bp+16, zErr))
					}
				} else {
					rc = SQLITE_ERROR
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+28991 /* "unexpected: %s" */, libc.VaList(bp+24, zCmd))
				}
			}
		}
	}

	if rc == SQLITE_OK {
		rc = tclNext(tls, pVtabCursor)
	}
	return rc
}

func tclColumn(tls *libc.TLS, pVtabCursor uintptr, ctx uintptr, i int32) int32 { /* test_bestindex.c:356:12: */
	var pCsr uintptr = pVtabCursor
	sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, i+1))
	return SQLITE_OK
}

func tclRowid(tls *libc.TLS, pVtabCursor uintptr, pRowid uintptr) int32 { /* test_bestindex.c:366:12: */
	var pCsr uintptr = pVtabCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt, 0)
	return SQLITE_OK
}

func tclEof(tls *libc.TLS, pVtabCursor uintptr) int32 { /* test_bestindex.c:372:12: */
	var pCsr uintptr = pVtabCursor
	return libc.Bool32((*tcl_cursor)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0))
}

func tclBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_bestindex.c:377:12: */
	bp := tls.Alloc(76)
	defer tls.Free(76)

	var pTab uintptr = tab
	var interp uintptr = (*tcl_vtab)(unsafe.Pointer(pTab)).Finterp
	var pArg uintptr
	var pScript uintptr
	var ii int32
	var rc int32 = SQLITE_OK

	pScript = tcl.XTcl_DuplicateObj(tls, (*tcl_vtab)(unsafe.Pointer(pTab)).FpCmd)
	(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, interp, pScript, tcl.XTcl_NewStringObj(tls, ts+28130 /* "xBestIndex" */, -1))

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		var zOp uintptr = ts + 3405 /* "?" */

		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		switch int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) {
		case SQLITE_INDEX_CONSTRAINT_EQ:
			zOp = ts + 29006 /* "eq" */
			break
		case SQLITE_INDEX_CONSTRAINT_GT:
			zOp = ts + 29009 /* "gt" */
			break
		case SQLITE_INDEX_CONSTRAINT_LE:
			zOp = ts + 29012 /* "le" */
			break
		case SQLITE_INDEX_CONSTRAINT_LT:
			zOp = ts + 29015 /* "lt" */
			break
		case SQLITE_INDEX_CONSTRAINT_GE:
			zOp = ts + 29018 /* "ge" */
			break
		case SQLITE_INDEX_CONSTRAINT_MATCH:
			zOp = ts + 29021 /* "match" */
			break
		case SQLITE_INDEX_CONSTRAINT_LIKE:
			zOp = ts + 28228 /* "like" */
			break
		case SQLITE_INDEX_CONSTRAINT_GLOB:
			zOp = ts + 28233 /* "glob" */
			break
		case SQLITE_INDEX_CONSTRAINT_REGEXP:
			zOp = ts + 6474 /* "regexp" */
			break
		case SQLITE_INDEX_CONSTRAINT_NE:
			zOp = ts + 29027 /* "ne" */
			break
		case SQLITE_INDEX_CONSTRAINT_ISNOT:
			zOp = ts + 29030 /* "isnot" */
			break
		case SQLITE_INDEX_CONSTRAINT_ISNOTNULL:
			zOp = ts + 29036 /* "isnotnull" */
			break
		case SQLITE_INDEX_CONSTRAINT_ISNULL:
			zOp = ts + 29046 /* "isnull" */
			break
		case SQLITE_INDEX_CONSTRAINT_IS:
			zOp = ts + 5851 /* "is" */
			break
		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+29053 /* "op" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, zOp, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+29056 /* "column" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+29063 /* "usable" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, pElem)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pElem
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, pArg)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	pArg = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnOrderBy; ii++ {
		var pOrder uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaOrderBy + uintptr(ii)*8
		var pElem uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pElem)).FrefCount++

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+29056 /* "column" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, (*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).FiColumn))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewStringObj(tls, ts+29070 /* "desc" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pElem, tcl.XTcl_NewIntObj(tls, int32((*sqlite3_index_orderby)(unsafe.Pointer(pOrder)).Fdesc)))

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, pElem)
		for ok2 := true; ok2; ok2 = 0 != 0 {
			var _objPtr uintptr = pElem
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, pArg)
	for ok3 := true; ok3; ok3 = 0 != 0 {
		var _objPtr uintptr = pArg
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pScript, tcl.XTcl_NewWideIntObj(tls, int64((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FcolUsed)))

	rc = tcl.XTcl_EvalObjEx(tls, interp, pScript, TCL_EVAL_GLOBAL)
	for ok4 := true; ok4; ok4 = 0 != 0 {
		var _objPtr uintptr = pScript
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc != TCL_OK {
		var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
		rc = SQLITE_ERROR
		(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, zErr))
	} else {
		// Analyze the scripts return value. The return value should be a tcl
		// list object with an even number of elements. The first element of each
		// pair must be one of:
		//
		//   "orderby"          (value of orderByConsumed flag)
		//   "cost"             (value of estimatedCost field)
		//   "rows"             (value of estimatedRows field)
		//   "use"              (index of used constraint in aConstraint[])
		//   "idxnum"           (value of idxNum field)
		//   "idxstr"           (value of idxStr field)
		//   "omit"             (index of omitted constraint in aConstraint[])
		var pRes uintptr = tcl.XTcl_GetObjResult(tls, interp)
		*(*uintptr)(unsafe.Pointer(bp + 56 /* apElem */)) = uintptr(0)
		// var nElem int32 at bp+48, 4

		rc = tcl.XTcl_ListObjGetElements(tls, interp, pRes, bp+48 /* &nElem */, bp+56 /* &apElem */)
		if rc != TCL_OK {
			var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
			rc = SQLITE_ERROR
			(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, zErr))
		} else {
			var iArgv int32 = 1
			for ii = 0; rc == SQLITE_OK && ii < *(*int32)(unsafe.Pointer(bp + 48 /* nElem */)); ii = ii + 2 {
				var zCmd uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 56 /* apElem */)) + uintptr(ii)*8)))
				var p uintptr = *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 56 /* apElem */)) + uintptr(ii+1)*8))
				if sqlite3.Xsqlite3_stricmp(tls, ts+29075, zCmd) == 0 {
					rc = tcl.XTcl_GetDoubleFromObj(tls, interp, p, pIdxInfo+64)
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+29080, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, pIdxInfo+60)
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+29088, zCmd) == 0 {
					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, pIdxInfo+40)
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+29095, zCmd) == 0 {
					sqlite3.Xsqlite3_free(tls, (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+16, tcl.XTcl_GetString(tls, p)))
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+29102, zCmd) == 0 {
					*(*Tcl_WideInt)(unsafe.Pointer(bp + 64 /* x */)) = int64(0)
					rc = tcl.XTcl_GetWideIntFromObj(tls, interp, p, bp+64 /* &x */)
					(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedRows = sqlite3_int64(tRowcnt(*(*Tcl_WideInt)(unsafe.Pointer(bp + 64 /* x */))))
				} else if sqlite3.Xsqlite3_stricmp(tls, ts+29107, zCmd) == 0 ||
					sqlite3.Xsqlite3_stricmp(tls, ts+29111, zCmd) == 0 {
					// var iCons int32 at bp+72, 4

					rc = tcl.XTcl_GetIntFromObj(tls, interp, p, bp+72 /* &iCons */)
					if rc == SQLITE_OK {
						if *(*int32)(unsafe.Pointer(bp + 72)) < 0 || *(*int32)(unsafe.Pointer(bp + 72)) >= (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint {
							rc = SQLITE_ERROR
							(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+29116 /* "unexpected: %d" */, libc.VaList(bp+24, *(*int32)(unsafe.Pointer(bp + 72 /* iCons */))))
						} else {
							var bOmit int32 = libc.Bool32(int32(*(*int8)(unsafe.Pointer(zCmd))) == 'o' || int32(*(*int8)(unsafe.Pointer(zCmd))) == 'O')
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* iCons */)))*8)).FargvIndex = libc.PostIncInt32(&iArgv, 1)
							(*sqlite3_index_constraint_usage)(unsafe.Pointer((*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(*(*int32)(unsafe.Pointer(bp + 72 /* iCons */)))*8)).Fomit = uint8(bOmit)
						}
					}
				} else {
					rc = SQLITE_ERROR
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+28991 /* "unexpected: %s" */, libc.VaList(bp+32, zCmd))
				}
				if rc != SQLITE_OK && (*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg == uintptr(0) {
					var zErr uintptr = tcl.XTcl_GetStringResult(tls, interp)
					(*tcl_vtab)(unsafe.Pointer(pTab)).Fbase.FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+40, zErr))
				}
			}
		}
	}

	return rc
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var tclModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_bestindex.c:549:23 */

// Register the echo virtual table module.
func register_tcl_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_bestindex.c:580:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+29131 /* "tcl" */, uintptr(unsafe.Pointer(&tclModule)), interp)
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetesttcl_Init(tls *libc.TLS, interp uintptr) int32 { /* test_bestindex.c:604:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd4))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd4[i].FzName,
			aObjCmd4[i].FxProc, aObjCmd4[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd4 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 29135 /* "register_tcl_mod..." */, FxProc: 0},
} /* test_bestindex.c:610:5 */

// Return a pointer to a buffer containing a text representation of the
// pointer passed as the only argument. The original pointer may be extracted
// from the text using sqlite3TestTextToPtr().
func ptrToText(tls *libc.TLS, p uintptr) uintptr { /* test_blob.c:37:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	sqlite3.Xsqlite3_snprintf(tls, int32(uint64(unsafe.Sizeof(buf))-uint64(1)), uintptr(unsafe.Pointer(&buf)), ts+10721 /* "%p" */, libc.VaList(bp, p))
	return uintptr(unsafe.Pointer(&buf))
}

var buf [100]int8 /* test_blob.c:38:15: */

// Attempt to extract a blob handle (type sqlite3_blob*) from the Tcl
// object passed as the second argument. If successful, set *ppBlob to
// point to the blob handle and return TCL_OK. Otherwise, store an error
// message in the tcl interpreter and return TCL_ERROR. The final value
// of *ppBlob is undefined in this case.
//
// If the object contains a string that begins with "incrblob_", then it
// is assumed to be the name of a Tcl channel opened using the [db incrblob]
// command (see tclsqlite.c). Otherwise, it is assumed to be a pointer
// encoded using the ptrToText() routine or similar.
func blobHandleFromObj1(tls *libc.TLS, interp uintptr, pObj uintptr, ppBlob uintptr) int32 { /* test_blob.c:55:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var z uintptr
	// var n int32 at bp, 4

	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	if *(*int32)(unsafe.Pointer(bp)) == 0 {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = uintptr(0)
	} else if *(*int32)(unsafe.Pointer(bp)) > 9 && 0 == libc.Xmemcmp(tls, ts+29155, z, uint64(9)) {
		// var notUsed int32 at bp+4, 4

		var channel Tcl_Channel
		var instanceData ClientData

		channel = tcl.XTcl_GetChannel(tls, interp, z, bp+4 /* &notUsed */)
		if !(channel != 0) {
			return TCL_ERROR
		}

		tcl.XTcl_Flush(tls, channel)
		tcl.XTcl_Seek(tls, channel, int64(0), SEEK_SET)

		instanceData = tcl.XTcl_GetChannelInstanceData(tls, channel)
		*(*uintptr)(unsafe.Pointer(ppBlob)) = *(*uintptr)(unsafe.Pointer(instanceData))
	} else {
		*(*uintptr)(unsafe.Pointer(ppBlob)) = sqlite3TestTextToPtr(tls, z)
	}

	return TCL_OK
}

// Like Tcl_GetString(), except that if the string is 0 bytes in size, a
// NULL Pointer is returned.
func blobStringFromObj(tls *libc.TLS, pObj uintptr) uintptr { /* test_blob.c:90:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var n int32 at bp, 4

	var z uintptr
	z = tcl.XTcl_GetStringFromObj(tls, pObj, bp /* &n */)
	return func() uintptr {
		if *(*int32)(unsafe.Pointer(bp)) != 0 {
			return z
		}
		return uintptr(0)
	}()
}

// sqlite3_blob_open DB DATABASE TABLE COLUMN ROWID FLAGS VARNAME
//
// Tcl test harness for the sqlite3_blob_open() function.
func test_blob_open(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:102:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+8, 8

	var zDb uintptr
	var zTable uintptr
	var zColumn uintptr
	// var iRowid Tcl_WideInt at bp+16, 8

	// var flags int32 at bp, 4

	var zVarname uintptr
	// var nVarname int32 at bp+24, 4

	*(*uintptr)(unsafe.Pointer(bp + 32 /* pBlob */)) = bp /* &flags */ // Non-zero initialization
	var rc int32

	if objc != 8 {
		var zUsage uintptr = ts + 29165 /* "DB DATABASE TABL..." */
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, zUsage)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+8) != 0 {
		return TCL_ERROR
	}
	zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	zTable = blobStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	zColumn = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 6*8)), bp) != 0 {
		return TCL_ERROR
	}
	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 7*8)), bp+24 /* &nVarname */)

	if *(*int32)(unsafe.Pointer(bp + 24)) > 0 {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), zDb, zTable, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 16 /* iRowid */)), *(*int32)(unsafe.Pointer(bp /* flags */)), bp+32 /* &pBlob */)
		tcl.XTcl_SetVar2(tls, interp, zVarname, uintptr(0), ptrToText(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pBlob */))), 0)
	} else {
		rc = sqlite3.Xsqlite3_blob_open(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* db */)), zDb, zTable, zColumn, *(*Tcl_WideInt)(unsafe.Pointer(bp + 16 /* iRowid */)), *(*int32)(unsafe.Pointer(bp /* flags */)), uintptr(0))
	}

	if rc == SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
		return TCL_ERROR
	}
	return TCL_OK
}

// sqlite3_blob_close  HANDLE
func test_blob_close(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:153:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pBlob uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_blob_close(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)))

	if rc != 0 {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	} else {
		tcl.XTcl_ResetResult(tls, interp)
	}
	return TCL_OK
}

// sqlite3_blob_bytes  HANDLE
func test_blob_bytes(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:181:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var pBlob uintptr at bp, 8

	var nByte int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	nByte = sqlite3.Xsqlite3_blob_bytes(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nByte))

	return TCL_OK
}

// sqlite3_blob_read  CHANNEL OFFSET N
//
//   This command is used to test the sqlite3_blob_read() in ways that
//   the Tcl channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method
//   of a database handle. This function calls sqlite3_blob_read()
//   to read N bytes from offset OFFSET from the underlying SQLite
//   blob handle.
//
//   On success, a byte-array object containing the read data is
//   returned. On failure, the interpreter result is set to the
//   text representation of the returned error code (i.e. "SQLITE_NOMEM")
//   and a Tcl exception is thrown.
func test_blob_read(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:217:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var pBlob uintptr at bp+16, 8

	// var nByte int32 at bp+28, 4

	// var iOffset int32 at bp+24, 4

	var zBuf uintptr = uintptr(0)
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29217 /* "CHANNEL OFFSET N" */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+24) ||
		TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+28) {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 28)) > 0 {
		zBuf = tcl.XTcl_AttemptAlloc(tls, uint32(*(*int32)(unsafe.Pointer(bp + 28 /* nByte */))))
		if zBuf == uintptr(0) {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+29234 /* "out of memory in..." */, 0))
			return TCL_ERROR
		}
	}
	rc = sqlite3.Xsqlite3_blob_read(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* pBlob */)), zBuf, *(*int32)(unsafe.Pointer(bp + 28 /* nByte */)), *(*int32)(unsafe.Pointer(bp + 24 /* iOffset */)))
	if rc == SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, zBuf, *(*int32)(unsafe.Pointer(bp + 28 /* nByte */))))
	} else {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}
	tcl.XTcl_Free(tls, zBuf)

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

// sqlite3_blob_write HANDLE OFFSET DATA ?NDATA?
//
//   This command is used to test the sqlite3_blob_write() in ways that
//   the Tcl channel interface does not. The first argument should
//   be the name of a valid channel created by the [incrblob] method
//   of a database handle. This function calls sqlite3_blob_write()
//   to write the DATA byte-array to the underlying SQLite blob handle.
//   at offset OFFSET.
//
//   On success, an empty string is returned. On failure, the interpreter
//   result is set to the text representation of the returned error code
//   (i.e. "SQLITE_NOMEM") and a Tcl exception is thrown.
func test_blob_write(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_blob.c:273:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pBlob uintptr at bp, 8

	// var iOffset int32 at bp+8, 4

	var rc int32
	var zBuf uintptr
	// var nBuf int32 at bp+12, 4

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29295 /* "HANDLE OFFSET DA..." */)
		return TCL_ERROR
	}

	if blobHandleFromObj1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) {
		return TCL_ERROR
	}

	zBuf = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+12 /* &nBuf */)
	if objc == 5 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+12) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_blob_write(tls, *(*uintptr)(unsafe.Pointer(bp /* pBlob */)), zBuf, *(*int32)(unsafe.Pointer(bp + 12 /* nBuf */)), *(*int32)(unsafe.Pointer(bp + 8 /* iOffset */)))
	if rc != SQLITE_OK {
		tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	}

	return func() int32 {
		if rc == SQLITE_OK {
			return TCL_OK
		}
		return TCL_ERROR
	}()
}

// Register commands with the TCL interpreter.
func Sqlitetest_blob_Init(tls *libc.TLS, interp uintptr) int32 { /* test_blob.c:312:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd5))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd5[i].FzName, aObjCmd5[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd5 = [5]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 29322 /* "sqlite3_blob_ope..." */, FxProc: 0},
	{FzName: ts + 29340 /* "sqlite3_blob_clo..." */, FxProc: 0},
	{FzName: ts + 29359 /* "sqlite3_blob_byt..." */, FxProc: 0},
	{FzName: ts + 29378 /* "sqlite3_blob_rea..." */, FxProc: 0},
	{FzName: ts + 29396 /* "sqlite3_blob_wri..." */, FxProc: 0},
} /* test_blob.c:317:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Usage: sqlite3_shared_cache_report
//
// Return a list of file that are shared and the number of
// references to each file.
func sqlite3BtreeSharedCacheReport(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_btree.c:29:19: */
	var pBt uintptr
	var pRet uintptr = tcl.XTcl_NewObj(tls)
	for pBt = sqlite3.Xsqlite3SharedCacheList; pBt != 0; pBt = (*BtShared)(unsafe.Pointer(pBt)).FpNext {
		var zFile uintptr = sqlite3.Xsqlite3PagerFilename(tls, (*BtShared)(unsafe.Pointer(pBt)).FpPager, 1)
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, zFile, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, (*BtShared)(unsafe.Pointer(pBt)).FnRef))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// Print debugging information about all cursors to standard output.
func sqlite3BtreeCursorList(tls *libc.TLS, p uintptr) { /* test_btree.c:52:6: */
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// Macro to stringify the results of the evaluation a pre-processor
// macro. i.e. so that STRINGVALUE(SQLITE_NOMEM) -> "7".

// This routine sets entries in the global ::sqlite_options() array variable
// according to the compile-time configuration of the database.  Test
// procedures use this to determine when tests should be omitted.
func set_options(tls *libc.TLS, interp uintptr) { /* test_config.c:47:13: */
	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29430 /* "malloc_usable_si..." */, ts+29449, /* "1" */
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29451 /* "rowid32" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29459 /* "casesensitivelik..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29477 /* "configslower" */, ts+29490 /* "1.0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29494 /* "curdir" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29501 /* "win32malloc" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29513 /* "debug" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29519 /* "default_ckptfull..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29541 /* "direct_read" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29553 /* "dirsync" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29561 /* "lfs" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29565 /* "pagecache_overfl..." */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29590 /* "mmap" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29595, /* "worker_threads" */
		ts+29610 /* "8" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29612 /* "memdebug" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29621 /* "8_3_names" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29631 /* "cursorhints" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29643 /* "hiddencolumns" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+14299 /* "deserialize" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29657 /* "mathlib" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29665 /* "mem3" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29670 /* "mem5" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29675 /* "offset_sql_func" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+14407 /* "preupdate" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29691 /* "snapshot" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29700 /* "mutex" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29706 /* "mutex_noop" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29717 /* "altertable" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+1957 /* "analyze" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29728 /* "api_armor" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29738 /* "atomicwrite" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29750 /* "geopoly" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29758 /* "json1" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29764 /* "has_codec" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29774 /* "like_match_blobs" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+10953 /* "attach" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29791 /* "auth" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29796 /* "autoinc" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+13883 /* "autoindex" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29804 /* "autoreset" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29814 /* "autovacuum" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29825, /* "default_autovacu..." */
		ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29844 /* "between_opt" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29856 /* "builtin_test" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29869 /* "bloblit" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29877 /* "cast" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29882 /* "check" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29888 /* "cte" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29892 /* "columnmetadata" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29907 /* "oversize_cell_ch..." */, ts+15020, /* "0" */
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29927 /* "compileoption_di..." */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+14278 /* "complete" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29947 /* "compound" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29956 /* "conflict" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29965 /* "crashtest" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29975 /* "datetime" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29984 /* "decltype" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+29993 /* "deprecated" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30004 /* "diskio" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+4974 /* "explain" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30011 /* "floatingpoint" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30025 /* "foreignkey" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30036 /* "fts1" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30041 /* "fts2" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30046 /* "fts3" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30051 /* "fts5" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30056 /* "fts3_unicode" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30069 /* "fts4_deferred" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30083 /* "gettable" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30092 /* "icu" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30096 /* "icu_collations" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+11702 /* "incrblob" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30111 /* "integrityck" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30123 /* "legacyformat" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30136 /* "like_opt" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30145 /* "load_ext" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30154 /* "localtime" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30164 /* "lookaside" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30174, /* "long_double" */
		func() uintptr {
			if uint64(unsafe.Sizeof(float64(0))) > uint64(unsafe.Sizeof(float64(0))) {
				return ts + 29449 /* "1" */
			}
			return ts + 15020 /* "0" */
		}(),
		TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30186 /* "memorydb" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30195 /* "memorymanage" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30208 /* "mergesort" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30218 /* "null_trim" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30228 /* "or_opt" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30235 /* "rbu" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30239 /* "pager_pragmas" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30253 /* "pragma" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+10396 /* "progress" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30260 /* "reindex" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30268 /* "rtree" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30274 /* "rtree_int_only" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30289 /* "schema_pragmas" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30304 /* "schema_version" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30319 /* "session" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+19546 /* "stat4" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30327 /* "stmtvtab" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30336 /* "scanstatus" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30347 /* "lock_proxy_pragm..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30366 /* "prefer_proxy_loc..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30387 /* "shared_cache" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30400 /* "subquery" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30409 /* "tclvar" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30416, /* "threadsafe" */
		func() uintptr {
			if 1 != 0 {
				return ts + 29449 /* "1" */
			}
			return ts + 15020 /* "0" */
		}(), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30427, /* "threadsafe1" */
		func() uintptr {
			if SQLITE_THREADSAFE == 1 {
				return ts + 29449 /* "1" */
			}
			return ts + 15020 /* "0" */
		}(), TCL_GLOBAL_ONLY)
	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30439, /* "threadsafe2" */
		func() uintptr {
			if SQLITE_THREADSAFE == 2 {
				return ts + 29449 /* "1" */
			}
			return ts + 15020 /* "0" */
		}(), TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30451 /* "tempdb" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+14492 /* "trace" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30458 /* "trigger" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30466 /* "truncate_opt" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+16565 /* "utf16" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30479 /* "vacuum" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30486 /* "view" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30491 /* "vtab" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30496 /* "wal" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30500 /* "wsd" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30504 /* "update_delete_li..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+14519 /* "unlock_notify" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30524 /* "fast_secure_dele..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30543 /* "secure_delete" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30557 /* "userauth" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30566 /* "multiplex_ext_ov..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30590 /* "yytrackmaxstackd..." */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30611 /* "sqllog" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30618 /* "uri_00_error" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30631 /* "normalize" */, ts+15020 /* "0" */, TCL_GLOBAL_ONLY)

	tcl.XTcl_SetVar2(tls, interp, ts+29415 /* "sqlite_options" */, ts+30641 /* "windowfunc" */, ts+29449 /* "1" */, TCL_GLOBAL_ONLY)

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30652 /* "SQLITE_MAX_LENGT..." */, uintptr(unsafe.Pointer(&cv_MAX_LENGTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30670 /* "SQLITE_MAX_COLUM..." */, uintptr(unsafe.Pointer(&cv_MAX_COLUMN)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30688 /* "SQLITE_MAX_SQL_L..." */, uintptr(unsafe.Pointer(&cv_MAX_SQL_LENGTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30710 /* "SQLITE_MAX_EXPR_..." */, uintptr(unsafe.Pointer(&cv_MAX_EXPR_DEPTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30732 /* "SQLITE_MAX_COMPO..." */, uintptr(unsafe.Pointer(&cv_MAX_COMPOUND_SELECT)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30759 /* "SQLITE_MAX_VDBE_..." */, uintptr(unsafe.Pointer(&cv_MAX_VDBE_OP)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30778 /* "SQLITE_MAX_FUNCT..." */, uintptr(unsafe.Pointer(&cv_MAX_FUNCTION_ARG)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30802 /* "SQLITE_MAX_VARIA..." */, uintptr(unsafe.Pointer(&cv_MAX_VARIABLE_NUMBER)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30829 /* "SQLITE_MAX_PAGE_..." */, uintptr(unsafe.Pointer(&cv_MAX_PAGE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30850 /* "SQLITE_MAX_PAGE_..." */, uintptr(unsafe.Pointer(&cv_MAX_PAGE_COUNT)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30872 /* "SQLITE_MAX_LIKE_..." */, uintptr(unsafe.Pointer(&cv_MAX_LIKE_PATTERN_LENGTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30903 /* "SQLITE_MAX_TRIGG..." */, uintptr(unsafe.Pointer(&cv_MAX_TRIGGER_DEPTH)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30928 /* "SQLITE_DEFAULT_C..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_CACHE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30954 /* "SQLITE_DEFAULT_P..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_PAGE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+30979 /* "SQLITE_DEFAULT_F..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_FILE_FORMAT)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+31006 /* "SQLITE_DEFAULT_S..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_SYNCHRONOUS)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+31033 /* "SQLITE_DEFAULT_W..." */, uintptr(unsafe.Pointer(&cv_DEFAULT_WAL_SYNCHRONOUS)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+31064 /* "SQLITE_MAX_ATTAC..." */, uintptr(unsafe.Pointer(&cv_MAX_ATTACHED)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+31084 /* "SQLITE_MAX_DEFAU..." */, uintptr(unsafe.Pointer(&cv_MAX_DEFAULT_PAGE_SIZE)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+31113 /* "SQLITE_MAX_WORKE..." */, uintptr(unsafe.Pointer(&cv_MAX_WORKER_THREADS)), TCL_LINK_INT|TCL_LINK_READ_ONLY)
	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+31139 /* "TEMP_STORE" */, uintptr(unsafe.Pointer(&cv_TEMP_STORE)),
			TCL_LINK_INT|TCL_LINK_READ_ONLY)

	}

	{
		tcl.XTcl_LinkVar(tls, interp, ts+31150 /* "__GNUC__" */, uintptr(unsafe.Pointer(&cv___GNUC__)),
			TCL_LINK_INT|TCL_LINK_READ_ONLY)

	}
}

var cv_MAX_LENGTH int32 = SQLITE_MAX_LENGTH                           /* test_config.c:791:3 */
var cv_MAX_COLUMN int32 = SQLITE_MAX_COLUMN                           /* test_config.c:792:3 */
var cv_MAX_SQL_LENGTH int32 = SQLITE_MAX_SQL_LENGTH                   /* test_config.c:793:3 */
var cv_MAX_EXPR_DEPTH int32 = SQLITE_MAX_EXPR_DEPTH                   /* test_config.c:794:3 */
var cv_MAX_COMPOUND_SELECT int32 = SQLITE_MAX_COMPOUND_SELECT         /* test_config.c:795:3 */
var cv_MAX_VDBE_OP int32 = SQLITE_MAX_VDBE_OP                         /* test_config.c:796:3 */
var cv_MAX_FUNCTION_ARG int32 = SQLITE_MAX_FUNCTION_ARG               /* test_config.c:797:3 */
var cv_MAX_VARIABLE_NUMBER int32 = SQLITE_MAX_VARIABLE_NUMBER         /* test_config.c:798:3 */
var cv_MAX_PAGE_SIZE int32 = SQLITE_MAX_PAGE_SIZE                     /* test_config.c:799:3 */
var cv_MAX_PAGE_COUNT int32 = SQLITE_MAX_PAGE_COUNT                   /* test_config.c:800:3 */
var cv_MAX_LIKE_PATTERN_LENGTH int32 = SQLITE_MAX_LIKE_PATTERN_LENGTH /* test_config.c:801:3 */
var cv_MAX_TRIGGER_DEPTH int32 = SQLITE_MAX_TRIGGER_DEPTH             /* test_config.c:802:3 */
var cv_DEFAULT_CACHE_SIZE int32 = -2000                               /* test_config.c:803:3 */
var cv_DEFAULT_PAGE_SIZE int32 = SQLITE_DEFAULT_PAGE_SIZE             /* test_config.c:804:3 */
var cv_DEFAULT_FILE_FORMAT int32 = SQLITE_DEFAULT_FILE_FORMAT         /* test_config.c:805:3 */
var cv_DEFAULT_SYNCHRONOUS int32 = SQLITE_DEFAULT_SYNCHRONOUS         /* test_config.c:806:3 */
var cv_DEFAULT_WAL_SYNCHRONOUS int32 = SQLITE_DEFAULT_SYNCHRONOUS     /* test_config.c:807:3 */
var cv_MAX_ATTACHED int32 = SQLITE_MAX_ATTACHED                       /* test_config.c:808:3 */
var cv_MAX_DEFAULT_PAGE_SIZE int32 = SQLITE_MAX_DEFAULT_PAGE_SIZE     /* test_config.c:809:3 */
var cv_MAX_WORKER_THREADS int32 = SQLITE_MAX_WORKER_THREADS           /* test_config.c:810:3 */
var cv_TEMP_STORE int32 = SQLITE_TEMP_STORE                           /* test_config.c:813:22 */
var cv___GNUC__ int32 = 1                                             /* test_config.c:827:22 */

// Register commands with the TCL interpreter.
func Sqliteconfig_Init(tls *libc.TLS, interp uintptr) int32 { /* test_config.c:838:5: */
	set_options(tls, interp)
	return TCL_OK
}

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// The following #defines are copied from test_multiplex.c

// This routine is a copy of (most of) the code from SQLite function
// sqlite3FileSuffix3(). It modifies the filename in buffer z in the
// same way as SQLite does when in 8.3 filenames mode.
func sqlite3Delete83Name(tls *libc.TLS, z uintptr) { /* test_delete.c:46:13: */
	var i int32
	var sz int32
	sz = int32(libc.Xstrlen(tls, z))
	for i = sz - 1; i > 0 && int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '/' && int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) != '.'; i-- {
	}
	if int32(*(*int8)(unsafe.Pointer(z + uintptr(i)))) == '.' && sz > i+4 {
		libc.Xmemmove(tls, z+uintptr(i+1), z+uintptr(sz-3), uint64(4))
	}
}

// zFile is a filename. Assuming no error occurs, if this file exists,
// set *pbExists to true and unlink it. Or, if the file does not exist,
// set *pbExists to false before returning.
//
// If an error occurs, non-zero is returned. Or, if no error occurs, zero.
func sqlite3DeleteUnlinkIfExists(tls *libc.TLS, pVfs uintptr, zFile uintptr, pbExists uintptr) int32 { /* test_delete.c:60:12: */
	var rc int32 = SQLITE_ERROR

	rc = libc.Xaccess(tls, zFile, F_OK)
	if rc != 0 {
		if *(*int32)(unsafe.Pointer(libc.X__error(tls))) == ENOENT {
			if pbExists != 0 {
				*(*int32)(unsafe.Pointer(pbExists)) = 0
			}
			rc = SQLITE_OK
		}
	} else {
		if pbExists != 0 {
			*(*int32)(unsafe.Pointer(pbExists)) = 1
		}
		rc = libc.Xunlink(tls, zFile)
	}
	return rc
}

// Delete the database file identified by the string argument passed to this
// function. The string must contain a filename, not an SQLite URI.
func sqlite3_delete_database(tls *libc.TLS, zFile uintptr) int32 { /* test_delete.c:95:16: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	var zBuf uintptr // Buffer to sprintf() filenames to
	var nBuf int32   // Size of buffer in bytes
	var rc int32 = 0 // System error code
	var i int32      // Iterate through azFmt[] and aMFile[]

	*(*[4]uintptr)(unsafe.Pointer(bp + 24 /* azFmt */)) = [4]uintptr{ts /* "%s" */, ts + 31159 /* "%s-journal" */, ts + 31170 /* "%s-wal" */, ts + 31177 /* "%s-shm" */}

	*(*[6]MFile)(unsafe.Pointer(bp + 56 /* aMFile */)) = [6]MFile{
		{FzFmt: ts + 31184 /* "%s%03d" */},
		{FzFmt: ts + 31191 /* "%s-journal%03d" */},
		{FzFmt: ts + 31206 /* "%s-wal%03d" */},
		{FzFmt: ts + 31184 /* "%s%03d" */, Fb83: 1},
		{FzFmt: ts + 31191 /* "%s-journal%03d" */, FiOffset: SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET, Fb83: 1},
		{FzFmt: ts + 31206 /* "%s-wal%03d" */, FiOffset: SQLITE_MULTIPLEX_WAL_8_3_OFFSET, Fb83: 1},
	}

	var pVfs uintptr = uintptr(0)

	// Allocate a buffer large enough for any of the files that need to be
	// deleted.
	nBuf = int32(libc.Xstrlen(tls, zFile)) + 100
	zBuf = sqlite3.Xsqlite3_malloc(tls, nBuf)
	if zBuf == uintptr(0) {
		return SQLITE_NOMEM
	}

	// Delete both the regular and 8.3 filenames versions of the database,
	// journal, wal and shm files.
	for i = 0; rc == 0 && uint64(i) < uint64(unsafe.Sizeof([4]uintptr{}))/uint64(unsafe.Sizeof(uintptr(0))); i++ {
		sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, *(*uintptr)(unsafe.Pointer(bp + 24 /* &azFmt[0] */ + uintptr(i)*8)), libc.VaList(bp, zFile))
		rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		if rc == 0 && i != 0 {
			sqlite3Delete83Name(tls, zBuf)
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, uintptr(0))
		}
	}

	// Delete any multiplexor files
	for i = 0; rc == 0 && uint64(i) < uint64(unsafe.Sizeof([6]MFile{}))/uint64(unsafe.Sizeof(MFile{})); i++ {
		var p uintptr = bp + 56 + uintptr(i)*16
		var iChunk int32
		for iChunk = 1; iChunk <= MX_CHUNK_NUMBER; iChunk++ {
			// var bExists int32 at bp+152, 4

			sqlite3.Xsqlite3_snprintf(tls, nBuf, zBuf, (*MFile)(unsafe.Pointer(p)).FzFmt, libc.VaList(bp+8, zFile, iChunk+(*MFile)(unsafe.Pointer(p)).FiOffset))
			if (*MFile)(unsafe.Pointer(p)).Fb83 != 0 {
				sqlite3Delete83Name(tls, zBuf)
			}
			rc = sqlite3DeleteUnlinkIfExists(tls, pVfs, zBuf, bp+152 /* &bExists */)
			if *(*int32)(unsafe.Pointer(bp + 152)) == 0 || rc != 0 {
				break
			}
		}
	}

	sqlite3.Xsqlite3_free(tls, zBuf)
	return func() int32 {
		if rc != 0 {
			return SQLITE_ERROR
		}
		return SQLITE_OK
	}()
}

type MFile = struct {
	FzFmt    uintptr
	FiOffset int32
	Fb83     int32
} /* test_delete.c:105:3 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func Sqlitetest_demovfs_Init(tls *libc.TLS, interp uintptr) int32 { /* test_demovfs.c:686:5: */
	return TCL_OK
}

// Maximum pathname length supported by the devsym backend.

// Name used to identify this VFS.

type devsym_file1 = struct {
	Fbase  sqlite3_file
	FpReal uintptr
} /* test_devsym.c:33:9 */

// Maximum pathname length supported by the devsym backend.

// Name used to identify this VFS.

type devsym_file = devsym_file1 /* test_devsym.c:33:28 */

type DevsymGlobal = struct {
	FpVfs        uintptr
	FiDeviceChar int32
	FiSectorSize int32
	FnWriteCrash int32
	F__ccgo_pad1 [4]byte
} /* test_devsym.c:76:1 */

var g1 = DevsymGlobal{FiSectorSize: 512} /* test_devsym.c:82:21 */

// Close an devsym-file.
func devsymClose(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:87:12: */
	var p uintptr = pFile
	sqlite3.Xsqlite3OsClose(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
	return SQLITE_OK
}

// Read data from an devsym-file.
func devsymRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:96:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Write data to an devsym-file.
func devsymWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:109:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Truncate an devsym-file.
func devsymTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_devsym.c:122:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsTruncate(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, size)
}

// Sync an devsym-file.
func devsymSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_devsym.c:130:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSync(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags)
}

// Return the current file-size of an devsym-file.
func devsymFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_devsym.c:138:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an devsym-file.
func devsymLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_devsym.c:146:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

// Unlock an devsym-file.
func devsymUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_devsym.c:154:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsUnlock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, eLock)
}

// Check if another file-handle holds a RESERVED lock on an devsym-file.
func devsymCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_devsym.c:162:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

// File control method. For custom operations on an devsym-file.
func devsymFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_devsym.c:170:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileControl(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

// Return the sector-size in bytes for an devsym-file.
func devsymSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:178:12: */
	return g1.FiSectorSize
}

// Return the device characteristic flags supported by an devsym-file.
func devsymDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:185:12: */
	return g1.FiDeviceChar
}

// Shared-memory methods are all pass-thrus.
func devsymShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_devsym.c:192:12: */
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmLock})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
}

func devsymShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 { /* test_devsym.c:196:12: */
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmMap})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, pp)
}

func devsymShmBarrier(tls *libc.TLS, pFile uintptr) { /* test_devsym.c:206:13: */
	var p uintptr = pFile
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmBarrier})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

func devsymShmUnmap(tls *libc.TLS, pFile uintptr, delFlag int32) int32 { /* test_devsym.c:210:12: */
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmUnmap})).f(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, delFlag)
}

// Open an devsym file handle.
func devsymOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_devsym.c:220:12: */
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = p + 1*16
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&devsym_io_methods))
	}
	return rc
}

var devsym_io_methods = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test_devsym.c:227:27 */

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func devsymDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_devsym.c:262:12: */
	return sqlite3.Xsqlite3OsDelete(tls, g1.FpVfs, zPath, dirSync)
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func devsymAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_devsym.c:270:12: */
	return sqlite3.Xsqlite3OsAccess(tls, g1.FpVfs, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (DEVSYM_MAX_PATHNAME+1) bytes.
func devsymFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_devsym.c:284:12: */
	return sqlite3.Xsqlite3OsFullPathname(tls, g1.FpVfs, zPath, nOut, zOut)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func devsymRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_devsym.c:329:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, g1.FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func devsymSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_devsym.c:337:12: */
	return sqlite3.Xsqlite3OsSleep(tls, g1.FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func devsymCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_devsym.c:344:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FxCurrentTime})).f(tls, g1.FpVfs, pTimeOut)
}

// Return the sector-size in bytes for an writecrash-file.
func writecrashSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:351:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

// Return the device characteristic flags supported by an writecrash-file.
func writecrashDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_devsym.c:359:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal)
}

// Write data to an writecrash-file.
func writecrashWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_devsym.c:367:12: */
	var p uintptr = pFile
	if g1.FnWriteCrash > 0 {
		g1.FnWriteCrash--
		if g1.FnWriteCrash == 0 {
			libc.Xabort(tls)
		}
	}
	return sqlite3.Xsqlite3OsWrite(tls, (*devsym_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

// Open an writecrash file handle.
func writecrashOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_devsym.c:384:12: */
	var rc int32
	var p uintptr = pFile
	(*devsym_file)(unsafe.Pointer(p)).FpReal = p + 1*16
	rc = sqlite3.Xsqlite3OsOpen(tls, g1.FpVfs, zName, (*devsym_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*devsym_file)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&writecrash_io_methods))
	}
	return rc
}

var writecrash_io_methods = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test_devsym.c:391:27 */

var devsym_vfs = sqlite3_vfs{
	FiVersion:      2,                                   // iVersion
	FszOsFile:      int32(unsafe.Sizeof(devsym_file{})), // szOsFile
	FmxPathname:    DEVSYM_MAX_PATHNAME,                 // pNext
	FzName:         ts + 31217,                          /* "devsym" */ // pAppData
	FxOpen:         0,                                   // xOpen
	FxDelete:       0,                                   // xDelete
	FxAccess:       0,                                   // xAccess
	FxFullPathname: 0,                                   // xDlClose
	FxRandomness:   0,                                   // xRandomness
	FxSleep:        0,                                   // xSleep
	FxCurrentTime:  0,                                   // xCurrentTimeInt64
} /* test_devsym.c:421:20 */

var writecrash_vfs = sqlite3_vfs{
	FiVersion:      2,                                   // iVersion
	FszOsFile:      int32(unsafe.Sizeof(devsym_file{})), // szOsFile
	FmxPathname:    DEVSYM_MAX_PATHNAME,                 // pNext
	FzName:         ts + 31224,                          /* "writecrash" */ // pAppData
	FxOpen:         0,                                   // xOpen
	FxDelete:       0,                                   // xDelete
	FxAccess:       0,                                   // xAccess
	FxFullPathname: 0,                                   // xDlClose
	FxRandomness:   0,                                   // xRandomness
	FxSleep:        0,                                   // xSleep
	FxCurrentTime:  0,                                   // xCurrentTimeInt64
} /* test_devsym.c:450:20 */

// This procedure registers the devsym vfs with SQLite. If the argument is
// true, the devsym vfs becomes the new default vfs. It is the only publicly
// available function in this file.
func devsym_register(tls *libc.TLS, iDeviceChar int32, iSectorSize int32) { /* test_devsym.c:485:6: */

	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	if iDeviceChar >= 0 {
		g1.FiDeviceChar = iDeviceChar
	} else {
		g1.FiDeviceChar = 0
	}
	if iSectorSize >= 0 {
		g1.FiSectorSize = iSectorSize
	} else {
		g1.FiSectorSize = 512
	}
}

func devsym_unregister(tls *libc.TLS) { /* test_devsym.c:506:6: */
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&devsym_vfs)))
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&writecrash_vfs)))
	g1.FpVfs = uintptr(0)
	g1.FiDeviceChar = 0
	g1.FiSectorSize = 0
}

func devsym_crash_on_write(tls *libc.TLS, nWrite int32) { /* test_devsym.c:514:6: */
	if g1.FpVfs == uintptr(0) {
		g1.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 4)) += (*sqlite3_vfs)(unsafe.Pointer(g1.FpVfs)).FszOsFile
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&devsym_vfs)), 0)
		sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&writecrash_vfs)), 0)
	}
	g1.FnWriteCrash = nWrite
}

// The next short section of defines are only done when not running on Windows
// or some other strange platform.

type Tcl_StatBuf = stat /* tcl.h:470:25 */

type fs_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
	FzDb  uintptr
	FzTbl uintptr
} /* test_fs.c:96:9 */

type fs_vtab = fs_vtab1 /* test_fs.c:96:24 */
type fs_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpStmt  uintptr
	FzBuf   uintptr
	FnBuf   int32
	FnAlloc int32
} /* test_fs.c:97:9 */

type fs_cursor = fs_cursor1 /* test_fs.c:97:26 */

// ************************************************************************
//
// Start of fsdir implementation.
type FsdirVtab1 = struct{ Fbase sqlite3_vtab } /* test_fs.c:121:9 */

// ************************************************************************
//
// Start of fsdir implementation.
type FsdirVtab = FsdirVtab1 /* test_fs.c:121:26 */
type FsdirCsr1 = struct {
	Fbase   sqlite3_vtab_cursor
	FzDir   uintptr
	FpDir   uintptr
	FiRowid sqlite3_int64
	FpEntry uintptr
} /* test_fs.c:122:9 */

type FsdirCsr = FsdirCsr1 /* test_fs.c:122:25 */

// This function is the implementation of both the xConnect and xCreate
// methods of the fsdir virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fsdirConnect1(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:146:12: */
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+28965 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FsdirVtab{})))
	if !(pTab != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pTab, 0, uint64(unsafe.Sizeof(FsdirVtab{})))

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+31235 /* "CREATE TABLE xyz..." */)

	return SQLITE_OK
}

// xDestroy/xDisconnect implementation.
func fsdirDisconnect1(tls *libc.TLS, pVtab uintptr) int32 { /* test_fs.c:173:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// xBestIndex implementation. The only constraint supported is:
//
//   (dir = ?)
func fsdirBestIndex1(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:183:12: */
	var ii int32

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0 && (*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0 && int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			var pUsage uintptr
			pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return SQLITE_OK
}

// xOpen implementation.
//
// Open a new fsdir cursor.
func fsdirOpen1(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:209:12: */
	var pCur uintptr
	// Allocate an extra 256 bytes because it is undefined how big dirent.d_name
	// is and we need enough space.  Linux provides plenty already, but
	// Solaris only provides one byte.
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(FsdirCsr{}))+uint64(256)))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(FsdirCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Close a fsdir cursor.
func fsdirClose1(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:224:12: */
	var pCur uintptr = cur
	if (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir != 0 {
		libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FpDir)
	}
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCur)).FzDir)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Skip the cursor to the next entry.
func fsdirNext1(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:235:12: */
	var pCsr uintptr = cur

	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry = libc.Xreaddir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry == uintptr(0) {
			libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
			(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
		}
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid++
	}

	return SQLITE_OK
}

// xFilter method implementation.
func fsdirFilter1(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:253:12: */
	var pCsr uintptr = pVtabCursor
	var zDir uintptr
	var nDir int32

	if idxNum != 1 || argc != 1 {
		return SQLITE_ERROR
	}

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	sqlite3.Xsqlite3_free(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir != 0 {
		libc.Xclosedir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir)
		(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = uintptr(0)
	}

	zDir = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	nDir = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	(*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir = sqlite3.Xsqlite3_malloc(tls, nDir+1)
	if (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemcpy(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, zDir, uint64(nDir+1))

	(*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir = libc.Xopendir(tls, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir)
	return fsdirNext1(tls, pVtabCursor)
}

// xEof method implementation.
func fsdirEof1(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:287:12: */
	var pCsr uintptr = cur
	return libc.Bool32((*FsdirCsr)(unsafe.Pointer(pCsr)).FpDir == uintptr(0))
}

// xColumn method implementation.
func fsdirColumn1(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:295:12: */
	var pCsr uintptr = cur
	switch i {
	case 0: // dir
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FzDir, -1, uintptr(0))
		break

	case 1: // name
		sqlite3.Xsqlite3_result_text(tls, ctx, (*FsdirCsr)(unsafe.Pointer(pCsr)).FpEntry+24, -1, libc.UintptrFromInt32(-1))
		break

	default:

	}

	return SQLITE_OK
}

// xRowid method implementation.
func fsdirRowid1(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:316:12: */
	var pCsr uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*FsdirCsr)(unsafe.Pointer(pCsr)).FiRowid
	return SQLITE_OK
}

//
// End of fsdir implementation.
//

// ************************************************************************
//
// Start of fstree implementation.
type FstreeVtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
} /* test_fs.c:328:9 */

//
// End of fsdir implementation.
//

// ************************************************************************
//
// Start of fstree implementation.
type FstreeVtab = FstreeVtab1 /* test_fs.c:328:27 */
type FstreeCsr1 = struct {
	Fbase        sqlite3_vtab_cursor
	FpStmt       uintptr
	Ffd          int32
	F__ccgo_pad1 [4]byte
} /* test_fs.c:329:9 */

type FstreeCsr = FstreeCsr1 /* test_fs.c:329:26 */

// This function is the implementation of both the xConnect and xCreate
// methods of the fstree virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fstreeConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:352:12: */
	var pTab uintptr

	if argc != 3 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+28965 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}

	pTab = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeVtab{})))
	if !(pTab != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pTab, 0, uint64(unsafe.Sizeof(FstreeVtab{})))
	(*FstreeVtab)(unsafe.Pointer(pTab)).Fdb = db

	*(*uintptr)(unsafe.Pointer(ppVtab)) = pTab
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+31264 /* "CREATE TABLE xyz..." */)

	return SQLITE_OK
}

// xDestroy/xDisconnect implementation.
func fstreeDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_fs.c:380:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// xBestIndex implementation. The only constraint supported is:
//
//   (dir = ?)
func fstreeBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:390:12: */
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var p uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(p)).FiColumn == 0 && (*sqlite3_index_constraint)(unsafe.Pointer(p)).Fusable != 0 && (int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_GLOB ||
			int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_LIKE ||
			int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ) {
			var pUsage uintptr
			pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = int32((*sqlite3_index_constraint)(unsafe.Pointer(p)).Fop)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 100000.0
			return SQLITE_OK
		}
	}

	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1000000000.0
	return SQLITE_OK
}

// xOpen implementation.
//
// Open a new fstree cursor.
func fstreeOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:418:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(FstreeCsr{})))
	if pCur == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(FstreeCsr{})))
	(*FstreeCsr)(unsafe.Pointer(pCur)).Ffd = -1
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

func fstreeCloseFd(tls *libc.TLS, pCsr uintptr) { /* test_fs.c:428:13: */
	if (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd >= 0 {
		libc.Xclose(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = -1
	}
}

// Close a fstree cursor.
func fstreeClose(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:438:12: */
	var pCsr uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_free(tls, pCsr)
	return SQLITE_OK
}

// Skip the cursor to the next entry.
func fstreeNext(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:449:12: */
	var pCsr uintptr = cur
	var rc int32

	fstreeCloseFd(tls, pCsr)
	rc = sqlite3.Xsqlite3_step(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	if rc != SQLITE_ROW {
		rc = sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
		(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	} else {
		rc = SQLITE_OK
		(*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd = libc.Xopen(tls, sqlite3.Xsqlite3_column_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0), O_RDONLY, 0)
	}

	return rc
}

// xFilter method implementation.
func fstreeFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:469:12: */
	bp := tls.Alloc(2)
	defer tls.Free(2)

	var pCsr uintptr = pVtabCursor
	var pTab uintptr = (*FstreeCsr)(unsafe.Pointer(pCsr)).Fbase.FpVtab
	var rc int32
	var zSql uintptr = ts + 31300 /* "WITH r(d) AS (  ..." */
	var zRoot uintptr
	var nRoot int32
	var zPrefix uintptr
	var nPrefix int32
	var zDir uintptr
	var nDir int32
	*(*[2]int8)(unsafe.Pointer(bp /* aWild */)) = [2]int8{int8(0), int8(0)}

	zRoot = ts + 31532 /* "/" */
	nRoot = 1
	zPrefix = ts + 584 /* "" */
	nPrefix = 0

	zDir = zRoot
	nDir = nRoot

	fstreeCloseFd(tls, pCsr)
	sqlite3.Xsqlite3_finalize(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt)
	(*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt = uintptr(0)
	rc = sqlite3.Xsqlite3_prepare_v2(tls, (*FstreeVtab)(unsafe.Pointer(pTab)).Fdb, zSql, -1, pCsr+8, uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	if idxNum != 0 {
		var zQuery uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		switch idxNum {
		case SQLITE_INDEX_CONSTRAINT_GLOB:
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */)) = int8('*')
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + 1)) = int8('?')
			break
			fallthrough
		case SQLITE_INDEX_CONSTRAINT_LIKE:
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */)) = int8('_')
			*(*int8)(unsafe.Pointer(bp /* &aWild[0] */ + 1)) = int8('%')
			break
		}

		if sqlite3.Xsqlite3_strnicmp(tls, zQuery, zPrefix, nPrefix) == 0 {
			var i int32
			for i = nPrefix; *(*int8)(unsafe.Pointer(zQuery + uintptr(i))) != 0; i++ {
				if int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp))) || int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == int32(*(*int8)(unsafe.Pointer(bp + 1))) {
					break
				}
				if int32(*(*int8)(unsafe.Pointer(zQuery + uintptr(i)))) == '/' {
					nDir = i
				}
			}
			zDir = zQuery
		}
	}
	if nDir == 0 {
		nDir = 1
	}

	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 1, zDir, nDir, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 2, zRoot, nRoot, libc.UintptrFromInt32(-1))
	sqlite3.Xsqlite3_bind_text(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 3, zPrefix, nPrefix, libc.UintptrFromInt32(-1))

	return fstreeNext(tls, pVtabCursor)
}

// xEof method implementation.
func fstreeEof(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:557:12: */
	var pCsr uintptr = cur
	return libc.Bool32((*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt == uintptr(0))
}

// xColumn method implementation.
func fstreeColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:565:12: */
	bp := tls.Alloc(224)
	defer tls.Free(224)

	var pCsr uintptr = cur
	if i == 0 { // path
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).FpStmt, 0))
	} else {
		// var sBuf stat at bp, 224

		libc.Xfstat(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, bp /* &sBuf */)

		if int32((*stat)(unsafe.Pointer(bp)).Fst_mode)&0170000 == 0100000 {
			if i == 1 {
				sqlite3.Xsqlite3_result_int64(tls, ctx, int64((*stat)(unsafe.Pointer(bp /* &sBuf */)).Fst_size))
			} else {
				var nRead int32
				var aBuf uintptr = sqlite3.Xsqlite3_malloc(tls, int32((*stat)(unsafe.Pointer(bp)).Fst_mode)+1)
				if !(aBuf != 0) {
					return SQLITE_NOMEM
				}
				nRead = int32(libc.Xread(tls, (*FstreeCsr)(unsafe.Pointer(pCsr)).Ffd, aBuf, uint64((*stat)(unsafe.Pointer(bp /* &sBuf */)).Fst_mode)))
				if nRead != int32((*stat)(unsafe.Pointer(bp)).Fst_mode) {
					return SQLITE_IOERR
				}
				sqlite3.Xsqlite3_result_blob(tls, ctx, aBuf, nRead, libc.UintptrFromInt32(-1))
				sqlite3.Xsqlite3_free(tls, aBuf)
			}
		}
	}

	return SQLITE_OK
}

// xRowid method implementation.
func fstreeRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:596:12: */
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

//
// End of fstree implementation.
//

// This function is the implementation of both the xConnect and xCreate
// methods of the fs virtual table.
//
// The argv[] array contains the following:
//
//   argv[0]   -> module name  ("fs")
//   argv[1]   -> database name
//   argv[2]   -> table name
//   argv[...] -> other module argument fields.
func fsConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_fs.c:618:12: */
	var pVtab uintptr
	var nByte int32
	var zTbl uintptr
	var zDb uintptr = *(*uintptr)(unsafe.Pointer(argv + 1*8))

	if argc != 4 {
		*(*uintptr)(unsafe.Pointer(pzErr)) = sqlite3.Xsqlite3_mprintf(tls, ts+28965 /* "wrong number of ..." */, 0)
		return SQLITE_ERROR
	}
	zTbl = *(*uintptr)(unsafe.Pointer(argv + 3*8))

	nByte = int32(uint64(unsafe.Sizeof(fs_vtab{})) + uint64(int32(libc.Xstrlen(tls, zTbl))) + uint64(1) + uint64(int32(libc.Xstrlen(tls, zDb))) + uint64(1))
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(nByte))
	if !(pVtab != 0) {
		return SQLITE_NOMEM
	}

	(*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl = pVtab + 1*48
	(*fs_vtab)(unsafe.Pointer(pVtab)).FzDb = (*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl + uintptr(libc.Xstrlen(tls, zTbl)+uint64(1))
	(*fs_vtab)(unsafe.Pointer(pVtab)).Fdb = db
	libc.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzTbl, zTbl, libc.Xstrlen(tls, zTbl))
	libc.Xmemcpy(tls, (*fs_vtab)(unsafe.Pointer(pVtab)).FzDb, zDb, libc.Xstrlen(tls, zDb))
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	sqlite3.Xsqlite3_declare_vtab(tls, db, ts+31534 /* "CREATE TABLE x(p..." */)

	return SQLITE_OK
}

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func fsDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_fs.c:653:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// The xDisconnect and xDestroy methods are also the same

// Open a new fs cursor.
func fsOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_fs.c:662:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(fs_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Close a fs cursor.
func fsClose(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:672:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	sqlite3.Xsqlite3_free(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

func fsNext(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:680:12: */
	var pCur uintptr = cur
	var rc int32

	rc = sqlite3.Xsqlite3_step(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt)
	if rc == SQLITE_ROW || rc == SQLITE_DONE {
		rc = SQLITE_OK
	}

	return rc
}

func fsFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_fs.c:690:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	var rc int32
	var pCur uintptr = pVtabCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab

	if idxNum == 1 {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls,
			ts+31571 /* "SELECT * FROM %Q..." */, libc.VaList(bp, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return SQLITE_NOMEM
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, pCur+8, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_bind_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1, *(*uintptr)(unsafe.Pointer(argv)))
		}
	} else {
		var zStmt uintptr = sqlite3.Xsqlite3_mprintf(tls, ts+3407 /* "SELECT * FROM %Q..." */, libc.VaList(bp+16, (*fs_vtab)(unsafe.Pointer(p)).FzDb, (*fs_vtab)(unsafe.Pointer(p)).FzTbl))
		if !(zStmt != 0) {
			return SQLITE_NOMEM
		}
		rc = sqlite3.Xsqlite3_prepare_v2(tls, (*fs_vtab)(unsafe.Pointer(p)).Fdb, zStmt, -1, pCur+8, uintptr(0))
		sqlite3.Xsqlite3_free(tls, zStmt)
	}

	if rc == SQLITE_OK {
		rc = fsNext(tls, pVtabCursor)
	}
	return rc
}

func fsColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_fs.c:722:12: */
	bp := tls.Alloc(224)
	defer tls.Free(224)

	var pCur uintptr = cur

	if i == 0 {
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0))
	} else {
		var zFile uintptr = sqlite3.Xsqlite3_column_text(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 1)
		// var sbuf stat at bp, 224

		var fd int32
		var n int32
		fd = libc.Xopen(tls, zFile, O_RDONLY, 0)
		if fd < 0 {
			return SQLITE_IOERR
		}
		libc.Xfstat(tls, fd, bp /* &sbuf */)

		if (*stat)(unsafe.Pointer(bp)).Fst_size >= off_t((*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc) {
			var nNew sqlite3_int64 = sqlite3_int64((*stat)(unsafe.Pointer(bp)).Fst_size * int64(2))
			var zNew uintptr
			if nNew < int64(1024) {
				nNew = int64(1024)
			}

			zNew = sqlite3.Xsqlite3Realloc(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint64(nNew))
			if zNew == uintptr(0) {
				libc.Xclose(tls, fd)
				return SQLITE_NOMEM
			}
			(*fs_cursor)(unsafe.Pointer(pCur)).FzBuf = zNew
			(*fs_cursor)(unsafe.Pointer(pCur)).FnAlloc = int32(nNew)
		}

		n = int32(libc.Xread(tls, fd, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, uint64((*stat)(unsafe.Pointer(bp /* &sbuf */)).Fst_size)))
		libc.Xclose(tls, fd)
		if off_t(n) != (*stat)(unsafe.Pointer(bp)).Fst_size {
			return SQLITE_ERROR
		}
		(*fs_cursor)(unsafe.Pointer(pCur)).FnBuf = int32((*stat)(unsafe.Pointer(bp /* &sbuf */)).Fst_size)
		*(*int8)(unsafe.Pointer((*fs_cursor)(unsafe.Pointer(pCur)).FzBuf + uintptr((*fs_cursor)(unsafe.Pointer(pCur)).FnBuf))) = int8(0)

		sqlite3.Xsqlite3_result_text(tls, ctx, (*fs_cursor)(unsafe.Pointer(pCur)).FzBuf, -1, libc.UintptrFromInt32(-1))
	}
	return SQLITE_OK
}

func fsRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_fs.c:763:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite3.Xsqlite3_column_int64(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt, 0)
	return SQLITE_OK
}

func fsEof(tls *libc.TLS, cur uintptr) int32 { /* test_fs.c:769:12: */
	var pCur uintptr = cur
	return libc.Bool32(sqlite3.Xsqlite3_data_count(tls, (*fs_cursor)(unsafe.Pointer(pCur)).FpStmt) == 0)
}

func fsBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_fs.c:774:12: */
	var ii int32

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn < 0 && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 &&
			int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ {
			var pUsage uintptr
			pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
			(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxNum = 1
			(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 1.0
			break
		}
	}

	return SQLITE_OK
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var fsModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_fs.c:798:23 */

var fsdirModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_fs.c:821:23 */

var fstreeModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_fs.c:844:23 */

// Register the echo virtual table module.
func register_fs_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_fs.c:875:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+31605 /* "fs" */, uintptr(unsafe.Pointer(&fsModule)), interp)
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+5325 /* "fsdir" */, uintptr(unsafe.Pointer(&fsdirModule)), uintptr(0))
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+31608 /* "fstree" */, uintptr(unsafe.Pointer(&fstreeModule)), uintptr(0))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetestfs_Init(tls *libc.TLS, interp uintptr) int32 { /* test_fs.c:901:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd6))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd6[i].FzName,
			aObjCmd6[i].FxProc, aObjCmd6[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd6 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 31615 /* "register_fs_modu..." */, FxProc: 0},
} /* test_fs.c:907:5 */

// Allocate nByte bytes of space using sqlite3_malloc(). If the
// allocation fails, call sqlite3_result_error_nomem() to notify
// the database handle that malloc() has failed.
func testContextMalloc(tls *libc.TLS, context uintptr, nByte int32) uintptr { /* test_func.c:33:13: */
	var z uintptr = sqlite3.Xsqlite3_malloc(tls, nByte)
	if !(z != 0) && nByte > 0 {
		sqlite3.Xsqlite3_result_error_nomem(tls, context)
	}
	return z
}

// This function generates a string of random characters.  Used for
// generating test data.
func randStr(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:45:13: */
	bp := tls.Alloc(1004)
	defer tls.Free(1004)

	var iMin int32
	var iMax int32
	var n int32
	// var r int32 at bp, 4

	var i int32
	// var zBuf [1000]uint8 at bp+4, 1000

	// It used to be possible to call randstr() with any number of arguments,
	// but now it is registered with SQLite as requiring exactly 2.

	iMin = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	if iMin < 0 {
		iMin = 0
	}
	if uint64(iMin) >= uint64(unsafe.Sizeof([1000]uint8{})) {
		iMin = int32(uint64(unsafe.Sizeof([1000]uint8{})) - uint64(1))
	}
	iMax = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
	if iMax < iMin {
		iMax = iMin
	}
	if uint64(iMax) >= uint64(unsafe.Sizeof([1000]uint8{})) {
		iMax = int32(uint64(unsafe.Sizeof([1000]uint8{})) - uint64(1))
	}
	n = iMin
	if iMax > iMin {
		sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(int32(0))), bp /* &r */)
		*(*int32)(unsafe.Pointer(bp /* r */)) &= 0x7fffffff
		n = n + *(*int32)(unsafe.Pointer(bp))%(iMax+1-iMin)
	}

	sqlite3.Xsqlite3_randomness(tls, n, bp+4 /* &zBuf[0] */)
	for i = 0; i < n; i++ {
		*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(i))) = zSrc[uint64(*(*uint8)(unsafe.Pointer(bp + 4 + uintptr(i))))%(uint64(unsafe.Sizeof(zSrc))-uint64(1))]
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &zBuf[0] */ + uintptr(n))) = uint8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+4 /* zBuf */, n, libc.UintptrFromInt32(-1))
}

var zSrc = *(*[79]uint8)(unsafe.Pointer(ts + 31634 /* "abcdefghijklmnop..." */)) /* test_func.c:46:30 */

// The following two SQL functions are used to test returning a text
// result with a destructor. Function 'test_destructor' takes one argument
// and returns the same argument interpreted as TEXT. A destructor is
// passed with the sqlite3_result_text() call.
//
// SQL function 'test_destructor_count' returns the number of outstanding
// allocations made by 'test_destructor';
//
// WARNING: Not threadsafe.
var test_destructor_count_var int32 = 0 /* test_func.c:91:12 */

func destructor(tls *libc.TLS, p uintptr) { /* test_func.c:92:13: */
	var zVal uintptr = p

	zVal--
	sqlite3.Xsqlite3_free(tls, zVal)
	test_destructor_count_var--
}

func test_destructor(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:99:13: */
	var zVal uintptr
	var len int32

	test_destructor_count_var++

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	len = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zVal = testContextMalloc(tls, pCtx, len+3)
	if !(zVal != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+1))) = int8(0)
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+2))) = int8(0)
	zVal++
	libc.Xmemcpy(tls, zVal, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), uint64(len))
	sqlite3.Xsqlite3_result_text(tls, pCtx, zVal, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{destructor})))
}

func test_destructor16(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:122:13: */
	var zVal uintptr
	var len int32

	test_destructor_count_var++

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		return
	}
	len = sqlite3.Xsqlite3_value_bytes16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zVal = testContextMalloc(tls, pCtx, len+3)
	if !(zVal != 0) {
		return
	}
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+1))) = int8(0)
	*(*int8)(unsafe.Pointer(zVal + uintptr(len+2))) = int8(0)
	zVal++
	libc.Xmemcpy(tls, zVal, sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv))), uint64(len))
	sqlite3.Xsqlite3_result_text16(tls, pCtx, zVal, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{destructor})))
}

func test_destructor_count(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:145:13: */
	sqlite3.Xsqlite3_result_int(tls, pCtx, test_destructor_count_var)
}

func test_agg_errmsg16_step(tls *libc.TLS, a uintptr, b int32, c uintptr) { /* test_func.c:165:13: */
}

func test_agg_errmsg16_final(tls *libc.TLS, ctx uintptr) { /* test_func.c:167:13: */
	var z uintptr
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, ctx)
	sqlite3.Xsqlite3_aggregate_context(tls, ctx, 2048)
	z = sqlite3.Xsqlite3_errmsg16(tls, db)
	sqlite3.Xsqlite3_result_text16(tls, ctx, z, -1, libc.UintptrFromInt32(-1))
}

// Routines for testing the sqlite3_get_auxdata() and sqlite3_set_auxdata()
// interface.
//
// The test_auxdata() SQL function attempts to register each of its arguments
// as auxiliary data.  If there are no prior registrations of aux data for
// that argument (meaning the argument is not a constant or this is its first
// call) then the result for that argument is 0.  If there is a prior
// registration, the result for that argument is 1.  The overall result
// is the individual argument results separated by spaces.
func free_test_auxdata(tls *libc.TLS, p uintptr) { /* test_func.c:188:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

func test_auxdata(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:189:13: */
	var i int32
	var zRet uintptr = testContextMalloc(tls, pCtx, nArg*2)
	if !(zRet != 0) {
		return
	}
	libc.Xmemset(tls, zRet, 0, uint64(nArg*2))
	for i = 0; i < nArg; i++ {
		var z uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
		if z != 0 {
			var n int32
			var zAux uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, i)
			if zAux != 0 {
				*(*int8)(unsafe.Pointer(zRet + uintptr(i*2))) = int8('1')

			} else {
				*(*int8)(unsafe.Pointer(zRet + uintptr(i*2))) = int8('0')
			}
			n = int32(libc.Xstrlen(tls, z)) + 1
			zAux = testContextMalloc(tls, pCtx, n)
			if zAux != 0 {
				libc.Xmemcpy(tls, zAux, z, uint64(n))
				sqlite3.Xsqlite3_set_auxdata(tls, pCtx, i, zAux, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{free_test_auxdata})))
			}
			*(*int8)(unsafe.Pointer(zRet + uintptr(i*2+1))) = int8(' ')
		}
	}
	sqlite3.Xsqlite3_result_text(tls, pCtx, zRet, 2*nArg-1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{free_test_auxdata})))
}

// A function to test error reporting from user functions. This function
// returns a copy of its first argument as the error message.  If the
// second argument exists, it becomes the error code.
func test_error(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:226:13: */
	sqlite3.Xsqlite3_result_error(tls, pCtx, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv))), -1)
	if nArg == 2 {
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))))
	}
}

// Implementation of the counter(X) function.  If X is an integer
// constant, then the first invocation will return X.  The second X+1.
// and so forth.  Can be used (for example) to provide a sequence number
// in a result set.
func counterFunc(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:243:13: */
	var pCounter uintptr = sqlite3.Xsqlite3_get_auxdata(tls, pCtx, 0)
	if pCounter == uintptr(0) {
		pCounter = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(int32(0))))
		if pCounter == uintptr(0) {
			sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
			return
		}
		*(*int32)(unsafe.Pointer(pCounter)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		sqlite3.Xsqlite3_set_auxdata(tls, pCtx, 0, pCounter, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	} else {
		*(*int32)(unsafe.Pointer(pCounter))++
	}
	sqlite3.Xsqlite3_result_int(tls, pCtx, *(*int32)(unsafe.Pointer(pCounter)))
}

// This function takes two arguments.  It performance UTF-8/16 type
// conversions on the first argument then returns a copy of the second
// argument.
//
// This function is used in cases such as the following:
//
//      SELECT test_isolation(x,x) FROM t1;
//
// We want to verify that the type conversions that occur on the
// first argument do not invalidate the second argument.
func test_isolation(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:276:13: */
	sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text16(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_value(tls, pCtx, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
}

// Invoke an SQL statement recursively.  The function result is the
// first column of the first row of the result set.
func test_eval(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:294:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pStmt uintptr at bp+8, 8

	var rc int32
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, pCtx)
	var zSql uintptr

	zSql = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	rc = sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, -1, bp+8 /* &pStmt */, uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
		if rc == SQLITE_ROW {
			sqlite3.Xsqlite3_result_value(tls, pCtx, sqlite3.Xsqlite3_column_value(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)), 0))
		}
		rc = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* pStmt */)))
	}
	if rc != 0 {
		var zErr uintptr

		zErr = sqlite3.Xsqlite3_mprintf(tls, ts+31713 /* "sqlite3_prepare_..." */, libc.VaList(bp, sqlite3.Xsqlite3_errmsg(tls, db)))
		sqlite3.Xsqlite3_result_text(tls, pCtx, zErr, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
		sqlite3.Xsqlite3_result_error_code(tls, pCtx, rc)
	}
}

// convert one character from hex to binary
func testHexChar(tls *libc.TLS, c int8) int32 { /* test_func.c:326:12: */
	if int32(c) >= '0' && int32(c) <= '9' {
		return int32(c) - '0'
	} else if int32(c) >= 'a' && int32(c) <= 'f' {
		return int32(c) - 'a' + 10
	} else if int32(c) >= 'A' && int32(c) <= 'F' {
		return int32(c) - 'A' + 10
	}
	return 0
}

// Convert hex to binary.
func testHexToBin(tls *libc.TLS, zIn uintptr, zOut uintptr) { /* test_func.c:340:13: */
	for *(*int8)(unsafe.Pointer(zIn)) != 0 && *(*int8)(unsafe.Pointer(zIn + 1)) != 0 {
		*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zOut, 1))) = int8(testHexChar(tls, *(*int8)(unsafe.Pointer(zIn)))<<4 + testHexChar(tls, *(*int8)(unsafe.Pointer(zIn + 1))))
		zIn += uintptr(2)
	}
}

//      hex_to_utf16be(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().
func testHexToUtf16be(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:354:13: */
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, n/2)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text16be(tls, pCtx, zOut, n/2, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//      hex_to_utf8(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().
func testHexToUtf8(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:381:13: */
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, n/2)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text(tls, pCtx, zOut, n/2, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

//      hex_to_utf16le(HEX)
//
// Convert the input string from HEX into binary.  Then return the
// result using sqlite3_result_text16le().
func testHexToUtf16le(tls *libc.TLS, pCtx uintptr, nArg int32, argv uintptr) { /* test_func.c:408:13: */
	var n int32
	var zIn uintptr
	var zOut uintptr

	n = sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zIn = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
	zOut = sqlite3.Xsqlite3_malloc(tls, n/2)
	if zOut == uintptr(0) {
		sqlite3.Xsqlite3_result_error_nomem(tls, pCtx)
	} else {
		testHexToBin(tls, zIn, zOut)
		sqlite3.Xsqlite3_result_text16le(tls, pCtx, zOut, n/2, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	}
}

// SQL function:   real2hex(X)
//
// If argument X is a real number, then convert it into a string which is
// the big-endian hexadecimal representation of the ieee754 encoding of
// that number.  If X is not a real number, return NULL.
func real2hex(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:436:13: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	// var v struct {Fi sqlite3_uint64;} at bp, 8

	// var zOut [20]int8 at bp+8, 20

	var i int32
	var bigEndian int32
	*(*sqlite3_uint64)(unsafe.Pointer(bp /* &v */)) = uint64(1)
	bigEndian = libc.Bool32(int32(*(*uint8)(unsafe.Pointer(bp))) == 0)
	*(*float64)(unsafe.Pointer(bp /* &v */)) = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(argv)))
	for i = 0; i < 8; i++ {
		if bigEndian != 0 {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(i*2))) = *(*int8)(unsafe.Pointer(ts + 31744 /* "0123456789abcdef" */ + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))>>4)))
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(i*2+1))) = *(*int8)(unsafe.Pointer(ts + 31744 /* "0123456789abcdef" */ + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))&0xf)))
		} else {
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(14-i*2))) = *(*int8)(unsafe.Pointer(ts + 31744 /* "0123456789abcdef" */ + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))>>4)))
			*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + uintptr(14-i*2+1))) = *(*int8)(unsafe.Pointer(ts + 31744 /* "0123456789abcdef" */ + uintptr(int32(*(*uint8)(unsafe.Pointer(bp + uintptr(i))))&0xf)))
		}
	}
	*(*int8)(unsafe.Pointer(bp + 8 /* &zOut[0] */ + 16)) = int8(0)
	sqlite3.Xsqlite3_result_text(tls, context, bp+8 /* &zOut[0] */, -1, libc.UintptrFromInt32(-1))
}

//     test_extract(record, field)
//
// This function implements an SQL user-function that accepts a blob
// containing a formatted database record as the first argument. The
// second argument is the index of the field within that record to
// extract and return.
func test_extract(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:473:13: */
	bp := tls.Alloc(72)
	defer tls.Free(72)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr // Points to one byte past record header
	var pHdr uintptr    // Current point in record header
	var pBody uintptr   // Current point in record data
	// var nHdr u64 at bp, 8
	// Bytes in record header
	var iIdx int32         // Required field
	var iCurrent int32 = 0 // Current field

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))
	iIdx = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))

	pHdr = pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp))
	pBody = libc.AssignUintptr(&pEndHdr, pRec+uintptr(*(*u64)(unsafe.Pointer(bp))))

	for iCurrent = 0; pHdr < pEndHdr && iCurrent <= iIdx; iCurrent++ {
		// var iSerialType u64 at bp+64, 8

		// var mem Mem at bp+8, 56

		libc.Xmemset(tls, bp+8 /* &mem */, 0, uint64(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 8 /* &mem */)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 8 /* &mem */)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+64 /* &iSerialType */))
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 64 /* iSerialType */))), bp+8 /* &mem */))

		if iCurrent == iIdx {
			sqlite3.Xsqlite3_result_value(tls, context, bp+8 /* &mem */)
		}

		if (*Mem)(unsafe.Pointer(bp+8)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+8 /* &mem */)).FzMalloc)
		}
	}
}

//      test_decode(record)
//
// This function implements an SQL user-function that accepts a blob
// containing a formatted database record as its only argument. It returns
// a tcl list (type SQLITE_TEXT) containing each of the values stored
// in the record.
func test_decode(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:520:13: */
	bp := tls.Alloc(123)
	defer tls.Free(123)

	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var pRec uintptr
	var pEndHdr uintptr // Points to one byte past record header
	var pHdr uintptr    // Current point in record header
	var pBody uintptr   // Current point in record data
	// var nHdr u64 at bp+32, 8
	// Bytes in record header
	var pRet uintptr // Return value

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++

	pRec = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(argv)))

	pHdr = pRec + uintptr(sqlite3.Xsqlite3GetVarint(tls, pRec, bp+32))
	pBody = libc.AssignUintptr(&pEndHdr, pRec+uintptr(*(*u64)(unsafe.Pointer(bp + 32))))
	for pHdr < pEndHdr {
		var pVal uintptr = uintptr(0)
		// var iSerialType u64 at bp+96, 8

		// var mem Mem at bp+40, 56

		libc.Xmemset(tls, bp+40 /* &mem */, 0, uint64(unsafe.Sizeof(Mem{})))
		(*Mem)(unsafe.Pointer(bp + 40 /* &mem */)).Fdb = db
		(*Mem)(unsafe.Pointer(bp + 40 /* &mem */)).Fenc = (*sqlite31)(unsafe.Pointer(db)).Fenc
		pHdr += uintptr(sqlite3.Xsqlite3GetVarint(tls, pHdr, bp+96 /* &iSerialType */))
		pBody += uintptr(sqlite3.Xsqlite3VdbeSerialGet(tls, pBody, u32(*(*u64)(unsafe.Pointer(bp + 96 /* iSerialType */))), bp+40 /* &mem */))

		switch sqlite3.Xsqlite3_value_type(tls, bp+40 /* &mem */) {
		case SQLITE_TEXT:
			pVal = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, bp+40 /* &mem */), -1)
			break

		case SQLITE_BLOB:
			{
				*(*[16]int8)(unsafe.Pointer(bp + 107 /* hexdigit */)) = [16]int8{
					int8('0'), int8('1'), int8('2'), int8('3'), int8('4'), int8('5'), int8('6'), int8('7'),
					int8('8'), int8('9'), int8('a'), int8('b'), int8('c'), int8('d'), int8('e'), int8('f'),
				}
				var n int32 = sqlite3.Xsqlite3_value_bytes(tls, bp+40 /* &mem */)
				var z uintptr = sqlite3.Xsqlite3_value_blob(tls, bp+40 /* &mem */)
				var i int32
				pVal = tcl.XTcl_NewStringObj(tls, ts+31761 /* "x'" */, -1)
				for i = 0; i < n; i++ {
					// var hex [3]int8 at bp+104, 3

					*(*int8)(unsafe.Pointer(bp + 104 /* &hex[0] */)) = *(*int8)(unsafe.Pointer(bp + 107 /* &hexdigit[0] */ + uintptr(int32(*(*u8)(unsafe.Pointer(z + uintptr(i))))>>4&0x0F)))
					*(*int8)(unsafe.Pointer(bp + 104 /* &hex[0] */ + 1)) = *(*int8)(unsafe.Pointer(bp + 107 /* &hexdigit[0] */ + uintptr(int32(*(*u8)(unsafe.Pointer(z + uintptr(i))))&0x0F)))
					*(*int8)(unsafe.Pointer(bp + 104 /* &hex[0] */ + 2)) = int8(0)
					tcl.XTcl_AppendStringsToObj(tls, pVal, libc.VaList(bp, bp+104 /* &hex[0] */, 0))
				}
				tcl.XTcl_AppendStringsToObj(tls, pVal, libc.VaList(bp+16, ts+5624 /* "'" */, 0))
				break

			}

		case SQLITE_FLOAT:
			pVal = tcl.XTcl_NewDoubleObj(tls, sqlite3.Xsqlite3_value_double(tls, bp+40 /* &mem */))
			break

		case SQLITE_INTEGER:
			pVal = tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_value_int64(tls, bp+40 /* &mem */))
			break

		case SQLITE_NULL:
			pVal = tcl.XTcl_NewStringObj(tls, ts+5846 /* "NULL" */, -1)
			break

		default:

		}

		tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRet, pVal)

		if (*Mem)(unsafe.Pointer(bp+40)).FszMalloc != 0 {
			sqlite3.Xsqlite3DbFree(tls, db, (*Mem)(unsafe.Pointer(bp+40 /* &mem */)).FzMalloc)
		}
	}

	sqlite3.Xsqlite3_result_text(tls, context, tcl.XTcl_GetString(tls, pRet), -1, libc.UintptrFromInt32(-1))
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

//       test_zeroblob(N)
//
// The implementation of scalar SQL function "test_zeroblob()". This is
// similar to the built-in zeroblob() function, except that it does not
// check that the integer parameter is within range before passing it
// to sqlite3_result_zeroblob().
func test_zeroblob(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:612:13: */
	var nZero int32 = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_zeroblob(tls, context, nZero)
}

// test_getsubtype(V)
//
// Return the subtype for value V.
func test_getsubtype(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:625:13: */
	sqlite3.Xsqlite3_result_int(tls, context, int32(sqlite3.Xsqlite3_value_subtype(tls, *(*uintptr)(unsafe.Pointer(argv)))))
}

// test_frombind(A,B,C,...)
//
// Return an integer bitmask that has a bit set for every argument
// (up to the first 63 arguments) that originates from a bind a parameter.
func test_frombind(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:638:13: */
	var m sqlite3_uint64 = uint64(0)
	var i int32
	for i = 0; i < argc && i < 63; i++ {
		if sqlite3.Xsqlite3_value_frombind(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8))) != 0 {
			m = m | sqlite3_uint64(uint64(1))<<i
		}
	}
	sqlite3.Xsqlite3_result_int64(tls, context, sqlite3_int64(m))
}

// test_setsubtype(V, T)
//
// Return the value V with its subtype changed to T
func test_setsubtype(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_func.c:655:13: */
	sqlite3.Xsqlite3_result_value(tls, context, *(*uintptr)(unsafe.Pointer(argv)))
	sqlite3.Xsqlite3_result_subtype(tls, context, uint32(sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))))
}

func registerTestFunctions(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 { /* test_func.c:664:12: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aFuncs))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		FnArg        int8
		F__ccgo_pad1 [3]byte
		FeTextRep    uint32
		FxFunc       uintptr
	}{})); i++ {
		sqlite3.Xsqlite3_create_function(tls, db, aFuncs[i].FzName, int32(aFuncs[i].FnArg),
			int32(aFuncs[i].FeTextRep), uintptr(0), aFuncs[i].FxFunc, uintptr(0), uintptr(0))
	}

	sqlite3.Xsqlite3_create_function(tls, db, ts+31764 /* "test_agg_errmsg1..." */, 0, SQLITE_ANY, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{test_agg_errmsg16_step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{test_agg_errmsg16_final})))

	return SQLITE_OK
}

var aFuncs = [20]struct {
	FzName       uintptr
	FnArg        int8
	F__ccgo_pad1 [3]byte
	FeTextRep    uint32
	FxFunc       uintptr
}{
	{FzName: ts + 31782 /* "randstr" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31790 /* "test_destructor" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31806 /* "test_destructor1..." */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31824 /* "hex_to_utf16be" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31839 /* "hex_to_utf16le" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31854 /* "hex_to_utf8" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31866 /* "test_destructor_..." */, FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31888 /* "test_auxdata" */, FnArg: int8(-1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31901 /* "test_error" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31901 /* "test_error" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31912 /* "test_eval" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31922 /* "test_isolation" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31937 /* "test_counter" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31950 /* "real2hex" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31959 /* "test_decode" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31971 /* "test_extract" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 31984 /* "test_zeroblob" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8 | SQLITE_DETERMINISTIC), FxFunc: 0},
	{FzName: ts + 31998 /* "test_getsubtype" */, FnArg: int8(1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 32014 /* "test_setsubtype" */, FnArg: int8(2), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
	{FzName: ts + 32030 /* "test_frombind" */, FnArg: int8(-1), FeTextRep: uint32(SQLITE_UTF8), FxFunc: 0},
} /* test_func.c:674:5 */

// TCLCMD:  autoinstall_test_functions
//
// Invoke this TCL command to use sqlite3_auto_extension() to cause
// the standard set of test functions to be loaded into each new
// database connection.
func autoinstall_test_funcs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:718:26: */
	var rc int32 = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr) int32
		}{Md5_Register})))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// A bogus step function and finalizer function.
func tStep(tls *libc.TLS, a uintptr, b int32, c uintptr) { /* test_func.c:736:13: */
}

func tFinal(tls *libc.TLS, a uintptr) { /* test_func.c:737:13: */
}

// tclcmd:  abuse_create_function
//
// Make various calls to sqlite3_create_function that do not have valid
// parameters.  Verify that the error condition is detected and reported.
func abuse_create_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:746:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var db uintptr at bp+16, 8

	var rc int32
	var mxArg int32

	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0) {
		goto __1
	}
	return TCL_ERROR
__1:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+32044 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __2
	}
	goto abuse_err
__2:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+32044 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	goto abuse_err
__3:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+32044 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	goto abuse_err
__4:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+32044 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tFinal})))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	goto abuse_err
__5:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+32044 /* "tx" */, 1, SQLITE_UTF8, uintptr(0), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	goto abuse_err
__6:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+32044 /* "tx" */, -2, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __7
	}
	goto abuse_err
__7:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), ts+32044 /* "tx" */, 128, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __8
	}
	goto abuse_err
__8:
	;

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)),

		ts+32047, /* "funcxx_123456789..." */
		1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __9
	}
	goto abuse_err
__9:
	;

	// This last function registration should actually work.  Generate
	// a no-op function (that always returns NULL) and which has the
	// maximum-length function name and the maximum number of parameters.
	sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), SQLITE_LIMIT_FUNCTION_ARG, 10000)
	mxArg = sqlite3.Xsqlite3_limit(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), SQLITE_LIMIT_FUNCTION_ARG, -1)
	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)),

		ts+32304, /* "nullx_123456789_..." */
		mxArg, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{tStep})), uintptr(0), uintptr(0))
	if !(rc != SQLITE_OK) {
		goto __10
	}
	goto abuse_err
__10:
	;

	return TCL_OK

abuse_err:
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32560, /* "sqlite3_create_f..." */
		uintptr(0)))
	return TCL_ERROR
}

// SQLite user defined function to use with matchinfo() to calculate the
// relevancy of an FTS match. The value returned is the relevancy score
// (a real value greater than or equal to zero). A larger value indicates
// a more relevant document.
//
// The overall relevancy returned is the sum of the relevancies of each
// column value in the FTS table. The relevancy of a column value is the
// sum of the following for each reportable phrase in the FTS query:
//
//   (<hit count> / <global hit count>) * <column weight>
//
// where <hit count> is the number of instances of the phrase in the
// column value of the current row and <global hit count> is the number
// of instances of the phrase in the same column of all rows in the FTS
// table. The <column weight> is a weighting factor assigned to each
// column by the caller (see below).
//
// The first argument to this function must be the return value of the FTS
// matchinfo() function. Following this must be one argument for each column
// of the FTS table containing a numeric weight factor for the corresponding
// column. Example:
//
//     CREATE VIRTUAL TABLE documents USING fts3(title, content)
//
// The following query returns the docids of documents that match the full-text
// query <query> sorted from most to least relevant. When calculating
// relevance, query term instances in the 'title' column are given twice the
// weighting of those in the 'content' column.
//
//     SELECT docid FROM documents
//     WHERE documents MATCH <query>
//     ORDER BY rank(matchinfo(documents), 1.0, 0.5) DESC
func rankfunc(tls *libc.TLS, pCtx uintptr, nVal int32, apVal uintptr) { /* test_func.c:847:13: */
	var aMatchinfo uintptr // Return value of matchinfo()
	var nMatchinfo int32   // Number of elements in aMatchinfo[]
	var nCol int32         // Number of columns in the table
	var nPhrase int32      // Number of phrases in the query
	var iPhrase int32      // Current phrase
	var score float64
	var nHitCount int32
	var nGlobalHitCount int32
	var weight float64
	var iCol int32 // Current column

	// Now iterate through each column in the users query. For each column,
	// increment the relevancy score by:
	//
	//   (<hit count> / <global hit count>) * <column weight>
	//
	// aPhraseinfo[] points to the start of the data for phrase iPhrase. So
	// the hit count and global hit counts for each column are found in
	// aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
	var aPhraseinfo uintptr
	nCol = 0
	nPhrase = 0
	score = 0.0 // Value to return

	// Check that the number of arguments passed to this function is correct.
	// If not, jump to wrong_number_args. Set aMatchinfo to point to the array
	// of unsigned integer values returned by FTS function matchinfo. Set
	// nPhrase to contain the number of reportable phrases in the users full-text
	// query, and nCol to the number of columns in the table. Then check that the
	// size of the matchinfo blob is as expected. Return an error if it is not.
	if !(nVal < 1) {
		goto __1
	}
	goto wrong_number_args
__1:
	;
	aMatchinfo = sqlite3.Xsqlite3_value_blob(tls, *(*uintptr)(unsafe.Pointer(apVal)))
	nMatchinfo = int32(uint64(sqlite3.Xsqlite3_value_bytes(tls, *(*uintptr)(unsafe.Pointer(apVal)))) / uint64(unsafe.Sizeof(int32(0))))
	if !(nMatchinfo >= 2) {
		goto __2
	}
	nPhrase = *(*int32)(unsafe.Pointer(aMatchinfo))
	nCol = *(*int32)(unsafe.Pointer(aMatchinfo + 1*4))
__2:
	;
	if !(nMatchinfo != 2+3*nCol*nPhrase) {
		goto __3
	}
	sqlite3.Xsqlite3_result_error(tls, pCtx,
		ts+32603 /* "invalid matchinf..." */, -1)
	return
__3:
	;
	if !(nVal != 1+nCol) {
		goto __4
	}
	goto wrong_number_args
__4:
	;

	// Iterate through each phrase in the users query.
	iPhrase = 0
__5:
	if !(iPhrase < nPhrase) {
		goto __7
	} // Current column

	// Now iterate through each column in the users query. For each column,
	// increment the relevancy score by:
	//
	//   (<hit count> / <global hit count>) * <column weight>
	//
	// aPhraseinfo[] points to the start of the data for phrase iPhrase. So
	// the hit count and global hit counts for each column are found in
	// aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.
	aPhraseinfo = aMatchinfo + uintptr(2+iPhrase*nCol*3)*4
	iCol = 0
__8:
	if !(iCol < nCol) {
		goto __10
	}
	nHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr(3*iCol)*4))
	nGlobalHitCount = *(*int32)(unsafe.Pointer(aPhraseinfo + uintptr(3*iCol+1)*4))
	weight = sqlite3.Xsqlite3_value_double(tls, *(*uintptr)(unsafe.Pointer(apVal + uintptr(iCol+1)*8)))
	if !(nHitCount > 0) {
		goto __11
	}
	score = score + float64(nHitCount)/float64(nGlobalHitCount)*weight
__11:
	;
	goto __9
__9:
	iCol++
	goto __8
	goto __10
__10:
	;
	goto __6
__6:
	iPhrase++
	goto __5
	goto __7
__7:
	;

	sqlite3.Xsqlite3_result_double(tls, pCtx, score)
	return

	// Jump here if the wrong number of arguments are passed to this function
wrong_number_args:
	sqlite3.Xsqlite3_result_error(tls, pCtx, ts+32652 /* "wrong number of ..." */, -1)
}

func install_fts3_rank_function(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_func.c:910:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+32697 /* "rank" */, -1, SQLITE_UTF8, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{rankfunc})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest_func_Init(tls *libc.TLS, interp uintptr) int32 { /* test_func.c:933:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd7))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd7[i].FzName, aObjCmd7[i].FxProc, uintptr(0), uintptr(0))
	}
	sqlite3.Xsqlite3_initialize(tls)
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{registerTestFunctions})))
	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{Md5_Register})))
	return TCL_OK
}

var aObjCmd7 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 32702 /* "autoinstall_test..." */, FxProc: 0},
	{FzName: ts + 32729 /* "abuse_create_fun..." */, FxProc: 0},
	{FzName: ts + 32751 /* "install_fts3_ran..." */, FxProc: 0},
} /* test_func.c:937:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)assert.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Unlike other ANSI header files, <assert.h> may usefully be included
// multiple times, with and without NDEBUG defined.

// Convert binary to hex.  The input zBuf[] contains N bytes of
// binary data.  zBuf[] is 2*n+1 bytes long.  Overwrite zBuf[]
// with a hexadecimal representation of its original binary input.
func sqlite3TestBinToHex(tls *libc.TLS, zBuf uintptr, N int32) { /* test_hexio.c:36:6: */
	bp := tls.Alloc(17)
	defer tls.Free(17)

	*(*[17]uint8)(unsafe.Pointer(bp /* zHex */)) = *(*[17]uint8)(unsafe.Pointer(ts + 32778 /* "0123456789ABCDEF" */))
	var i int32
	var j int32
	var c uint8
	i = N * 2
	*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = uint8(0)
	for j = N - 1; j >= 0; j-- {
		c = *(*uint8)(unsafe.Pointer(zBuf + uintptr(j)))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp /* &zHex[0] */ + uintptr(int32(c)&0xf)))
		*(*uint8)(unsafe.Pointer(zBuf + uintptr(libc.PostDecInt32(&i, 1)))) = *(*uint8)(unsafe.Pointer(bp /* &zHex[0] */ + uintptr(int32(c)>>4)))
	}

}

// Convert hex to binary.  The input zIn[] contains N bytes of
// hexadecimal.  Convert this into binary and write aOut[] with
// the binary data.  Spaces in the original input are ignored.
// Return the number of bytes of binary rendered.
func sqlite3TestHexToBin(tls *libc.TLS, zIn uintptr, N int32, aOut uintptr) int32 { /* test_hexio.c:56:5: */
	bp := tls.Alloc(256)
	defer tls.Free(256)

	*(*[256]uint8)(unsafe.Pointer(bp /* aMap */)) = [256]uint8{
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(1), uint8(2), uint8(3), uint8(4), uint8(5), uint8(6), uint8(7), uint8(8), uint8(9), uint8(10), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(11), uint8(12), uint8(13), uint8(14), uint8(15), uint8(16), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
		uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0), uint8(0),
	}
	var i int32
	var j int32
	var hi int32 = 1
	var c uint8

	for i = libc.AssignInt32(&j, 0); i < N; i++ {
		c = *(*uint8)(unsafe.Pointer(bp /* &aMap[0] */ + uintptr(*(*uint8)(unsafe.Pointer(zIn + uintptr(i))))))
		if int32(c) == 0 {
			continue
		}
		if hi != 0 {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(j))) = uint8((int32(c) - 1) << 4)
			hi = 0
		} else {
			*(*uint8)(unsafe.Pointer(aOut + uintptr(libc.PostIncInt32(&j, 1)))) |= uint8(int32(c) - 1)
			hi = 1
		}
	}
	return j
}

// Usage:   hexio_read  FILENAME  OFFSET  AMT
//
// Read AMT bytes from file FILENAME beginning at OFFSET from the
// beginning of the file.  Convert that information to hexadecimal
// and return the resulting HEX string.
func hexio_read(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:101:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	// var offset int32 at bp+40, 4

	// var amt int32 at bp+44, 4

	var got int32
	var zFile uintptr
	var zBuf uintptr
	var in uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32795 /* "FILENAME OFFSET ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+44) != 0 {
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zBuf = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp + 44))*2+1)
	if zBuf == uintptr(0) {
		return TCL_ERROR
	}
	in = libc.Xfopen(tls, zFile, ts+4402 /* "rb" */)
	if in == uintptr(0) {
		in = libc.Xfopen(tls, zFile, ts+32815 /* "r" */)
	}
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32817 /* "cannot open inpu..." */, zFile, 0))
		return TCL_ERROR
	}
	libc.Xfseek(tls, in, int64(*(*int32)(unsafe.Pointer(bp + 40 /* offset */))), SEEK_SET)
	got = int32(libc.Xfread(tls, zBuf, uint64(1), uint64(*(*int32)(unsafe.Pointer(bp + 44 /* amt */))), in))
	libc.Xfclose(tls, in)
	if got < 0 {
		got = 0
	}
	sqlite3TestBinToHex(tls, zBuf, got)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, zBuf, 0))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return TCL_OK
}

// Usage:   hexio_write  FILENAME  OFFSET  DATA
//
// Write DATA into file FILENAME beginning at OFFSET from the
// beginning of the file.  DATA is expressed in hexadecimal.
func hexio_write(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:151:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var offset int32 at bp+24, 4

	// var nIn int32 at bp+28, 4

	var nOut int32
	var written int32
	var zFile uintptr
	var zIn uintptr
	var aOut uintptr
	var out uintptr

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32841 /* "FILENAME OFFSET ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+24) != 0 {
		return TCL_ERROR
	}
	zFile = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+28 /* &nIn */)
	aOut = sqlite3.Xsqlite3_malloc(tls, 1+*(*int32)(unsafe.Pointer(bp + 28))/2)
	if aOut == uintptr(0) {
		return TCL_ERROR
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp + 28 /* nIn */)), aOut)
	out = libc.Xfopen(tls, zFile, ts+32865 /* "r+b" */)
	if out == uintptr(0) {
		out = libc.Xfopen(tls, zFile, ts+32869 /* "r+" */)
	}
	if out == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+32872 /* "cannot open outp..." */, zFile, 0))
		return TCL_ERROR
	}
	libc.Xfseek(tls, out, int64(*(*int32)(unsafe.Pointer(bp + 24 /* offset */))), SEEK_SET)
	written = int32(libc.Xfwrite(tls, aOut, uint64(1), uint64(nOut), out))
	sqlite3.Xsqlite3_free(tls, aOut)
	libc.Xfclose(tls, out)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, written))
	return TCL_OK
}

// USAGE:   hexio_get_int   HEXDATA
//
// Interpret the HEXDATA argument as a big-endian integer.  Return
// the value of that integer.  HEXDATA can contain between 2 and 8
// hexadecimal digits.
func hexio_get_int(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:199:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var val int32
	// var nIn int32 at bp, 4

	var nOut int32
	var zIn uintptr
	var aOut uintptr
	// var aNum [4]uint8 at bp+4, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32897 /* "HEXDATA" */)
		return TCL_ERROR
	}
	zIn = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &nIn */)
	aOut = sqlite3.Xsqlite3_malloc(tls, 1+*(*int32)(unsafe.Pointer(bp))/2)
	if aOut == uintptr(0) {
		return TCL_ERROR
	}
	nOut = sqlite3TestHexToBin(tls, zIn, *(*int32)(unsafe.Pointer(bp /* nIn */)), aOut)
	if nOut >= 4 {
		libc.Xmemcpy(tls, bp+4 /* &aNum[0] */, aOut, uint64(4))
	} else {
		libc.Xmemset(tls, bp+4 /* &aNum[0] */, 0, uint64(unsafe.Sizeof([4]uint8{})))
		libc.Xmemcpy(tls, bp+4+uintptr(4-nOut), aOut, uint64(nOut))
	}
	sqlite3.Xsqlite3_free(tls, aOut)
	val = int32(*(*uint8)(unsafe.Pointer(bp + 4)))<<24 | int32(*(*uint8)(unsafe.Pointer(bp + 4 + 1)))<<16 | int32(*(*uint8)(unsafe.Pointer(bp + 4 + 2)))<<8 | int32(*(*uint8)(unsafe.Pointer(bp + 4 + 3)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, val))
	return TCL_OK
}

// USAGE:   hexio_render_int16   INTEGER
//
// Render INTEGER has a 16-bit big-endian integer in hexadecimal.
func hexio_render_int16(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:239:26: */
	bp := tls.Alloc(14)
	defer tls.Free(14)

	// var val int32 at bp, 4

	// var aNum [10]uint8 at bp+4, 10

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2413 /* "INTEGER" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 8)
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 1)) = uint8(*(*int32)(unsafe.Pointer(bp /* val */)))
	sqlite3TestBinToHex(tls, bp+4 /* &aNum[0] */, 2)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4 /* aNum */, 4))
	return TCL_OK
}

// USAGE:   hexio_render_int32   INTEGER
//
// Render INTEGER has a 32-bit big-endian integer in hexadecimal.
func hexio_render_int32(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:266:26: */
	bp := tls.Alloc(14)
	defer tls.Free(14)

	// var val int32 at bp, 4

	// var aNum [10]uint8 at bp+4, 10

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2413 /* "INTEGER" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 24)
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 1)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 16)
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 2)) = uint8(*(*int32)(unsafe.Pointer(bp)) >> 8)
	*(*uint8)(unsafe.Pointer(bp + 4 /* &aNum[0] */ + 3)) = uint8(*(*int32)(unsafe.Pointer(bp /* val */)))
	sqlite3TestBinToHex(tls, bp+4 /* &aNum[0] */, 4)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, bp+4 /* aNum */, 8))
	return TCL_OK
}

// USAGE:  utf8_to_utf8  HEX
//
// The argument is a UTF8 string represented in hexadecimal.
// The UTF8 might not be well-formed.  Run this string through
// sqlite3Utf8to8() convert it back to hex and return the result.
func utf8_to_utf8(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:296:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	tcl.XTcl_AppendResult(tls, interp,
		libc.VaList(bp, ts+32905 /* "[utf8_to_utf8] u..." */, 0))
	return TCL_ERROR
}

func getFts3Varint(tls *libc.TLS, p uintptr, v uintptr) int32 { /* test_hexio.c:328:12: */
	var q uintptr = p
	var x sqlite_uint64 = uint64(0)
	var y sqlite_uint64 = uint64(1)
	for int32(*(*uint8)(unsafe.Pointer(q)))&0x80 == 0x80 {
		x = x + y*sqlite_uint64(int32(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))))&0x7f)
		y <<= 7
	}
	x = x + y*sqlite_uint64(*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))))
	*(*sqlite_int64)(unsafe.Pointer(v)) = sqlite_int64(x)
	return int32((int64(q) - int64(p)) / 1)
}

func putFts3Varint(tls *libc.TLS, p uintptr, v sqlite_int64) int32 { /* test_hexio.c:340:12: */
	var q uintptr = p
	var vu sqlite_uint64 = sqlite_uint64(v)
	for ok := true; ok; ok = vu != uint64(0) {
		*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&q, 1))) = uint8(vu&uint64(0x7f) | uint64(0x80))
		vu >>= 7
	}
	*(*uint8)(unsafe.Pointer(q + libc.UintptrFromInt32(-1))) &= uint8(0x7f) // turn off high bit in final byte

	return int32((int64(q) - int64(p)) / 1)
}

// USAGE:  read_fts3varint BLOB VARNAME
//
// Read a varint from the start of BLOB. Set variable VARNAME to contain
// the interpreted value. Return the number of bytes of BLOB consumed.
func read_fts3varint(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:358:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var nBlob int32 at bp, 4

	var zBlob uintptr
	// var iVal sqlite3_int64 at bp+8, 8

	var nVal int32

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32959 /* "BLOB VARNAME" */)
		return TCL_ERROR
	}
	zBlob = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &nBlob */)

	nVal = getFts3Varint(tls, zBlob, bp+8)
	tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(0), tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* iVal */))), 0)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nVal))
	return TCL_OK
}

// USAGE:  make_fts3record ARGLIST
func make_fts3record(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_hexio.c:384:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	*(*uintptr)(unsafe.Pointer(bp + 8 /* aArg */)) = uintptr(0)
	*(*int32)(unsafe.Pointer(bp /* nArg */)) = 0
	var aOut uintptr = uintptr(0)
	var nOut int32 = 0
	var nAlloc int32 = 0
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+32972 /* "LIST" */)
		return TCL_ERROR
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp, bp+8) != 0 {
		return TCL_ERROR
	}

	for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nArg */)); i++ {
		// var iVal sqlite3_int64 at bp+16, 8

		if TCL_OK == tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8)) + uintptr(i)*8)), bp+16) {
			if nOut+10 > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = nAlloc * 2
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return TCL_ERROR
				}
				aOut = aNew
				nAlloc = nNew
			}
			nOut = nOut + putFts3Varint(tls, aOut+uintptr(nOut), *(*sqlite3_int64)(unsafe.Pointer(bp + 16)))
		} else {
			*(*int32)(unsafe.Pointer(bp + 24 /* nVal */)) = 0
			var zVal uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* aArg */)) + uintptr(i)*8)), bp+24 /* &nVal */)
			for nOut+*(*int32)(unsafe.Pointer(bp + 24)) > nAlloc {
				var nNew int32
				if nAlloc != 0 {
					nNew = nAlloc * 2
				} else {
					nNew = 128
				}
				var aNew uintptr = sqlite3.Xsqlite3_realloc(tls, aOut, nNew)
				if aNew == uintptr(0) {
					sqlite3.Xsqlite3_free(tls, aOut)
					return TCL_ERROR
				}
				aOut = aNew
				nAlloc = nNew
			}
			libc.Xmemcpy(tls, aOut+uintptr(nOut), zVal, uint64(*(*int32)(unsafe.Pointer(bp + 24 /* nVal */))))
			nOut = nOut + *(*int32)(unsafe.Pointer(bp + 24))
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewByteArrayObj(tls, aOut, nOut))
	sqlite3.Xsqlite3_free(tls, aOut)
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest_hexio_Init(tls *libc.TLS, interp uintptr) int32 { /* test_hexio.c:446:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd8))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd8[i].FzName, aObjCmd8[i].FxProc, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

var aObjCmd8 = [8]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 32977 /* "hexio_read" */, FxProc: 0},
	{FzName: ts + 32988 /* "hexio_write" */, FxProc: 0},
	{FzName: ts + 33000 /* "hexio_get_int" */, FxProc: 0},
	{FzName: ts + 33014 /* "hexio_render_int..." */, FxProc: 0},
	{FzName: ts + 33033 /* "hexio_render_int..." */, FxProc: 0},
	{FzName: ts + 33052 /* "utf8_to_utf8" */, FxProc: 0},
	{FzName: ts + 33065 /* "read_fts3varint" */, FxProc: 0},
	{FzName: ts + 33081 /* "make_fts3record" */, FxProc: 0},
} /* test_hexio.c:450:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Wrapped = struct {
	Fpcache      sqlite3_pcache_methods2
	Fmem         sqlite3_mem_methods
	Fmutex       sqlite3_mutex_methods
	Fmem_init    int32
	Fmem_fail    int32
	Fmutex_init  int32
	Fmutex_fail  int32
	Fpcache_init int32
	Fpcache_fail int32
} /* test_init.c:36:8 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

var wrapped Wrapped /* test_init.c:47:3: */

func wrMemInit(tls *libc.TLS, pAppData uintptr) int32 { /* test_init.c:49:12: */
	var rc int32
	if wrapped.Fmem_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxInit})).f(tls, wrapped.Fmem.FpAppData)
	}
	if rc == SQLITE_OK {
		wrapped.Fmem_init = 1
	}
	return rc
}

func wrMemShutdown(tls *libc.TLS, pAppData uintptr) { /* test_init.c:61:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxShutdown})).f(tls, wrapped.Fmem.FpAppData)
	wrapped.Fmem_init = 0
}

func wrMemMalloc(tls *libc.TLS, n int32) uintptr { /* test_init.c:65:13: */
	return (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxMalloc})).f(tls, n)
}

func wrMemFree(tls *libc.TLS, p uintptr) { /* test_init.c:66:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxFree})).f(tls, p)
}

func wrMemRealloc(tls *libc.TLS, p uintptr, n int32) uintptr { /* test_init.c:67:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxRealloc})).f(tls, p, n)
}

func wrMemSize(tls *libc.TLS, p uintptr) int32 { /* test_init.c:68:12: */
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxSize})).f(tls, p)
}

func wrMemRoundup(tls *libc.TLS, n int32) int32 { /* test_init.c:69:12: */
	return (*struct{ f func(*libc.TLS, int32) int32 })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmem.FxRoundup})).f(tls, n)
}

func wrMutexInit(tls *libc.TLS) int32 { /* test_init.c:72:12: */
	var rc int32
	if wrapped.Fmutex_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexInit})).f(tls)
	}
	if rc == SQLITE_OK {
		wrapped.Fmutex_init = 1
	}
	return rc
}

func wrMutexEnd(tls *libc.TLS) int32 { /* test_init.c:84:12: */
	(*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexEnd})).f(tls)
	wrapped.Fmutex_init = 0
	return SQLITE_OK
}

func wrMutexAlloc(tls *libc.TLS, e int32) uintptr { /* test_init.c:89:22: */
	return (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexAlloc})).f(tls, e)
}

func wrMutexFree(tls *libc.TLS, p uintptr) { /* test_init.c:92:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexFree})).f(tls, p)
}

func wrMutexEnter(tls *libc.TLS, p uintptr) { /* test_init.c:95:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexEnter})).f(tls, p)
}

func wrMutexTry(tls *libc.TLS, p uintptr) int32 { /* test_init.c:98:12: */
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexTry})).f(tls, p)
}

func wrMutexLeave(tls *libc.TLS, p uintptr) { /* test_init.c:101:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexLeave})).f(tls, p)
}

func wrMutexHeld(tls *libc.TLS, p uintptr) int32 { /* test_init.c:104:12: */
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexHeld})).f(tls, p)
}

func wrMutexNotheld(tls *libc.TLS, p uintptr) int32 { /* test_init.c:107:12: */
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fmutex.FxMutexNotheld})).f(tls, p)
}

func wrPCacheInit(tls *libc.TLS, pArg uintptr) int32 { /* test_init.c:113:12: */
	var rc int32
	if wrapped.Fpcache_fail != 0 {
		rc = SQLITE_ERROR
	} else {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxInit})).f(tls, wrapped.Fpcache.FpArg)
	}
	if rc == SQLITE_OK {
		wrapped.Fpcache_init = 1
	}
	return rc
}

func wrPCacheShutdown(tls *libc.TLS, pArg uintptr) { /* test_init.c:125:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxShutdown})).f(tls, wrapped.Fpcache.FpArg)
	wrapped.Fpcache_init = 0
}

func wrPCacheCreate(tls *libc.TLS, a int32, b int32, c int32) uintptr { /* test_init.c:130:23: */
	return (*struct {
		f func(*libc.TLS, int32, int32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxCreate})).f(tls, a, b, c)
}

func wrPCacheCachesize(tls *libc.TLS, p uintptr, n int32) { /* test_init.c:133:13: */
	(*struct {
		f func(*libc.TLS, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxCachesize})).f(tls, p, n)
}

func wrPCachePagecount(tls *libc.TLS, p uintptr) int32 { /* test_init.c:136:12: */
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxPagecount})).f(tls, p)
}

func wrPCacheFetch(tls *libc.TLS, p uintptr, a uint32, b int32) uintptr { /* test_init.c:139:28: */
	return (*struct {
		f func(*libc.TLS, uintptr, uint32, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxFetch})).f(tls, p, a, b)
}

func wrPCacheUnpin(tls *libc.TLS, p uintptr, a uintptr, b int32) { /* test_init.c:142:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxUnpin})).f(tls, p, a, b)
}

func wrPCacheRekey(tls *libc.TLS, p uintptr, a uintptr, b uint32, c uint32) { /* test_init.c:145:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, uint32, uint32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxRekey})).f(tls, p, a, b, c)
}

func wrPCacheTruncate(tls *libc.TLS, p uintptr, a uint32) { /* test_init.c:153:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uint32)
	})(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxTruncate})).f(tls, p, a)
}

func wrPCacheDestroy(tls *libc.TLS, p uintptr) { /* test_init.c:156:13: */
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{wrapped.Fpcache.FxDestroy})).f(tls, p)
}

func installInitWrappers(tls *libc.TLS) { /* test_init.c:160:13: */
	bp := tls.Alloc(288)
	defer tls.Free(288)

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 48 /* mutexmethods */)) = sqlite3_mutex_methods{
		FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{wrMutexInit})), FxMutexEnd: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{wrMutexEnd})), FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{wrMutexAlloc})),
		FxMutexFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexFree})), FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexEnter})), FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexTry})),
		FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMutexLeave})), FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexHeld})), FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMutexNotheld})),
	}
	*(*sqlite3_pcache_methods2)(unsafe.Pointer(bp + 184 /* pcachemethods */)) = sqlite3_pcache_methods2{
		FiVersion: 1,
		FxInit: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrPCacheInit})), FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrPCacheShutdown})), FxCreate: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32, int32, int32) uintptr
		}{wrPCacheCreate})),
		FxCachesize: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32)
		}{wrPCacheCachesize})), FxPagecount: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrPCachePagecount})), FxFetch: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uint32, int32) uintptr
		}{wrPCacheFetch})),
		FxUnpin: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32)
		}{wrPCacheUnpin})), FxRekey: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, uint32, uint32)
		}{wrPCacheRekey})), FxTruncate: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uint32)
		}{wrPCacheTruncate})),
		FxDestroy: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrPCacheDestroy})),
	}
	*(*sqlite3_mem_methods)(unsafe.Pointer(bp + 120 /* memmethods */)) = sqlite3_mem_methods{
		FxMalloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{wrMemMalloc})), FxFree: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMemFree})), FxRealloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		}{wrMemRealloc})),
		FxSize: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMemSize})), FxRoundup: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{wrMemRoundup})), FxInit: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{wrMemInit})),
		FxShutdown: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{wrMemShutdown})),
	}

	libc.Xmemset(tls, uintptr(unsafe.Pointer(&wrapped)), 0, uint64(unsafe.Sizeof(wrapped)))

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMUTEX, libc.VaList(bp, uintptr(unsafe.Pointer(&wrapped))+168))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp+8, uintptr(unsafe.Pointer(&wrapped))+104))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETPCACHE2, libc.VaList(bp+16, uintptr(unsafe.Pointer(&wrapped))))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+24, bp+48 /* &mutexmethods */))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+32, bp+120 /* &memmethods */))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+40, bp+184 /* &pcachemethods */))
}

func init_wrapper_install(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:191:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var i int32
	installInitWrappers(tls)
	for i = 1; i < objc; i++ {
		var z uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)))
		if libc.Xstrcmp(tls, z, ts+33097) == 0 {
			wrapped.Fmem_fail = 1
		} else if libc.Xstrcmp(tls, z, ts+29700) == 0 {
			wrapped.Fmutex_fail = 1
		} else if libc.Xstrcmp(tls, z, ts+33101) == 0 {
			wrapped.Fpcache_fail = 1
		} else {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33108 /* "Unknown argument..." */, z, ts+12784 /* "\"" */))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

func init_wrapper_uninstall(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:215:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_shutdown(tls)
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp, uintptr(unsafe.Pointer(&wrapped))+168))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+8, uintptr(unsafe.Pointer(&wrapped))+104))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+16, uintptr(unsafe.Pointer(&wrapped))))
	return TCL_OK
}

func init_wrapper_clear(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:233:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	wrapped.Fmem_fail = 0
	wrapped.Fmutex_fail = 0
	wrapped.Fpcache_fail = 0
	return TCL_OK
}

func init_wrapper_query(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_init.c:250:26: */
	var pRet uintptr

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	if wrapped.Fmutex_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+29700 /* "mutex" */, -1))
	}
	if wrapped.Fmem_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+33097 /* "mem" */, -1))
	}
	if wrapped.Fpcache_init != 0 {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, ts+33101 /* "pcache" */, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

func Sqlitetest_init_Init(tls *libc.TLS, interp uintptr) int32 { /* test_init.c:278:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd9))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd9[i].FzName, aObjCmd9[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aObjCmd9 = [4]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 33128 /* "init_wrapper_ins..." */, FxProc: 0},
	{FzName: ts + 33149 /* "init_wrapper_que..." */, FxProc: 0},
	{FzName: ts + 33168 /* "init_wrapper_uni..." */, FxProc: 0},
	{FzName: ts + 33191 /* "init_wrapper_cle..." */, FxProc: 0},
} /* test_init.c:282:5 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// Make sure we can call this stuff from C++.

// An sqlite3_intarray is an abstract type to stores an instance of
// an integer array.
type sqlite3_intarray1 = struct {
	Fn           int32
	F__ccgo_pad1 [4]byte
	Fa           uintptr
	FxFree       uintptr
} /* test_intarray.h:99:9 */

//
// END OF REGISTRATION API
//

//******* End of fts5.h ********

// Make sure we can call this stuff from C++.

// An sqlite3_intarray is an abstract type to stores an instance of
// an integer array.
type sqlite3_intarray = sqlite3_intarray1 /* test_intarray.h:99:33 */

// Objects used internally by the virtual table implementation
type intarray_vtab1 = struct {
	Fbase     sqlite3_vtab
	FpContent uintptr
} /* test_intarray.c:41:9 */

// Objects used internally by the virtual table implementation
type intarray_vtab = intarray_vtab1 /* test_intarray.c:41:30 */
type intarray_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	Fi           int32
	F__ccgo_pad1 [4]byte
} /* test_intarray.c:42:9 */

type intarray_cursor = intarray_cursor1 /* test_intarray.c:42:32 */

// None of this works unless we have virtual tables.

// Free an sqlite3_intarray object.
func intarrayFree(tls *libc.TLS, p uintptr) { /* test_intarray.c:64:13: */
	if (*sqlite3_intarray)(unsafe.Pointer(p)).FxFree != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_intarray)(unsafe.Pointer(p)).FxFree})).f(tls, (*sqlite3_intarray)(unsafe.Pointer(p)).Fa)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

// Table destructor for the intarray module.
func intarrayDestroy(tls *libc.TLS, p uintptr) int32 { /* test_intarray.c:74:12: */
	var pVtab uintptr = p
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Table constructor for the intarray module.
func intarrayCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_intarray.c:83:12: */
	var rc int32 = SQLITE_NOMEM
	var pVtab uintptr = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_vtab{})))

	if pVtab != 0 {
		libc.Xmemset(tls, pVtab, 0, uint64(unsafe.Sizeof(intarray_vtab{})))
		(*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent = pAux
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db, ts+33210 /* "CREATE TABLE x(v..." */)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

// Open a new cursor on the intarray table.
func intarrayOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_intarray.c:106:12: */
	var rc int32 = SQLITE_NOMEM
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(intarray_cursor{})))
	if pCur != 0 {
		libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(intarray_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = SQLITE_OK
	}
	return rc
}

// Close a intarray table cursor.
func intarrayClose(tls *libc.TLS, cur uintptr) int32 { /* test_intarray.c:121:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Retrieve a column of data.
func intarrayColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_intarray.c:130:12: */
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	if (*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= 0 && (*intarray_cursor)(unsafe.Pointer(pCur)).Fi < (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn {
		sqlite3.Xsqlite3_result_int64(tls, ctx, *(*sqlite3_int64)(unsafe.Pointer((*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fa + uintptr((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)*8)))
	}
	return SQLITE_OK
}

// Retrieve the current rowid.
func intarrayRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_intarray.c:142:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*intarray_cursor)(unsafe.Pointer(pCur)).Fi)
	return SQLITE_OK
}

func intarrayEof(tls *libc.TLS, cur uintptr) int32 { /* test_intarray.c:148:12: */
	var pCur uintptr = cur
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	return libc.Bool32((*intarray_cursor)(unsafe.Pointer(pCur)).Fi >= (*sqlite3_intarray)(unsafe.Pointer((*intarray_vtab)(unsafe.Pointer(pVtab)).FpContent)).Fn)
}

// Advance the cursor to the next row.
func intarrayNext(tls *libc.TLS, cur uintptr) int32 { /* test_intarray.c:157:12: */
	var pCur uintptr = cur
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi++
	return SQLITE_OK
}

// Reset a intarray table cursor.
func intarrayFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_intarray.c:166:12: */
	var pCur uintptr = pVtabCursor
	(*intarray_cursor)(unsafe.Pointer(pCur)).Fi = 0
	return SQLITE_OK
}

// Analyse the WHERE condition.
func intarrayBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_intarray.c:179:12: */
	return SQLITE_OK
}

// A virtual table module that merely echos method calls into TCL
// variables.
var intarrayModule = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate - create a new virtual table
	FxConnect:    0, // xConnect - connect to an existing vtab
	FxBestIndex:  0, // xBestIndex - find the best query index
	FxDisconnect: 0, // xDisconnect - disconnect a vtab
	FxDestroy:    0, // xDestroy - destroy a vtab
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_intarray.c:187:23 */

// Invoke this routine to create a specific instance of an intarray object.
// The new intarray object is returned by the 3rd parameter.
//
// Each intarray object corresponds to a virtual table in the TEMP table
// with a name of zName.
//
// Destroy the intarray object by dropping the virtual table.  If not done
// explicitly by the application, the virtual table will be dropped implicitly
// by the system when the database connection is closed.
func sqlite3_intarray_create(tls *libc.TLS, db uintptr, zName uintptr, ppReturn uintptr) int32 { /* test_intarray.c:223:16: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32 = SQLITE_OK
	var p uintptr

	*(*uintptr)(unsafe.Pointer(ppReturn)) = libc.AssignUintptr(&p, sqlite3.Xsqlite3_malloc64(tls, uint64(unsafe.Sizeof(sqlite3_intarray{}))))
	if p == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(sqlite3_intarray{})))
	rc = sqlite3.Xsqlite3_create_module_v2(tls, db, zName, uintptr(unsafe.Pointer(&intarrayModule)), p,
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{intarrayFree})))
	if rc == SQLITE_OK {
		var zSql uintptr
		zSql = sqlite3.Xsqlite3_mprintf(tls, ts+33252, /* "CREATE VIRTUAL T..." */
			libc.VaList(bp, zName, zName))
		rc = sqlite3.Xsqlite3_exec(tls, db, zSql, uintptr(0), uintptr(0), uintptr(0))
		sqlite3.Xsqlite3_free(tls, zSql)
	}
	return rc
}

// Bind a new array array of integers to a specific intarray object.
//
// The array of integers bound must be unchanged for the duration of
// any query against the corresponding virtual table.  If the integer
// array does change or is deallocated undefined behavior will result.
func sqlite3_intarray_bind(tls *libc.TLS, pIntArray uintptr, nElements int32, aElements uintptr, xFree uintptr) int32 { /* test_intarray.c:257:16: */
	if (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree})).f(tls, (*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa)
	}
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fn = nElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).Fa = aElements
	(*sqlite3_intarray)(unsafe.Pointer(pIntArray)).FxFree = xFree
	return SQLITE_OK
}

//    sqlite3_intarray_create  DB  NAME
//
// Invoke the sqlite3_intarray_create interface.  A string that becomes
// the first parameter to sqlite3_intarray_bind.
func test_intarray_create(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_intarray.c:300:26: */
	bp := tls.Alloc(148)
	defer tls.Free(148)

	// var db uintptr at bp+32, 8

	var zName uintptr
	// var pArray uintptr at bp+40, 8

	var rc int32 = SQLITE_OK
	// var zPtr [100]int8 at bp+48, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	rc = sqlite3_intarray_create(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* db */)), zName, bp+40 /* &pArray */)
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}
	sqlite3TestMakePointerStr(tls, interp, bp+48 /* &zPtr[0] */, *(*uintptr)(unsafe.Pointer(bp + 40 /* pArray */)))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, bp+48 /* &zPtr[0] */, uintptr(0)))
	return TCL_OK
}

//    sqlite3_intarray_bind  INTARRAY  ?VALUE ...?
//
// Invoke the sqlite3_intarray_bind interface on the given array of integers.
func test_intarray_bind(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_intarray.c:335:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	var pArray uintptr
	var rc int32 = SQLITE_OK
	var i int32
	var n int32
	var a uintptr

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33290 /* "INTARRAY" */)
		return TCL_ERROR
	}
	pArray = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	n = objc - 2
	a = sqlite3.Xsqlite3_malloc64(tls, uint64(uint64(unsafe.Sizeof(sqlite3_int64(0)))*uint64(n)))
	if a == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33299 /* "SQLITE_NOMEM" */, uintptr(0)))
		return TCL_ERROR
	}
	for i = 0; i < n; i++ {
		*(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* x */)) = int64(0)
		tcl.XTcl_GetWideIntFromObj(tls, uintptr(0), *(*uintptr)(unsafe.Pointer(objv + uintptr(i+2)*8)), bp+32 /* &x */)
		*(*sqlite3_int64)(unsafe.Pointer(a + uintptr(i)*8)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 32 /* x */))
	}
	rc = sqlite3_intarray_bind(tls, pArray, n, a, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
	if rc != SQLITE_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0)))
		return TCL_ERROR
	}
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetestintarray_Init(tls *libc.TLS, interp uintptr) int32 { /* test_intarray.c:375:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd10))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd10[i].FzName,
			aObjCmd10[i].FxProc, aObjCmd10[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd10 = [2]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 33312 /* "sqlite3_intarray..." */, FxProc: 0},
	{FzName: ts + 33336 /* "sqlite3_intarray..." */, FxProc: 0},
} /* test_intarray.c:380:5 */

// Maximum pathname length supported by the jt backend.

// Name used to identify this VFS.

type jt_file1 = struct {
	Fbase        sqlite3_file
	FzName       uintptr
	Fflags       int32
	FeLock       int32
	FnPage       u32
	FnPagesize   u32
	FpWritable   uintptr
	FaCksum      uintptr
	FnSync       int32
	F__ccgo_pad1 [4]byte
	FiMaxOff     sqlite3_int64
	FpNext       uintptr
	FpReal       uintptr
} /* test_journal.c:111:9 */

// Maximum pathname length supported by the jt backend.

// Name used to identify this VFS.

type jt_file = jt_file1 /* test_journal.c:111:24 */

var jt_vfs = sqlite3_vfs{
	FiVersion:          2,                               // iVersion
	FszOsFile:          int32(unsafe.Sizeof(jt_file{})), // szOsFile
	FmxPathname:        JT_MAX_PATHNAME,                 // pNext
	FzName:             ts + 33358,                      /* "jt" */ // pAppData
	FxOpen:             0,                               // xOpen
	FxDelete:           0,                               // xDelete
	FxAccess:           0,                               // xAccess
	FxFullPathname:     0,                               // xFullPathname
	FxDlOpen:           0,                               // xDlOpen
	FxDlError:          0,                               // xDlError
	FxDlSym:            0,                               // xDlSym
	FxDlClose:          0,                               // xDlClose
	FxRandomness:       0,                               // xRandomness
	FxSleep:            0,                               // xSleep
	FxCurrentTime:      0,                               // xCurrentTime
	FxGetLastError:     0,                               // xGetLastError
	FxCurrentTimeInt64: 0,                               // xCurrentTimeInt64
} /* test_journal.c:165:20 */

var jt_io_methods = sqlite3_io_methods{
	FiVersion:               1, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
} /* test_journal.c:187:27 */

type JtGlobal = struct {
	FpVfs  uintptr
	FpList uintptr
} /* test_journal.c:203:1 */

var g2 = JtGlobal{} /* test_journal.c:207:24 */

// Functions to obtain and relinquish a mutex to protect g.pList. The
// STATIC_PRNG mutex is reused, purely for the sake of convenience.
func enterJtMutex(tls *libc.TLS) { /* test_journal.c:213:13: */
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_PRNG))
}

func leaveJtMutex(tls *libc.TLS) { /* test_journal.c:216:13: */
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_STATIC_PRNG))
}

func stop_ioerr_simulation(tls *libc.TLS, piSave uintptr, piSave2 uintptr) { /* test_journal.c:222:13: */
	*(*int32)(unsafe.Pointer(piSave)) = libc.AtomicLoadInt32(&sqlite3.Xsqlite3_io_error_pending)
	*(*int32)(unsafe.Pointer(piSave2)) = sqlite3.Xsqlite3_io_error_hit
	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(-1))
	sqlite3.Xsqlite3_io_error_hit = 0
}

func start_ioerr_simulation(tls *libc.TLS, iSave int32, iSave2 int32) { /* test_journal.c:228:13: */
	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(iSave))
	sqlite3.Xsqlite3_io_error_hit = iSave2
}

// The jt_file pointed to by the argument may or may not be a file-handle
// open on a main database file. If it is, and a transaction is currently
// opened on the file, then discard all transaction related data.
func closeTransaction(tls *libc.TLS, p uintptr) { /* test_journal.c:238:13: */
	sqlite3.Xsqlite3BitvecDestroy(tls, (*jt_file)(unsafe.Pointer(p)).FpWritable)
	sqlite3.Xsqlite3_free(tls, (*jt_file)(unsafe.Pointer(p)).FaCksum)
	(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FnSync = 0
}

// Close an jt-file.
func jtClose(tls *libc.TLS, pFile uintptr) int32 { /* test_journal.c:249:12: */
	var pp uintptr
	var p uintptr = pFile

	closeTransaction(tls, p)
	enterJtMutex(tls)
	if (*jt_file)(unsafe.Pointer(p)).FzName != 0 {
		for pp = uintptr(unsafe.Pointer(&g2)) + 8; *(*uintptr)(unsafe.Pointer(pp)) != p; pp = *(*uintptr)(unsafe.Pointer(pp)) + 64 {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*jt_file)(unsafe.Pointer(p)).FpNext
	}
	leaveJtMutex(tls)
	sqlite3.Xsqlite3OsClose(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
	return SQLITE_OK
}

// Read data from an jt-file.
func jtRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_journal.c:267:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
}

//
// Parameter zJournal is the name of a journal file that is currently
// open. This function locates and returns the handle opened on the
// corresponding database file by the pager that currently has the
// journal file opened. This file-handle is identified by the
// following properties:
//
//   a) SQLITE_OPEN_MAIN_DB was specified when the file was opened.
//
//   b) The file-name specified when the file was opened matches
//      all but the final 8 characters of the journal file name.
//
//   c) There is currently a reserved lock on the file. This
//      condition is waived if the noLock argument is non-zero.
//
func locateDatabaseHandle(tls *libc.TLS, zJournal uintptr, noLock int32) uintptr { /* test_journal.c:292:16: */
	var pMain uintptr = uintptr(0)
	enterJtMutex(tls)
	for pMain = g2.FpList; pMain != 0; pMain = (*jt_file)(unsafe.Pointer(pMain)).FpNext {
		var nName int32 = int32(libc.Xstrlen(tls, zJournal) - libc.Xstrlen(tls, ts+33361))
		if (*jt_file)(unsafe.Pointer(pMain)).Fflags&SQLITE_OPEN_MAIN_DB != 0 &&
			int32(libc.Xstrlen(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName)) == nName &&
			0 == libc.Xmemcmp(tls, (*jt_file)(unsafe.Pointer(pMain)).FzName, zJournal, uint64(nName)) &&
			((*jt_file)(unsafe.Pointer(pMain)).FeLock >= SQLITE_LOCK_RESERVED || noLock != 0) {
			break
		}
	}
	leaveJtMutex(tls)
	return pMain
}

// Parameter z points to a buffer of 4 bytes in size containing a
// unsigned 32-bit integer stored in big-endian format. Decode the
// integer and return its value.
func decodeUint32(tls *libc.TLS, z uintptr) u32 { /* test_journal.c:314:12: */
	return u32(int32(*(*uint8)(unsafe.Pointer(z)))<<24 + int32(*(*uint8)(unsafe.Pointer(z + 1)))<<16 + int32(*(*uint8)(unsafe.Pointer(z + 2)))<<8 + int32(*(*uint8)(unsafe.Pointer(z + 3))))
}

// Calculate a checksum from the buffer of length n bytes pointed to
// by parameter z.
func genCksum(tls *libc.TLS, z uintptr, n int32) u32 { /* test_journal.c:322:12: */
	var i int32
	var cksum u32 = u32(0)
	for i = 0; i < n; i++ {
		cksum = cksum + u32(*(*uint8)(unsafe.Pointer(z + uintptr(i)))) + cksum<<3
	}
	return cksum
}

// The first argument, zBuf, points to a buffer containing a 28 byte
// serialized journal header. This function deserializes four of the
// integer fields contained in the journal header and writes their
// values to the output variables.
//
// SQLITE_OK is returned if the journal-header is successfully
// decoded. Otherwise, SQLITE_ERROR.
func decodeJournalHdr(tls *libc.TLS, zBuf uintptr, pnRec uintptr, pnPage uintptr, pnSector uintptr, pnPagesize uintptr) int32 { /* test_journal.c:340:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*[8]uint8)(unsafe.Pointer(bp /* aMagic */)) = [8]uint8{uint8(0xd9), uint8(0xd5), uint8(0x05), uint8(0xf9), uint8(0x20), uint8(0xa1), uint8(0x63), uint8(0xd7)}
	if libc.Xmemcmp(tls, bp, zBuf, uint64(8)) != 0 {
		return SQLITE_ERROR
	}
	if pnRec != 0 {
		*(*u32)(unsafe.Pointer(pnRec)) = decodeUint32(tls, zBuf+8)
	}
	if pnPage != 0 {
		*(*u32)(unsafe.Pointer(pnPage)) = decodeUint32(tls, zBuf+16)
	}
	if pnSector != 0 {
		*(*u32)(unsafe.Pointer(pnSector)) = decodeUint32(tls, zBuf+20)
	}
	if pnPagesize != 0 {
		*(*u32)(unsafe.Pointer(pnPagesize)) = decodeUint32(tls, zBuf+24)
	}
	return SQLITE_OK
}

// This function is called when a new transaction is opened, just after
// the first journal-header is written to the journal file.
func openTransaction(tls *libc.TLS, pMain uintptr, pJournal uintptr) int32 { /* test_journal.c:360:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var aData uintptr
	var p uintptr = (*jt_file)(unsafe.Pointer(pMain)).FpReal
	var rc int32 = SQLITE_OK

	closeTransaction(tls, pMain)
	aData = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	(*jt_file)(unsafe.Pointer(pMain)).FpWritable = sqlite3.Xsqlite3BitvecCreate(tls, (*jt_file)(unsafe.Pointer(pMain)).FnPage)
	(*jt_file)(unsafe.Pointer(pMain)).FaCksum = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(u32(0)))*uint64((*jt_file)(unsafe.Pointer(pMain)).FnPage+u32(1))))
	(*jt_file)(unsafe.Pointer(pJournal)).FiMaxOff = int64(0)

	if !(int32((*jt_file)(unsafe.Pointer(pMain)).FpWritable) != 0) || !(int32((*jt_file)(unsafe.Pointer(pMain)).FaCksum) != 0) || !(aData != 0) {
		rc = SQLITE_IOERR | int32(12)<<8
	} else if (*jt_file)(unsafe.Pointer(pMain)).FnPage > u32(0) {
		var iTrunk u32
		// var iSave int32 at bp, 4

		// var iSave2 int32 at bp+4, 4

		stop_ioerr_simulation(tls, bp /* &iSave */, bp+4 /* &iSave2 */)

		// Read the database free-list. Add the page-number for each free-list
		// leaf to the jt_file.pWritable bitvec.
		rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), int64(0))
		if rc == SQLITE_OK {
			var nDbsize u32 = decodeUint32(tls, aData+28)
			if nDbsize > u32(0) && libc.Xmemcmp(tls, aData+24, aData+92, uint64(4)) == 0 {
				var iPg u32
				for iPg = nDbsize + u32(1); iPg <= (*jt_file)(unsafe.Pointer(pMain)).FnPage; iPg++ {
					sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, iPg)
				}
			}
		}
		iTrunk = decodeUint32(tls, aData+32)
		for rc == SQLITE_OK && iTrunk > u32(0) {
			var nLeaf u32
			var iLeaf u32
			var iOff sqlite3_int64 = i64(iTrunk-u32(1)) * i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize)
			rc = sqlite3.Xsqlite3OsRead(tls, p, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
			nLeaf = decodeUint32(tls, aData+4)
			for iLeaf = u32(0); rc == SQLITE_OK && iLeaf < nLeaf; iLeaf++ {
				var pgno u32 = decodeUint32(tls, aData+uintptr(u32(8)+u32(4)*iLeaf))
				sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
			}
			iTrunk = decodeUint32(tls, aData)
		}

		// Calculate and store a checksum for each page in the database file.
		if rc == SQLITE_OK {
			var ii int32
			for ii = 0; rc == SQLITE_OK && ii < int32((*jt_file)(unsafe.Pointer(pMain)).FnPage); ii++ {
				var iOff i64 = i64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize) * i64(ii)
				if iOff == i64(sqlite3.Xsqlite3PendingByte) {
					continue
				}
				rc = sqlite3.Xsqlite3OsRead(tls, (*jt_file)(unsafe.Pointer(pMain)).FpReal, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff)
				*(*u32)(unsafe.Pointer((*jt_file)(unsafe.Pointer(pMain)).FaCksum + uintptr(ii)*4)) = genCksum(tls, aData, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
				if ii+1 == int32((*jt_file)(unsafe.Pointer(pMain)).FnPage) && rc == SQLITE_IOERR|int32(2)<<8 {
					rc = SQLITE_OK
				}
			}
		}

		start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp /* iSave */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSave2 */)))
	}

	sqlite3.Xsqlite3_free(tls, aData)
	return rc
}

// The first argument to this function is a handle open on a journal file.
// This function reads the journal file and adds the page number for each
// page in the journal to the Bitvec object passed as the second argument.
func readJournalFile(tls *libc.TLS, p uintptr, pMain uintptr) int32 { /* test_journal.c:433:12: */
	bp := tls.Alloc(52)
	defer tls.Free(52)

	var rc int32
	// var zBuf [28]uint8 at bp+8, 28

	var pReal uintptr
	var iOff sqlite3_int64
	var iSize sqlite3_int64
	var aPage uintptr
	// var iSave int32 at bp, 4

	// var iSave2 int32 at bp+4, 4

	var cksum u32
	_ = cksum
	var pgno u32
	// var nRec u32 at bp+36, 4

	// var nPage u32 at bp+40, 4

	// var nSector u32 at bp+44, 4

	// var nPagesize u32 at bp+48, 4

	var ii u32
	rc = SQLITE_OK
	pReal = (*jt_file)(unsafe.Pointer(p)).FpReal
	iOff = int64(0)
	iSize = (*jt_file)(unsafe.Pointer(p)).FiMaxOff

	aPage = sqlite3.Xsqlite3_malloc(tls, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))
	if !!(aPage != 0) {
		goto __1
	}
	return SQLITE_IOERR | int32(12)<<8
__1:
	;

	stop_ioerr_simulation(tls, bp /* &iSave */, bp+4 /* &iSave2 */)

__2:
	if !(rc == SQLITE_OK && iOff < iSize) {
		goto __3
	}

	// Read and decode the next journal-header from the journal file.
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 28, iOff)
	if !(rc != SQLITE_OK ||
		decodeJournalHdr(tls, bp+8, bp+36, bp+40, bp+44, bp+48) != 0) {
		goto __4
	}
	goto finish_rjf
__4:
	;
	iOff = iOff + sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44)))

	if !(*(*u32)(unsafe.Pointer(bp + 36)) == u32(0)) {
		goto __5
	}
	// A trick. There might be another journal-header immediately
	// following this one. In this case, 0 records means 0 records,
	// not "read until the end of the file". See also ticket #2565.
	if !(iSize >= iOff+sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44)))) {
		goto __6
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 28, iOff)
	if !(rc != SQLITE_OK || 0 == decodeJournalHdr(tls, bp+8, uintptr(0), uintptr(0), uintptr(0), uintptr(0))) {
		goto __7
	}
	goto __2
__7:
	;
__6:
	;
	*(*u32)(unsafe.Pointer(bp + 36 /* nRec */)) = u32((iSize - iOff) / sqlite3_int64((*jt_file)(unsafe.Pointer(pMain)).FnPagesize+u32(8)))
__5:
	;

	// Read all the records that follow the journal-header just read.
	ii = u32(0)
__8:
	if !(rc == SQLITE_OK && ii < *(*u32)(unsafe.Pointer(bp + 36)) && iOff < iSize) {
		goto __10
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, bp+8 /* &zBuf[0] */, 4, iOff)
	if !(rc == SQLITE_OK) {
		goto __11
	}
	pgno = decodeUint32(tls, bp+8 /* &zBuf[0] */)
	if !(pgno > u32(0) && pgno <= (*jt_file)(unsafe.Pointer(pMain)).FnPage) {
		goto __12
	}
	if !(0 == sqlite3.Xsqlite3BitvecTest(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)) {
		goto __13
	}
	rc = sqlite3.Xsqlite3OsRead(tls, pReal, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize), iOff+int64(4))
	if !(rc == SQLITE_OK) {
		goto __14
	}
	cksum = genCksum(tls, aPage, int32((*jt_file)(unsafe.Pointer(pMain)).FnPagesize))

__14:
	;
__13:
	;
	sqlite3.Xsqlite3BitvecSet(tls, (*jt_file)(unsafe.Pointer(pMain)).FpWritable, pgno)
__12:
	;
	iOff = iOff + sqlite3_int64(u32(8)+(*jt_file)(unsafe.Pointer(pMain)).FnPagesize)
__11:
	;
	goto __9
__9:
	ii++
	goto __8
	goto __10
__10:
	;

	iOff = (iOff + sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44))-u32(1))) / sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44))) * sqlite3_int64(*(*u32)(unsafe.Pointer(bp + 44)))
	goto __2
__3:
	;

finish_rjf:
	start_ioerr_simulation(tls, *(*int32)(unsafe.Pointer(bp /* iSave */)), *(*int32)(unsafe.Pointer(bp + 4 /* iSave2 */)))
	sqlite3.Xsqlite3_free(tls, aPage)
	if !(rc == SQLITE_IOERR|int32(2)<<8) {
		goto __15
	}
	rc = SQLITE_OK
__15:
	;
	return rc
}

// Write data to an jt-file.
func jtWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_journal.c:512:12: */
	var rc int32
	var p uintptr = pFile
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 {
		if iOfst == int64(0) {
			var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

			if iAmt == 28 {
				// Zeroing the first journal-file header. This is the end of a
				// transaction.
				closeTransaction(tls, pMain)
			} else if iAmt != 12 {
				// Writing the first journal header to a journal file. This happens
				// when a transaction is first started.
				var z uintptr = zBuf
				(*jt_file)(unsafe.Pointer(pMain)).FnPage = decodeUint32(tls, z+16)
				(*jt_file)(unsafe.Pointer(pMain)).FnPagesize = decodeUint32(tls, z+24)
				if SQLITE_OK != libc.AssignInt32(&rc, openTransaction(tls, pMain, p)) {
					return rc
				}
			}
		}
		if (*jt_file)(unsafe.Pointer(p)).FiMaxOff < iOfst+sqlite_int64(iAmt) {
			(*jt_file)(unsafe.Pointer(p)).FiMaxOff = iOfst + sqlite_int64(iAmt)
		}
	}

	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_DB != 0 && (*jt_file)(unsafe.Pointer(p)).FpWritable != 0 {
		if iAmt < int32((*jt_file)(unsafe.Pointer(p)).FnPagesize) &&
			(*jt_file)(unsafe.Pointer(p)).FnPagesize%u32(iAmt) == u32(0) &&
			iOfst >= sqlite_int64(sqlite3.Xsqlite3PendingByte+512) &&
			iOfst+sqlite_int64(iAmt) <= sqlite_int64(u32(sqlite3.Xsqlite3PendingByte)+(*jt_file)(unsafe.Pointer(p)).FnPagesize) {
			// No-op. This special case is hit when the backup code is copying a
			// to a database with a larger page-size than the source database and
			// it needs to fill in the non-locking-region part of the original
			// pending-byte page.
		} else {
			var pgno u32 = u32(iOfst/sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize) + int64(1))
			_ = pgno

			// The following assert() statements may fail if this layer is used
			// with a connection in "PRAGMA synchronous=off" mode. If they
			// fail with sync=normal or sync=full, this may indicate problem.

		}
	}

	rc = sqlite3.Xsqlite3OsWrite(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 && iAmt == 12 {
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		var rc2 int32 = readJournalFile(tls, p, pMain)
		if rc == SQLITE_OK {
			rc = rc2
		}
	}
	return rc
}

// Truncate an jt-file.
func jtTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_journal.c:580:12: */
	var p uintptr = pFile
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 && size == int64(0) {
		// Truncating a journal file. This is the end of a transaction.
		var pMain uintptr = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)
		closeTransaction(tls, pMain)
	}
	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_DB != 0 && (*jt_file)(unsafe.Pointer(p)).FpWritable != 0 {
		var pgno u32
		var locking_page u32 = u32(sqlite3.Xsqlite3PendingByte)/(*jt_file)(unsafe.Pointer(p)).FnPagesize + u32(1)
		_ = locking_page
		for pgno = u32(size/sqlite_int64((*jt_file)(unsafe.Pointer(p)).FnPagesize) + int64(1)); pgno <= (*jt_file)(unsafe.Pointer(p)).FnPage; pgno++ {

		}
	}
	return sqlite3.Xsqlite3OsTruncate(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, size)
}

// Sync an jt-file.
func jtSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_journal.c:600:12: */
	var p uintptr = pFile

	if (*jt_file)(unsafe.Pointer(p)).Fflags&SQLITE_OPEN_MAIN_JOURNAL != 0 {
		var rc int32
		var pMain uintptr // The associated database file

		// The journal file is being synced. At this point, we inspect the
		// contents of the file up to this point and set each bit in the
		// jt_file.pWritable bitvec of the main database file associated with
		// this journal file.
		pMain = locateDatabaseHandle(tls, (*jt_file)(unsafe.Pointer(p)).FzName, 0)

		// Set the bitvec values
		if pMain != 0 && (*jt_file)(unsafe.Pointer(pMain)).FpWritable != 0 {
			(*jt_file)(unsafe.Pointer(pMain)).FnSync++
			rc = readJournalFile(tls, p, pMain)
			if rc != SQLITE_OK {
				return rc
			}
		}
	}

	return sqlite3.Xsqlite3OsSync(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, flags)
}

// Return the current file-size of an jt-file.
func jtFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_journal.c:630:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsFileSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an jt-file.
func jtLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_journal.c:638:12: */
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if rc == SQLITE_OK && eLock > (*jt_file)(unsafe.Pointer(p)).FeLock {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

// Unlock an jt-file.
func jtUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_journal.c:651:12: */
	var rc int32
	var p uintptr = pFile
	rc = sqlite3.Xsqlite3OsUnlock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, eLock)
	if rc == SQLITE_OK && eLock < (*jt_file)(unsafe.Pointer(p)).FeLock {
		(*jt_file)(unsafe.Pointer(p)).FeLock = eLock
	}
	return rc
}

// Check if another file-handle holds a RESERVED lock on an jt-file.
func jtCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_journal.c:664:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, pResOut)
}

// File control method. For custom operations on an jt-file.
func jtFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_journal.c:672:12: */
	var p uintptr = pFile
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxFileControl})).f(tls, (*jt_file)(unsafe.Pointer(p)).FpReal, op, pArg)
}

// Return the sector-size in bytes for an jt-file.
func jtSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_journal.c:680:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsSectorSize(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

// Return the device characteristic flags supported by an jt-file.
func jtDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_journal.c:688:12: */
	var p uintptr = pFile
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*jt_file)(unsafe.Pointer(p)).FpReal)
}

// Open an jt file handle.
func jtOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_journal.c:696:12: */
	var rc int32
	var p uintptr = pFile
	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(0)
	(*jt_file)(unsafe.Pointer(p)).FpReal = p + 1*80
	(*sqlite3_file)(unsafe.Pointer((*jt_file)(unsafe.Pointer(p)).FpReal)).FpMethods = uintptr(0)
	rc = sqlite3.Xsqlite3OsOpen(tls, g2.FpVfs, zName, (*jt_file)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)

	if rc == SQLITE_OK {
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&jt_io_methods))
		(*jt_file)(unsafe.Pointer(p)).FeLock = 0
		(*jt_file)(unsafe.Pointer(p)).FzName = zName
		(*jt_file)(unsafe.Pointer(p)).Fflags = flags
		(*jt_file)(unsafe.Pointer(p)).FpNext = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FpWritable = uintptr(0)
		(*jt_file)(unsafe.Pointer(p)).FaCksum = uintptr(0)
		enterJtMutex(tls)
		if zName != 0 {
			(*jt_file)(unsafe.Pointer(p)).FpNext = g2.FpList
			g2.FpList = p
		}
		leaveJtMutex(tls)
	}
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func jtDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_journal.c:733:12: */
	var nPath int32 = int32(libc.Xstrlen(tls, zPath))
	if nPath > 8 && 0 == libc.Xstrcmp(tls, ts+33361, zPath+uintptr(nPath-8)) {
		// Deleting a journal file. The end of a transaction.
		var pMain uintptr = locateDatabaseHandle(tls, zPath, 0)
		if pMain != 0 {
			closeTransaction(tls, pMain)
		}
	}

	return sqlite3.Xsqlite3OsDelete(tls, g2.FpVfs, zPath, dirSync)
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func jtAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_journal.c:750:12: */
	return sqlite3.Xsqlite3OsAccess(tls, g2.FpVfs, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (JT_MAX_PATHNAME+1) bytes.
func jtFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_journal.c:764:12: */
	return sqlite3.Xsqlite3OsFullPathname(tls, g2.FpVfs, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func jtDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_journal.c:776:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlOpen})).f(tls, g2.FpVfs, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func jtDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_journal.c:785:13: */
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlError})).f(tls, g2.FpVfs, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func jtDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* test_journal.c:792:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlSym})).f(tls, g2.FpVfs, p, zSym)
}

// Close the dynamic library handle pHandle.
func jtDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* test_journal.c:799:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxDlClose})).f(tls, g2.FpVfs, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func jtRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_journal.c:807:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, g2.FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func jtSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_journal.c:815:12: */
	return sqlite3.Xsqlite3OsSleep(tls, g2.FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func jtCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_journal.c:822:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTime})).f(tls, g2.FpVfs, pTimeOut)
}

// Return the current time as a Julian Day number in *pTimeOut.
func jtCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_journal.c:828:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTimeInt64})).f(tls, g2.FpVfs, pTimeOut)
}

func jtGetLastError(tls *libc.TLS, pVfs uintptr, n int32, z uintptr) int32 { /* test_journal.c:832:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxGetLastError})).f(tls, g2.FpVfs, n, z)
}

// *************************************************************************
//
// Start of public API.

// Configure the jt VFS as a wrapper around the VFS named by parameter
// zWrap. If the isDefault parameter is true, then the jt VFS is installed
// as the new default VFS for SQLite connections. If isDefault is not
// true, then the jt VFS is installed as non-default. In this case it
// is available via its name, "jt".
func jt_register(tls *libc.TLS, zWrap uintptr, isDefault int32) int32 { /* test_journal.c:847:5: */
	g2.FpVfs = sqlite3.Xsqlite3_vfs_find(tls, zWrap)
	if g2.FpVfs == uintptr(0) {
		return SQLITE_ERROR
	}
	jt_vfs.FszOsFile = int32(uint64(unsafe.Sizeof(jt_file{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FszOsFile))
	if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FiVersion == 1 {
		jt_vfs.FiVersion = 1
	} else if (*sqlite3_vfs)(unsafe.Pointer(g2.FpVfs)).FxCurrentTimeInt64 == uintptr(0) {
		jt_vfs.FxCurrentTimeInt64 = uintptr(0)
	}
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&jt_vfs)), isDefault)
	return SQLITE_OK
}

// Uninstall the jt VFS, if it is installed.
func jt_unregister(tls *libc.TLS) { /* test_journal.c:865:6: */
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&jt_vfs)))
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)assert.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Unlike other ANSI header files, <assert.h> may usefully be included
// multiple times, with and without NDEBUG defined.

// This structure is used to encapsulate the global state variables used
// by malloc() fault simulation.
type MemFault = struct {
	FiCountdown   int32
	FnRepeat      int32
	FnBenign      int32
	FnFail        int32
	FnOkBefore    int32
	FnOkAfter     int32
	Fenable       u8
	F__ccgo_pad1  [3]byte
	FisInstalled  int32
	FisBenignMode int32
	F__ccgo_pad2  [4]byte
	Fm            sqlite3_mem_methods
} /* test_malloc.c:30:8 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)assert.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Unlike other ANSI header files, <assert.h> may usefully be included
// multiple times, with and without NDEBUG defined.

// This structure is used to encapsulate the global state variables used
// by malloc() fault simulation.
var memfault MemFault /* test_malloc.c:41:3: */

// This routine exists as a place to set a breakpoint that will
// fire on any simulated malloc() failure.
func sqlite3Fault(tls *libc.TLS) { /* test_malloc.c:47:13: */
	cnt1++
}

var cnt1 int32 = 0 /* test_malloc.c:48:14 */

// This routine exists as a place to set a breakpoint that will
// fire the first time any malloc() fails on a single test case.
// The sqlite3Fault() routine above runs on every malloc() failure.
// This routine only runs on the first such failure.
func sqlite3FirstFault(tls *libc.TLS) { /* test_malloc.c:58:13: */
	cnt2++
}

var cnt2 int32 = 0 /* test_malloc.c:59:14 */

// Check to see if a fault should be simulated.  Return true to simulate
// the fault.  Return false if the fault should not be simulated.
func faultsimStep(tls *libc.TLS) int32 { /* test_malloc.c:67:12: */
	if !(int32(memfault.Fenable) != 0) {
		memfault.FnOkAfter++
		return 0
	}
	if memfault.FiCountdown > 0 {
		memfault.FiCountdown--
		memfault.FnOkBefore++
		return 0
	}
	if memfault.FnFail == 0 {
		sqlite3FirstFault(tls)
	}
	sqlite3Fault(tls)
	memfault.FnFail++
	if memfault.FisBenignMode > 0 {
		memfault.FnBenign++
	}
	memfault.FnRepeat--
	if memfault.FnRepeat <= 0 {
		memfault.Fenable = u8(0)
	}
	return 1
}

// A version of sqlite3_mem_methods.xMalloc() that includes fault simulation
// logic.
func faultsimMalloc(tls *libc.TLS, n int32) uintptr { /* test_malloc.c:94:13: */
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*struct {
			f func(*libc.TLS, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{memfault.Fm.FxMalloc})).f(tls, n)
	}
	return p
}

// A version of sqlite3_mem_methods.xRealloc() that includes fault simulation
// logic.
func faultsimRealloc(tls *libc.TLS, pOld uintptr, n int32) uintptr { /* test_malloc.c:107:13: */
	var p uintptr = uintptr(0)
	if !(faultsimStep(tls) != 0) {
		p = (*struct {
			f func(*libc.TLS, uintptr, int32) uintptr
		})(unsafe.Pointer(&struct{ uintptr }{memfault.Fm.FxRealloc})).f(tls, pOld, n)
	}
	return p
}

// This routine configures the malloc failure simulation.  After
// calling this routine, the next nDelay mallocs will succeed, followed
// by a block of nRepeat failures, after which malloc() calls will begin
// to succeed again.
func faultsimConfig(tls *libc.TLS, nDelay int32, nRepeat int32) { /* test_malloc.c:121:13: */
	memfault.FiCountdown = nDelay
	memfault.FnRepeat = nRepeat
	memfault.FnBenign = 0
	memfault.FnFail = 0
	memfault.FnOkBefore = 0
	memfault.FnOkAfter = 0
	memfault.Fenable = u8(libc.Bool32(nDelay >= 0))

	// Sometimes, when running multi-threaded tests, the isBenignMode
	// variable is not properly incremented/decremented so that it is
	// 0 when not inside a benign malloc block. This doesn't affect
	// the multi-threaded tests, as they do not use this system. But
	// it does affect OOM tests run later in the same process. So
	// zero the variable here, just to be sure.
	memfault.FisBenignMode = 0
}

// Return the number of faults (both hard and benign faults) that have
// occurred since the injector was last configured.
func faultsimFailures(tls *libc.TLS) int32 { /* test_malloc.c:144:12: */
	return memfault.FnFail
}

// Return the number of benign faults that have occurred since the
// injector was last configured.
func faultsimBenignFailures(tls *libc.TLS) int32 { /* test_malloc.c:152:12: */
	return memfault.FnBenign
}

// Return the number of successes that will occur before the next failure.
// If no failures are scheduled, return -1.
func faultsimPending(tls *libc.TLS) int32 { /* test_malloc.c:160:12: */
	if memfault.Fenable != 0 {
		return memfault.FiCountdown
	} else {
		return -1
	}
	return int32(0)
}

func faultsimBeginBenign(tls *libc.TLS) { /* test_malloc.c:169:13: */
	memfault.FisBenignMode++
}

func faultsimEndBenign(tls *libc.TLS) { /* test_malloc.c:172:13: */
	memfault.FisBenignMode--
}

// Add or remove the fault-simulation layer using sqlite3_config(). If
// the argument is non-zero, the
func faultsimInstall(tls *libc.TLS, install int32) int32 { /* test_malloc.c:180:12: */
	bp := tls.Alloc(200)
	defer tls.Free(200)

	var rc int32

	install = func() int32 {
		if install != 0 {
			return 1
		}
		return 0
	}()

	if install == memfault.FisInstalled {
		return SQLITE_ERROR
	}

	if install != 0 {
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp, uintptr(unsafe.Pointer(&memfault))+40))

		if rc == SQLITE_OK {
			*(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72 /* m */)) = memfault.Fm
			(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72 /* &m */)).FxMalloc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, int32) uintptr
			}{faultsimMalloc}))
			(*sqlite3_mem_methods)(unsafe.Pointer(bp + 72 /* &m */)).FxRealloc = *(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr, int32) uintptr
			}{faultsimRealloc}))
			rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+8, bp+72 /* &m */))
		}
		sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,
			libc.VaList(bp+16, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{faultsimBeginBenign})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) }{faultsimEndBenign}))))
	} else {
		// var m2 sqlite3_mem_methods at bp+136, 64

		// One should be able to reset the default memory allocator by storing
		// a zeroed allocator then calling GETMALLOC.
		libc.Xmemset(tls, bp+136 /* &m2 */, 0, uint64(unsafe.Sizeof(sqlite3_mem_methods{})))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+32, bp+136 /* &m2 */))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMALLOC, libc.VaList(bp+40, bp+136 /* &m2 */))

		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MALLOC, libc.VaList(bp+48, uintptr(unsafe.Pointer(&memfault))+40))
		sqlite3.Xsqlite3_test_control(tls, SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS,
			libc.VaList(bp+56, uintptr(0), uintptr(0)))
	}

	if rc == SQLITE_OK {
		memfault.FisInstalled = 1
	}
	return rc
}

// Transform pointers to text and back again
func pointerToText(tls *libc.TLS, p uintptr, z uintptr) { /* test_malloc.c:239:13: */
	bp := tls.Alloc(20)
	defer tls.Free(20)
	*(*uintptr)(unsafe.Pointer(bp + 8)) = p

	var i int32
	var k int32
	// var u uint32 at bp+16, 4

	// var n sqlite3_uint64 at bp, 8

	if *(*uintptr)(unsafe.Pointer(bp + 8)) == uintptr(0) {
		libc.Xstrcpy(tls, z, ts+15020 /* "0" */)
		return
	}
	if uint64(unsafe.Sizeof(sqlite3_uint64(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp /* &n */, bp+8 /* &p */, uint64(unsafe.Sizeof(uintptr(0))))
	} else if uint64(unsafe.Sizeof(uint32(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, bp+16 /* &u */, bp+8 /* &p */, uint64(unsafe.Sizeof(uint32(0))))
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = sqlite3_uint64(*(*uint32)(unsafe.Pointer(bp + 16 /* u */)))
	} else {

	}
	i = 0
	k = int32(uint64(unsafe.Sizeof(uintptr(0)))*uint64(2) - uint64(1))
__1:
	if !(uint64(i) < uint64(unsafe.Sizeof(uintptr(0)))*uint64(2)) {
		goto __3
	}
	{
		*(*int8)(unsafe.Pointer(z + uintptr(k))) = zHex[*(*sqlite3_uint64)(unsafe.Pointer(bp))&uint64(0xf)]
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) >>= 4

	}
	goto __2
__2:
	i++
	k--
	goto __1
	goto __3
__3:
	;
	*(*int8)(unsafe.Pointer(z + 16)) = int8(0)
}

var zHex = *(*[17]int8)(unsafe.Pointer(ts + 31744 /* "0123456789abcdef" */)) /* test_malloc.c:240:21 */

func hexToInt(tls *libc.TLS, h int32) int32 { /* test_malloc.c:262:12: */
	if h >= '0' && h <= '9' {
		return h - '0'
	} else if h >= 'a' && h <= 'f' {
		return h - 'a' + 10
	} else {
		return -1
	}
	return int32(0)
}

func textToPointer(tls *libc.TLS, z uintptr, pp uintptr) int32 { /* test_malloc.c:271:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = uint64(0)
	var i int32
	// var u uint32 at bp+8, 4

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(uintptr(0)))*uint64(2) && *(*int8)(unsafe.Pointer(z)) != 0; i++ {
		var v int32
		v = hexToInt(tls, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))))
		if v < 0 {
			return TCL_ERROR
		}
		*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)) = *(*sqlite3_uint64)(unsafe.Pointer(bp))*uint64(16) + sqlite3_uint64(v)
	}
	if int32(*(*int8)(unsafe.Pointer(z))) != 0 {
		return TCL_ERROR
	}
	if uint64(unsafe.Sizeof(sqlite3_uint64(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		libc.Xmemcpy(tls, pp, bp /* &n */, uint64(unsafe.Sizeof(sqlite3_uint64(0))))
	} else if uint64(unsafe.Sizeof(uint32(0))) == uint64(unsafe.Sizeof(uintptr(0))) {
		*(*uint32)(unsafe.Pointer(bp + 8 /* u */)) = uint32(*(*sqlite3_uint64)(unsafe.Pointer(bp /* n */)))
		libc.Xmemcpy(tls, pp, bp+8 /* &u */, uint64(unsafe.Sizeof(uint32(0))))
	} else {

	}
	return TCL_OK
}

// Usage:    sqlite3_malloc  NBYTES
//
// Raw test interface for sqlite3_malloc().
func test_malloc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:298:26: */
	bp := tls.Alloc(120)
	defer tls.Free(120)

	// var nByte int32 at bp+16, 4

	var p uintptr
	// var zOut [100]int8 at bp+20, 100

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33370 /* "NBYTES" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	p = sqlite3.Xsqlite3_malloc(tls, int32(uint32(*(*int32)(unsafe.Pointer(bp + 16 /* nByte */)))))
	pointerToText(tls, p, bp+20 /* &zOut[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+20 /* &zOut[0] */, uintptr(0)))
	return TCL_OK
}

// Usage:    sqlite3_realloc  PRIOR  NBYTES
//
// Raw test interface for sqlite3_realloc().
func test_realloc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:323:26: */
	bp := tls.Alloc(156)
	defer tls.Free(156)

	// var nByte int32 at bp+40, 4

	// var pPrior uintptr at bp+48, 8

	var p uintptr
	// var zOut [100]int8 at bp+56, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33377 /* "PRIOR NBYTES" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+40) != 0 {
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+48) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33390 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0)))
		return TCL_ERROR
	}
	p = sqlite3.Xsqlite3_realloc(tls, *(*uintptr)(unsafe.Pointer(bp + 48 /* pPrior */)), int32(uint32(*(*int32)(unsafe.Pointer(bp + 40 /* nByte */)))))
	pointerToText(tls, p, bp+56 /* &zOut[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, bp+56 /* &zOut[0] */, uintptr(0)))
	return TCL_OK
}

// Usage:    sqlite3_free  PRIOR
//
// Raw test interface for sqlite3_free().
func test_free(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:352:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var pPrior uintptr at bp+24, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33404 /* "PRIOR" */)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+24) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33390 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0)))
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* pPrior */)))
	return TCL_OK
}

// Usage:    memset  ADDRESS  SIZE  HEX
//
// Set a chunk of memory (obtained from malloc, probably) to a
// specified hex pattern.
func test_memset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:383:26: */
	bp := tls.Alloc(172)
	defer tls.Free(172)

	// var p uintptr at bp+56, 8

	// var size int32 at bp+64, 4

	// var n int32 at bp+68, 4

	var i int32
	var zHex uintptr
	var zOut uintptr
	// var zBin [100]int8 at bp+72, 100

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33410 /* "ADDRESS SIZE HEX" */)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+56) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33390 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+64) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 64)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+33427 /* "size must be pos..." */, uintptr(0)))
		return TCL_ERROR
	}
	zHex = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+68 /* &n */)
	if uint64(*(*int32)(unsafe.Pointer(bp + 68))) > uint64(unsafe.Sizeof([100]int8{}))*uint64(2) {
		*(*int32)(unsafe.Pointer(bp + 68 /* n */)) = int32(uint64(unsafe.Sizeof([100]int8{})) * uint64(2))
	}
	*(*int32)(unsafe.Pointer(bp + 68 /* n */)) = sqlite3TestHexToBin(tls, zHex, *(*int32)(unsafe.Pointer(bp + 68 /* n */)), bp+72 /* &zBin[0] */)
	if *(*int32)(unsafe.Pointer(bp + 68)) == 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, ts+33449 /* "no data" */, uintptr(0)))
		return TCL_ERROR
	}
	zOut = *(*uintptr)(unsafe.Pointer(bp + 56 /* p */))
	for i = 0; i < *(*int32)(unsafe.Pointer(bp + 64 /* size */)); i++ {
		*(*int8)(unsafe.Pointer(zOut + uintptr(i))) = *(*int8)(unsafe.Pointer(bp + 72 /* &zBin[0] */ + uintptr(i%*(*int32)(unsafe.Pointer(bp + 68 /* n */)))))
	}
	return TCL_OK
}

// Usage:    memget  ADDRESS  SIZE
//
// Return memory as hexadecimal text.
func test_memget(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:429:26: */
	bp := tls.Alloc(168)
	defer tls.Free(168)

	// var p uintptr at bp+56, 8

	// var size int32 at bp+64, 4

	var n int32
	var zBin uintptr
	// var zHex [100]int8 at bp+68, 100

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33457 /* "ADDRESS SIZE" */)
		return TCL_ERROR
	}
	if textToPointer(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+56) != 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33390 /* "bad pointer: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), uintptr(0)))
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+64) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 64)) <= 0 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+33427 /* "size must be pos..." */, uintptr(0)))
		return TCL_ERROR
	}
	zBin = *(*uintptr)(unsafe.Pointer(bp + 56 /* p */))
	for *(*int32)(unsafe.Pointer(bp + 64)) > 0 {
		if uint64(*(*int32)(unsafe.Pointer(bp + 64))) > (uint64(unsafe.Sizeof([100]int8{}))-uint64(1))/uint64(2) {
			n = int32((uint64(unsafe.Sizeof([100]int8{})) - uint64(1)) / uint64(2))
		} else {
			n = *(*int32)(unsafe.Pointer(bp + 64 /* size */))
		}
		libc.Xmemcpy(tls, bp+68 /* &zHex[0] */, zBin, uint64(n))
		zBin += uintptr(n)
		*(*int32)(unsafe.Pointer(bp + 64 /* size */)) -= n
		sqlite3TestBinToHex(tls, bp+68 /* &zHex[0] */, n)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+68 /* &zHex[0] */, uintptr(0)))
	}
	return TCL_OK
}

// Usage:    sqlite3_memory_used
//
// Raw test interface for sqlite3_memory_used().
func test_memory_used(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:476:26: */
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_memory_used(tls)))
	return TCL_OK
}

// Usage:    sqlite3_memory_highwater ?RESETFLAG?
//
// Raw test interface for sqlite3_memory_highwater().
func test_memory_highwater(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:491:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* resetFlag */)) = 0
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33470 /* "?RESET?" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
			return TCL_ERROR
		}
	}
	tcl.XTcl_SetObjResult(tls, interp,
		tcl.XTcl_NewWideIntObj(tls, sqlite3.Xsqlite3_memory_highwater(tls, *(*int32)(unsafe.Pointer(bp /* resetFlag */)))))
	return TCL_OK
}

// Usage:    sqlite3_memdebug_backtrace DEPTH
//
// Set the depth of backtracing.  If SQLITE_MEMDEBUG is not defined
// then this routine is a no-op.
func test_memdebug_backtrace(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:516:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var depth int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33478 /* "DEPT" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:    sqlite3_memdebug_dump  FILENAME
//
// Write a summary of unfreed memory to FILENAME.
func test_memdebug_dump(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:542:26: */
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33483 /* "FILENAME" */)
		return TCL_ERROR
	}
	return TCL_OK
}

// Usage:    sqlite3_memdebug_malloc_count
//
// Return the total number of times malloc() has been called.
func test_memdebug_malloc_count(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:567:26: */
	var nMalloc int32 = -1
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nMalloc))
	return TCL_OK
}

// Usage:    sqlite3_memdebug_fail  COUNTER  ?OPTIONS?
//
// where options are:
//
//     -repeat    <count>
//     -benigncnt <varname>
//
// Arrange for a simulated malloc() failure after COUNTER successes.
// If a repeat count is specified, the fault is repeated that many
// times.
//
// Each call to this routine overrides the prior counter value.
// This routine returns the number of simulated failures that have
// happened since the previous call to this routine.
//
// To disable simulated failures, use a COUNTER of -1.
func test_memdebug_fail(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:607:26: */
	bp := tls.Alloc(36)
	defer tls.Free(36)

	var ii int32
	// var iFail int32 at bp+24, 4

	*(*int32)(unsafe.Pointer(bp + 32 /* nRepeat */)) = 1
	var pBenignCnt uintptr = uintptr(0)
	var nBenign int32
	var nFail int32 = 0

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33492 /* "COUNTER ?OPTIONS..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+24) != 0 {
		return TCL_ERROR
	}

	for ii = 2; ii < objc; ii = ii + 2 {
		// var nOption int32 at bp+28, 4

		var zOption uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(ii)*8)), bp+28 /* &nOption */)
		var zErr uintptr = uintptr(0)

		if *(*int32)(unsafe.Pointer(bp + 28)) > 1 && libc.Xstrncmp(tls, zOption, ts+33510, uint64(*(*int32)(unsafe.Pointer(bp + 28)))) == 0 {
			if ii == objc-1 {
				zErr = ts + 13477 /* "option requires ..." */
			} else {
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(ii+1)*8)), bp+32) != 0 {
					return TCL_ERROR
				}
			}
		} else if *(*int32)(unsafe.Pointer(bp + 28)) > 1 && libc.Xstrncmp(tls, zOption, ts+33518, uint64(*(*int32)(unsafe.Pointer(bp + 28)))) == 0 {
			if ii == objc-1 {
				zErr = ts + 13477 /* "option requires ..." */
			} else {
				pBenignCnt = *(*uintptr)(unsafe.Pointer(objv + uintptr(ii+1)*8))
			}
		} else {
			zErr = ts + 13283 /* "unknown option: " */
		}

		if zErr != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, zErr, zOption, 0))
			return TCL_ERROR
		}
	}

	nBenign = faultsimBenignFailures(tls)
	nFail = faultsimFailures(tls)
	faultsimConfig(tls, *(*int32)(unsafe.Pointer(bp + 24 /* iFail */)), *(*int32)(unsafe.Pointer(bp + 32 /* nRepeat */)))

	if pBenignCnt != 0 {
		tcl.XTcl_ObjSetVar2(tls, interp, pBenignCnt, uintptr(0), tcl.XTcl_NewIntObj(tls, nBenign), 0)
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nFail))
	return TCL_OK
}

// Usage:    sqlite3_memdebug_pending
//
// Return the number of malloc() calls that will succeed before a
// simulated failure occurs. A negative return value indicates that
// no malloc() failure is scheduled.
func test_memdebug_pending(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:673:26: */
	var nPending int32
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}
	nPending = faultsimPending(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, nPending))
	return TCL_OK
}

// The following global variable keeps track of the number of tests
// that have run.  This variable is only useful when running in the
// debugger.
var sqlite3_memdebug_title_count int32 = 0 /* test_malloc.c:694:12 */

// Usage:    sqlite3_memdebug_settitle TITLE
//
// Set a title string stored with each allocation.  The TITLE is
// typically the name of the test that was running when the
// allocation occurred.  The TITLE is stored with the allocation
// and can be used to figure out which tests are leaking memory.
//
// Each title overwrite the previous.
func test_memdebug_settitle(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:706:26: */
	sqlite3_memdebug_title_count++
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33529 /* "TITLE" */)
		return TCL_ERROR
	}
	return TCL_OK
}

var aMallocLog Tcl_HashTable   /* test_malloc.c:732:22: */
var mallocLogEnabled int32 = 0 /* test_malloc.c:733:12 */

type MallocLog1 = struct {
	FnCall int32
	FnByte int32
} /* test_malloc.c:735:9 */

type MallocLog = MallocLog1 /* test_malloc.c:735:26 */

func test_memdebug_log_clear(tls *libc.TLS) { /* test_malloc.c:772:13: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var search Tcl_HashSearch at bp, 24

	var pEntry uintptr
	for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp /* &search */); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp /* &search */) {
		var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
		tcl.XTcl_Free(tls, pLog)
	}
	tcl.XTcl_DeleteHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)))
	tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), int32(uint64(10)*func() uint64 {
		if uint64(unsafe.Sizeof(int32(0))) >= uint64(unsafe.Sizeof(uintptr(0))) {
			return uint64(1)
		}
		return uint64(unsafe.Sizeof(uintptr(0))) / uint64(unsafe.Sizeof(int32(0)))
	}()))
}

func test_memdebug_log(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:787:26: */
	bp := tls.Alloc(128)
	defer tls.Free(128)

	// var iSub int32 at bp, 4

	if !(isInit != 0) {
		tcl.XTcl_InitHashTable(tls, uintptr(unsafe.Pointer(&aMallocLog)), int32(uint64(10)*func() uint64 {
			if uint64(unsafe.Sizeof(int32(0))) >= uint64(unsafe.Sizeof(uintptr(0))) {
				return uint64(1)
			}
			return uint64(unsafe.Sizeof(uintptr(0))) / uint64(unsafe.Sizeof(int32(0)))
		}()))
		isInit = 1
	}

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33535 /* "SUB-COMMAND ..." */)
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&MB_strs)), int32(unsafe.Sizeof(uintptr(0))), ts+2014, 0, bp) != 0 {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp /* iSub */))) {
	case uint32(0) /* MB_LOG_START */ :
		mallocLogEnabled = 1
		break
	case uint32(1) /* MB_LOG_STOP */ :
		mallocLogEnabled = 0
		break
	case uint32(2) /* MB_LOG_DUMP */ :
		{
			// var search Tcl_HashSearch at bp+8, 24

			var pEntry uintptr
			var pRet uintptr = tcl.XTcl_NewObj(tls)

			for pEntry = tcl.XTcl_FirstHashEntry(tls, uintptr(unsafe.Pointer(&aMallocLog)), bp+8 /* &search */); pEntry != 0; pEntry = tcl.XTcl_NextHashEntry(tls, bp+8 /* &search */) {
				// var apElem [12]uintptr at bp+32, 96

				var pLog uintptr = (*Tcl_HashEntry)(unsafe.Pointer(pEntry)).FclientData
				var aKey uintptr = func() uintptr {
					if (*Tcl_HashTable)(unsafe.Pointer(uintptr(unsafe.Pointer(&aMallocLog)))).FkeyType == 1 || (*Tcl_HashTable)(unsafe.Pointer(uintptr(unsafe.Pointer(&aMallocLog)))).FkeyType == -1 {
						return *(*uintptr)(unsafe.Pointer(pEntry + 32))
					}
					return pEntry + 32
				}()
				var ii int32

				*(*uintptr)(unsafe.Pointer(bp + 32 /* &apElem[0] */)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnCall)
				*(*uintptr)(unsafe.Pointer(bp + 32 /* &apElem[0] */ + 1*8)) = tcl.XTcl_NewIntObj(tls, (*MallocLog)(unsafe.Pointer(pLog)).FnByte)
				for ii = 0; ii < MALLOC_LOG_FRAMES; ii++ {
					*(*uintptr)(unsafe.Pointer(bp + 32 /* &apElem[0] */ + uintptr(ii+2)*8)) = tcl.XTcl_NewWideIntObj(tls, *(*Tcl_WideInt)(unsafe.Pointer(aKey + uintptr(ii)*8)))
				}

				tcl.XTcl_ListObjAppendElement(tls, interp, pRet,
					tcl.XTcl_NewListObj(tls, MALLOC_LOG_FRAMES+2, bp+32 /* &apElem[0] */))
			}

			tcl.XTcl_SetObjResult(tls, interp, pRet)
			break

		}
	case uint32(3) /* MB_LOG_CLEAR */ :
		{
			test_memdebug_log_clear(tls)
			break

		}

	case uint32(4) /* MB_LOG_SYNC */ :
		{
			break

		}
	}

	return TCL_OK
}

var isInit int32 = 0                                                                                                                                    /* test_malloc.c:793:14 */
var MB_strs = [5]uintptr{ts + 33551 /* "start" */, ts + 33557 /* "stop" */, ts + 33562 /* "dump" */, ts + 33567 /* "clear" */, ts + 33573 /* "sync" */} /* test_malloc.c:796:21 */

// Usage:    sqlite3_config_pagecache SIZE N
//
// Set the page-cache memory buffer using SQLITE_CONFIG_PAGECACHE.
// The buffer is static and is of limited size.  N might be
// adjusted downward as needed to accommodate the requested size.
// The revised value of N is returned.
//
// A negative SIZE causes the buffer pointer to be NULL.
func test_config_pagecache(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:885:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)

	// var sz int32 at bp+48, 4

	// var N int32 at bp+52, 4

	var pRes uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33578 /* "SIZE N" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+48) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+52) != 0 {
		return TCL_ERROR
	}
	libc.Xfree(tls, buf1)
	buf1 = uintptr(0)

	// Set the return value
	pRes = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszPage))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pRes, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnPage))
	tcl.XTcl_SetObjResult(tls, interp, pRes)

	if *(*int32)(unsafe.Pointer(bp + 48)) < 0 {
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PAGECACHE, libc.VaList(bp, uintptr(0), 0, 0))
	} else {
		buf1 = libc.Xmalloc(tls, uint64(*(*int32)(unsafe.Pointer(bp + 48))**(*int32)(unsafe.Pointer(bp + 52))))
		sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PAGECACHE, libc.VaList(bp+24, buf1, *(*int32)(unsafe.Pointer(bp + 48 /* sz */)), *(*int32)(unsafe.Pointer(bp + 52 /* N */))))
	}
	return TCL_OK
}

var buf1 uintptr = uintptr(0) /* test_malloc.c:893:15 */

// Usage:    sqlite3_config_alt_pcache INSTALL_FLAG DISCARD_CHANCE PRNG_SEED
//
// Set up the alternative test page cache.  Install if INSTALL_FLAG is
// true and uninstall (reverting to the default page cache) if INSTALL_FLAG
// is false.  DISCARD_CHANGE is an integer between 0 and 100 inclusive
// which determines the chance of discarding a page when unpinned.  100
// is certainty.  0 is never.  PRNG_SEED is the pseudo-random number generator
// seed.
func test_alt_pcache(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:928:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var installFlag int32 at bp+16, 4

	*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */)) = 0
	*(*int32)(unsafe.Pointer(bp + 24 /* prngSeed */)) = 0
	*(*int32)(unsafe.Pointer(bp + 28 /* highStress */)) = 0
	if objc < 2 || objc > 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+33585 /* "INSTALLFLAG DISC..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	if objc >= 3 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+20) != 0 {
		return TCL_ERROR
	}
	if objc >= 4 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+24) != 0 {
		return TCL_ERROR
	}
	if objc >= 5 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+28) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 20)) < 0 || *(*int32)(unsafe.Pointer(bp + 20)) > 100 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+33632, /* "discard-chance s..." */
			uintptr(0)))
		return TCL_ERROR
	}
	installTestPCache(tls, *(*int32)(unsafe.Pointer(bp + 16 /* installFlag */)), uint32(*(*int32)(unsafe.Pointer(bp + 20 /* discardChance */))), uint32(*(*int32)(unsafe.Pointer(bp + 24 /* prngSeed */))),
		uint32(*(*int32)(unsafe.Pointer(bp + 28 /* highStress */))))
	return TCL_OK
}

// Usage:    sqlite3_config_memstatus BOOLEAN
//
// Enable or disable memory status reporting using SQLITE_CONFIG_MEMSTATUS.
func test_config_memstatus(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:969:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var enable int32 at bp+8, 4

	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18974 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MEMSTATUS, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* enable */))))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// Usage:    sqlite3_config_lookaside  SIZE  COUNT
//
func test_config_lookaside(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:990:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	// var sz int32 at bp+16, 4

	// var cnt int32 at bp+20, 4

	var pRet uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33675 /* "SIZE COUNT" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+20) != 0 {
		return TCL_ERROR
	}
	pRet = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FszLookaside))
	tcl.XTcl_ListObjAppendElement(tls,
		interp, pRet, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3Config.FnLookaside))
	sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_LOOKASIDE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 16 /* sz */)), *(*int32)(unsafe.Pointer(bp + 20 /* cnt */))))
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	return TCL_OK
}

// Usage:    sqlite3_db_config_lookaside  CONNECTION  BUFID  SIZE  COUNT
//
// There are two static buffers with BUFID 1 and 2.   Each static buffer
// is 10KB in size.  A BUFID of 0 indicates that the buffer should be NULL
// which will cause sqlite3_db_config() to allocate space on its own.
func test_db_config_lookaside(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1024:26: */
	bp := tls.Alloc(84)
	defer tls.Free(84)

	var rc int32
	// var sz int32 at bp+76, 4

	// var cnt int32 at bp+80, 4

	// var db uintptr at bp+64, 8

	// var bufid int32 at bp+72, 4

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33686 /* "BUFID SIZE COUNT" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+64) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+72) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+76) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+80) != 0 {
		return TCL_ERROR
	}
	if *(*int32)(unsafe.Pointer(bp + 72)) == 0 {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), SQLITE_DBCONFIG_LOOKASIDE, libc.VaList(bp, uintptr(0), *(*int32)(unsafe.Pointer(bp + 76 /* sz */)), *(*int32)(unsafe.Pointer(bp + 80 /* cnt */))))
	} else if *(*int32)(unsafe.Pointer(bp + 72)) >= 1 && *(*int32)(unsafe.Pointer(bp + 72)) <= 2 && uint64(*(*int32)(unsafe.Pointer(bp + 76))**(*int32)(unsafe.Pointer(bp + 80))) <= uint64(unsafe.Sizeof([10000]int8{})) {
		rc = sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 64 /* db */)), SQLITE_DBCONFIG_LOOKASIDE, libc.VaList(bp+24, uintptr(unsafe.Pointer(&azBuf))+uintptr(*(*int32)(unsafe.Pointer(bp + 72)))*10000, *(*int32)(unsafe.Pointer(bp + 76 /* sz */)), *(*int32)(unsafe.Pointer(bp + 80 /* cnt */))))
	} else {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+33703 /* "illegal argument..." */, uintptr(0)))
		return TCL_ERROR
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

var azBuf [2][10000]int8 /* test_malloc.c:1034:15: */

// Usage:    sqlite3_config_heap NBYTE NMINALLOC
func test_config_heap(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1059:26: */
	bp := tls.Alloc(56)
	defer tls.Free(56)
	// Use this memory
	// var nByte int32 at bp+48, 4
	// Size of buffer to pass to sqlite3_config()
	// var nMinAlloc int32 at bp+52, 4
	// Size of minimum allocation
	var rc int32 // Return code of sqlite3_config()

	var aArg uintptr = objv + 1*8
	var nArg int32 = objc - 1

	if nArg != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33741 /* "NBYTE NMINALLOC" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg)), bp+48) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg + 1*8)), bp+52) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 48)) == 0 {
		libc.Xfree(tls, zBuf)
		zBuf = uintptr(0)
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_HEAP, libc.VaList(bp, uintptr(0), 0, 0))
	} else {
		zBuf = libc.Xrealloc(tls, zBuf, uint64(*(*int32)(unsafe.Pointer(bp + 48 /* nByte */))))
		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_HEAP, libc.VaList(bp+24, zBuf, *(*int32)(unsafe.Pointer(bp + 48 /* nByte */)), *(*int32)(unsafe.Pointer(bp + 52 /* nMinAlloc */))))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

var zBuf uintptr /* test_malloc.c:1065:15: */

// Usage:    sqlite3_config_heap_size NBYTE
func test_config_heap_size(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1096:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	// var nByte int32 at bp+8, 4
	// Size to pass to sqlite3_config()
	var rc int32 // Return code of sqlite3_config()

	var aArg uintptr = objv + 1*8
	var nArg int32 = objc - 1

	if nArg != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17051 /* "NBYTE" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(aArg)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_WIN32_HEAPSIZE, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* nByte */))))

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// Usage:    sqlite3_config_error  [DB]
//
// Invoke sqlite3_config() or sqlite3_db_config() with invalid
// opcodes and verify that they return errors.
func test_config_error(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1126:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var db uintptr at bp+32, 8

	if objc != 2 && objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33757 /* "[DB]" */)
		return TCL_ERROR
	}
	if objc == 2 {
		if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+32) != 0 {
			return TCL_ERROR
		}
		if sqlite3.Xsqlite3_db_config(tls, *(*uintptr)(unsafe.Pointer(bp + 32)), 99999, 0) != SQLITE_ERROR {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp, ts+33762, /* "sqlite3_db_confi..." */
					uintptr(0)))
			return TCL_ERROR
		}
	} else {
		if sqlite3.Xsqlite3_config(tls, 99999, 0) != SQLITE_ERROR {
			tcl.XTcl_AppendResult(tls, interp,
				libc.VaList(bp+16, ts+33820, /* "sqlite3_config(9..." */
					uintptr(0)))
			return TCL_ERROR
		}
	}
	return TCL_OK
}

// Usage:    sqlite3_config_uri  BOOLEAN
//
// Enables or disables interpretation of URI parameters by default using
// SQLITE_CONFIG_URI.
func test_config_uri(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1164:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var bOpenUri int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10984 /* "BOOL" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_URI, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* bOpenUri */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

// Usage:    sqlite3_config_cis  BOOLEAN
//
// Enables or disables the use of the covering-index scan optimization.
// SQLITE_CONFIG_COVERING_INDEX_SCAN.
func test_config_cis(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1193:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var bUseCis int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10984 /* "BOOL" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_COVERING_INDEX_SCAN, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* bUseCis */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

// Usage:    sqlite3_config_pmasz  INTEGER
//
// Set the minimum PMA size.
func test_config_pmasz(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1221:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var rc int32
	// var iPmaSz int32 at bp+8, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10984 /* "BOOL" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+8) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PMASZ, libc.VaList(bp, *(*int32)(unsafe.Pointer(bp + 8 /* iPmaSz */))))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))

	return TCL_OK
}

// Usage:    sqlite3_dump_memsys3  FILENAME
//           sqlite3_dump_memsys5  FILENAME
//
// Write a summary of unfreed memsys3 allocations to FILENAME.
func test_dump_memsys3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1251:26: */
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33483 /* "FILENAME" */)
		return TCL_ERROR
	}

	switch int32(clientData) {
	case 3:
		{

		}
		fallthrough
	case 5:
		{

		}
	}
	return TCL_OK
}

// Usage:    sqlite3_status  OPCODE  RESETFLAG
//
// Return a list of three elements which are the sqlite3_status() return
// code, the current value, and the high-water mark value.
func test_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1287:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32
	// var iValue int32 at bp+8, 4

	// var mxValue int32 at bp+12, 4

	var i int32
	*(*int32)(unsafe.Pointer(bp /* op */)) = 0
	// var resetFlag int32 at bp+4, 4

	var zOpName uintptr
	var pResult uintptr
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33871 /* "PARAMETER RESETF..." */)
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	for i = 0; i < int32(uint64(unsafe.Sizeof(aOp1))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fop          int32
		F__ccgo_pad1 [4]byte
	}{}))); i++ {
		if libc.Xstrcmp(tls, aOp1[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp /* op */)) = aOp1[i].Fop
			break
		}
	}
	if i >= int32(uint64(unsafe.Sizeof(aOp1))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fop          int32
		F__ccgo_pad1 [4]byte
	}{}))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+4) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 8 /* iValue */)) = 0
	*(*int32)(unsafe.Pointer(bp + 12 /* mxValue */)) = 0
	rc = sqlite3.Xsqlite3_status(tls, *(*int32)(unsafe.Pointer(bp /* op */)), bp+8 /* &iValue */, bp+12 /* &mxValue */, *(*int32)(unsafe.Pointer(bp + 4 /* resetFlag */)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 8 /* iValue */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 12 /* mxValue */))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

var aOp1 = [10]struct {
	FzName       uintptr
	Fop          int32
	F__ccgo_pad1 [4]byte
}{
	{FzName: ts + 33891 /* "SQLITE_STATUS_ME..." */},
	{FzName: ts + 33917 /* "SQLITE_STATUS_MA..." */, Fop: SQLITE_STATUS_MALLOC_SIZE},
	{FzName: ts + 33943 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PAGECACHE_USED},
	{FzName: ts + 33972 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PAGECACHE_OVERFLOW},
	{FzName: ts + 34005 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PAGECACHE_SIZE},
	{FzName: ts + 34034 /* "SQLITE_STATUS_SC..." */, Fop: SQLITE_STATUS_SCRATCH_USED},
	{FzName: ts + 34061 /* "SQLITE_STATUS_SC..." */, Fop: SQLITE_STATUS_SCRATCH_OVERFLOW},
	{FzName: ts + 34092 /* "SQLITE_STATUS_SC..." */, Fop: SQLITE_STATUS_SCRATCH_SIZE},
	{FzName: ts + 34119 /* "SQLITE_STATUS_PA..." */, Fop: SQLITE_STATUS_PARSER_STACK},
	{FzName: ts + 34146 /* "SQLITE_STATUS_MA..." */, Fop: SQLITE_STATUS_MALLOC_COUNT},
} /* test_malloc.c:1299:5 */

// Usage:    sqlite3_db_status  DATABASE  OPCODE  RESETFLAG
//
// Return a list of three elements which are the sqlite3_db_status() return
// code, the current value, and the high-water mark value.
func test_db_status(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1344:26: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	// var iValue int32 at bp+16, 4

	// var mxValue int32 at bp+20, 4

	var i int32
	*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = 0
	// var resetFlag int32 at bp+12, 4

	var zOpName uintptr
	// var db uintptr at bp, 8

	var pResult uintptr
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+34173 /* "DB PARAMETER RES..." */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zOpName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if libc.Xmemcmp(tls, zOpName, ts+34196, uint64(7)) == 0 {
		zOpName += uintptr(7)
	}
	if libc.Xmemcmp(tls, zOpName, ts+34204, uint64(9)) == 0 {
		zOpName += uintptr(9)
	}
	for i = 0; i < int32(uint64(unsafe.Sizeof(aOp2))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fop          int32
		F__ccgo_pad1 [4]byte
	}{}))); i++ {
		if libc.Xstrcmp(tls, aOp2[i].FzName, zOpName) == 0 {
			*(*int32)(unsafe.Pointer(bp + 8 /* op */)) = aOp2[i].Fop
			break
		}
	}
	if i >= int32(uint64(unsafe.Sizeof(aOp2))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		Fop          int32
		F__ccgo_pad1 [4]byte
	}{}))) {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+8) != 0 {
			return TCL_ERROR
		}
	}
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+12) != 0 {
		return TCL_ERROR
	}
	*(*int32)(unsafe.Pointer(bp + 16 /* iValue */)) = 0
	*(*int32)(unsafe.Pointer(bp + 20 /* mxValue */)) = 0
	rc = sqlite3.Xsqlite3_db_status(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), *(*int32)(unsafe.Pointer(bp + 8 /* op */)), bp+16 /* &iValue */, bp+20 /* &mxValue */, *(*int32)(unsafe.Pointer(bp + 12 /* resetFlag */)))
	pResult = tcl.XTcl_NewObj(tls)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, rc))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 16 /* iValue */))))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pResult, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(bp + 20 /* mxValue */))))
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

var aOp2 = [13]struct {
	FzName       uintptr
	Fop          int32
	F__ccgo_pad1 [4]byte
}{
	{FzName: ts + 34214 /* "LOOKASIDE_USED" */},
	{FzName: ts + 34229 /* "CACHE_USED" */, Fop: SQLITE_DBSTATUS_CACHE_USED},
	{FzName: ts + 34240 /* "SCHEMA_USED" */, Fop: SQLITE_DBSTATUS_SCHEMA_USED},
	{FzName: ts + 34252 /* "STMT_USED" */, Fop: SQLITE_DBSTATUS_STMT_USED},
	{FzName: ts + 34262 /* "LOOKASIDE_HIT" */, Fop: SQLITE_DBSTATUS_LOOKASIDE_HIT},
	{FzName: ts + 34276 /* "LOOKASIDE_MISS_S..." */, Fop: SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE},
	{FzName: ts + 34296 /* "LOOKASIDE_MISS_F..." */, Fop: SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL},
	{FzName: ts + 34316 /* "CACHE_HIT" */, Fop: SQLITE_DBSTATUS_CACHE_HIT},
	{FzName: ts + 34326 /* "CACHE_MISS" */, Fop: SQLITE_DBSTATUS_CACHE_MISS},
	{FzName: ts + 34337 /* "CACHE_WRITE" */, Fop: SQLITE_DBSTATUS_CACHE_WRITE},
	{FzName: ts + 34349 /* "DEFERRED_FKS" */, Fop: SQLITE_DBSTATUS_DEFERRED_FKS},
	{FzName: ts + 34362 /* "CACHE_USED_SHARE..." */, Fop: SQLITE_DBSTATUS_CACHE_USED_SHARED},
	{FzName: ts + 34380 /* "CACHE_SPILL" */, Fop: SQLITE_DBSTATUS_CACHE_SPILL},
} /* test_malloc.c:1358:5 */

// install_malloc_faultsim BOOLEAN
func test_install_malloc_faultsim(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1406:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	// var isInstall int32 at bp, 4

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18974 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) {
		return TCL_ERROR
	}
	rc = faultsimInstall(tls, *(*int32)(unsafe.Pointer(bp /* isInstall */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// sqlite3_install_memsys3
func test_install_memsys3(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1430:26: */
	var rc int32 = SQLITE_MISUSE
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

func test_vfs_oom_test(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_malloc.c:1445:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	if objc > 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+34392 /* "?INTEGER?" */)
		return TCL_ERROR
	} else if objc == 2 {
		// var iNew int32 at bp, 4

		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp) != 0 {
			return TCL_ERROR
		}
		sqlite3.Xsqlite3_memdebug_vfs_oom_test = *(*int32)(unsafe.Pointer(bp /* iNew */))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, sqlite3.Xsqlite3_memdebug_vfs_oom_test))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetest_malloc_Init(tls *libc.TLS, interp uintptr) int32 { /* test_malloc.c:1467:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd11))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		FxProc       uintptr
		FclientData  int32
		F__ccgo_pad1 [4]byte
	}{})); i++ {
		var c ClientData = uintptr(intptr_t(aObjCmd11[i].FclientData))
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd11[i].FzName, aObjCmd11[i].FxProc, c, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd11 = [32]struct {
	FzName       uintptr
	FxProc       uintptr
	FclientData  int32
	F__ccgo_pad1 [4]byte
}{
	{FzName: ts + 28736 /* "sqlite3_malloc" */, FxProc: 0},
	{FzName: ts + 28751 /* "sqlite3_realloc" */, FxProc: 0},
	{FzName: ts + 34402 /* "sqlite3_free" */, FxProc: 0},
	{FzName: ts + 34415 /* "memset" */, FxProc: 0},
	{FzName: ts + 34422 /* "memget" */, FxProc: 0},
	{FzName: ts + 34429 /* "sqlite3_memory_u..." */, FxProc: 0},
	{FzName: ts + 34449 /* "sqlite3_memory_h..." */, FxProc: 0},
	{FzName: ts + 34474 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 34501 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 34523 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 34545 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 34570 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 34596 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 34626 /* "sqlite3_memdebug..." */, FxProc: 0},
	{FzName: ts + 34647 /* "sqlite3_config_p..." */, FxProc: 0},
	{FzName: ts + 34672 /* "sqlite3_config_a..." */, FxProc: 0},
	{FzName: ts + 34698 /* "sqlite3_status" */, FxProc: 0},
	{FzName: ts + 34713 /* "sqlite3_db_statu..." */, FxProc: 0},
	{FzName: ts + 34731 /* "install_malloc_f..." */, FxProc: 0},
	{FzName: ts + 34755 /* "sqlite3_config_h..." */, FxProc: 0},
	{FzName: ts + 34775 /* "sqlite3_config_h..." */, FxProc: 0},
	{FzName: ts + 34800 /* "sqlite3_config_m..." */, FxProc: 0},
	{FzName: ts + 34825 /* "sqlite3_config_l..." */, FxProc: 0},
	{FzName: ts + 34850 /* "sqlite3_config_e..." */, FxProc: 0},
	{FzName: ts + 34871 /* "sqlite3_config_u..." */, FxProc: 0},
	{FzName: ts + 34890 /* "sqlite3_config_c..." */, FxProc: 0},
	{FzName: ts + 34909 /* "sqlite3_config_p..." */, FxProc: 0},
	{FzName: ts + 34930 /* "sqlite3_db_confi..." */, FxProc: 0},
	{FzName: ts + 34958 /* "sqlite3_dump_mem..." */, FxProc: 0, FclientData: 3},
	{FzName: ts + 34979 /* "sqlite3_dump_mem..." */, FxProc: 0, FclientData: 5},
	{FzName: ts + 35000 /* "sqlite3_install_..." */, FxProc: 0},
	{FzName: ts + 35024 /* "sqlite3_memdebug..." */, FxProc: 0},
} /* test_malloc.c:1472:5 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// This code implements the MD5 message-digest algorithm.
// The algorithm is due to Ron Rivest.  This code was
// written by Colin Plumb in 1993, no copyright is claimed.
// This code is in the public domain; do with it what you wish.
//
// Equivalent code is available from RSA Data Security, Inc.
// This code has been tested against that, and is equivalent,
// except that you don't need to include two pages of legalese
// with every copy.
//
// To compute the message digest of a chunk of bytes, declare an
// MD5Context structure, pass it to MD5Init, call MD5Update as
// needed on buffers full of bytes, and then call MD5Final, which
// will fill a supplied 16-byte array with the digest.

// If compiled on a machine that doesn't have a 32-bit integer,
// you just set "uint32" to the appropriate datatype for an
// unsigned 32-bit integer.  For example:
//
//       cc -Duint32='unsigned long' md5.c
//

type MD5Context1 = struct {
	FisInit int32
	Fbuf    [4]uint32
	Fbits   [2]uint32
	Fin     [64]uint8
} /* test_md5.c:57:1 */

type MD5Context = MD5Context1 /* test_md5.c:63:27 */

// Note: this code is harmless on little-endian machines.
func byteReverse(tls *libc.TLS, buf uintptr, longs uint32) { /* test_md5.c:68:13: */
	var t uint32
	for ok := true; ok; ok = libc.PreDecUint32(&longs, 1) != 0 {
		t = (uint32(*(*uint8)(unsafe.Pointer(buf + 3)))<<8|uint32(*(*uint8)(unsafe.Pointer(buf + 2))))<<16 | (uint32(*(*uint8)(unsafe.Pointer(buf + 1)))<<8 | uint32(*(*uint8)(unsafe.Pointer(buf))))
		*(*uint32)(unsafe.Pointer(buf)) = t
		buf += uintptr(4)
	}
}

// The four core functions - F1 is optimized somewhat

// #define F1(x, y, z) (x & y | ~x & z)

// This is the central step in the MD5 algorithm.

// The core of the MD5 algorithm, this alters an existing MD5 hash to
// reflect the addition of 16 longwords of new data.  MD5Update blocks
// the data and converts bytes into longwords for this routine.
func MD5Transform(tls *libc.TLS, buf uintptr, in uintptr) { /* test_md5.c:94:13: */
	var a uint32
	var b uint32
	var c uint32
	var d uint32

	a = *(*uint32)(unsafe.Pointer(buf))
	b = *(*uint32)(unsafe.Pointer(buf + 1*4))
	c = *(*uint32)(unsafe.Pointer(buf + 2*4))
	d = *(*uint32)(unsafe.Pointer(buf + 3*4))

	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in)) + 0xd76aa478)
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0xe8c7b756)
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 2*4)) + uint32(0x242070db))
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0xc1bdceee)
	b = b<<22 | b>>(32-22)
	b = b + c
	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in + 4*4)) + 0xf57c0faf)
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 5*4)) + uint32(0x4787c62a))
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 6*4)) + 0xa8304613)
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 7*4)) + 0xfd469501)
	b = b<<22 | b>>(32-22)
	b = b + c
	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in + 8*4)) + uint32(0x698098d8))
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 9*4)) + 0x8b44f7af)
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 10*4)) + 0xffff5bb1)
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 11*4)) + 0x895cd7be)
	b = b<<22 | b>>(32-22)
	b = b + c
	a = a + (d ^ b&(c^d) + *(*uint32)(unsafe.Pointer(in + 12*4)) + uint32(0x6b901122))
	a = a<<7 | a>>(32-7)
	a = a + b
	d = d + (c ^ a&(b^c) + *(*uint32)(unsafe.Pointer(in + 13*4)) + 0xfd987193)
	d = d<<12 | d>>(32-12)
	d = d + a
	c = c + (b ^ d&(a^b) + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xa679438e)
	c = c<<17 | c>>(32-17)
	c = c + d
	b = b + (a ^ c&(d^a) + *(*uint32)(unsafe.Pointer(in + 15*4)) + uint32(0x49b40821))
	b = b<<22 | b>>(32-22)
	b = b + c

	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0xf61e2562)
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 6*4)) + 0xc040b340)
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 11*4)) + uint32(0x265e5a51))
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in)) + 0xe9b6c7aa)
	b = b<<20 | b>>(32-20)
	b = b + c
	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 5*4)) + 0xd62f105d)
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 10*4)) + uint32(0x02441453))
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 15*4)) + 0xd8a1e681)
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in + 4*4)) + 0xe7d3fbc8)
	b = b<<20 | b>>(32-20)
	b = b + c
	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 9*4)) + uint32(0x21e1cde6))
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xc33707d6)
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0xf4d50d87)
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in + 8*4)) + uint32(0x455a14ed))
	b = b<<20 | b>>(32-20)
	b = b + c
	a = a + (c ^ d&(b^c) + *(*uint32)(unsafe.Pointer(in + 13*4)) + 0xa9e3e905)
	a = a<<5 | a>>(32-5)
	a = a + b
	d = d + (b ^ c&(a^b) + *(*uint32)(unsafe.Pointer(in + 2*4)) + 0xfcefa3f8)
	d = d<<9 | d>>(32-9)
	d = d + a
	c = c + (a ^ b&(d^a) + *(*uint32)(unsafe.Pointer(in + 7*4)) + uint32(0x676f02d9))
	c = c<<14 | c>>(32-14)
	c = c + d
	b = b + (d ^ a&(c^d) + *(*uint32)(unsafe.Pointer(in + 12*4)) + 0x8d2a4c8a)
	b = b<<20 | b>>(32-20)
	b = b + c

	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 5*4)) + 0xfffa3942)
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in + 8*4)) + 0x8771f681)
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 11*4)) + uint32(0x6d9d6122))
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xfde5380c)
	b = b<<23 | b>>(32-23)
	b = b + c
	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0xa4beea44)
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in + 4*4)) + uint32(0x4bdecfa9))
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 7*4)) + 0xf6bb4b60)
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 10*4)) + 0xbebfbc70)
	b = b<<23 | b>>(32-23)
	b = b + c
	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 13*4)) + uint32(0x289b7ec6))
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in)) + 0xeaa127fa)
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0xd4ef3085)
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 6*4)) + uint32(0x04881d05))
	b = b<<23 | b>>(32-23)
	b = b + c
	a = a + (b ^ c ^ d + *(*uint32)(unsafe.Pointer(in + 9*4)) + 0xd9d4d039)
	a = a<<4 | a>>(32-4)
	a = a + b
	d = d + (a ^ b ^ c + *(*uint32)(unsafe.Pointer(in + 12*4)) + 0xe6db99e5)
	d = d<<11 | d>>(32-11)
	d = d + a
	c = c + (d ^ a ^ b + *(*uint32)(unsafe.Pointer(in + 15*4)) + uint32(0x1fa27cf8))
	c = c<<16 | c>>(32-16)
	c = c + d
	b = b + (c ^ d ^ a + *(*uint32)(unsafe.Pointer(in + 2*4)) + 0xc4ac5665)
	b = b<<23 | b>>(32-23)
	b = b + c

	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in)) + 0xf4292244)
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 7*4)) + uint32(0x432aff97))
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 14*4)) + 0xab9423a7)
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 5*4)) + 0xfc93a039)
	b = b<<21 | b>>(32-21)
	b = b + c
	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in + 12*4)) + uint32(0x655b59c3))
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 3*4)) + 0x8f0ccc92)
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 10*4)) + 0xffeff47d)
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 1*4)) + 0x85845dd1)
	b = b<<21 | b>>(32-21)
	b = b + c
	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in + 8*4)) + uint32(0x6fa87e4f))
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 15*4)) + 0xfe2ce6e0)
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 6*4)) + 0xa3014314)
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 13*4)) + uint32(0x4e0811a1))
	b = b<<21 | b>>(32-21)
	b = b + c
	a = a + (c ^ (b | ^d) + *(*uint32)(unsafe.Pointer(in + 4*4)) + 0xf7537e82)
	a = a<<6 | a>>(32-6)
	a = a + b
	d = d + (b ^ (a | ^c) + *(*uint32)(unsafe.Pointer(in + 11*4)) + 0xbd3af235)
	d = d<<10 | d>>(32-10)
	d = d + a
	c = c + (a ^ (d | ^b) + *(*uint32)(unsafe.Pointer(in + 2*4)) + uint32(0x2ad7d2bb))
	c = c<<15 | c>>(32-15)
	c = c + d
	b = b + (d ^ (c | ^a) + *(*uint32)(unsafe.Pointer(in + 9*4)) + 0xeb86d391)
	b = b<<21 | b>>(32-21)
	b = b + c

	*(*uint32)(unsafe.Pointer(buf)) += a
	*(*uint32)(unsafe.Pointer(buf + 1*4)) += b
	*(*uint32)(unsafe.Pointer(buf + 2*4)) += c
	*(*uint32)(unsafe.Pointer(buf + 3*4)) += d
}

// Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
// initialization constants.
func MD5Init(tls *libc.TLS, ctx uintptr) { /* test_md5.c:180:13: */
	(*MD5Context)(unsafe.Pointer(ctx)).FisInit = 1
	*(*uint32)(unsafe.Pointer(ctx + 4)) = uint32(0x67452301)
	*(*uint32)(unsafe.Pointer(ctx + 4 + 1*4)) = 0xefcdab89
	*(*uint32)(unsafe.Pointer(ctx + 4 + 2*4)) = 0x98badcfe
	*(*uint32)(unsafe.Pointer(ctx + 4 + 3*4)) = uint32(0x10325476)
	*(*uint32)(unsafe.Pointer(ctx + 20)) = uint32(0)
	*(*uint32)(unsafe.Pointer(ctx + 20 + 1*4)) = uint32(0)
}

// Update context to reflect the concatenation of another buffer full
// of bytes.
func MD5Update(tls *libc.TLS, ctx uintptr, buf uintptr, len uint32) { /* test_md5.c:195:6: */
	var t uint32

	// Update bitcount

	t = *(*uint32)(unsafe.Pointer(ctx + 20))
	if libc.AssignPtrUint32(ctx+20, t+len<<3) < t {
		*(*uint32)(unsafe.Pointer(ctx + 20 + 1*4))++
	} // Carry from low to high
	*(*uint32)(unsafe.Pointer(ctx + 20 + 1*4)) += len >> 29

	t = t >> 3 & uint32(0x3f) // Bytes already in shsInfo->data

	// Handle any leading odd-sized chunks

	if t != 0 {
		var p uintptr = ctx + 28 + uintptr(t)

		t = uint32(64) - t
		if len < t {
			libc.Xmemcpy(tls, p, buf, uint64(len))
			return
		}
		libc.Xmemcpy(tls, p, buf, uint64(t))
		byteReverse(tls, ctx+28, uint32(16))
		MD5Transform(tls, ctx+4, ctx+28 /* &.in */)
		buf += uintptr(t)
		len = len - t
	}

	// Process data in 64-byte chunks

	for len >= uint32(64) {
		libc.Xmemcpy(tls, ctx+28, buf, uint64(64))
		byteReverse(tls, ctx+28, uint32(16))
		MD5Transform(tls, ctx+4, ctx+28 /* &.in */)
		buf += uintptr(64)
		len = len - uint32(64)
	}

	// Handle any remaining bytes of data.

	libc.Xmemcpy(tls, ctx+28, buf, uint64(len))
}

// Final wrapup - pad to 64-byte boundary with the bit pattern
// 1 0* (64-bit count of bits processed, MSB-first)
func MD5Final(tls *libc.TLS, digest uintptr, ctx uintptr) { /* test_md5.c:243:13: */
	var count uint32
	var p uintptr

	// Compute number of bytes mod 64
	count = *(*uint32)(unsafe.Pointer(ctx + 20)) >> 3 & uint32(0x3F)

	// Set the first char of padding to 0x80.  This is safe since there is
	//            always at least one byte free
	p = ctx + 28 + uintptr(count)
	*(*uint8)(unsafe.Pointer(libc.PostIncUintptr(&p, 1))) = uint8(0x80)

	// Bytes of padding needed to make 64 bytes
	count = uint32(64-1) - count

	// Pad out to 56 mod 64
	if count < uint32(8) {
		// Two lots of padding:  Pad the first block to 64 bytes
		libc.Xmemset(tls, p, 0, uint64(count))
		byteReverse(tls, ctx+28, uint32(16))
		MD5Transform(tls, ctx+4, ctx+28 /* &.in */)

		// Now fill the next block with 56 bytes
		libc.Xmemset(tls, ctx+28, 0, uint64(56))
	} else {
		// Pad block to 56 bytes
		libc.Xmemset(tls, p, 0, uint64(count-uint32(8)))
	}
	byteReverse(tls, ctx+28, uint32(14))

	// Append length in bits and transform
	libc.Xmemcpy(tls, ctx+28+uintptr(14*4), ctx+20, uint64(8))

	MD5Transform(tls, ctx+4, ctx+28 /* &.in */)
	byteReverse(tls, ctx+4 /* &.buf */, uint32(4))
	libc.Xmemcpy(tls, digest, ctx+4, uint64(16))
}

// Convert a 128-bit MD5 digest into a 32-digit base-16 number.
func MD5DigestToBase16(tls *libc.TLS, digest uintptr, zBuf uintptr) { /* test_md5.c:284:13: */
	var i int32
	var j int32

	for j = libc.AssignInt32(&i, 0); i < 16; i++ {
		var a int32 = int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i))))
		*(*int8)(unsafe.Pointer(zBuf + uintptr(libc.PostIncInt32(&j, 1)))) = zEncode[a>>4&0xf]
		*(*int8)(unsafe.Pointer(zBuf + uintptr(libc.PostIncInt32(&j, 1)))) = zEncode[a&0xf]
	}
	*(*int8)(unsafe.Pointer(zBuf + uintptr(j))) = int8(0)
}

var zEncode = *(*[17]int8)(unsafe.Pointer(ts + 31744 /* "0123456789abcdef" */)) /* test_md5.c:285:21 */

// Convert a 128-bit MD5 digest into sequency of eight 5-digit integers
// each representing 16 bits of the digest and separated from each
// other by a "-" character.
func MD5DigestToBase10x8(tls *libc.TLS, digest uintptr, zDigest uintptr) { /* test_md5.c:302:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var i int32
	var j int32
	var x uint32
	for i = libc.AssignInt32(&j, 0); i < 16; i = i + 2 {
		x = uint32(int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i))))*256 + int32(*(*uint8)(unsafe.Pointer(digest + uintptr(i+1)))))
		if i > 0 {
			*(*int8)(unsafe.Pointer(zDigest + uintptr(libc.PostIncInt32(&j, 1)))) = int8('-')
		}
		sqlite3.Xsqlite3_snprintf(tls, 50-j, zDigest+uintptr(j), ts+35054 /* "%05u" */, libc.VaList(bp, x))
		j = j + 5
	}
	*(*int8)(unsafe.Pointer(zDigest + uintptr(j))) = int8(0)
}

// A TCL command for md5.  The argument is the text to be hashed.  The
// Result is the hash in base64.
func md5_cmd(tls *libc.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test_md5.c:318:26: */
	bp := tls.Alloc(206)
	defer tls.Free(206)

	// var ctx MD5Context at bp+48, 92

	// var digest [16]uint8 at bp+140, 16

	// var zBuf [50]int8 at bp+156, 50

	var converter uintptr

	if argc != 2 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+16139 /* " TEXT\"" */, uintptr(0)))
		return TCL_ERROR
	}
	MD5Init(tls, bp+48 /* &ctx */)
	MD5Update(tls, bp+48 /* &ctx */, *(*uintptr)(unsafe.Pointer(argv + 1*8)), uint32(libc.Xstrlen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))))
	MD5Final(tls, bp+140 /* &digest[0] */, bp+48 /* &ctx */)
	converter = cd
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{converter})).f(tls, bp+140 /* &digest[0] */, bp+156 /* &zBuf[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, bp+156 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// A TCL command to take the md5 hash of a file.  The argument is the
// name of the file.
func md5file_cmd(tls *libc.TLS, cd uintptr, interp uintptr, argc int32, argv uintptr) int32 { /* test_md5.c:347:26: */
	bp := tls.Alloc(10428)
	defer tls.Free(10428)

	var in uintptr
	var ofst int32
	var amt int32
	// var ctx MD5Context at bp+80, 92

	var converter uintptr
	// var digest [16]uint8 at bp+10412, 16

	// var zBuf [10240]int8 at bp+172, 10240

	if argc != 2 && argc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776 /* "wrong # args: sh..." */, *(*uintptr)(unsafe.Pointer(argv)),
			ts+35059 /* " FILENAME [OFFSE..." */, uintptr(0)))
		return TCL_ERROR
	}
	if argc == 4 {
		ofst = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 2*8)))
		amt = libc.Xatoi(tls, *(*uintptr)(unsafe.Pointer(argv + 3*8)))
	} else {
		ofst = 0
		amt = 2147483647
	}
	in = libc.Xfopen(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4402 /* "rb" */)
	if in == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+35083 /* "unable to open f..." */, *(*uintptr)(unsafe.Pointer(argv + 1*8)),
			ts+35105 /* "\" for reading" */, uintptr(0)))
		return TCL_ERROR
	}
	libc.Xfseek(tls, in, int64(ofst), SEEK_SET)
	MD5Init(tls, bp+80 /* &ctx */)
	for amt > 0 {
		var n int32
		n = int32(libc.Xfread(tls, bp+172 /* &zBuf[0] */, uint64(1), func() uint64 {
			if uint64(unsafe.Sizeof([10240]int8{})) <= uint64(amt) {
				return uint64(unsafe.Sizeof([10240]int8{}))
			}
			return uint64(amt)
		}(), in))
		if n <= 0 {
			break
		}
		MD5Update(tls, bp+80 /* &ctx */, bp+172 /* zBuf */, uint32(n))
		amt = amt - n
	}
	libc.Xfclose(tls, in)
	MD5Final(tls, bp+10412 /* &digest[0] */, bp+80 /* &ctx */)
	converter = cd
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{converter})).f(tls, bp+10412 /* &digest[0] */, bp+172 /* &zBuf[0] */)
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+172 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// Register the four new TCL commands for generating MD5 checksums
// with the TCL interpreter.
func Md5_Init(tls *libc.TLS, interp uintptr) int32 { /* test_md5.c:400:5: */
	tcl.XTcl_CreateCommand(tls, interp, ts+35119 /* "md5" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+35123 /* "md5-10x8" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+35132 /* "md5file" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase16})), uintptr(0))
	tcl.XTcl_CreateCommand(tls, interp, ts+35140 /* "md5file-10x8" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{md5file_cmd})),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr)
		}{MD5DigestToBase10x8})), uintptr(0))
	return TCL_OK
}

// During testing, the special md5sum() aggregate function is available.
// inside SQLite.  The following routines implement that function.
func md5step(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_md5.c:416:13: */
	var p uintptr
	var i int32
	if argc < 1 {
		return
	}
	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	if p == uintptr(0) {
		return
	}
	if !((*MD5Context)(unsafe.Pointer(p)).FisInit != 0) {
		MD5Init(tls, p)
	}
	for i = 0; i < argc; i++ {
		var zData uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
		if zData != 0 {
			MD5Update(tls, p, zData, uint32(int32(libc.Xstrlen(tls, zData))))
		}
	}
}

func md5finalize(tls *libc.TLS, context uintptr) { /* test_md5.c:432:13: */
	bp := tls.Alloc(49)
	defer tls.Free(49)

	var p uintptr
	// var digest [16]uint8 at bp, 16

	// var zBuf [33]int8 at bp+16, 33

	p = sqlite3.Xsqlite3_aggregate_context(tls, context, int32(unsafe.Sizeof(MD5Context{})))
	MD5Final(tls, bp /* &digest[0] */, p)
	MD5DigestToBase16(tls, bp /* &digest[0] */, bp+16 /* &zBuf[0] */)
	sqlite3.Xsqlite3_result_text(tls, context, bp+16 /* &zBuf[0] */, -1, libc.UintptrFromInt32(-1))
}

func Md5_Register(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pThunk uintptr) int32 { /* test_md5.c:441:5: */
	var rc int32 = sqlite3.Xsqlite3_create_function(tls, db, ts+35153 /* "md5sum" */, -1, SQLITE_UTF8, uintptr(0), uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{md5step})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{md5finalize})))
	sqlite3.Xsqlite3_overload_function(tls, db, ts+35153 /* "md5sum" */, -1) // To exercise this API
	return rc
}

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// These should be defined to be the same as the values in
// sqliteInt.h.  They are defined separately here so that
// the multiplex VFS shim can be built as a loadable
// module.

// Maximum chunk number

// First chunk for rollback journal files

//*********************** Shim Definitions *****************************

// This is the limit on the chunk size.  It may be changed by calling
// the xFileControl() interface.  It will be rounded up to a
// multiple of MAX_PAGE_SIZE.  We default it here to 2GiB less 64KiB.

// This used to be the default limit on number of chunks, but
// it is no longer enforced. There is currently no limit to the
// number of chunks.
//
// May be changed by calling the xFileControl() interface.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type multiplexGroup1 = struct {
	FaReal       uintptr
	FnReal       int32
	F__ccgo_pad1 [4]byte
	FzName       uintptr
	FnName       int32
	Fflags       int32
	FszChunk     uint32
	FbEnabled    uint8
	FbTruncate   uint8
	F__ccgo_pad2 [2]byte
} /* test_multiplex.c:106:9 */

// The following macros redefine the API routines so that they are
// redirected through the global sqlite3_api structure.
//
// This header file is also used by the loadext.c source file
// (part of the main SQLite library - not an extension) so that
// it can get access to the sqlite3_api_routines structure
// definition.  But the main library does not want to redefine
// the API.  So the redefinition macros are only valid if the
// SQLITE_CORE macros is undefined.

// This case when the file is being statically linked into the
// application

// These should be defined to be the same as the values in
// sqliteInt.h.  They are defined separately here so that
// the multiplex VFS shim can be built as a loadable
// module.

// Maximum chunk number

// First chunk for rollback journal files

//*********************** Shim Definitions *****************************

// This is the limit on the chunk size.  It may be changed by calling
// the xFileControl() interface.  It will be rounded up to a
// multiple of MAX_PAGE_SIZE.  We default it here to 2GiB less 64KiB.

// This used to be the default limit on number of chunks, but
// it is no longer enforced. There is currently no limit to the
// number of chunks.
//
// May be changed by calling the xFileControl() interface.

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type multiplexGroup = multiplexGroup1 /* test_multiplex.c:106:31 */
type multiplexConn1 = struct {
	Fbase   sqlite3_file
	FpGroup uintptr
} /* test_multiplex.c:107:9 */

type multiplexConn = multiplexConn1 /* test_multiplex.c:107:30 */

// A "multiplex group" is a collection of files that collectively
// makeup a single SQLite DB file.  This allows the size of the DB
// to exceed the limits imposed by the file system.
//
// There is an instance of the following object for each defined multiplex
// group.
type multiplexReal = struct {
	Fp uintptr
	Fz uintptr
} /* test_multiplex.c:106:9 */

//************************ Global Variables *********************************
// All global variables used by this file are containing within the following
// gMultiplex structure.
var gMultiplex struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
	F__ccgo_pad1   [4]byte
} /* test_multiplex.c:176:3: */

//************************ Utility Routines ********************************
// Compute a string length that is limited to what can be stored in
// lower 30 bits of a 32-bit signed integer.
//
// The value returned will never be negative.  Nor will it ever be greater
// than the actual length of the string.  For very long strings (greater
// than 1GiB) the value returned might be less than the true string length.
func multiplexStrlen30(tls *libc.TLS, z uintptr) int32 { /* test_multiplex.c:187:12: */
	var z2 uintptr = z
	if z == uintptr(0) {
		return 0
	}
	for *(*int8)(unsafe.Pointer(z2)) != 0 {
		z2++
	}
	return 0x3fffffff & int32((int64(z2)-int64(z))/1)
}

// Generate the file-name for chunk iChunk of the group with base name
// zBase. The file-name is written to buffer zOut before returning. Buffer
// zOut must be allocated by the caller so that it is at least (nBase+5)
// bytes in size, where nBase is the length of zBase, not including the
// nul-terminator.
//
// If iChunk is 0 (or 400 - the number for the first journal file chunk),
// the output is a copy of the input string. Otherwise, if
// SQLITE_ENABLE_8_3_NAMES is not defined or the input buffer does not contain
// a "." character, then the output is a copy of the input string with the
// three-digit zero-padded decimal representation if iChunk appended to it.
// For example:
//
//   zBase="test.db", iChunk=4  ->  zOut="test.db004"
//
// Or, if SQLITE_ENABLE_8_3_NAMES is defined and the input buffer contains
// a "." character, then everything after the "." is replaced by the
// three-digit representation of iChunk.
//
//   zBase="test.db", iChunk=4  ->  zOut="test.004"
//
// The output buffer string is terminated by 2 0x00 bytes. This makes it safe
// to pass to sqlite3_uri_parameter() and similar.
func multiplexFilename(tls *libc.TLS, zBase uintptr, nBase int32, flags int32, iChunk int32, zOut uintptr) { /* test_multiplex.c:219:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var n int32 = nBase
	libc.Xmemcpy(tls, zOut, zBase, uint64(n+1))
	if iChunk != 0 && iChunk <= MX_CHUNK_NUMBER {
		sqlite3.Xsqlite3_snprintf(tls, 4, zOut+uintptr(n), ts+35160 /* "%03d" */, libc.VaList(bp, iChunk))
		n = n + 3
	}

	*(*int8)(unsafe.Pointer(zOut + uintptr(n+1))) = int8(0)
}

// Compute the filename for the iChunk-th chunk
func multiplexSubFilename(tls *libc.TLS, pGroup uintptr, iChunk int32) int32 { /* test_multiplex.c:256:12: */
	if iChunk >= (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal {
		var p uintptr
		p = sqlite3.Xsqlite3_realloc64(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal, uint64(uint64(iChunk+1)*uint64(unsafe.Sizeof(multiplexReal{}))))
		if p == uintptr(0) {
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, p+uintptr((*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal)*16, 0, uint64(unsafe.Sizeof(multiplexReal{}))*uint64(iChunk+1-(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = p
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = iChunk + 1
	}
	if (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName != 0 && (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz == uintptr(0) {
		var z uintptr
		var n int32 = (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName
		z = sqlite3.Xsqlite3_malloc64(tls, uint64(n+5))
		if z == uintptr(0) {
			return SQLITE_NOMEM
		}
		multiplexFilename(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, (*multiplexGroup)(unsafe.Pointer(pGroup)).FnName, (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags, iChunk, z)
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fz = sqlite3.Xsqlite3_create_filename(tls, z, ts+584 /* "" */, ts+584 /* "" */, 0, uintptr(0))
		sqlite3.Xsqlite3_free(tls, z)
		if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz == uintptr(0) {
			return SQLITE_NOMEM
		}
	}
	return SQLITE_OK
}

// Translate an sqlite3_file* that is really a multiplexGroup* into
// the sqlite3_file* for the underlying original VFS.
//
// For chunk 0, the pGroup->flags determines whether or not a new file
// is created if it does not already exist.  For chunks 1 and higher, the
// file is created only if createFlag is 1.
func multiplexSubOpen(tls *libc.TLS, pGroup uintptr, iChunk int32, rc uintptr, pOutFlags uintptr, createFlag int32) uintptr { /* test_multiplex.c:289:21: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pSubOpen uintptr = uintptr(0)
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS

	*(*int32)(unsafe.Pointer(rc)) = multiplexSubFilename(tls, pGroup, iChunk)
	if *(*int32)(unsafe.Pointer(rc)) == SQLITE_OK && libc.AssignUintptr(&pSubOpen, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fp) == uintptr(0) {
		var flags int32
		// var bExists int32 at bp+16, 4

		flags = (*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags
		if createFlag != 0 {
			flags = flags | SQLITE_OPEN_CREATE
		} else if iChunk == 0 {
			// Fall through
		} else if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz == uintptr(0) {
			return uintptr(0)
		} else {
			*(*int32)(unsafe.Pointer(rc)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz,
				SQLITE_ACCESS_EXISTS, bp+16 /* &bExists */)
			if *(*int32)(unsafe.Pointer(rc)) != 0 || !(*(*int32)(unsafe.Pointer(bp + 16)) != 0) {
				if *(*int32)(unsafe.Pointer(rc)) != 0 {
					sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+35165, /* "multiplexor.xAcc..." */
						libc.VaList(bp, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz))
				}
				return uintptr(0)
			}
			flags = flags & libc.CplInt32(SQLITE_OPEN_CREATE)
		}
		pSubOpen = sqlite3.Xsqlite3_malloc64(tls, uint64((*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FszOsFile))
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(rc)) = SQLITE_IOERR | int32(12)<<8
			return uintptr(0)
		}
		(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fp = pSubOpen
		*(*int32)(unsafe.Pointer(rc)) = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, pSubOpen,
			flags, pOutFlags)
		if *(*int32)(unsafe.Pointer(rc)) != SQLITE_OK {
			sqlite3.Xsqlite3_log(tls, *(*int32)(unsafe.Pointer(rc)), ts+35199, /* "multiplexor.xOpe..." */
				libc.VaList(bp+8, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz))
			sqlite3.Xsqlite3_free(tls, pSubOpen)
			(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fp = uintptr(0)
			return uintptr(0)
		}
	}
	return pSubOpen
}

// Return the size, in bytes, of chunk number iChunk.  If that chunk
// does not exist, then return 0.  This function does not distingish between
// non-existant files and zero-length files.
func multiplexSubSize(tls *libc.TLS, pGroup uintptr, iChunk int32, rc uintptr) sqlite3_int64 { /* test_multiplex.c:357:22: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSub uintptr
	*(*sqlite3_int64)(unsafe.Pointer(bp /* sz */)) = int64(0)

	if *(*int32)(unsafe.Pointer(rc)) != 0 {
		return int64(0)
	}
	pSub = multiplexSubOpen(tls, pGroup, iChunk, rc, uintptr(0), 0)
	if pSub == uintptr(0) {
		return int64(0)
	}
	*(*int32)(unsafe.Pointer(rc)) = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSub)).FpMethods)).FxFileSize})).f(tls, pSub, bp /* &sz */)
	return *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
}

// This is the implementation of the multiplex_control() SQL function.
func multiplexControlFunc(tls *libc.TLS, context uintptr, argc int32, argv uintptr) { /* test_multiplex.c:375:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32 = SQLITE_OK
	var db uintptr = sqlite3.Xsqlite3_context_db_handle(tls, context)
	var op int32 = 0
	// var iVal int32 at bp, 4

	if !(db != 0) || argc != 2 {
		rc = SQLITE_ERROR
	} else {
		// extract params
		op = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv)))
		*(*int32)(unsafe.Pointer(bp /* iVal */)) = sqlite3.Xsqlite3_value_int(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		// map function op to file_control op
		switch op {
		case 1:
			op = MULTIPLEX_CTRL_ENABLE
			break
			fallthrough
		case 2:
			op = MULTIPLEX_CTRL_SET_CHUNK_SIZE
			break
			fallthrough
		case 3:
			op = MULTIPLEX_CTRL_SET_MAX_CHUNKS
			break
			fallthrough
		default:
			rc = SQLITE_NOTFOUND
			break
		}
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_file_control(tls, db, uintptr(0), op, bp /* &iVal */)
	}
	sqlite3.Xsqlite3_result_error_code(tls, context, rc)
}

// This is the entry point to register the auto-extension for the
// multiplex_control() function.
func multiplexFuncInit(tls *libc.TLS, db uintptr, pzErrMsg uintptr, pApi uintptr) int32 { /* test_multiplex.c:417:12: */
	var rc int32
	rc = sqlite3.Xsqlite3_create_function(tls, db, ts+35231 /* "multiplex_contro..." */, 2, SQLITE_ANY,
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{multiplexControlFunc})), uintptr(0), uintptr(0))
	return rc
}

// Close a single sub-file in the connection group.
func multiplexSubClose(tls *libc.TLS, pGroup uintptr, iChunk int32, pOrigVfs uintptr) { /* test_multiplex.c:431:13: */
	var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(iChunk)*16)).Fp
	if pSubOpen != 0 {
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxClose})).f(tls, pSubOpen)
		if pOrigVfs != 0 && (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, 0)
		}
		sqlite3.Xsqlite3_free(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fp)
	}
	sqlite3.Xsqlite3_free_filename(tls, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz)
	libc.Xmemset(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16, 0, uint64(unsafe.Sizeof(multiplexReal{})))
}

// Deallocate memory held by a multiplexGroup
func multiplexFreeComponents(tls *libc.TLS, pGroup uintptr) { /* test_multiplex.c:451:13: */
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		multiplexSubClose(tls, pGroup, i, uintptr(0))
	}
	sqlite3.Xsqlite3_free(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal = uintptr(0)
	(*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal = 0
}

//************************ VFS Method Wrappers ****************************

// This is the xOpen method used for the "multiplex" VFS.
//
// Most of the work is done by the underlying original VFS.  This method
// simply links the new file into the appropriate multiplex group if it is a
// file that needs to be tracked.
func multiplexOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 { /* test_multiplex.c:469:12: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK // Result code
	var pMultiplexOpen uintptr                         // The new multiplex file descriptor
	var pGroup uintptr = uintptr(0)                    // Corresponding multiplexGroup object
	var pSubOpen uintptr = uintptr(0)                  // Real file descriptor
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs        // Real VFS
	var nName int32 = 0
	var sz int32 = 0
	var zToFree uintptr = uintptr(0)

	_ = pVfs
	libc.Xmemset(tls, pConn, 0, uint64((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile))

	// We need to create a group structure and manage
	// access to this group of files.
	pMultiplexOpen = pConn

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		// allocate space for group
		if zName != 0 {
			nName = multiplexStrlen30(tls, zName)
		} else {
			nName = 0
		}
		sz = int32(uint64(unsafe.Sizeof(multiplexGroup{})) +
			uint64(nName) + uint64(1)) // zName
		pGroup = sqlite3.Xsqlite3_malloc64(tls, uint64(sz))
		if pGroup == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_NOMEM
		}
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		var zUri uintptr
		if flags&SQLITE_OPEN_URI != 0 {
			zUri = zName
		} else {
			zUri = uintptr(0)
		}
		// assign pointers to extra space allocated
		libc.Xmemset(tls, pGroup, 0, uint64(sz))
		(*multiplexConn)(unsafe.Pointer(pMultiplexOpen)).FpGroup = pGroup
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = libc.Uint8(libc.Uint8FromInt32(-1))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(sqlite3.Xsqlite3_uri_boolean(tls, zUri, ts+19040, /* "truncate" */
			libc.Bool32(flags&SQLITE_OPEN_MAIN_DB == 0)))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(sqlite3.Xsqlite3_uri_int64(tls, zUri, ts+35249, /* "chunksize" */
			int64(SQLITE_MULTIPLEX_CHUNK_SIZE))))
		(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = ((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk + uint32(0xffff)) & libc.Uint32FromInt32(libc.CplInt32(0xffff))
		if zName != 0 {
			var p uintptr = pGroup + 1*40
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FzName = p
			libc.Xmemcpy(tls, (*multiplexGroup)(unsafe.Pointer(pGroup)).FzName, zName, uint64(nName+1))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FnName = nName
		}
		if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled != 0 {
			for uint32(sqlite3.Xsqlite3PendingByte)%(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk >= (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk-uint32(65536) {
				*(*uint32)(unsafe.Pointer(pGroup + 32)) += uint32(65536)
			}
		}
		(*multiplexGroup)(unsafe.Pointer(pGroup)).Fflags = flags & libc.CplInt32(SQLITE_OPEN_URI)
		*(*int32)(unsafe.Pointer(bp /* rc */)) = multiplexSubFilename(tls, pGroup, 1)
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, pOutFlags, 0)
			if pSubOpen == uintptr(0) && *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_CANTOPEN
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			// var sz64 sqlite3_int64 at bp+8, 8

			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileSize})).f(tls, pSubOpen, bp+8 /* &sz64 */)
			if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && zName != 0 {
				// var bExists int32 at bp+16, 4

				if flags&SQLITE_OPEN_SUPER_JOURNAL != 0 {
					(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
				} else if *(*sqlite3_int64)(unsafe.Pointer(bp + 8)) == int64(0) {
					if flags&SQLITE_OPEN_MAIN_JOURNAL != 0 {
						// If opening a main journal file and the first chunk is zero
						// bytes in size, delete any subsequent chunks from the
						// file-system.
						var iChunk int32 = 1
						for ok := true; ok; ok = *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && *(*int32)(unsafe.Pointer(bp + 16)) != 0 {
							*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
								f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
							})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs,
								(*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, SQLITE_ACCESS_EXISTS, bp+16 /* &bExists */)
							if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && *(*int32)(unsafe.Pointer(bp + 16)) != 0 {
								*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
									f func(*libc.TLS, uintptr, uintptr, int32) int32
								})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(iChunk)*16)).Fz, 0)
								if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
									*(*int32)(unsafe.Pointer(bp /* rc */)) = multiplexSubFilename(tls, pGroup, libc.PreIncInt32(&iChunk, 1))
								}
							}
						}
					}
				} else {
					// If the first overflow file exists and if the size of the main file
					// is different from the chunk size, that means the chunk size is set
					// set incorrectly.  So fix it.
					//
					// Or, if the first overflow file does not exist and the main file is
					// larger than the chunk size, that means the chunk size is too small.
					// But we have no way of determining the intended chunk size, so
					// just disable the multiplexor all togethre.
					*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+1*16)).Fz,
						SQLITE_ACCESS_EXISTS, bp+16 /* &bExists */)
					*(*int32)(unsafe.Pointer(bp + 16 /* bExists */)) = libc.Bool32(multiplexSubSize(tls, pGroup, 1, bp) > int64(0))
					if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && *(*int32)(unsafe.Pointer(bp + 16)) != 0 && *(*sqlite3_int64)(unsafe.Pointer(bp + 8)) == *(*sqlite3_int64)(unsafe.Pointer(bp + 8))&int64(0xffff0000) && *(*sqlite3_int64)(unsafe.Pointer(bp + 8)) > int64(0) &&
						*(*sqlite3_int64)(unsafe.Pointer(bp + 8)) != sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = uint32(int32(*(*sqlite3_int64)(unsafe.Pointer(bp + 8 /* sz64 */))))
					} else if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && !(*(*int32)(unsafe.Pointer(bp + 16)) != 0) && *(*sqlite3_int64)(unsafe.Pointer(bp + 8)) > sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) {
						(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(0)
					}
				}
			}
		}

		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*sqlite3_file)(unsafe.Pointer(pConn)).FpMethods = uintptr(unsafe.Pointer(&gMultiplex)) + 176
			} else {
				(*sqlite3_file)(unsafe.Pointer(pConn)).FpMethods = uintptr(unsafe.Pointer(&gMultiplex)) + 328
			}
		} else {
			multiplexFreeComponents(tls, pGroup)
			sqlite3.Xsqlite3_free(tls, pGroup)
		}
	}
	sqlite3.Xsqlite3_free(tls, zToFree)
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// This is the xDelete method used for the "multiplex" VFS.
// It attempts to delete the filename specified.
func multiplexDelete(tls *libc.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 { /* test_multiplex.c:611:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, zName, syncDir)
	if rc == SQLITE_OK {
		// If the main chunk was deleted successfully, also delete any subsequent
		// chunks - starting with the last (highest numbered).
		var nName int32 = int32(libc.Xstrlen(tls, zName))
		var z uintptr
		z = sqlite3.Xsqlite3_malloc64(tls, uint64(nName+5))
		if z == uintptr(0) {
			rc = SQLITE_IOERR | int32(12)<<8
		} else {
			var iChunk int32 = 0
			// var bExists int32 at bp, 4

			for ok := true; ok; ok = rc == SQLITE_OK && *(*int32)(unsafe.Pointer(bp)) != 0 {
				multiplexFilename(tls, zName, nName, SQLITE_OPEN_MAIN_JOURNAL, libc.PreIncInt32(&iChunk, 1), z)
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, z, SQLITE_ACCESS_EXISTS, bp /* &bExists */)
			}
			for rc == SQLITE_OK && iChunk > 1 {
				multiplexFilename(tls, zName, nName, SQLITE_OPEN_MAIN_JOURNAL, libc.PreDecInt32(&iChunk, 1), z)
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, z, syncDir)
			}
			if rc == SQLITE_OK {
				iChunk = 0
				for ok1 := true; ok1; ok1 = rc == SQLITE_OK && *(*int32)(unsafe.Pointer(bp)) != 0 {
					multiplexFilename(tls, zName, nName, SQLITE_OPEN_WAL, libc.PreIncInt32(&iChunk, 1), z)
					rc = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxAccess})).f(tls, pOrigVfs, z, SQLITE_ACCESS_EXISTS, bp /* &bExists */)
				}
				for rc == SQLITE_OK && iChunk > 1 {
					multiplexFilename(tls, zName, nName, SQLITE_OPEN_WAL, libc.PreDecInt32(&iChunk, 1), z)
					rc = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, z, syncDir)
				}
			}
		}
		sqlite3.Xsqlite3_free(tls, z)
	}
	return rc
}

func multiplexAccess(tls *libc.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 { /* test_multiplex.c:656:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxAccess})).f(tls, gMultiplex.FpOrigVfs, b, c, d)
}

func multiplexFullPathname(tls *libc.TLS, a uintptr, b uintptr, c int32, d uintptr) int32 { /* test_multiplex.c:659:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxFullPathname})).f(tls, gMultiplex.FpOrigVfs, b, c, d)
}

func multiplexDlOpen(tls *libc.TLS, a uintptr, b uintptr) uintptr { /* test_multiplex.c:662:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlOpen})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexDlError(tls *libc.TLS, a uintptr, b int32, c uintptr) { /* test_multiplex.c:665:13: */
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlError})).f(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexDlSym(tls *libc.TLS, a uintptr, b uintptr, c uintptr) uintptr { /* test_multiplex.c:668:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlSym})).f(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexDlClose(tls *libc.TLS, a uintptr, b uintptr) { /* test_multiplex.c:671:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxDlClose})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexRandomness(tls *libc.TLS, a uintptr, b int32, c uintptr) int32 { /* test_multiplex.c:674:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxRandomness})).f(tls, gMultiplex.FpOrigVfs, b, c)
}

func multiplexSleep(tls *libc.TLS, a uintptr, b int32) int32 { /* test_multiplex.c:677:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxSleep})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexCurrentTime(tls *libc.TLS, a uintptr, b uintptr) int32 { /* test_multiplex.c:680:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxCurrentTime})).f(tls, gMultiplex.FpOrigVfs, b)
}

func multiplexGetLastError(tls *libc.TLS, a uintptr, b int32, c uintptr) int32 { /* test_multiplex.c:683:12: */
	if (*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxGetLastError != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxGetLastError})).f(tls, gMultiplex.FpOrigVfs, b, c)
	} else {
		return 0
	}
	return int32(0)
}

func multiplexCurrentTimeInt64(tls *libc.TLS, a uintptr, b uintptr) int32 { /* test_multiplex.c:690:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gMultiplex.FpOrigVfs)).FxCurrentTimeInt64})).f(tls, gMultiplex.FpOrigVfs, b)
}

//*********************** I/O Method Wrappers ******************************

// xClose requests get passed through to the original VFS.
// We loop over all open chunk handles and close them.
// The group structure for this file is unlinked from
// our list of groups and freed.
func multiplexClose(tls *libc.TLS, pConn uintptr) int32 { /* test_multiplex.c:701:12: */
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = SQLITE_OK
	multiplexFreeComponents(tls, pGroup)
	sqlite3.Xsqlite3_free(tls, pGroup)
	return rc
}

// Pass xRead requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up reads across chunk boundaries.
func multiplexRead(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_multiplex.c:714:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR | int32(1)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxRead})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for iAmt > 0 {
			var i int32 = int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
			var pSubOpen uintptr
			pSubOpen = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = int32(uint32(int32(iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))+iAmt) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - extra
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxRead})).f(tls, pSubOpen, pBuf, iAmt,
					iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
					break
				}
				pBuf = pBuf + uintptr(iAmt)
				iOfst = iOfst + sqlite3_int64(iAmt)
				iAmt = extra
			} else {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR | int32(1)<<8
				break
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xWrite requests thru to the original VFS after
// determining the correct chunk to operate on.
// Break up writes across chunk boundaries.
func multiplexWrite(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_multiplex.c:759:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR | int32(3)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxWrite})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
		}
	} else {
		for *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && iAmt > 0 {
			var i int32 = int32(iOfst / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
			var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 1)
			if pSubOpen != 0 {
				var extra int32 = int32(uint32(int32(iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))+iAmt) - (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk)
				if extra < 0 {
					extra = 0
				}
				iAmt = iAmt - extra
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxWrite})).f(tls, pSubOpen, pBuf, iAmt,
					iOfst%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
				pBuf = pBuf + uintptr(iAmt)
				iOfst = iOfst + sqlite3_int64(iAmt)
				iAmt = extra
			}
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xTruncate requests thru to the original VFS after
// determining the correct chunk to operate on.  Delete any
// chunks above the truncate mark.
func multiplexTruncate(tls *libc.TLS, pConn uintptr, size sqlite3_int64) int32 { /* test_multiplex.c:799:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR | int32(6)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
				f func(*libc.TLS, uintptr, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, size)
		}
	} else {
		var i int32
		var iBaseGroup int32 = int32(size / sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
		var pSubOpen uintptr
		var pOrigVfs uintptr = gMultiplex.FpOrigVfs // Real VFS
		// delete the chunks above the truncate limit
		for i = (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal - 1; i > iBaseGroup && *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK; i-- {
			if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
				multiplexSubClose(tls, pGroup, i, pOrigVfs)
			} else {
				pSubOpen = multiplexSubOpen(tls, pGroup, i, bp /* &rc */, uintptr(0), 0)
				if pSubOpen != 0 {
					*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
						f func(*libc.TLS, uintptr, sqlite3_int64) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, int64(0))
				}
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
			pSubOpen = multiplexSubOpen(tls, pGroup, iBaseGroup, bp /* &rc */, uintptr(0), 0)
			if pSubOpen != 0 {
				*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
					f func(*libc.TLS, uintptr, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, size%sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
			}
		}
		if *(*int32)(unsafe.Pointer(bp)) != 0 {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR | int32(6)<<8
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xSync requests through to the original VFS without change
func multiplexSync(tls *libc.TLS, pConn uintptr, flags int32) int32 { /* test_multiplex.c:839:12: */
	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	var rc int32 = SQLITE_OK
	var i int32
	for i = 0; i < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; i++ {
		var pSubOpen uintptr = (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal + uintptr(i)*16)).Fp
		if pSubOpen != 0 {
			var rc2 int32 = (*struct {
				f func(*libc.TLS, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSync})).f(tls, pSubOpen, flags)
			if rc2 != SQLITE_OK {
				rc = rc2
			}
		}
	}
	return rc
}

// Pass xFileSize requests through to the original VFS.
// Aggregate the size of all the chunks before returning.
func multiplexFileSize(tls *libc.TLS, pConn uintptr, pSize uintptr) int32 { /* test_multiplex.c:857:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var i int32
	if !(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0) {
		var pSubOpen uintptr = multiplexSubOpen(tls, pGroup, 0, bp /* &rc */, uintptr(0), 0)
		if pSubOpen == uintptr(0) {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR | int32(7)<<8
		} else {
			*(*int32)(unsafe.Pointer(bp /* rc */)) = (*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileSize})).f(tls, pSubOpen, pSize)
		}
	} else {
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = int64(0)
		for i = 0; *(*int32)(unsafe.Pointer(bp /* rc */)) == SQLITE_OK; i++ {
			var sz sqlite3_int64 = multiplexSubSize(tls, pGroup, i, bp /* &rc */)
			if sz == int64(0) {
				break
			}
			*(*sqlite3_int64)(unsafe.Pointer(pSize)) = sqlite3_int64(i)*sqlite3_int64((*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk) + sz
		}
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Pass xLock requests through to the original VFS unchanged.
func multiplexLock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_multiplex.c:882:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxLock})).f(tls, pSubOpen, lock)
	}
	return SQLITE_BUSY
}

// Pass xUnlock requests through to the original VFS unchanged.
func multiplexUnlock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_multiplex.c:894:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxUnlock})).f(tls, pSubOpen, lock)
	}
	return SQLITE_IOERR | int32(8)<<8
}

// Pass xCheckReservedLock requests through to the original VFS unchanged.
func multiplexCheckReservedLock(tls *libc.TLS, pConn uintptr, pResOut uintptr) int32 { /* test_multiplex.c:906:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxCheckReservedLock})).f(tls, pSubOpen, pResOut)
	}
	return SQLITE_IOERR | int32(14)<<8
}

// Pass xFileControl requests through to the original VFS unchanged,
// except for any MULTIPLEX_CTRL_* requests here.
func multiplexFileControl(tls *libc.TLS, pConn uintptr, op int32, pArg uintptr) int32 { /* test_multiplex.c:919:12: */
	bp := tls.Alloc(44)
	defer tls.Free(44)

	var p uintptr = pConn
	var pGroup uintptr = (*multiplexConn)(unsafe.Pointer(p)).FpGroup
	*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_ERROR
	var pSubOpen uintptr

	if !(gMultiplex.FisInitialized != 0) {
		return SQLITE_MISUSE
	}
	switch op {
	case MULTIPLEX_CTRL_ENABLE:
		if pArg != 0 {
			var bEnabled int32 = *(*int32)(unsafe.Pointer(pArg))
			(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled = uint8(bEnabled)
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
		}
		break
	case MULTIPLEX_CTRL_SET_CHUNK_SIZE:
		if pArg != 0 {
			var szChunk uint32 = *(*uint32)(unsafe.Pointer(pArg))
			if szChunk < uint32(1) {
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_MISUSE
			} else {
				// Round up to nearest multiple of MAX_PAGE_SIZE.
				szChunk = szChunk + uint32(MAX_PAGE_SIZE-1)
				szChunk = szChunk & libc.Uint32FromInt32(libc.CplInt32(MAX_PAGE_SIZE-1))
				(*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk = szChunk
				*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
			}
		}
		break
	case MULTIPLEX_CTRL_SET_MAX_CHUNKS:
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
		break
	case SQLITE_FCNTL_SIZE_HINT:
		fallthrough
	case SQLITE_FCNTL_CHUNK_SIZE:
		// no-op these
		*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
		break
	case SQLITE_FCNTL_PRAGMA:
		{
			var aFcntl uintptr = pArg
			// EVIDENCE-OF: R-29875-31678 The argument to the SQLITE_FCNTL_PRAGMA
			// file control is an array of pointers to strings (char**) in which the
			// second element of the array is the name of the pragma and the third
			// element is the argument to the pragma or NULL if the pragma has no
			// argument.
			if *(*uintptr)(unsafe.Pointer(aFcntl + 1*8)) != 0 && sqlite3.Xsqlite3_strnicmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*8)), ts+35259, 10) == 0 {
				*(*sqlite3_int64)(unsafe.Pointer(bp + 32 /* sz */)) = int64(0)
				multiplexFileSize(tls, pConn, bp+32 /* &sz */)
				// PRAGMA multiplex_truncate=BOOLEAN;
				// PRAGMA multiplex_truncate;
				//
				// Turn the multiplexor truncate feature on or off.  Return either
				// "on" or "off" to indicate the new setting.  If the BOOLEAN argument
				// is omitted, just return the current value for the truncate setting.
				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*8)), ts+35270) == 0 {
					if *(*uintptr)(unsafe.Pointer(aFcntl + 2*8)) != 0 && *(*int8)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(aFcntl + 2*8)))) != 0 {
						if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*8)), ts+4178) == 0 ||
							sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*8)), ts+29449) == 0 {
							(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(1)
						} else if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*8)), ts+4542) == 0 ||
							sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 2*8)), ts+15020) == 0 {
							(*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate = uint8(0)
						}
					}
					// EVIDENCE-OF: R-27806-26076 The handler for an SQLITE_FCNTL_PRAGMA
					// file control can optionally make the first element of the char**
					// argument point to a string obtained from sqlite3_mprintf() or the
					// equivalent and that string will become the result of the pragma
					// or the error message if the pragma fails.
					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, func() uintptr {
						if (*multiplexGroup)(unsafe.Pointer(pGroup)).FbTruncate != 0 {
							return ts + 4178 /* "on" */
						}
						return ts + 4542 /* "off" */
					}(), 0)
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
					break
				}
				// PRAGMA multiplex_enabled;
				//
				// Return 0 or 1 depending on whether the multiplexor is enabled or
				// disabled, respectively.
				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*8)), ts+35289) == 0 {
					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, ts+1333 /* "%d" */, libc.VaList(bp, libc.Bool32(int32((*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled) != 0)))
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
					break
				}
				// PRAGMA multiplex_chunksize;
				//
				// Return the chunksize for the multiplexor, or no-op if the
				// multiplexor is not active.
				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*8)), ts+35307) == 0 &&
					(*multiplexGroup)(unsafe.Pointer(pGroup)).FbEnabled != 0 {
					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, ts+18527 /* "%u" */, libc.VaList(bp+8, (*multiplexGroup)(unsafe.Pointer(pGroup)).FszChunk))
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
					break
				}
				// PRAGMA multiplex_filecount;
				//
				// Return the number of disk files currently in use by the
				// multiplexor.  This should be the total database size size
				// divided by the chunksize and rounded up.
				if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(aFcntl + 1*8)), ts+35327) == 0 {
					var n int32 = 0
					var ii int32
					for ii = 0; ii < (*multiplexGroup)(unsafe.Pointer(pGroup)).FnReal; ii++ {
						if (*multiplexReal)(unsafe.Pointer((*multiplexGroup)(unsafe.Pointer(pGroup)).FaReal+uintptr(ii)*16)).Fp != uintptr(0) {
							n++
						}
					}
					*(*uintptr)(unsafe.Pointer(aFcntl)) = sqlite3.Xsqlite3_mprintf(tls, ts+1333 /* "%d" */, libc.VaList(bp+16, n))
					*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = SQLITE_OK
					break
				}
			}
			// If the multiplexor does not handle the pragma, pass it through
			// into the default case.

		}
		fallthrough
	default:
		pSubOpen = multiplexSubOpen(tls, pGroup, 0, bp+40 /* &rc */, uintptr(0), 0)
		if pSubOpen != 0 {
			*(*int32)(unsafe.Pointer(bp + 40 /* rc */)) = (*struct {
				f func(*libc.TLS, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileControl})).f(tls, pSubOpen, op, pArg)
			if op == SQLITE_FCNTL_VFSNAME && *(*int32)(unsafe.Pointer(bp + 40)) == SQLITE_OK {
				*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+35347 /* "multiplex/%z" */, libc.VaList(bp+24, *(*uintptr)(unsafe.Pointer(pArg))))
			}
		}
		break
	}
	return *(*int32)(unsafe.Pointer(bp + 40 /* rc */))
}

// Pass xSectorSize requests through to the original VFS unchanged.
func multiplexSectorSize(tls *libc.TLS, pConn uintptr) int32 { /* test_multiplex.c:1057:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 && (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize})).f(tls, pSubOpen)
	}
	return DEFAULT_SECTOR_SIZE
}

// Pass xDeviceCharacteristics requests through to the original VFS unchanged.
func multiplexDeviceCharacteristics(tls *libc.TLS, pConn uintptr) int32 { /* test_multiplex.c:1069:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxDeviceCharacteristics})).f(tls, pSubOpen)
	}
	return 0
}

// Pass xShmMap requests through to the original VFS unchanged.
func multiplexShmMap(tls *libc.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 { /* test_multiplex.c:1081:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmMap})).f(tls, pSubOpen, iRegion, szRegion, bExtend, pp)
	}
	return SQLITE_IOERR
}

// Pass xShmLock requests through to the original VFS unchanged.
func multiplexShmLock(tls *libc.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 { /* test_multiplex.c:1099:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmLock})).f(tls, pSubOpen, ofst, n, flags)
	}
	return SQLITE_BUSY
}

// Pass xShmBarrier requests through to the original VFS unchanged.
func multiplexShmBarrier(tls *libc.TLS, pConn uintptr) { /* test_multiplex.c:1116:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmBarrier})).f(tls, pSubOpen)
	}
}

// Pass xShmUnmap requests through to the original VFS unchanged.
func multiplexShmUnmap(tls *libc.TLS, pConn uintptr, deleteFlag int32) int32 { /* test_multiplex.c:1127:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pConn
	// var rc int32 at bp, 4

	var pSubOpen uintptr = multiplexSubOpen(tls, (*multiplexConn)(unsafe.Pointer(p)).FpGroup, 0, bp /* &rc */, uintptr(0), 0)
	if pSubOpen != 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmUnmap})).f(tls, pSubOpen, deleteFlag)
	}
	return SQLITE_OK
}

//************************* Public Interfaces ****************************
// CAPI: Initialize the multiplex VFS shim - sqlite3_multiplex_initialize()
//
// Use the VFS named zOrigVfsName as the VFS that does the actual work.
// Use the default if zOrigVfsName==NULL.
//
// The multiplex VFS shim is named "multiplex".  It will become the default
// VFS if makeDefault is non-zero.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
// during start-up.
func sqlite3_multiplex_initialize(tls *libc.TLS, zOrigVfsName uintptr, makeDefault int32) int32 { /* test_multiplex.c:1150:5: */
	var pOrigVfs uintptr
	if gMultiplex.FisInitialized != 0 {
		return SQLITE_MISUSE
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return SQLITE_ERROR
	}

	gMultiplex.FisInitialized = 1
	gMultiplex.FpOrigVfs = pOrigVfs
	gMultiplex.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gMultiplex)) + 8 + 4)) += int32(uint64(unsafe.Sizeof(multiplexConn{})))
	gMultiplex.FsThisVfs.FzName = ts + 35360 /* "multiplex" */
	gMultiplex.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{multiplexOpen}))
	gMultiplex.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{multiplexDelete}))
	gMultiplex.FsThisVfs.FxAccess = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexAccess}))
	gMultiplex.FsThisVfs.FxFullPathname = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{multiplexFullPathname}))
	gMultiplex.FsThisVfs.FxDlOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	}{multiplexDlOpen}))
	gMultiplex.FsThisVfs.FxDlError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	}{multiplexDlError}))
	gMultiplex.FsThisVfs.FxDlSym = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	}{multiplexDlSym}))
	gMultiplex.FsThisVfs.FxDlClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr)
	}{multiplexDlClose}))
	gMultiplex.FsThisVfs.FxRandomness = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexRandomness}))
	gMultiplex.FsThisVfs.FxSleep = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexSleep}))
	gMultiplex.FsThisVfs.FxCurrentTime = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTime}))
	gMultiplex.FsThisVfs.FxGetLastError = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexGetLastError}))
	gMultiplex.FsThisVfs.FxCurrentTimeInt64 = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCurrentTimeInt64}))

	gMultiplex.FsIoMethodsV1.FiVersion = 1
	gMultiplex.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexClose}))
	gMultiplex.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexRead}))
	gMultiplex.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{multiplexWrite}))
	gMultiplex.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	}{multiplexTruncate}))
	gMultiplex.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexSync}))
	gMultiplex.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexFileSize}))
	gMultiplex.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexLock}))
	gMultiplex.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexUnlock}))
	gMultiplex.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{multiplexCheckReservedLock}))
	gMultiplex.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{multiplexFileControl}))
	gMultiplex.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexSectorSize}))
	gMultiplex.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{multiplexDeviceCharacteristics}))
	gMultiplex.FsIoMethodsV2 = gMultiplex.FsIoMethodsV1
	gMultiplex.FsIoMethodsV2.FiVersion = 2
	gMultiplex.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{multiplexShmMap}))
	gMultiplex.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	}{multiplexShmLock}))
	gMultiplex.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{multiplexShmBarrier}))
	gMultiplex.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{multiplexShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&gMultiplex))+8, makeDefault)

	sqlite3.Xsqlite3_auto_extension(tls, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) int32
	}{multiplexFuncInit})))

	return SQLITE_OK
}

// CAPI: Shutdown the multiplex system - sqlite3_multiplex_shutdown()
//
// All SQLite database connections must be closed before calling this
// routine.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
// shutting down in order to free all remaining multiplex groups.
func sqlite3_multiplex_shutdown(tls *libc.TLS, eForce int32) int32 { /* test_multiplex.c:1211:5: */
	var rc int32 = SQLITE_OK
	if gMultiplex.FisInitialized == 0 {
		return SQLITE_MISUSE
	}
	gMultiplex.FisInitialized = 0
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&gMultiplex))+8)
	libc.Xmemset(tls, uintptr(unsafe.Pointer(&gMultiplex)), 0, uint64(unsafe.Sizeof(gMultiplex)))
	return rc
}

// tclcmd: sqlite3_multiplex_initialize NAME MAKEDEFAULT
func test_multiplex_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1236:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr // Name of new multiplex VFS
	// var makeDefault int32 at bp, 4
	// True to make the new VFS the default
	var rc int32 // Value returned by multiplex_initialize()

	_ = clientData

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35370 /* "NAME MAKEDEFAULT" */)
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 {
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(zName))) == 0 {
		zName = uintptr(0)
	}

	// Call sqlite3_multiplex_initialize()
	rc = sqlite3_multiplex_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp /* makeDefault */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// tclcmd: sqlite3_multiplex_shutdown
func test_multiplex_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1267:26: */
	var rc int32 // Value returned by multiplex_shutdown()

	_ = clientData

	if objc == 2 && libc.Xstrcmp(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), ts+35387) != 0 {
		objc = 3
	}
	if objc != 1 && objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35394 /* "?-force?" */)
		return TCL_ERROR
	}

	// Call sqlite3_multiplex_shutdown()
	rc = sqlite3_multiplex_shutdown(tls, libc.Bool32(objc == 2))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// Tclcmd: test_multiplex_control HANDLE DBNAME SUB-COMMAND ?INT-VALUE?
func test_multiplex_control(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_multiplex.c:1295:26: */
	bp := tls.Alloc(176)
	defer tls.Free(176)

	var rc int32 // Return code from file_control()
	// var idx int32 at bp+168, 4
	// Index in aSub[]
	// var cmdInfo Tcl_CmdInfo at bp+40, 64
	// Command info structure for HANDLE
	var db uintptr // Underlying db handle for HANDLE
	*(*int32)(unsafe.Pointer(bp + 172 /* iValue */)) = 0
	var pArg uintptr = uintptr(0)

	*(*[4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 104)) = [4]struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	}{
		{FzName: ts + 10977 /* "enable" */, Fop: MULTIPLEX_CTRL_ENABLE, Fargtype: 1},
		{FzName: ts + 35403 /* "chunk_size" */, Fop: MULTIPLEX_CTRL_SET_CHUNK_SIZE, Fargtype: 1},
		{FzName: ts + 35414 /* "max_chunks" */, Fop: MULTIPLEX_CTRL_SET_MAX_CHUNKS, Fargtype: 1},
		{},
	}

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35425 /* "HANDLE DBNAME SU..." */)
		return TCL_ERROR
	}

	if 0 == tcl.XTcl_GetCommandInfo(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+40) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+35461 /* "expected databas..." */, 0))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), ts+12784 /* "\"" */, 0))
		return TCL_ERROR
	} else {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 40 /* &cmdInfo */)).FobjClientData))
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+104 /* &aSub[0] */, int32(unsafe.Sizeof(struct {
			FzName   uintptr
			Fop      int32
			Fargtype int32
		}{})), ts+2014 /* "sub-command" */, 0, bp+168 /* &idx */)
	if rc != TCL_OK {
		return rc
	}

	switch (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp + 104 + uintptr(*(*int32)(unsafe.Pointer(bp + 168)))*16)).Fargtype {
	case 1:
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+172) != 0 {
			return TCL_ERROR
		}
		pArg = bp + 172 /* &iValue */
		break
	default:
		tcl.XTcl_WrongNumArgs(tls, interp, 4, objv, ts+2523 /* "SUB-COMMAND" */)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_file_control(tls, db, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), (*struct {
		FzName   uintptr
		Fop      int32
		Fargtype int32
	})(unsafe.Pointer(bp+104+uintptr(*(*int32)(unsafe.Pointer(bp + 168)))*16)).Fop, pArg)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	if rc == SQLITE_OK {
		return TCL_OK
	}
	return TCL_ERROR
}

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitemultiplex_Init(tls *libc.TLS, interp uintptr) int32 { /* test_multiplex.c:1359:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd7))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd7[i].FzName, aCmd7[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aCmd7 = [3]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 35493 /* "sqlite3_multiple..." */, FxProc: 0},
	{FzName: ts + 35522 /* "sqlite3_multiple..." */, FxProc: 0},
	{FzName: ts + 35549 /* "sqlite3_multiple..." */, FxProc: 0},
} /* test_multiplex.c:1363:5 */

// CAPI3REF: Standard File Control Opcodes
// KEYWORDS: {file control opcodes} {file control opcode}
//
// These integer constants are opcodes for the xFileControl method
// of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
// interface.
//
// <ul>
// <li>[[SQLITE_FCNTL_LOCKSTATE]]
// The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
// opcode causes the xFileControl method to write the current state of
// the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
// [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
// into an integer that the pArg argument points to. This capability
// is used during testing and is only available when the SQLITE_TEST
// compile-time option is used.
//
// <li>[[SQLITE_FCNTL_SIZE_HINT]]
// The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
// layer a hint of how large the database file will grow to be during the
// current transaction.  This hint is not guaranteed to be accurate but it
// is often close.  The underlying VFS might choose to preallocate database
// file space based on this hint in order to help writes to the database
// file run faster.
//
// <li>[[SQLITE_FCNTL_SIZE_LIMIT]]
// The [SQLITE_FCNTL_SIZE_LIMIT] opcode is used by in-memory VFS that
// implements [sqlite3_deserialize()] to set an upper bound on the size
// of the in-memory database.  The argument is a pointer to a [sqlite3_int64].
// If the integer pointed to is negative, then it is filled in with the
// current limit.  Otherwise the limit is set to the larger of the value
// of the integer pointed to and the current database size.  The integer
// pointed to is set to the new limit.
//
// <li>[[SQLITE_FCNTL_CHUNK_SIZE]]
// The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS
// extends and truncates the database file in chunks of a size specified
// by the user. The fourth argument to [sqlite3_file_control()] should
// point to an integer (type int) containing the new chunk-size to use
// for the nominated database. Allocating database file space in large
// chunks (say 1MB at a time), may reduce file-system fragmentation and
// improve performance on some systems.
//
// <li>[[SQLITE_FCNTL_FILE_POINTER]]
// The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with a particular database
// connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].
//
// <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]
// The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer
// to the [sqlite3_file] object associated with the journal file (either
// the [rollback journal] or the [write-ahead log]) for a particular database
// connection.  See also [SQLITE_FCNTL_FILE_POINTER].
//
// <li>[[SQLITE_FCNTL_SYNC_OMITTED]]
// No longer in use.
//
// <li>[[SQLITE_FCNTL_SYNC]]
// The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and
// sent to the VFS immediately before the xSync method is invoked on a
// database file descriptor. Or, if the xSync method is not invoked
// because the user has configured SQLite with
// [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place
// of the xSync method. In most cases, the pointer argument passed with
// this file-control is NULL. However, if the database file is being synced
// as part of a multi-database commit, the argument points to a nul-terminated
// string containing the transactions super-journal file name. VFSes that
// do not need this signal should silently ignore this opcode. Applications
// should not call [sqlite3_file_control()] with this opcode as doing so may
// disrupt the operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]
// The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite
// and sent to the VFS after a transaction has been committed immediately
// but before the database is unlocked. VFSes that do not need this signal
// should silently ignore this opcode. Applications should not call
// [sqlite3_file_control()] with this opcode as doing so may disrupt the
// operation of the specialized VFSes that do require it.
//
// <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]
// ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic
// retry counts and intervals for certain disk I/O operations for the
// windows [VFS] in order to provide robustness in the presence of
// anti-virus programs.  By default, the windows VFS will retry file read,
// file write, and file delete operations up to 10 times, with a delay
// of 25 milliseconds before the first retry and with the delay increasing
// by an additional 25 milliseconds with each subsequent retry.  This
// opcode allows these two values (10 retries and 25 milliseconds of delay)
// to be adjusted.  The values are changed for all database connections
// within the same process.  The argument is a pointer to an array of two
// integers where the first integer is the new retry count and the second
// integer is the delay.  If either integer is negative, then the setting
// is not changed but instead the prior value of that setting is written
// into the array entry, allowing the current retry settings to be
// interrogated.  The zDbName parameter is ignored.
//
// <li>[[SQLITE_FCNTL_PERSIST_WAL]]
// ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the
// persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary
// write ahead log ([WAL file]) and shared memory
// files used for transaction control
// are automatically deleted when the latest connection to the database
// closes.  Setting persistent WAL mode causes those files to persist after
// close.  Persisting the files is useful when other processes that do not
// have write permission on the directory containing the database file want
// to read the database file, as the WAL and shared memory files must exist
// in order for the database to be readable.  The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable persistent WAL mode or 1 to enable persistent
// WAL mode.  If the integer is -1, then it is overwritten with the current
// WAL persistence setting.
//
// <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]
// ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the
// persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting
// determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the
// xDeviceCharacteristics methods. The fourth parameter to
// [sqlite3_file_control()] for this opcode should be a pointer to an integer.
// That integer is 0 to disable zero-damage mode or 1 to enable zero-damage
// mode.  If the integer is -1, then it is overwritten with the current
// zero-damage mode setting.
//
// <li>[[SQLITE_FCNTL_OVERWRITE]]
// ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening
// a write transaction to indicate that, unless it is rolled back for some
// reason, the entire database file will be overwritten by the current
// transaction. This is used by VACUUM operations.
//
// <li>[[SQLITE_FCNTL_VFSNAME]]
// ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of
// all [VFSes] in the VFS stack.  The names are of all VFS shims and the
// final bottom-level VFS are written into memory obtained from
// [sqlite3_malloc()] and the result is stored in the char* variable
// that the fourth parameter of [sqlite3_file_control()] points to.
// The caller is responsible for freeing the memory when done.  As with
// all file-control actions, there is no guarantee that this will actually
// do anything.  Callers should initialize the char* variable to a NULL
// pointer in case this file-control is not implemented.  This file-control
// is intended for diagnostic use only.
//
// <li>[[SQLITE_FCNTL_VFS_POINTER]]
// ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level
// [VFSes] currently in use.  ^(The argument X in
// sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be
// of type "[sqlite3_vfs] **".  This opcodes will set *X
// to a pointer to the top-level VFS.)^
// ^When there are multiple VFS shims in the stack, this opcode finds the
// upper-most shim only.
//
// <li>[[SQLITE_FCNTL_PRAGMA]]
// ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]
// file control is sent to the open [sqlite3_file] object corresponding
// to the database file to which the pragma statement refers. ^The argument
// to the [SQLITE_FCNTL_PRAGMA] file control is an array of
// pointers to strings (char**) in which the second element of the array
// is the name of the pragma and the third element is the argument to the
// pragma or NULL if the pragma has no argument.  ^The handler for an
// [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element
// of the char** argument point to a string obtained from [sqlite3_mprintf()]
// or the equivalent and that string will become the result of the pragma or
// the error message if the pragma fails. ^If the
// [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal
// [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
// file control returns [SQLITE_OK], then the parser assumes that the
// VFS has handled the PRAGMA itself and the parser generates a no-op
// prepared statement if result string is NULL, or that returns a copy
// of the result string if the string is non-NULL.
// ^If the [SQLITE_FCNTL_PRAGMA] file control returns
// any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
// that the VFS encountered an error while handling the [PRAGMA] and the
// compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
// file control occurs at the beginning of pragma statement analysis and so
// it is able to override built-in [PRAGMA] statements.
//
// <li>[[SQLITE_FCNTL_BUSYHANDLER]]
// ^The [SQLITE_FCNTL_BUSYHANDLER]
// file-control may be invoked by SQLite on the database file handle
// shortly after it is opened in order to provide a custom VFS with access
// to the connection's busy-handler callback. The argument is of type (void**)
// - an array of two (void *) values. The first (void *) actually points
// to a function of type (int (*)(void *)). In order to invoke the connection's
// busy-handler, this function should be invoked with the second (void *) in
// the array as the only argument. If it returns non-zero, then the operation
// should be retried. If it returns zero, the custom VFS should abandon the
// current operation.
//
// <li>[[SQLITE_FCNTL_TEMPFILENAME]]
// ^Applications can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control
// to have SQLite generate a
// temporary filename using the same algorithm that is followed to generate
// temporary filenames for TEMP tables and other internal uses.  The
// argument should be a char** which will be filled with the filename
// written into memory obtained from [sqlite3_malloc()].  The caller should
// invoke [sqlite3_free()] on the result to avoid a memory leak.
//
// <li>[[SQLITE_FCNTL_MMAP_SIZE]]
// The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the
// maximum number of bytes that will be used for memory-mapped I/O.
// The argument is a pointer to a value of type sqlite3_int64 that
// is an advisory maximum number of bytes in the file to memory map.  The
// pointer is overwritten with the old value.  The limit is not changed if
// the value originally pointed to is negative, and so the current limit
// can be queried by passing in a pointer to a negative number.  This
// file-control is used internally to implement [PRAGMA mmap_size].
//
// <li>[[SQLITE_FCNTL_TRACE]]
// The [SQLITE_FCNTL_TRACE] file control provides advisory information
// to the VFS about what the higher layers of the SQLite stack are doing.
// This file control is used by some VFS activity tracing [shims].
// The argument is a zero-terminated string.  Higher layers in the
// SQLite stack may generate instances of this file control if
// the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.
//
// <li>[[SQLITE_FCNTL_HAS_MOVED]]
// The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a
// pointer to an integer and it writes a boolean into that integer depending
// on whether or not the file has been renamed, moved, or deleted since it
// was first opened.
//
// <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the
// underlying native file handle associated with a file handle.  This file
// control interprets its argument as a pointer to a native file handle and
// writes the resulting value there.
//
// <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]
// The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This
// opcode causes the xFileControl method to swap the file handle with the one
// pointed to by the pArg argument.  This capability is used during testing
// and only needs to be supported when SQLITE_TEST is defined.
//
// <li>[[SQLITE_FCNTL_WAL_BLOCK]]
// The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
// be advantageous to block on the next WAL lock if the lock is not immediately
// available.  The WAL subsystem issues this signal during rare
// circumstances in order to fix a problem with priority inversion.
// Applications should <em>not</em> use this file-control.
//
// <li>[[SQLITE_FCNTL_ZIPVFS]]
// The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other
// VFS should return SQLITE_NOTFOUND for this opcode.
//
// <li>[[SQLITE_FCNTL_RBU]]
// The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by
// the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for
// this opcode.
//
// <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]
// If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then
// the file descriptor is placed in "batch write mode", which
// means all subsequent write operations will be deferred and done
// atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems
// that do not support batch atomic writes will return SQLITE_NOTFOUND.
// ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to
// the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or
// [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make
// no VFS interface calls on the same [sqlite3_file] file descriptor
// except for calls to the xWrite method and the xFileControl method
// with [SQLITE_FCNTL_SIZE_HINT].
//
// <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.
// This file control returns [SQLITE_OK] if and only if the writes were
// all performed successfully and have been committed to persistent storage.
// ^Regardless of whether or not it is successful, this file control takes
// the file descriptor out of batch write mode so that all subsequent
// write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]
// The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write
// operations since the previous successful call to
// [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.
// ^This file control takes the file descriptor out of batch write mode
// so that all subsequent write operations are independent.
// ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
// a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
//
// <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
// The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode is used to configure a VFS
// to block for up to M milliseconds before failing when attempting to
// obtain a file lock using the xLock or xShmLock methods of the VFS.
// The parameter is a pointer to a 32-bit signed integer that contains
// the value that M is to be set to. Before returning, the 32-bit signed
// integer is overwritten with the previous value of M.
//
// <li>[[SQLITE_FCNTL_DATA_VERSION]]
// The [SQLITE_FCNTL_DATA_VERSION] opcode is used to detect changes to
// a database file.  The argument is a pointer to a 32-bit unsigned integer.
// The "data version" for the pager is written into the pointer.  The
// "data version" changes whenever any change occurs to the corresponding
// database file, either through SQL statements on the same database
// connection or through transactions committed by separate database
// connections possibly in other processes. The [sqlite3_total_changes()]
// interface can be used to find if any database on the connection has changed,
// but that interface responds to changes on TEMP as well as MAIN and does
// not provide a mechanism to detect changes to MAIN only.  Also, the
// [sqlite3_total_changes()] interface responds to internal changes only and
// omits changes made by other database connections.  The
// [PRAGMA data_version] command provides a mechanism to detect changes to
// a single attached database that occur due to other database connections,
// but omits changes implemented by the database connection on which it is
// called.  This file control is the only mechanism to detect changes that
// happen either internally or externally and that are associated with
// a particular attached database.
//
// <li>[[SQLITE_FCNTL_CKPT_START]]
// The [SQLITE_FCNTL_CKPT_START] opcode is invoked from within a checkpoint
// in wal mode before the client starts to copy pages from the wal
// file to the database file.
//
// <li>[[SQLITE_FCNTL_CKPT_DONE]]
// The [SQLITE_FCNTL_CKPT_DONE] opcode is invoked from within a checkpoint
// in wal mode after the client has finished copying pages from the wal
// file to the database file, but before the *-shm file is updated to
// record the fact that the pages have been checkpointed.
// </ul>
//
// <li>[[SQLITE_FCNTL_EXTERNAL_READER]]
// The EXPERIMENTAL [SQLITE_FCNTL_EXTERNAL_READER] opcode is used to detect
// whether or not there is a database client in another process with a wal-mode
// transaction open on the database or not. It is only available on unix.The
// (void*) argument passed with this file-control should be a pointer to a
// value of type (int). The integer value is set to 1 if the database is a wal
// mode database and there exists at least one client in another process that
// currently has an SQL transaction open on the database. It is set to 0 if
// the database is not a wal-mode db, or if there is no such connection in any
// other process. This opcode cannot be used to detect transactions opened
// by clients within the current process, only within other processes.
// </ul>
//
// <li>[[SQLITE_FCNTL_CKSM_FILE]]
// Used by the cksmvfs VFS module only.
// </ul>

// deprecated names

// CAPI3REF: Mutex Handle
//
// The mutex module within SQLite defines [sqlite3_mutex] to be an
// abstract type for a mutex object.  The SQLite core never looks
// at the internal representation of an [sqlite3_mutex].  It only
// deals with pointers to the [sqlite3_mutex] object.
//
// Mutexes are created using [sqlite3_mutex_alloc()].
type sqlite3_mutex = sqlite3_mutex1 /* sqlite3.h:1244:30 */

var aName = [15]uintptr{
	ts + 35575 /* "fast" */, ts + 35580 /* "recursive" */, ts + 35590 /* "static_main" */, ts + 35602, /* "static_mem" */
	ts + 35613 /* "static_open" */, ts + 35625 /* "static_prng" */, ts + 35637 /* "static_lru" */, ts + 35648, /* "static_pmem" */
	ts + 35660 /* "static_app1" */, ts + 35672 /* "static_app2" */, ts + 35684 /* "static_app3" */, ts + 35696, /* "static_vfs1" */
	ts + 35708 /* "static_vfs2" */, ts + 35720 /* "static_vfs3" */, uintptr(0),
} /* test_mutex.c:32:19 */

// State variables
type test_mutex_globals = struct {
	FisInstalled int32
	FdisableInit int32
	FdisableTry  int32
	FisInit      int32
	Fm           sqlite3_mutex_methods
	FaCounter    [14]int32
	FaStatic     [12]sqlite3_mutex
} /* test_mutex.c:46:8 */

// State variables
var g3 = test_mutex_globals{} /* test_mutex.c:54:3 */

// Return true if the countable mutex is currently held
func counterMutexHeld(tls *libc.TLS, p uintptr) int32 { /* test_mutex.c:57:12: */
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexHeld})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Return true if the countable mutex is not currently held
func counterMutexNotheld(tls *libc.TLS, p uintptr) int32 { /* test_mutex.c:62:12: */
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexNotheld})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Initialize the countable mutex interface
// Or, if g.disableInit is non-zero, then do not initialize but instead
// return the value of g.disableInit as the result code.  This can be used
// to simulate an initialization failure.
func counterMutexInit(tls *libc.TLS) int32 { /* test_mutex.c:71:12: */
	var rc int32
	if g3.FdisableInit != 0 {
		return g3.FdisableInit
	}
	rc = (*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexInit})).f(tls)
	g3.FisInit = 1
	return rc
}

// Uninitialize the mutex subsystem
func counterMutexEnd(tls *libc.TLS) int32 { /* test_mutex.c:82:12: */
	g3.FisInit = 0
	return (*struct{ f func(*libc.TLS) int32 })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexEnd})).f(tls)
}

// Allocate a countable mutex
func counterMutexAlloc(tls *libc.TLS, eType int32) uintptr { /* test_mutex.c:90:22: */
	var pReal uintptr
	var pRet uintptr = uintptr(0)

	pReal = (*struct {
		f func(*libc.TLS, int32) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexAlloc})).f(tls, eType)
	if !(pReal != 0) {
		return uintptr(0)
	}

	if eType == SQLITE_MUTEX_FAST || eType == SQLITE_MUTEX_RECURSIVE {
		pRet = libc.Xmalloc(tls, uint64(unsafe.Sizeof(sqlite3_mutex{})))
	} else {
		var eStaticType int32 = eType - (SQLITE_MUTEX_STATIC_VFS3 + 1 - (SQLITE_MUTEX_STATIC_VFS3 + 1 - (SQLITE_MUTEX_RECURSIVE + 1)))

		pRet = uintptr(unsafe.Pointer(&g3)) + 144 + uintptr(eStaticType)*16
	}

	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FeType = eType
	(*sqlite3_mutex)(unsafe.Pointer(pRet)).FpReal = pReal
	return pRet
}

// Free a countable mutex
func counterMutexFree(tls *libc.TLS, p uintptr) { /* test_mutex.c:118:13: */

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexFree})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
	if (*sqlite3_mutex)(unsafe.Pointer(p)).FeType == SQLITE_MUTEX_FAST || (*sqlite3_mutex)(unsafe.Pointer(p)).FeType == SQLITE_MUTEX_RECURSIVE {
		libc.Xfree(tls, p)
	}
}

// Enter a countable mutex.  Block until entry is safe.
func counterMutexEnter(tls *libc.TLS, p uintptr) { /* test_mutex.c:129:13: */

	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 88 + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexEnter})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Try to enter a mutex.  Return true on success.
func counterMutexTry(tls *libc.TLS, p uintptr) int32 { /* test_mutex.c:140:12: */

	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 88 + uintptr((*sqlite3_mutex)(unsafe.Pointer(p)).FeType)*4))++
	if g3.FdisableTry != 0 {
		return SQLITE_BUSY
	}
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexTry})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// Leave a mutex
func counterMutexLeave(tls *libc.TLS, p uintptr) { /* test_mutex.c:151:13: */

	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{g3.Fm.FxMutexLeave})).f(tls, (*sqlite3_mutex)(unsafe.Pointer(p)).FpReal)
}

// sqlite3_shutdown
func test_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:159:26: */
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// sqlite3_initialize
func test_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:180:26: */
	var rc int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_initialize(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// install_mutex_counters BOOLEAN
func test_install_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:201:26: */
	bp := tls.Alloc(136)
	defer tls.Free(136)

	var rc int32 = SQLITE_OK
	// var isInstall int32 at bp+56, 4

	*(*sqlite3_mutex_methods)(unsafe.Pointer(bp + 64 /* counter_methods */)) = sqlite3_mutex_methods{
		FxMutexInit: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{counterMutexInit})),
		FxMutexEnd:  *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{counterMutexEnd})),
		FxMutexAlloc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, int32) uintptr
		}{counterMutexAlloc})),
		FxMutexFree:  *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexFree})),
		FxMutexEnter: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexEnter})),
		FxMutexTry: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexTry})),
		FxMutexLeave: *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{counterMutexLeave})),
		FxMutexHeld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexHeld})),
		FxMutexNotheld: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr) int32
		}{counterMutexNotheld})),
	}

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+18974 /* "BOOLEAN" */)
		return TCL_ERROR
	}
	if TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+56) {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 56)) == g3.FisInstalled {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+35732 /* "mutex counters a..." */, 0))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, func() uintptr {
			if *(*int32)(unsafe.Pointer(bp + 56)) != 0 {
				return ts + 35752 /* "already installe..." */
			}
			return ts + 35770 /* "not installed" */
		}(), 0))
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 56)) != 0 {

		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETMUTEX, libc.VaList(bp+32, uintptr(unsafe.Pointer(&g3))+16))
		if rc == SQLITE_OK {
			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+40, bp+64 /* &counter_methods */))
		}
		g3.FdisableTry = 0
	} else {

		rc = sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_MUTEX, libc.VaList(bp+48, uintptr(unsafe.Pointer(&g3))+16))
		libc.Xmemset(tls, uintptr(unsafe.Pointer(&g3))+16, 0, uint64(unsafe.Sizeof(sqlite3_mutex_methods{})))
	}

	if rc == SQLITE_OK {
		g3.FisInstalled = *(*int32)(unsafe.Pointer(bp + 56 /* isInstall */))
	}

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

// read_mutex_counters
func test_read_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:262:26: */
	var pRet uintptr
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	pRet = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pRet)).FrefCount++
	for ii = 0; ii < SQLITE_MUTEX_STATIC_VFS3+1; ii++ {
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewStringObj(tls, aName[ii], -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pRet, tcl.XTcl_NewIntObj(tls, *(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 88 + uintptr(ii)*4))))
	}
	tcl.XTcl_SetObjResult(tls, interp, pRet)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pRet
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return TCL_OK
}

// clear_mutex_counters
func test_clear_mutex_counters(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:291:26: */
	var ii int32

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	for ii = 0; ii < SQLITE_MUTEX_STATIC_VFS3+1; ii++ {
		*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&g3)) + 88 + uintptr(ii)*4)) = 0
	}
	return TCL_OK
}

// Create and free a mutex.  Return the mutex pointer.  The pointer
// will be invalid since the mutex has already been freed.  The
// return pointer just checks to see if the mutex really was allocated.
func test_alloc_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:315:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var p uintptr = sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_FAST)
	// var zBuf [100]int8 at bp+24, 100

	sqlite3.Xsqlite3_mutex_free(tls, p)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([100]int8{})), bp+24 /* &zBuf[0] */, ts+10721 /* "%p" */, libc.VaList(bp, p))
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+8, bp+24 /* &zBuf[0] */, uintptr(0)))
	return TCL_OK
}

// sqlite3_config OPTION
//
// OPTION can be either one of the keywords:
//
//            SQLITE_CONFIG_SINGLETHREAD
//            SQLITE_CONFIG_MULTITHREAD
//            SQLITE_CONFIG_SERIALIZED
//
// Or OPTION can be an raw integer.
func test_config(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:342:26: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	*(*[4]ConfigOption)(unsafe.Pointer(bp /* aOpt */)) = [4]ConfigOption{
		{FzName: ts + 35784 /* "singlethread" */, FiValue: SQLITE_CONFIG_SINGLETHREAD},
		{FzName: ts + 35797 /* "multithread" */, FiValue: SQLITE_CONFIG_MULTITHREAD},
		{FzName: ts + 35809 /* "serialized" */, FiValue: SQLITE_CONFIG_SERIALIZED},
		{},
	}
	var s int32 = int32(unsafe.Sizeof(ConfigOption{}))
	// var i int32 at bp+64, 4

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp, s, ts+18367, 0, bp+64) != 0 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+64) != 0 {
			return TCL_ERROR
		}
	} else {
		*(*int32)(unsafe.Pointer(bp + 64 /* i */)) = (*ConfigOption)(unsafe.Pointer(bp /* &aOpt */ + uintptr(*(*int32)(unsafe.Pointer(bp + 64 /* i */)))*16)).FiValue
	}

	rc = sqlite3.Xsqlite3_config(tls, *(*int32)(unsafe.Pointer(bp + 64 /* i */)), 0)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(1))
	return TCL_OK
}

type ConfigOption = struct {
	FzName       uintptr
	FiValue      int32
	F__ccgo_pad1 [4]byte
} /* test_mutex.c:348:3 */

func getDbPointer1(tls *libc.TLS, pInterp uintptr, pObj uintptr) uintptr { /* test_mutex.c:379:16: */
	bp := tls.Alloc(64)
	defer tls.Free(64)

	var db uintptr
	// var info Tcl_CmdInfo at bp, 64

	var zCmd uintptr = tcl.XTcl_GetString(tls, pObj)
	if tcl.XTcl_GetCommandInfo(tls, pInterp, zCmd, bp) != 0 {
		db = *(*uintptr)(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp)).FobjClientData))
	} else {
		db = sqlite3TestTextToPtr(tls, zCmd)
	}

	return db
}

func getStaticMutexPointer(tls *libc.TLS, pInterp uintptr, pObj uintptr) uintptr { /* test_mutex.c:392:22: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var iMutex int32 at bp, 4

	if tcl.XTcl_GetIndexFromObjStruct(tls, pInterp, pObj, uintptr(unsafe.Pointer(&aName)), int32(unsafe.Sizeof(uintptr(0))), ts+35820, 0, bp) != 0 {
		return uintptr(0)
	}

	return counterMutexAlloc(tls, *(*int32)(unsafe.Pointer(bp /* iMutex */)))
}

func test_enter_static_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:404:26: */
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10594 /* "NAME" */)
		return TCL_ERROR
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(pMutex != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, pMutex)
	return TCL_OK
}

func test_leave_static_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:423:26: */
	var pMutex uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+10594 /* "NAME" */)
		return TCL_ERROR
	}
	pMutex = getStaticMutexPointer(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(pMutex != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, pMutex)
	return TCL_OK
}

func test_enter_db_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:442:26: */
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	db = getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(db != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_enter(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return TCL_OK
}

func test_leave_db_mutex(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_mutex.c:461:26: */
	var db uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	db = getDbPointer1(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if !(db != 0) {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_mutex_leave(tls, sqlite3.Xsqlite3_db_mutex(tls, db))
	return TCL_OK
}

func Sqlitetest_mutex_Init(tls *libc.TLS, interp uintptr) int32 { /* test_mutex.c:480:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd8))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd8[i].FzName, aCmd8[i].FxProc, uintptr(0), uintptr(0))
	}

	tcl.XTcl_LinkVar(tls, interp, ts+35831, /* "disable_mutex_in..." */
		uintptr(unsafe.Pointer(&g3))+4, TCL_LINK_INT)
	tcl.XTcl_LinkVar(tls, interp, ts+35850, /* "disable_mutex_tr..." */
		uintptr(unsafe.Pointer(&g3))+8, TCL_LINK_INT)
	return SQLITE_OK
}

var aCmd8 = [11]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 35868 /* "sqlite3_shutdown" */, FxProc: 0},
	{FzName: ts + 35885 /* "sqlite3_initiali..." */, FxProc: 0},
	{FzName: ts + 35904 /* "sqlite3_config" */, FxProc: 0},

	{FzName: ts + 35919 /* "enter_static_mut..." */, FxProc: 0},
	{FzName: ts + 35938 /* "leave_static_mut..." */, FxProc: 0},

	{FzName: ts + 35957 /* "enter_db_mutex" */, FxProc: 0},
	{FzName: ts + 35972 /* "leave_db_mutex" */, FxProc: 0},

	{FzName: ts + 35987 /* "alloc_dealloc_mu..." */, FxProc: 0},
	{FzName: ts + 36007 /* "install_mutex_co..." */, FxProc: 0},
	{FzName: ts + 36030 /* "read_mutex_count..." */, FxProc: 0},
	{FzName: ts + 36050 /* "clear_mutex_coun..." */, FxProc: 0},
} /* test_mutex.c:484:5 */

// Maximum pathname length supported by the fs backend.

// Name used to identify this VFS.

type fs_real_file1 = struct {
	FpFile     uintptr
	FzName     uintptr
	FnDatabase int32
	FnJournal  int32
	FnBlob     int32
	FnRef      int32
	FpNext     uintptr
	FppThis    uintptr
} /* test_onefile.c:97:9 */

// Maximum pathname length supported by the fs backend.

// Name used to identify this VFS.

type fs_real_file = fs_real_file1 /* test_onefile.c:97:29 */

type fs_file1 = struct {
	Fbase        sqlite3_file
	FeType       int32
	F__ccgo_pad1 [4]byte
	FpReal       uintptr
} /* test_onefile.c:109:9 */

type fs_file = fs_file1 /* test_onefile.c:109:24 */

type tmp_file1 = struct {
	Fbase   sqlite3_file
	FnSize  int32
	FnAlloc int32
	FzAlloc uintptr
} /* test_onefile.c:116:9 */

type tmp_file = tmp_file1 /* test_onefile.c:116:25 */

type fs_vfs_t1 = struct {
	Fbase      sqlite3_vfs
	FpFileList uintptr
	FpParent   uintptr
} /* test_onefile.c:176:9 */

type fs_vfs_t = fs_vfs_t1 /* test_onefile.c:176:25 */

var fs_vfs = fs_vfs_t{
	Fbase: sqlite3_vfs{
		FiVersion:      1,          // pNext
		FzName:         ts + 31605, /* "fs" */ // pAppData
		FxOpen:         0,          // xOpen
		FxDelete:       0,          // xDelete
		FxAccess:       0,          // xAccess
		FxFullPathname: 0,          // xFullPathname
		FxDlOpen:       0,          // xDlOpen
		FxDlError:      0,          // xDlError
		FxDlSym:        0,          // xDlSym
		FxDlClose:      0,          // xDlClose
		FxRandomness:   0,          // xRandomness
		FxSleep:        0,          // xSleep
		FxCurrentTime:  0,          // xCurrentTimeInt64
	}, // pParent
} /* test_onefile.c:183:17 */

var fs_io_methods = sqlite3_io_methods{
	FiVersion:               1, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xShmUnmap
} /* test_onefile.c:208:27 */

var tmp_io_methods = sqlite3_io_methods{
	FiVersion:               1, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xShmUnmap
} /* test_onefile.c:229:27 */

// Useful macros used in several places

// Close a tmp-file.
func tmpClose(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:257:12: */
	var pTmp uintptr = pFile
	sqlite3.Xsqlite3_free(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc)
	return SQLITE_OK
}

// Read data from a tmp-file.
func tmpRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:266:12: */
	var pTmp uintptr = pFile
	if sqlite_int64(iAmt)+iOfst > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) {
		return SQLITE_IOERR | int32(2)<<8
	}
	libc.Xmemcpy(tls, zBuf, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc+uintptr(iOfst), uint64(iAmt))
	return SQLITE_OK
}

// Write data to a tmp-file.
func tmpWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:283:12: */
	var pTmp uintptr = pFile
	if sqlite_int64(iAmt)+iOfst > sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc) {
		var nNew int32 = int32(int64(2) * (sqlite_int64(iAmt) + iOfst + sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc)))
		var zNew uintptr = sqlite3.Xsqlite3_realloc(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc, nNew)
		if !(zNew != 0) {
			return SQLITE_NOMEM
		}
		(*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc = zNew
		(*tmp_file)(unsafe.Pointer(pTmp)).FnAlloc = nNew
	}
	libc.Xmemcpy(tls, (*tmp_file)(unsafe.Pointer(pTmp)).FzAlloc+uintptr(iOfst), zBuf, uint64(iAmt))
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) > iOfst+sqlite_int64(iAmt) {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return int32(iOfst + sqlite_int64(iAmt))
	}()
	return SQLITE_OK
}

// Truncate a tmp-file.
func tmpTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_onefile.c:307:12: */
	var pTmp uintptr = pFile
	(*tmp_file)(unsafe.Pointer(pTmp)).FnSize = func() int32 {
		if sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize) < size {
			return (*tmp_file)(unsafe.Pointer(pTmp)).FnSize
		}
		return int32(size)
	}()
	return SQLITE_OK
}

// Sync a tmp-file.
func tmpSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_onefile.c:316:12: */
	return SQLITE_OK
}

// Return the current file-size of a tmp-file.
func tmpFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_onefile.c:323:12: */
	var pTmp uintptr = pFile
	*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*tmp_file)(unsafe.Pointer(pTmp)).FnSize)
	return SQLITE_OK
}

// Lock a tmp-file.
func tmpLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:332:12: */
	return SQLITE_OK
}

// Unlock a tmp-file.
func tmpUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:339:12: */
	return SQLITE_OK
}

// Check if another file-handle holds a RESERVED lock on a tmp-file.
func tmpCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_onefile.c:346:12: */
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return SQLITE_OK
}

// File control method. For custom operations on a tmp-file.
func tmpFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_onefile.c:354:12: */
	return SQLITE_OK
}

// Return the sector-size in bytes for a tmp-file.
func tmpSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:361:12: */
	return 0
}

// Return the device characteristic flags supported by a tmp-file.
func tmpDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:368:12: */
	return 0
}

// Close an fs-file.
func fsClose1(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:375:12: */
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal

	// Decrement the real_file ref-count.
	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef--

	// When the ref-count reaches 0, destroy the structure
	if (*fs_real_file)(unsafe.Pointer(pReal)).FnRef == 0 {
		*(*uintptr)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FppThis)) = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
		if (*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0 {
			(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = (*fs_real_file)(unsafe.Pointer(pReal)).FppThis
		}
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods)).FxClose})).f(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
		sqlite3.Xsqlite3_free(tls, pReal)
	}

	return rc
}

// Read data from an fs-file.
func fsRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:400:12: */
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE && sqlite_int64(iAmt)+iOfst > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) ||
		(*fs_file)(unsafe.Pointer(p)).FeType == JOURNAL_FILE && sqlite_int64(iAmt)+iOfst > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) {
		rc = SQLITE_IOERR | int32(2)<<8
	} else if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxRead})).f(tls, pF, zBuf, iAmt, iOfst+int64(BLOCKSIZE))
	} else {
		// Journal file.
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for iRem > 0 && rc == SQLITE_OK {
			var iRealOff int32 = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - BLOCKSIZE*(ii/BLOCKSIZE+1) + ii%BLOCKSIZE
			var iRealAmt int32 = func() int32 {
				if iRem < BLOCKSIZE-iRealOff%BLOCKSIZE {
					return iRem
				}
				return BLOCKSIZE - iRealOff%BLOCKSIZE
			}()

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxRead})).f(tls, pF, zBuf+uintptr(iBuf), iRealAmt, int64(iRealOff))
			ii = ii + iRealAmt
			iBuf = iBuf + iRealAmt
			iRem = iRem - iRealAmt
		}
	}

	return rc
}

// Write data to an fs-file.
func fsWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_onefile.c:439:12: */
	var rc int32 = SQLITE_OK
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pF uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		if sqlite_int64(iAmt)+iOfst+int64(BLOCKSIZE) > sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob-(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) {
			rc = SQLITE_FULL
		} else {
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxWrite})).f(tls, pF, zBuf, iAmt, iOfst+int64(BLOCKSIZE))
			if rc == SQLITE_OK {
				(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
					if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) > sqlite_int64(iAmt)+iOfst {
						return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
					}
					return int32(sqlite_int64(iAmt) + iOfst)
				}()
			}
		}
	} else {
		// Journal file.
		var iRem int32 = iAmt
		var iBuf int32 = 0
		var ii int32 = int32(iOfst)
		for iRem > 0 && rc == SQLITE_OK {
			var iRealOff int32 = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob - BLOCKSIZE*(ii/BLOCKSIZE+1) + ii%BLOCKSIZE
			var iRealAmt int32 = func() int32 {
				if iRem < BLOCKSIZE-iRealOff%BLOCKSIZE {
					return iRem
				}
				return BLOCKSIZE - iRealOff%BLOCKSIZE
			}()

			if iRealOff < (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase+BLOCKSIZE {
				rc = SQLITE_FULL
			} else {
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxWrite})).f(tls, pF, zBuf+uintptr(iBuf), iRealAmt, int64(iRealOff))
				ii = ii + iRealAmt
				iBuf = iBuf + iRealAmt
				iRem = iRem - iRealAmt
			}
		}
		if rc == SQLITE_OK {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
				if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) > sqlite_int64(iAmt)+iOfst {
					return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
				}
				return int32(sqlite_int64(iAmt) + iOfst)
			}()
		}
	}

	return rc
}

// Truncate an fs-file.
func fsTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_onefile.c:488:12: */
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = func() int32 {
			if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) < size {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase
			}
			return int32(size)
		}()
	} else {
		(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = func() int32 {
			if sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal) < size {
				return (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal
			}
			return int32(size)
		}()
	}
	return SQLITE_OK
}

// Sync an fs-file.
func fsSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_onefile.c:502:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	var pRealFile uintptr = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
	var rc int32 = SQLITE_OK

	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		// var zSize [4]uint8 at bp, 4

		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */)) = uint8(uint32((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase) & 0xFF000000 >> 24)
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + 1)) = uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x00FF0000 >> 16)
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + 2)) = uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x0000FF00 >> 8)
		*(*uint8)(unsafe.Pointer(bp /* &zSize[0] */ + 3)) = uint8((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase & 0x000000FF)
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxWrite})).f(tls, pRealFile, bp /* &zSize[0] */, 4, int64(0))
	}
	if rc == SQLITE_OK {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxSync})).f(tls, pRealFile, flags&libc.CplInt32(SQLITE_SYNC_DATAONLY))
	}

	return rc
}

// Return the current file-size of an fs-file.
func fsFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_onefile.c:526:12: */
	var p uintptr = pFile
	var pReal uintptr = (*fs_file)(unsafe.Pointer(p)).FpReal
	if (*fs_file)(unsafe.Pointer(p)).FeType == DATABASE_FILE {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase)
	} else {
		*(*sqlite_int64)(unsafe.Pointer(pSize)) = sqlite_int64((*fs_real_file)(unsafe.Pointer(pReal)).FnJournal)
	}
	return SQLITE_OK
}

// Lock an fs-file.
func fsLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:540:12: */
	return SQLITE_OK
}

// Unlock an fs-file.
func fsUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_onefile.c:547:12: */
	return SQLITE_OK
}

// Check if another file-handle holds a RESERVED lock on an fs-file.
func fsCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_onefile.c:554:12: */
	*(*int32)(unsafe.Pointer(pResOut)) = 0
	return SQLITE_OK
}

// File control method. For custom operations on an fs-file.
func fsFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_onefile.c:562:12: */
	if op == SQLITE_FCNTL_PRAGMA {
		return SQLITE_NOTFOUND
	}
	return SQLITE_OK
}

// Return the sector-size in bytes for an fs-file.
func fsSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:570:12: */
	return BLOCKSIZE
}

// Return the device characteristic flags supported by an fs-file.
func fsDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_onefile.c:577:12: */
	return 0
}

// Open an fs file handle.
func fsOpen1(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_onefile.c:584:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pFsVfs uintptr
	var p uintptr
	var pReal uintptr
	var eType int32
	var nName int32
	var rc int32
	var p2 uintptr
	// var zS [4]uint8 at bp+8, 4

	var real_flags int32
	// var size sqlite3_int64 at bp, 8

	var pRealFile uintptr
	var pParent uintptr
	pFsVfs = pVfs
	p = pFile
	pReal = uintptr(0)
	rc = SQLITE_OK

	if !(0 == flags&(SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_MAIN_JOURNAL)) {
		goto __1
	}
	p2 = pFile
	libc.Xmemset(tls, p2, 0, uint64(unsafe.Sizeof(tmp_file{})))
	(*tmp_file)(unsafe.Pointer(p2)).Fbase.FpMethods = uintptr(unsafe.Pointer(&tmp_io_methods))
	return SQLITE_OK
__1:
	;

	eType = func() int32 {
		if flags&SQLITE_OPEN_MAIN_DB != 0 {
			return DATABASE_FILE
		}
		return JOURNAL_FILE
	}()
	(*fs_file)(unsafe.Pointer(p)).Fbase.FpMethods = uintptr(unsafe.Pointer(&fs_io_methods))
	(*fs_file)(unsafe.Pointer(p)).FeType = eType

	nName = int32(libc.Xstrlen(tls, zName)) - func() int32 {
		if eType == JOURNAL_FILE {
			return 8
		}
		return 0
	}()
	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
__2:
	if !(pReal != 0 && libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zName, uint64(nName)) != 0) {
		goto __4
	}
	goto __3
__3:
	pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext
	goto __2
	goto __4
__4:
	;

	if !!(pReal != 0) {
		goto __5
	}
	real_flags = flags&libc.CplInt32(SQLITE_OPEN_MAIN_DB) | SQLITE_OPEN_TEMP_DB
	pParent = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpParent

	pReal = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(fs_real_file{}))+uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)))
	if !!(pReal != 0) {
		goto __6
	}
	rc = SQLITE_NOMEM
	goto open_out
__6:
	;
	libc.Xmemset(tls, pReal, 0, uint64(unsafe.Sizeof(fs_real_file{}))+uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile))
	(*fs_real_file)(unsafe.Pointer(pReal)).FzName = zName
	(*fs_real_file)(unsafe.Pointer(pReal)).FpFile = pReal + 1*48

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxOpen})).f(tls, pParent, zName, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile, real_flags, pOutFlags)
	if !(rc != SQLITE_OK) {
		goto __7
	}
	goto open_out
__7:
	;
	pRealFile = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxFileSize})).f(tls, pRealFile, bp /* &size */)
	if !(rc != SQLITE_OK) {
		goto __8
	}
	goto open_out
__8:
	;
	if !(*(*sqlite3_int64)(unsafe.Pointer(bp)) == int64(0)) {
		goto __9
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxWrite})).f(tls, pRealFile, ts+36071 /* "\x00" */, 1, int64(BLOBSIZE-1))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = BLOBSIZE
	goto __10
__9:
	(*fs_real_file)(unsafe.Pointer(pReal)).FnBlob = int32(*(*sqlite3_int64)(unsafe.Pointer(bp /* size */)))
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxRead})).f(tls, pRealFile, bp+8 /* &zS[0] */, 4, int64(0))
	(*fs_real_file)(unsafe.Pointer(pReal)).FnDatabase = int32(*(*uint8)(unsafe.Pointer(bp + 8)))<<24 + int32(*(*uint8)(unsafe.Pointer(bp + 8 + 1)))<<16 + int32(*(*uint8)(unsafe.Pointer(bp + 8 + 2)))<<8 + int32(*(*uint8)(unsafe.Pointer(bp + 8 + 3)))
	if !(rc == SQLITE_OK) {
		goto __11
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pRealFile)).FpMethods)).FxRead})).f(tls, pRealFile, bp+8 /* &zS[0] */, 4, int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob-4))
	if !(*(*uint8)(unsafe.Pointer(bp + 8)) != 0 || *(*uint8)(unsafe.Pointer(bp + 8 + 1)) != 0 || *(*uint8)(unsafe.Pointer(bp + 8 + 2)) != 0 || *(*uint8)(unsafe.Pointer(bp + 8 + 3)) != 0) {
		goto __12
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = (*fs_real_file)(unsafe.Pointer(pReal)).FnBlob
__12:
	;
__11:
	;
__10:
	;

	if !(rc == SQLITE_OK) {
		goto __13
	}
	(*fs_real_file)(unsafe.Pointer(pReal)).FpNext = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	if !((*fs_real_file)(unsafe.Pointer(pReal)).FpNext != 0) {
		goto __14
	}
	(*fs_real_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpNext)).FppThis = pReal + 32
__14:
	;
	(*fs_real_file)(unsafe.Pointer(pReal)).FppThis = pFsVfs + 168
	(*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList = pReal
__13:
	;
__5:
	;

open_out:
	if !(pReal != 0) {
		goto __15
	}
	if !(rc == SQLITE_OK) {
		goto __16
	}
	(*fs_file)(unsafe.Pointer(p)).FpReal = pReal
	(*fs_real_file)(unsafe.Pointer(pReal)).FnRef++
	goto __17
__16:
	if !((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods != 0) {
		goto __18
	}
	(*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*fs_real_file)(unsafe.Pointer(pReal)).FpFile)).FpMethods)).FxClose})).f(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FpFile)
__18:
	;
	sqlite3.Xsqlite3_free(tls, pReal)
__17:
	;
__15:
	;
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func fsDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_onefile.c:686:12: */
	var rc int32 = SQLITE_OK
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var pF uintptr
	var nName int32 = int32(libc.Xstrlen(tls, zPath)) - 8

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; pReal != 0 && libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint64(nName)) != 0; pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}
	if pReal != 0 {
		pF = (*fs_real_file)(unsafe.Pointer(pReal)).FpFile
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pF)).FpMethods)).FxWrite})).f(tls, pF, ts+36073 /* "\x00\x00\x00\x00" */, 4, int64((*fs_real_file)(unsafe.Pointer(pReal)).FnBlob-BLOCKSIZE))
		if rc == SQLITE_OK {
			(*fs_real_file)(unsafe.Pointer(pReal)).FnJournal = 0
		}
	}
	return rc
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func fsAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_onefile.c:712:12: */
	var pFsVfs uintptr = pVfs
	var pReal uintptr
	var isJournal int32 = 0
	var nName int32 = int32(libc.Xstrlen(tls, zPath))

	if flags != SQLITE_ACCESS_EXISTS {
		var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxAccess})).f(tls, pParent, zPath, flags, pResOut)
	}

	if nName > 8 && libc.Xstrcmp(tls, ts+33361, zPath+uintptr(nName-8)) == 0 {
		nName = nName - 8
		isJournal = 1
	}

	pReal = (*fs_vfs_t)(unsafe.Pointer(pFsVfs)).FpFileList
	for ; pReal != 0 && libc.Xstrncmp(tls, (*fs_real_file)(unsafe.Pointer(pReal)).FzName, zPath, uint64(nName)) != 0; pReal = (*fs_real_file)(unsafe.Pointer(pReal)).FpNext {
	}

	*(*int32)(unsafe.Pointer(pResOut)) = libc.Bool32(pReal != 0 && (!(isJournal != 0) || (*fs_real_file)(unsafe.Pointer(pReal)).FnJournal > 0))
	return SQLITE_OK
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (FS_MAX_PATHNAME+1) bytes.
func fsFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_onefile.c:746:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxFullPathname})).f(tls, pParent, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func fsDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_onefile.c:759:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlOpen})).f(tls, pParent, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func fsDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_onefile.c:769:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlError})).f(tls, pParent, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func fsDlSym(tls *libc.TLS, pVfs uintptr, pH uintptr, zSym uintptr) uintptr { /* test_onefile.c:777:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlSym})).f(tls, pParent, pH, zSym)
}

// Close the dynamic library handle pHandle.
func fsDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* test_onefile.c:785:13: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDlClose})).f(tls, pParent, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func fsRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_onefile.c:794:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxRandomness})).f(tls, pParent, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func fsSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_onefile.c:803:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxSleep})).f(tls, pParent, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func fsCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_onefile.c:811:12: */
	var pParent uintptr = (*fs_vfs_t)(unsafe.Pointer(pVfs)).FpParent
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxCurrentTime})).f(tls, pParent, pTimeOut)
}

// This procedure registers the fs vfs with SQLite. If the argument is
// true, the fs vfs becomes the new default vfs. It is the only publicly
// available function in this file.
func fs_register(tls *libc.TLS) int32 { /* test_onefile.c:821:5: */
	if fs_vfs.FpParent != 0 {
		return SQLITE_OK
	}
	fs_vfs.FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	fs_vfs.Fbase.FmxPathname = (*sqlite3_vfs)(unsafe.Pointer(fs_vfs.FpParent)).FmxPathname
	fs_vfs.Fbase.FszOsFile = func() int32 {
		if uint64(unsafe.Sizeof(tmp_file{})) > uint64(unsafe.Sizeof(fs_file{})) {
			return int32(unsafe.Sizeof(tmp_file{}))
		}
		return int32(unsafe.Sizeof(fs_file{}))
	}()
	return sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&fs_vfs)), 0)
}

func SqlitetestOnefile_Init(tls *libc.TLS) int32 { /* test_onefile.c:830:7: */
	return fs_register(tls)
}

// Maximum pathname length supported by the vfslog backend.

type VfslogVfs1 = struct {
	Fbase        sqlite3_vfs
	FpVfs        uintptr
	FiNextFileId int32
	F__ccgo_pad1 [4]byte
	FpLog        uintptr
	FiOffset     sqlite3_int64
	FnBuf        int32
	FaBuf        [8192]int8
	F__ccgo_pad2 [4]byte
} /* test_osinst.c:117:9 */

// Maximum pathname length supported by the vfslog backend.

type VfslogVfs = VfslogVfs1 /* test_osinst.c:117:26 */
type VfslogFile1 = struct {
	Fbase        sqlite3_file
	FpReal       uintptr
	FpVfslog     uintptr
	FiFileId     int32
	F__ccgo_pad1 [4]byte
} /* test_osinst.c:118:9 */

type VfslogFile = VfslogFile1 /* test_osinst.c:118:27 */

var vfslog_vfs = sqlite3_vfs{
	FiVersion:          1,                                  // iVersion
	FszOsFile:          int32(unsafe.Sizeof(VfslogFile{})), // szOsFile
	FmxPathname:        INST_MAX_PATHNAME,                  // pAppData
	FxOpen:             0,                                  // xOpen
	FxDelete:           0,                                  // xDelete
	FxAccess:           0,                                  // xAccess
	FxFullPathname:     0,                                  // xFullPathname
	FxDlOpen:           0,                                  // xDlOpen
	FxDlError:          0,                                  // xDlError
	FxDlSym:            0,                                  // xDlSym
	FxDlClose:          0,                                  // xDlClose
	FxRandomness:       0,                                  // xRandomness
	FxSleep:            0,                                  // xSleep
	FxCurrentTime:      0,                                  // xCurrentTime
	FxGetLastError:     0,                                  // xGetLastError
	FxCurrentTimeInt64: 0,                                  // xCurrentTime
} /* test_osinst.c:180:20 */

var vfslog_io_methods = sqlite3_io_methods{
	FiVersion:               2, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
} /* test_osinst.c:202:27 */

func vfslog_time(tls *libc.TLS) sqlite3_uint64 { /* test_osinst.c:224:23: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var sTime timeval at bp, 16

	libc.Xgettimeofday(tls, bp /* &sTime */, uintptr(0))
	return sqlite3_uint64((*timeval)(unsafe.Pointer(bp)).Ftv_usec) + sqlite3_uint64((*timeval)(unsafe.Pointer(bp)).Ftv_sec)*uint64(1000000)
}

// Close an vfslog-file.
func vfslogClose(tls *libc.TLS, pFile uintptr) int32 { /* test_osinst.c:256:12: */
	var t sqlite3_uint64
	var rc int32 = SQLITE_OK
	var p uintptr = pFile

	t = vfslog_time(tls)
	if (*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods != 0 {
		rc = (*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxClose})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	}
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_CLOSE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Read data from an vfslog-file.
func vfslogRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_osinst.c:273:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxRead})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, zBuf, iAmt, iOfst)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_READ, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

// Write data to an vfslog-file.
func vfslogWrite(tls *libc.TLS, pFile uintptr, z uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_osinst.c:292:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxWrite})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, z, iAmt, iOfst)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_WRITE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, iAmt, int32(iOfst))
	return rc
}

// Truncate an vfslog-file.
func vfslogTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_osinst.c:311:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxTruncate})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, size)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_TRUNCATE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(size))
	return rc
}

// Sync an vfslog-file.
func vfslogSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_osinst.c:325:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxSync})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SYNC, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, flags, 0)
	return rc
}

// Return the current file-size of an vfslog-file.
func vfslogFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_osinst.c:339:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxFileSize})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pSize)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_FILESIZE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, int32(*(*sqlite_int64)(unsafe.Pointer(pSize))))
	return rc
}

// Lock an vfslog-file.
func vfslogLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_osinst.c:353:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxLock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_LOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

// Unlock an vfslog-file.
func vfslogUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_osinst.c:367:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxUnlock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, eLock)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_UNLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, eLock, 0)
	return rc
}

// Check if another file-handle holds a RESERVED lock on an vfslog-file.
func vfslogCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_osinst.c:381:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxCheckReservedLock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, pResOut)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_CHECKRESERVEDLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, *(*int32)(unsafe.Pointer(pResOut)), 0)
	return rc
}

// File control method. For custom operations on an vfslog-file.
func vfslogFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_osinst.c:395:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pFile
	var rc int32 = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxFileControl})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, op, pArg)
	if op == SQLITE_FCNTL_VFSNAME && rc == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+36078 /* "vfslog/%z" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Return the sector-size in bytes for an vfslog-file.
func vfslogSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_osinst.c:407:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxSectorSize})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SECTORSIZE, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Return the device characteristic flags supported by an vfslog-file.
func vfslogDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_osinst.c:421:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxDeviceCharacteristics})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_DEVCHAR, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_osinst.c:432:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmLock})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, ofst, n, flags)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMLOCK, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmMap(tls *libc.TLS, pFile uintptr, iRegion int32, szRegion int32, isWrite int32, pp uintptr) int32 { /* test_osinst.c:442:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmMap})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, iRegion, szRegion, isWrite, pp)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMMAP, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

func vfslogShmBarrier(tls *libc.TLS, pFile uintptr) { /* test_osinst.c:458:13: */
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmBarrier})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMBARRIER, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), SQLITE_OK, 0, 0)
}

func vfslogShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* test_osinst.c:466:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogFile)(unsafe.Pointer(p)).FpReal)).FpMethods)).FxShmUnmap})).f(tls, (*VfslogFile)(unsafe.Pointer(p)).FpReal, deleteFlag)
	t = vfslog_time(tls) - t
	vfslog_call(tls, (*VfslogFile)(unsafe.Pointer(p)).FpVfslog, OS_SHMUNMAP, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	return rc
}

// Open an vfslog file handle.
func vfslogOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_osinst.c:481:12: */
	var rc int32
	var t sqlite3_uint64
	var p uintptr = pFile
	var pLog uintptr = pVfs

	(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = uintptr(unsafe.Pointer(&vfslog_io_methods))
	(*VfslogFile)(unsafe.Pointer(p)).FpReal = p + 1*32
	(*VfslogFile)(unsafe.Pointer(p)).FpVfslog = pVfs
	(*VfslogFile)(unsafe.Pointer(p)).FiFileId = libc.PreIncInt32(&(*VfslogVfs)(unsafe.Pointer(pLog)).FiNextFileId, 1)

	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxOpen})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zName, (*VfslogFile)(unsafe.Pointer(p)).FpReal, flags, pOutFlags)
	t = vfslog_time(tls) - t

	vfslog_call(tls, pVfs, OS_OPEN, (*VfslogFile)(unsafe.Pointer(p)).FiFileId, int64(t), rc, 0, 0)
	vfslog_string(tls, pVfs, zName)
	return rc
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func vfslogDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_osinst.c:512:12: */
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDelete})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, dirSync)
	t = vfslog_time(tls) - t
	vfslog_call(tls, pVfs, OS_DELETE, 0, int64(t), rc, dirSync, 0)
	vfslog_string(tls, pVfs, zPath)
	return rc
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func vfslogAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_osinst.c:527:12: */
	var rc int32
	var t sqlite3_uint64
	t = vfslog_time(tls)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxAccess})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, flags, pResOut)
	t = vfslog_time(tls) - t
	vfslog_call(tls, pVfs, OS_ACCESS, 0, int64(t), rc, flags, *(*int32)(unsafe.Pointer(pResOut)))
	vfslog_string(tls, pVfs, zPath)
	return rc
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (INST_MAX_PATHNAME+1) bytes.
func vfslogFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_osinst.c:548:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxFullPathname})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath, nOut, zOut)
}

// Open the dynamic library located at zPath and return a handle.
func vfslogDlOpen(tls *libc.TLS, pVfs uintptr, zPath uintptr) uintptr { /* test_osinst.c:560:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlOpen})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, zPath)
}

// Populate the buffer zErrMsg (size nByte bytes) with a human readable
// utf-8 string describing the most recent error encountered associated
// with dynamic libraries.
func vfslogDlError(tls *libc.TLS, pVfs uintptr, nByte int32, zErrMsg uintptr) { /* test_osinst.c:569:13: */
	(*struct {
		f func(*libc.TLS, uintptr, int32, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlError})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zErrMsg)
}

// Return a pointer to the symbol zSymbol in the dynamic library pHandle.
func vfslogDlSym(tls *libc.TLS, pVfs uintptr, p uintptr, zSym uintptr) uintptr { /* test_osinst.c:576:13: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlSym})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p, zSym)
}

// Close the dynamic library handle pHandle.
func vfslogDlClose(tls *libc.TLS, pVfs uintptr, pHandle uintptr) { /* test_osinst.c:583:13: */
	(*struct {
		f func(*libc.TLS, uintptr, uintptr)
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxDlClose})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pHandle)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func vfslogRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_osinst.c:591:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxRandomness})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func vfslogSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_osinst.c:599:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxSleep})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func vfslogCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_osinst.c:606:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxCurrentTime})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, pTimeOut)
}

func vfslogGetLastError(tls *libc.TLS, pVfs uintptr, a int32, b uintptr) int32 { /* test_osinst.c:610:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxGetLastError})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, a, b)
}

func vfslogCurrentTimeInt64(tls *libc.TLS, pVfs uintptr, p uintptr) int32 { /* test_osinst.c:613:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs)).FxCurrentTimeInt64})).f(tls, (*VfslogVfs)(unsafe.Pointer(pVfs)).FpVfs, p)
}

func vfslog_flush(tls *libc.TLS, p uintptr) { /* test_osinst.c:617:13: */

	var pending int32 = libc.AtomicLoadInt32(&sqlite3.Xsqlite3_io_error_pending)
	var persist int32 = sqlite3.Xsqlite3_io_error_persist
	var diskfull int32 = sqlite3.Xsqlite3_diskfull_pending

	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(0))
	sqlite3.Xsqlite3_io_error_persist = 0
	sqlite3.Xsqlite3_diskfull_pending = 0

	if (*VfslogVfs)(unsafe.Pointer(p)).FnBuf != 0 {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods)).FxWrite})).f(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, p+204 /* &.aBuf */, (*VfslogVfs)(unsafe.Pointer(p)).FnBuf, (*VfslogVfs)(unsafe.Pointer(p)).FiOffset)
		*(*sqlite3_int64)(unsafe.Pointer(p + 192)) += sqlite3_int64((*VfslogVfs)(unsafe.Pointer(p)).FnBuf)
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 0
	}

	libc.AtomicStoreInt32(&sqlite3.Xsqlite3_io_error_pending, int32(pending))
	sqlite3.Xsqlite3_io_error_persist = persist
	sqlite3.Xsqlite3_diskfull_pending = diskfull
}

func put32bits(tls *libc.TLS, p uintptr, v uint32) { /* test_osinst.c:645:13: */
	*(*uint8)(unsafe.Pointer(p)) = uint8(v >> 24)
	*(*uint8)(unsafe.Pointer(p + 1)) = uint8(v >> 16)
	*(*uint8)(unsafe.Pointer(p + 2)) = uint8(v >> 8)
	*(*uint8)(unsafe.Pointer(p + 3)) = uint8(v)
}

func vfslog_call(tls *libc.TLS, pVfs uintptr, eEvent int32, iFileid int32, nClick sqlite3_int64, return_code int32, size int32, offset int32) { /* test_osinst.c:652:13: */
	var p uintptr = pVfs
	var zRec uintptr
	if uint64(24+(*VfslogVfs)(unsafe.Pointer(p)).FnBuf) > uint64(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = p + 204 + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf)
	put32bits(tls, zRec, uint32(eEvent))
	put32bits(tls, zRec+4, uint32(iFileid))
	put32bits(tls, zRec+8, uint32(nClick&int64(0xffff)))
	put32bits(tls, zRec+12, uint32(return_code))
	put32bits(tls, zRec+16, uint32(size))
	put32bits(tls, zRec+20, uint32(offset))
	*(*int32)(unsafe.Pointer(p + 200)) += 24
}

func vfslog_string(tls *libc.TLS, pVfs uintptr, zStr uintptr) { /* test_osinst.c:676:13: */
	var p uintptr = pVfs
	var zRec uintptr
	var nStr int32
	if zStr != 0 {
		nStr = int32(libc.Xstrlen(tls, zStr))
	} else {
		nStr = 0
	}
	if uint64(4+nStr+(*VfslogVfs)(unsafe.Pointer(p)).FnBuf) > uint64(unsafe.Sizeof([8192]int8{})) {
		vfslog_flush(tls, p)
	}
	zRec = p + 204 + uintptr((*VfslogVfs)(unsafe.Pointer(p)).FnBuf)
	put32bits(tls, zRec, uint32(nStr))
	if zStr != 0 {
		libc.Xmemcpy(tls, zRec+4, zStr, uint64(nStr))
	}
	*(*int32)(unsafe.Pointer(p + 200)) += 4 + nStr
}

func vfslog_finalize(tls *libc.TLS, p uintptr) { /* test_osinst.c:691:13: */
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods != 0 {
		vfslog_flush(tls, p)
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVfs)(unsafe.Pointer(p)).FpLog)).FpMethods)).FxClose})).f(tls, (*VfslogVfs)(unsafe.Pointer(p)).FpLog)
	}
	sqlite3.Xsqlite3_free(tls, p)
}

func sqlite3_vfslog_finalize(tls *libc.TLS, zVfs uintptr) int32 { /* test_osinst.c:699:5: */
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen})) {
		return SQLITE_ERROR
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, pVfs)
	vfslog_finalize(tls, pVfs)
	return SQLITE_OK
}

func sqlite3_vfslog_new(tls *libc.TLS, zVfs uintptr, zParentVfs uintptr, zLog uintptr) int32 { /* test_osinst.c:710:5: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var pParent uintptr
	var nByte int32
	// var flags int32 at bp, 4

	var rc int32
	var zFile uintptr
	var nVfs int32

	pParent = sqlite3.Xsqlite3_vfs_find(tls, zParentVfs)
	if !(pParent != 0) {
		return SQLITE_ERROR
	}

	nVfs = int32(libc.Xstrlen(tls, zVfs))
	nByte = int32(uint64(unsafe.Sizeof(VfslogVfs{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile) + uint64(nVfs) + uint64(1) + uint64((*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname) + uint64(1))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	libc.Xmemset(tls, p, 0, uint64(nByte))

	(*VfslogVfs)(unsafe.Pointer(p)).FpVfs = pParent
	(*VfslogVfs)(unsafe.Pointer(p)).FpLog = p + 1*8400
	libc.Xmemcpy(tls, p, uintptr(unsafe.Pointer(&vfslog_vfs)), uint64(unsafe.Sizeof(sqlite3_vfs{})))
	(*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName = (*VfslogVfs)(unsafe.Pointer(p)).FpLog + uintptr((*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile)
	*(*int32)(unsafe.Pointer(p + 4)) += (*sqlite3_vfs)(unsafe.Pointer(pParent)).FszOsFile
	libc.Xmemcpy(tls, (*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName, zVfs, uint64(nVfs))

	zFile = (*VfslogVfs)(unsafe.Pointer(p)).Fbase.FzName + uintptr(nVfs+1)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxFullPathname})).f(tls, pParent, zLog, (*sqlite3_vfs)(unsafe.Pointer(pParent)).FmxPathname, zFile)

	*(*int32)(unsafe.Pointer(bp /* flags */)) = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_SUPER_JOURNAL
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxDelete})).f(tls, pParent, zFile, 0)
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pParent)).FxOpen})).f(tls, pParent, zFile, (*VfslogVfs)(unsafe.Pointer(p)).FpLog, *(*int32)(unsafe.Pointer(bp /* flags */)), bp /* &flags */)
	if rc == SQLITE_OK {
		libc.Xmemcpy(tls, p+204, ts+36088 /* "sqlite_ostrace1...." */, uint64(20))
		(*VfslogVfs)(unsafe.Pointer(p)).FiOffset = int64(0)
		(*VfslogVfs)(unsafe.Pointer(p)).FnBuf = 20
		rc = sqlite3.Xsqlite3_vfs_register(tls, p, 1)
	}
	if rc != 0 {
		vfslog_finalize(tls, p)
	}
	return rc
}

func sqlite3_vfslog_annotate(tls *libc.TLS, zVfs uintptr, zMsg uintptr) int32 { /* test_osinst.c:758:5: */
	var pVfs uintptr
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, zVfs)
	if !(pVfs != 0) || (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen != *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{vfslogOpen})) {
		return SQLITE_ERROR
	}
	vfslog_call(tls, pVfs, OS_ANNOTATE, 0, int64(0), 0, 0, 0)
	vfslog_string(tls, pVfs, zMsg)
	return SQLITE_OK
}

func vfslog_eventname(tls *libc.TLS, eEvent int32) uintptr { /* test_osinst.c:769:19: */
	var zEvent uintptr = uintptr(0)

	switch eEvent {
	case OS_CLOSE:
		zEvent = ts + 36109 /* "xClose" */
		break
	case OS_READ:
		zEvent = ts + 36116 /* "xRead" */
		break
	case OS_WRITE:
		zEvent = ts + 36122 /* "xWrite" */
		break
	case OS_TRUNCATE:
		zEvent = ts + 36129 /* "xTruncate" */
		break
	case OS_SYNC:
		zEvent = ts + 28484 /* "xSync" */
		break
	case OS_FILESIZE:
		zEvent = ts + 36139 /* "xFilesize" */
		break
	case OS_LOCK:
		zEvent = ts + 36149 /* "xLock" */
		break
	case OS_UNLOCK:
		zEvent = ts + 36155 /* "xUnlock" */
		break
	case OS_CHECKRESERVEDLOCK:
		zEvent = ts + 36163 /* "xCheckResLock" */
		break
	case OS_FILECONTROL:
		zEvent = ts + 36177 /* "xFileControl" */
		break
	case OS_SECTORSIZE:
		zEvent = ts + 36190 /* "xSectorSize" */
		break
	case OS_DEVCHAR:
		zEvent = ts + 36202 /* "xDeviceChar" */
		break
	case OS_OPEN:
		zEvent = ts + 28056 /* "xOpen" */
		break
	case OS_DELETE:
		zEvent = ts + 36214 /* "xDelete" */
		break
	case OS_ACCESS:
		zEvent = ts + 36222 /* "xAccess" */
		break
	case OS_FULLPATHNAME:
		zEvent = ts + 36230 /* "xFullPathname" */
		break
	case OS_RANDOMNESS:
		zEvent = ts + 36244 /* "xRandomness" */
		break
	case OS_SLEEP:
		zEvent = ts + 36256 /* "xSleep" */
		break
	case OS_CURRENTTIME:
		zEvent = ts + 36263 /* "xCurrentTime" */
		break

	case OS_SHMUNMAP:
		zEvent = ts + 36276 /* "xShmUnmap" */
		break
	case OS_SHMLOCK:
		zEvent = ts + 36286 /* "xShmLock" */
		break
	case OS_SHMBARRIER:
		zEvent = ts + 36295 /* "xShmBarrier" */
		break
	case OS_SHMMAP:
		zEvent = ts + 36307 /* "xShmMap" */
		break

	case OS_ANNOTATE:
		zEvent = ts + 36315 /* "annotation" */
		break
	}

	return zEvent
}

type VfslogVtab1 = struct {
	Fbase  sqlite3_vtab
	FpFd   uintptr
	FnByte sqlite3_int64
	FzFile uintptr
} /* test_osinst.c:804:9 */

type VfslogVtab = VfslogVtab1 /* test_osinst.c:804:27 */
type VfslogCsr1 = struct {
	Fbase        sqlite3_vtab_cursor
	FiRowid      sqlite3_int64
	FiOffset     sqlite3_int64
	FzTransient  uintptr
	FnFile       int32
	F__ccgo_pad1 [4]byte
	FazFile      uintptr
	FaBuf        [1024]uint8
} /* test_osinst.c:805:9 */

type VfslogCsr = VfslogCsr1 /* test_osinst.c:805:26 */

func get32bits(tls *libc.TLS, p uintptr) uint32 { /* test_osinst.c:830:21: */
	return uint32(int32(*(*uint8)(unsafe.Pointer(p)))<<24 + int32(*(*uint8)(unsafe.Pointer(p + 1)))<<16 + int32(*(*uint8)(unsafe.Pointer(p + 2)))<<8 + int32(*(*uint8)(unsafe.Pointer(p + 3))))
}

// The argument must point to a buffer containing a nul-terminated string.
// If the string begins with an SQL quote character it is overwritten by
// the dequoted version. Otherwise the buffer is left unmodified.
func dequote(tls *libc.TLS, z uintptr) { /* test_osinst.c:839:13: */
	var quote int8 // Quote character (if any )
	quote = *(*int8)(unsafe.Pointer(z))
	if int32(quote) == '[' || int32(quote) == '\'' || int32(quote) == '"' || int32(quote) == '`' {
		var iIn int32 = 1  // Index of next byte to read from input
		var iOut int32 = 0 // Index of next byte to write to output
		if int32(quote) == '[' {
			quote = int8(']')
		}
		for *(*int8)(unsafe.Pointer(z + uintptr(iIn))) != 0 {
			if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn)))) == int32(quote) {
				if int32(*(*int8)(unsafe.Pointer(z + uintptr(iIn+1)))) != int32(quote) {
					break
				}
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = quote
				iIn = iIn + 2
			} else {
				*(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iOut, 1)))) = *(*int8)(unsafe.Pointer(z + uintptr(libc.PostIncInt32(&iIn, 1))))
			}
		}
		*(*int8)(unsafe.Pointer(z + uintptr(iOut))) = int8(0)
	}
}

// Connect to or create a vfslog virtual table.
func vlogConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_osinst.c:863:12: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var pVfs uintptr // VFS used to read log file
	// var flags int32 at bp+8, 4
	// flags passed to pVfs->xOpen()
	var p uintptr
	var rc int32
	var nByte int32
	var zFile uintptr

	*(*uintptr)(unsafe.Pointer(ppVtab)) = uintptr(0)
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	nByte = int32(uint64(unsafe.Sizeof(VfslogVtab{})) + uint64((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile) + uint64((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname))
	p = sqlite3.Xsqlite3_malloc(tls, nByte)
	if p == uintptr(0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, p, 0, uint64(nByte))

	(*VfslogVtab)(unsafe.Pointer(p)).FpFd = p + 1*48
	(*VfslogVtab)(unsafe.Pointer(p)).FzFile = (*VfslogVtab)(unsafe.Pointer(p)).FpFd + uintptr((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile)

	zFile = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(argv + 3*8))))
	if !(zFile != 0) {
		sqlite3.Xsqlite3_free(tls, p)
		return SQLITE_NOMEM
	}
	dequote(tls, zFile)
	(*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxFullPathname})).f(tls, pVfs, zFile, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname, (*VfslogVtab)(unsafe.Pointer(p)).FzFile)
	sqlite3.Xsqlite3_free(tls, zFile)

	*(*int32)(unsafe.Pointer(bp + 8 /* flags */)) = SQLITE_OPEN_READWRITE | SQLITE_OPEN_SUPER_JOURNAL
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxOpen})).f(tls, pVfs, (*VfslogVtab)(unsafe.Pointer(p)).FzFile, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, *(*int32)(unsafe.Pointer(bp + 8 /* flags */)), bp+8 /* &flags */)

	if rc == SQLITE_OK {
		(*struct {
			f func(*libc.TLS, uintptr, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxFileSize})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, p+32 /* &.nByte */)
		sqlite3.Xsqlite3_declare_vtab(tls, db,
			ts+36326 /* "CREATE TABLE xxx..." */)
		*(*uintptr)(unsafe.Pointer(ppVtab)) = p
	} else {
		sqlite3.Xsqlite3_free(tls, p)
	}

	return rc
}

// There is no "best-index". This virtual table always does a linear
// scan of the binary VFS log file.
func vlogBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_osinst.c:916:12: */
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FestimatedCost = 10.0
	return SQLITE_OK
}

// Disconnect from or destroy a vfslog virtual table.
func vlogDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_osinst.c:924:12: */
	var p uintptr = pVtab
	if (*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods != 0 {
		(*struct {
			f func(*libc.TLS, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxClose})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd)
		(*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods = uintptr(0)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Open a new vfslog cursor.
func vlogOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_osinst.c:937:12: */
	var pCsr uintptr // Newly allocated cursor object

	pCsr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(VfslogCsr{})))
	if !(pCsr != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pCsr, 0, uint64(unsafe.Sizeof(VfslogCsr{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCsr
	return SQLITE_OK
}

// Close a vfslog cursor.
func vlogClose(tls *libc.TLS, pCursor uintptr) int32 { /* test_osinst.c:950:12: */
	var p uintptr = pCursor
	var i int32
	for i = 0; i < (*VfslogCsr)(unsafe.Pointer(p)).FnFile; i++ {
		sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(p)).FazFile + uintptr(i)*8)))
	}
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FazFile)
	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(p)).FzTransient)
	sqlite3.Xsqlite3_free(tls, p)
	return SQLITE_OK
}

// Move a vfslog cursor to the next entry in the file.
func vlogNext(tls *libc.TLS, pCursor uintptr) int32 { /* test_osinst.c:965:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	var rc int32 = SQLITE_OK
	var nRead int32

	sqlite3.Xsqlite3_free(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = uintptr(0)

	nRead = 24
	if (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset+sqlite3_int64(nRead) <= (*VfslogVtab)(unsafe.Pointer(p)).FnByte {
		var eEvent int32
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxRead})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, pCsr+48 /* &.aBuf */, nRead, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset)

		eEvent = int32(get32bits(tls, pCsr+48))
		if rc == SQLITE_OK &&
			(eEvent == OS_OPEN || eEvent == OS_DELETE || eEvent == OS_ACCESS) {
			// var buf [4]int8 at bp, 4

			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxRead})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, bp /* &buf[0] */, 4, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset+sqlite3_int64(nRead))
			nRead = nRead + 4
			if rc == SQLITE_OK {
				var nStr int32 = int32(get32bits(tls, bp /* buf */))
				var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, nStr+1)
				rc = (*struct {
					f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*VfslogVtab)(unsafe.Pointer(p)).FpFd)).FpMethods)).FxRead})).f(tls, (*VfslogVtab)(unsafe.Pointer(p)).FpFd, zStr, nStr, (*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset+sqlite3_int64(nRead))
				*(*int8)(unsafe.Pointer(zStr + uintptr(nStr))) = int8(0)
				nRead = nRead + nStr

				if eEvent == OS_OPEN {
					var iFileid int32 = int32(get32bits(tls, pCsr+48+4))
					if iFileid >= (*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile {
						var nNew int32 = int32(uint64(unsafe.Sizeof(uintptr(0))) * uint64(iFileid+1))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile = sqlite3.Xsqlite3_realloc(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile, nNew)
						nNew = int32(uint64(nNew) - uint64(unsafe.Sizeof(uintptr(0)))*uint64((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile))
						libc.Xmemset(tls, (*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile+uintptr((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile)*8, 0, uint64(nNew))
						(*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile = iFileid + 1
					}
					sqlite3.Xsqlite3_free(tls, *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*8)))
					*(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(iFileid)*8)) = zStr
				} else {
					(*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient = zStr
				}
			}
		}
	}

	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 8)) += int64(1)
	*(*sqlite3_int64)(unsafe.Pointer(pCsr + 16)) += sqlite3_int64(nRead)
	return rc
}

func vlogEof(tls *libc.TLS, pCursor uintptr) int32 { /* test_osinst.c:1016:12: */
	var pCsr uintptr = pCursor
	var p uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pCursor)).FpVtab
	return libc.Bool32((*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset >= (*VfslogVtab)(unsafe.Pointer(p)).FnByte)
}

func vlogFilter(tls *libc.TLS, pCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_osinst.c:1022:12: */
	var pCsr uintptr = pCursor
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid = int64(0)
	(*VfslogCsr)(unsafe.Pointer(pCsr)).FiOffset = int64(20)
	return vlogNext(tls, pCursor)
}

func vlogColumn(tls *libc.TLS, pCursor uintptr, ctx uintptr, i int32) int32 { /* test_osinst.c:1033:12: */
	var val uint32
	var pCsr uintptr = pCursor

	val = get32bits(tls, pCsr+48+uintptr(4*i))

	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, vfslog_eventname(tls, int32(val)), -1, uintptr(0))
			break

		}
	case 1:
		{
			var zStr uintptr = (*VfslogCsr)(unsafe.Pointer(pCsr)).FzTransient
			if val != uint32(0) && val < uint32((*VfslogCsr)(unsafe.Pointer(pCsr)).FnFile) {
				zStr = *(*uintptr)(unsafe.Pointer((*VfslogCsr)(unsafe.Pointer(pCsr)).FazFile + uintptr(val)*8))
			}
			sqlite3.Xsqlite3_result_text(tls, ctx, zStr, -1, libc.UintptrFromInt32(-1))
			break

		}
	default:
		sqlite3.Xsqlite3_result_int(tls, ctx, int32(val))
		break
	}

	return SQLITE_OK
}

func vlogRowid(tls *libc.TLS, pCursor uintptr, pRowid uintptr) int32 { /* test_osinst.c:1065:12: */
	var pCsr uintptr = pCursor
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = (*VfslogCsr)(unsafe.Pointer(pCsr)).FiRowid
	return SQLITE_OK
}

func sqlite3_vfslog_register(tls *libc.TLS, db uintptr) int32 { /* test_osinst.c:1071:5: */

	sqlite3.Xsqlite3_create_module(tls, db, ts+36381 /* "vfslog" */, uintptr(unsafe.Pointer(&vfslog_module)), uintptr(0))
	return SQLITE_OK
}

var vfslog_module = sqlite3_module{ // iVersion
	FxCreate:     0, // xCreate
	FxConnect:    0, // xConnect
	FxBestIndex:  0, // xBestIndex
	FxDisconnect: 0, // xDisconnect
	FxDestroy:    0, // xDestroy
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_osinst.c:1072:25 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func test_vfslog(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_osinst.c:1116:26: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	var db uintptr
	// var cmdInfo Tcl_CmdInfo at bp+80, 64

	var rc int32 = SQLITE_ERROR
	// var iSub int32 at bp+72, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33535 /* "SUB-COMMAND ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), uintptr(unsafe.Pointer(&strs)), int32(unsafe.Sizeof(uintptr(0))), ts+2014, 0, bp+72) != 0 {
		return TCL_ERROR
	}

	switch uint32(*(*int32)(unsafe.Pointer(bp + 72 /* iSub */))) {
	case uint32(0) /* VL_ANNOTATE */ :
		{
			var zVfs uintptr
			var zMsg uintptr
			if objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 3, objv, ts+36388 /* "VFS" */)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			zMsg = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
			rc = sqlite3_vfslog_annotate(tls, zVfs, zMsg)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+36392 /* "failed" */, 0))
				return TCL_ERROR
			}
			break

		}
	case uint32(1) /* VL_FINALIZE */ :
		{
			var zVfs uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+36388 /* "VFS" */)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			rc = sqlite3_vfslog_finalize(tls, zVfs)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+16, ts+36392 /* "failed" */, 0))
				return TCL_ERROR
			}
			break

		}

	case uint32(2) /* VL_NEW */ :
		{
			var zVfs uintptr
			var zParent uintptr
			var zLog uintptr
			if objc != 5 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+36399 /* "VFS PARENT LOGFI..." */)
				return TCL_ERROR
			}
			zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			zParent = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
			zLog = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))
			if int32(*(*int8)(unsafe.Pointer(zParent))) == 0 {
				zParent = uintptr(0)
			}
			rc = sqlite3_vfslog_new(tls, zVfs, zParent, zLog)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+32, ts+36392 /* "failed" */, 0))
				return TCL_ERROR
			}
			break

		}

	case uint32(3) /* VL_REGISTER */ :
		{
			var zDb uintptr
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+2050 /* "DB" */)
				return TCL_ERROR
			}
			zDb = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
			if tcl.XTcl_GetCommandInfo(tls, interp, zDb, bp+80) != 0 {
				db = (*struct{ Fdb uintptr })(unsafe.Pointer((*Tcl_CmdInfo)(unsafe.Pointer(bp + 80)).FobjClientData)).Fdb
				rc = sqlite3_vfslog_register(tls, db)
			}
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+36418 /* "bad sqlite3 hand..." */, zDb, uintptr(0)))
				return TCL_ERROR
			}
			break

		}
	}

	return TCL_OK
}

var strs = [5]uintptr{ts + 36439 /* "annotate" */, ts + 36448 /* "finalize" */, ts + 14836 /* "new" */, ts + 36457 /* "register" */, uintptr(0)} /* test_osinst.c:1127:21 */

func SqlitetestOsinst_Init(tls *libc.TLS, interp uintptr) int32 { /* test_osinst.c:1219:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+36381 /* "vfslog" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfslog})), uintptr(0), uintptr(0))
	return TCL_OK
}

// Global data used by this test implementation.  There is no
// mutexing, which means this page cache will not work in a
// multi-threaded test.
type testpcacheGlobalType1 = struct {
	FpDummy        uintptr
	FnInstance     int32
	FdiscardChance uint32
	FprngSeed      uint32
	FhighStress    uint32
} /* test_pcache.c:33:9 */

// Global data used by this test implementation.  There is no
// mutexing, which means this page cache will not work in a
// multi-threaded test.
type testpcacheGlobalType = testpcacheGlobalType1 /* test_pcache.c:33:37 */
var testpcacheGlobal testpcacheGlobalType         /* test_pcache.c:41:29: */

// Initializer.
//
// Verify that the initializer is only called when the system is
// uninitialized.  Allocate some memory and report SQLITE_NOMEM if
// the allocation fails.  This provides a means to test the recovery
// from a failed initialization attempt.  It also verifies that the
// the destructor always gets call - otherwise there would be a
// memory leak.
func testpcacheInit(tls *libc.TLS, pArg uintptr) int32 { /* test_pcache.c:53:12: */

	testpcacheGlobal.FpDummy = sqlite3.Xsqlite3_malloc(tls, 10)
	if testpcacheGlobal.FpDummy == uintptr(0) {
		return SQLITE_NOMEM
	}
	return SQLITE_OK
}

// Destructor
//
// Verify that this is only called after initialization.
// Free the memory allocated by the initializer.
func testpcacheShutdown(tls *libc.TLS, pArg uintptr) { /* test_pcache.c:67:13: */

	sqlite3.Xsqlite3_free(tls, testpcacheGlobal.FpDummy)
	testpcacheGlobal.FpDummy = uintptr(0)
}

// Number of pages in a cache.
//
// The number of pages is a hard upper bound in this test module.
// If more pages are requested, sqlite3PcacheFetch() returns NULL.
//
// If testing with in-memory temp tables, provide a larger pcache.
// Some of the test cases need this.

// Magic numbers used to determine validity of the page cache.

// Private implementation of a page cache.
type testpcache1 = struct {
	FszPage      int32
	FszExtra     int32
	FbPurgeable  int32
	FnFree       int32
	FnPinned     int32
	FiRand       uint32
	FiMagic      uint32
	F__ccgo_pad1 [4]byte
	Fa           [217]struct {
		Fpage     sqlite3_pcache_page
		Fkey      uint32
		FisPinned int32
	}
} /* test_pcache.c:100:9 */

// Number of pages in a cache.
//
// The number of pages is a hard upper bound in this test module.
// If more pages are requested, sqlite3PcacheFetch() returns NULL.
//
// If testing with in-memory temp tables, provide a larger pcache.
// Some of the test cases need this.

// Magic numbers used to determine validity of the page cache.

// Private implementation of a page cache.
type testpcache = testpcache1 /* test_pcache.c:100:27 */
type testpcachePage = struct {
	Fpage     sqlite3_pcache_page
	Fkey      uint32
	FisPinned int32
} /* test_pcache.c:100:9 */

// Get a random number using the PRNG in the given page cache.
func testpcacheRandom(tls *libc.TLS, p uintptr) uint32 { /* test_pcache.c:119:17: */
	var x uint32 = uint32(0)
	var i int32
	for i = 0; i < 4; i++ {
		(*testpcache)(unsafe.Pointer(p)).FiRand = (*testpcache)(unsafe.Pointer(p)).FiRand*uint32(69069) + uint32(5)
		x = x<<8 | (*testpcache)(unsafe.Pointer(p)).FiRand>>16&uint32(0xff)
	}
	return x
}

// Allocate a new page cache instance.
func testpcacheCreate(tls *libc.TLS, szPage int32, szExtra int32, bPurgeable int32) uintptr { /* test_pcache.c:133:23: */
	var nMem int32
	var x uintptr
	var p uintptr
	var i int32

	szPage = (szPage + 7) & libc.CplInt32(7)
	nMem = int32(uint64(unsafe.Sizeof(testpcache{})) + uint64(TESTPCACHE_NPAGE*(szPage+szExtra)))
	p = sqlite3.Xsqlite3_malloc(tls, nMem)
	if p == uintptr(0) {
		return uintptr(0)
	}
	x = p + 1*5240
	(*testpcache)(unsafe.Pointer(p)).FszPage = szPage
	(*testpcache)(unsafe.Pointer(p)).FszExtra = szExtra
	(*testpcache)(unsafe.Pointer(p)).FnFree = TESTPCACHE_NPAGE
	(*testpcache)(unsafe.Pointer(p)).FnPinned = 0
	(*testpcache)(unsafe.Pointer(p)).FiRand = testpcacheGlobal.FprngSeed
	(*testpcache)(unsafe.Pointer(p)).FbPurgeable = bPurgeable
	(*testpcache)(unsafe.Pointer(p)).FiMagic = uint32(TESTPCACHE_VALID)
	i = 0
__1:
	if !(i < TESTPCACHE_NPAGE) {
		goto __3
	}
	{
		(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).Fkey = uint32(0)
		(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).FisPinned = 0
		(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).Fpage.FpBuf = x
		(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).Fpage.FpExtra = x + uintptr(szPage)

	}
	goto __2
__2:
	i++
	x += uintptr(szPage + szExtra)
	goto __1
	goto __3
__3:
	;
	testpcacheGlobal.FnInstance++
	return p
}

// Set the cache size
func testpcacheCachesize(tls *libc.TLS, pCache uintptr, newSize int32) { /* test_pcache.c:168:13: */
	var p uintptr = pCache
	_ = p

}

// Return the number of pages in the cache that are being used.
// This includes both pinned and unpinned pages.
func testpcachePagecount(tls *libc.TLS, pCache uintptr) int32 { /* test_pcache.c:179:12: */
	var p uintptr = pCache

	return TESTPCACHE_NPAGE - (*testpcache)(unsafe.Pointer(p)).FnFree
}

// Fetch a page.
func testpcacheFetch(tls *libc.TLS, pCache uintptr, key uint32, createFlag int32) uintptr { /* test_pcache.c:190:28: */
	var p uintptr = pCache
	var i int32
	var j int32

	// See if the page is already in cache.  Return immediately if it is
	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer(p+32+uintptr(i)*24)).Fkey == key {
			if !((*testpcachePage)(unsafe.Pointer(p+32+uintptr(i)*24)).FisPinned != 0) {
				(*testpcache)(unsafe.Pointer(p)).FnPinned++

				(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).FisPinned = 1
			}
			return p + 32 + uintptr(i)*24
		}
	}

	// If createFlag is 0, never allocate a new page
	if createFlag == 0 {
		return uintptr(0)
	}

	// If no pages are available, always fail
	if (*testpcache)(unsafe.Pointer(p)).FnPinned == TESTPCACHE_NPAGE {
		return uintptr(0)
	}

	// Do not allocate the last TESTPCACHE_RESERVE pages unless createFlag is 2
	if (*testpcache)(unsafe.Pointer(p)).FnPinned >= TESTPCACHE_NPAGE-TESTPCACHE_RESERVE && createFlag < 2 {
		return uintptr(0)
	}

	// Do not allocate if highStress is enabled and createFlag is not 2.
	//
	// The highStress setting causes pagerStress() to be called much more
	// often, which exercises the pager logic more intensely.
	if testpcacheGlobal.FhighStress != 0 && createFlag < 2 {
		return uintptr(0)
	}

	// Find a free page to allocate if there are any free pages.
	// Withhold TESTPCACHE_RESERVE free pages until createFlag is 2.
	if (*testpcache)(unsafe.Pointer(p)).FnFree > TESTPCACHE_RESERVE || createFlag == 2 && (*testpcache)(unsafe.Pointer(p)).FnFree > 0 {
		j = int32(testpcacheRandom(tls, p) % uint32(TESTPCACHE_NPAGE))
		i = 0
	__1:
		if !(i < TESTPCACHE_NPAGE) {
			goto __3
		}
		{
			if (*testpcachePage)(unsafe.Pointer(p+32+uintptr(j)*24)).Fkey == uint32(0) {
				(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(j)*24)).Fkey = key
				(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(j)*24)).FisPinned = 1
				libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+32+uintptr(j)*24)).Fpage.FpBuf, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszPage))
				libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+32+uintptr(j)*24)).Fpage.FpExtra, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszExtra))
				(*testpcache)(unsafe.Pointer(p)).FnPinned++
				(*testpcache)(unsafe.Pointer(p)).FnFree--

				return p + 32 + uintptr(j)*24
			}

		}
		goto __2
	__2:
		i++
		j = (j + 1) % TESTPCACHE_NPAGE
		goto __1
		goto __3
	__3:

		// The prior loop always finds a freepage to allocate

	}

	// If this cache is not purgeable then we have to fail.
	if (*testpcache)(unsafe.Pointer(p)).FbPurgeable == 0 {
		return uintptr(0)
	}

	// If there are no free pages, recycle a page.  The page to
	// recycle is selected at random from all unpinned pages.
	j = int32(testpcacheRandom(tls, p) % uint32(TESTPCACHE_NPAGE))
	i = 0
__4:
	if !(i < TESTPCACHE_NPAGE) {
		goto __6
	}
	{
		if (*testpcachePage)(unsafe.Pointer(p+32+uintptr(j)*24)).Fkey > uint32(0) && (*testpcachePage)(unsafe.Pointer(p+32+uintptr(j)*24)).FisPinned == 0 {
			(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(j)*24)).Fkey = key
			(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(j)*24)).FisPinned = 1
			libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+32+uintptr(j)*24)).Fpage.FpBuf, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszPage))
			libc.Xmemset(tls, (*testpcachePage)(unsafe.Pointer(p+32+uintptr(j)*24)).Fpage.FpExtra, 0, uint64((*testpcache)(unsafe.Pointer(p)).FszExtra))
			(*testpcache)(unsafe.Pointer(p)).FnPinned++

			return p + 32 + uintptr(j)*24
		}

	}
	goto __5
__5:
	i++
	j = (j + 1) % TESTPCACHE_NPAGE
	goto __4
	goto __6
__6:
	;

	// The previous loop always finds a page to recycle.

	return uintptr(0)
}

// Unpin a page.
func testpcacheUnpin(tls *libc.TLS, pCache uintptr, pOldPage uintptr, discard int32) { /* test_pcache.c:289:13: */
	var p uintptr = pCache
	var i int32

	// Randomly discard pages as they are unpinned according to the
	// discardChance setting.  If discardChance is 0, the random discard
	// never happens.  If discardChance is 100, it always happens.
	if (*testpcache)(unsafe.Pointer(p)).FbPurgeable != 0 &&
		uint32(100)-testpcacheGlobal.FdiscardChance <= testpcacheRandom(tls, p)%uint32(100) {
		discard = 1
	}

	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if p+32+uintptr(i)*24 == pOldPage {
			// The pOldPage pointer always points to a pinned page

			(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).FisPinned = 0
			(*testpcache)(unsafe.Pointer(p)).FnPinned--

			if discard != 0 {
				(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).Fkey = uint32(0)
				(*testpcache)(unsafe.Pointer(p)).FnFree++

			}
			return
		}
	}

	// The pOldPage pointer always points to a valid page

}

// Rekey a single page.
func testpcacheRekey(tls *libc.TLS, pCache uintptr, pOldPage uintptr, oldKey uint32, newKey uint32) { /* test_pcache.c:334:13: */
	var p uintptr = pCache
	var i int32

	// If there already exists another page at newKey, verify that
	// the other page is unpinned and discard it.
	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer(p+32+uintptr(i)*24)).Fkey == newKey {
			// The new key is never a page that is already pinned

			(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).Fkey = uint32(0)
			(*testpcache)(unsafe.Pointer(p)).FnFree++

			break
		}
	}

	// Find the page to be rekeyed and rekey it.
	for i = 0; i < TESTPCACHE_NPAGE; i++ {
		if (*testpcachePage)(unsafe.Pointer(p+32+uintptr(i)*24)).Fkey == oldKey {
			// The oldKey and pOldPage parameters match

			// Page to be rekeyed must be pinned

			(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).Fkey = newKey
			return
		}
	}

	// Rekey is always given a valid page to work with

}

// Truncate the page cache.  Every page with a key of iLimit or larger
// is discarded.
func testpcacheTruncate(tls *libc.TLS, pCache uintptr, iLimit uint32) { /* test_pcache.c:382:13: */
	var p uintptr = pCache
	var i uint32

	for i = uint32(0); i < uint32(TESTPCACHE_NPAGE); i++ {
		if (*testpcachePage)(unsafe.Pointer(p+32+uintptr(i)*24)).Fkey >= iLimit {
			(*testpcachePage)(unsafe.Pointer(p + 32 + uintptr(i)*24)).Fkey = uint32(0)
			if (*testpcachePage)(unsafe.Pointer(p+32+uintptr(i)*24)).FisPinned != 0 {
				(*testpcache)(unsafe.Pointer(p)).FnPinned--

			}
			(*testpcache)(unsafe.Pointer(p)).FnFree++

		}
	}
}

// Destroy a page cache.
func testpcacheDestroy(tls *libc.TLS, pCache uintptr) { /* test_pcache.c:404:13: */
	var p uintptr = pCache

	(*testpcache)(unsafe.Pointer(p)).FiMagic = TESTPCACHE_CLEAR
	sqlite3.Xsqlite3_free(tls, p)
	testpcacheGlobal.FnInstance--
}

// Invoke this routine to register or unregister the testing pager cache
// implemented by this file.
//
// Install the test pager cache if installFlag is 1 and uninstall it if
// installFlag is 0.
//
// When installing, discardChance is a number between 0 and 100 that
// indicates the probability of discarding a page when unpinning the
// page.  0 means never discard (unless the discard flag is set).
// 100 means always discard.
func installTestPCache(tls *libc.TLS, installFlag int32, discardChance uint32, prngSeed uint32, highStress uint32) { /* test_pcache.c:427:6: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	testpcacheGlobal.FdiscardChance = discardChance
	testpcacheGlobal.FprngSeed = prngSeed ^ prngSeed<<16
	testpcacheGlobal.FhighStress = highStress
	if installFlag != isInstalled {
		if installFlag != 0 {
			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_GETPCACHE2, libc.VaList(bp, uintptr(unsafe.Pointer(&defaultPcache))))

			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+8, uintptr(unsafe.Pointer(&testPcache))))
		} else {

			sqlite3.Xsqlite3_config(tls, SQLITE_CONFIG_PCACHE2, libc.VaList(bp+16, uintptr(unsafe.Pointer(&defaultPcache))))
		}
		isInstalled = installFlag
	}
}

var testPcache = sqlite3_pcache_methods2{
	FiVersion:   1,
	FpArg:       0,
	FxInit:      0,
	FxShutdown:  0,
	FxCreate:    0,
	FxCachesize: 0,
	FxPagecount: 0,
	FxFetch:     0,
	FxUnpin:     0,
	FxRekey:     0,
	FxTruncate:  0,
	FxDestroy:   0,
}                                         /* test_pcache.c:433:40 */
var defaultPcache sqlite3_pcache_methods2 /* test_pcache.c:447:34: */
var isInstalled int32 = 0                 /* test_pcache.c:448:14 */

// The following object serves the same role as FILE in the standard C
// library.  It represents an open connection to a file on disk for I/O.
//
// A single quota_FILE should not be used by two or more threads at the
// same time.  Multiple threads can be using different quota_FILE objects
// simultaneously, but not the same quota_FILE object.
type quota_FILE1 = struct {
	Ff     uintptr
	FiOfst sqlite3_int64
	FpFile uintptr
} /* test_quota.h:145:9 */

// The following object serves the same role as FILE in the standard C
// library.  It represents an open connection to a file on disk for I/O.
//
// A single quota_FILE should not be used by two or more threads at the
// same time.  Multiple threads can be using different quota_FILE objects
// simultaneously, but not the same quota_FILE object.
type quota_FILE = quota_FILE1 /* test_quota.h:145:27 */ // getopt(3) external variable

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type quotaGroup1 = struct {
	FzPattern  uintptr
	FiLimit    sqlite3_int64
	FiSize     sqlite3_int64
	FxCallback uintptr
	FpArg      uintptr
	FxDestroy  uintptr
	FpNext     uintptr
	FppPrev    uintptr
	FpFiles    uintptr
} /* test_quota.h:145:9 */

// getopt(3) external variable

//*********************** Object Definitions *****************************

// Forward declaration of all object types
type quotaGroup = quotaGroup1 /* test_quota.c:61:27 */
type quotaConn1 = struct {
	Fbase  sqlite3_file
	FpFile uintptr
} /* test_quota.c:62:9 */

type quotaConn = quotaConn1 /* test_quota.c:62:26 */
type quotaFile1 = struct {
	FzFilename     uintptr
	FpGroup        uintptr
	FiSize         sqlite3_int64
	FnRef          int32
	FdeleteOnClose int32
	FpNext         uintptr
	FppPrev        uintptr
} /* test_quota.h:145:9 */

type quotaFile = quotaFile1 /* test_quota.c:63:26 */

//************************ Global Variables *********************************
// All global variables used by this file are containing within the following
// gQuota structure.
var gQuota struct {
	FpOrigVfs      uintptr
	FsThisVfs      sqlite3_vfs
	FsIoMethodsV1  sqlite3_io_methods
	FsIoMethodsV2  sqlite3_io_methods
	FisInitialized int32
	F__ccgo_pad1   [4]byte
	FpMutex        uintptr
	FpGroup        uintptr
} /* test_quota.c:183:3: */

//************************ Utility Routines ********************************
// Acquire and release the mutex used to serialize access to the
// list of quotaGroups.
func quotaEnter(tls *libc.TLS) { /* test_quota.c:190:13: */
	sqlite3.Xsqlite3_mutex_enter(tls, gQuota.FpMutex)
}

func quotaLeave(tls *libc.TLS) { /* test_quota.c:191:13: */
	sqlite3.Xsqlite3_mutex_leave(tls, gQuota.FpMutex)
}

// Count the number of open files in a quotaGroup
func quotaGroupOpenFileCount(tls *libc.TLS, pGroup uintptr) int32 { /* test_quota.c:195:12: */
	var N int32 = 0
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for pFile != 0 {
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
			N++
		}
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	return N
}

// Remove a file from a quota group.
func quotaRemoveFile(tls *libc.TLS, pFile uintptr) { /* test_quota.c:207:13: */
	var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
	*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16)) -= (*quotaFile)(unsafe.Pointer(pFile)).FiSize
	*(*uintptr)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FppPrev)) = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	if (*quotaFile)(unsafe.Pointer(pFile)).FpNext != 0 {
		(*quotaFile)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpNext)).FppPrev = (*quotaFile)(unsafe.Pointer(pFile)).FppPrev
	}
	sqlite3.Xsqlite3_free(tls, pFile)
}

// Remove all files from a quota group.  It is always the case that
// all files will be closed when this routine is called.
func quotaRemoveAllFiles(tls *libc.TLS, pGroup uintptr) { /* test_quota.c:218:13: */
	for (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {

		quotaRemoveFile(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)
	}
}

// If the reference count and threshold for a quotaGroup are both
// zero, then destroy the quotaGroup.
func quotaGroupDeref(tls *libc.TLS, pGroup uintptr) { /* test_quota.c:229:13: */
	if (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit == int64(0) && quotaGroupOpenFileCount(tls, pGroup) == 0 {
		quotaRemoveAllFiles(tls, pGroup)
		*(*uintptr)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev)) = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext != 0 {
			(*quotaGroup)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpNext)).FppPrev = (*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev
		}
		if (*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0 {
			(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy})).f(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
		}
		sqlite3.Xsqlite3_free(tls, pGroup)
	}
}

// Return TRUE if string z matches glob pattern zGlob.
//
// Globbing rules:
//
//      '*'       Matches any sequence of zero or more characters.
//
//      '?'       Matches exactly one character.
//
//     [...]      Matches one character from the enclosed list of
//                characters.
//
//     [^...]     Matches one character not in the enclosed list.
//
//     /          Matches "/" or "\\"
//
func quotaStrglob(tls *libc.TLS, zGlob uintptr, z uintptr) int32 { /* test_quota.c:256:12: */
	var c int32
	var c2 int32
	var cx int32
	var invert int32
	var seen int32

	for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) != 0 {
		if c == '*' {
			for libc.AssignInt32(&c, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))) == '*' || c == '?' {
				if c == '?' && int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
					return 0
				}
			}
			if c == 0 {
				return 1
			} else if c == '[' {
				for *(*int8)(unsafe.Pointer(z)) != 0 && quotaStrglob(tls, zGlob-uintptr(1), z) == 0 {
					z++
				}
				return libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) != 0)
			}
			if c == '/' {
				cx = '\\'
			} else {
				cx = c
			}
			for libc.AssignInt32(&c2, int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))) != 0 {
				for c2 != c && c2 != cx {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
					if c2 == 0 {
						return 0
					}
				}
				if quotaStrglob(tls, zGlob, z) != 0 {
					return 1
				}
			}
			return 0
		} else if c == '?' {
			if int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) == 0 {
				return 0
			}
		} else if c == '[' {
			var prior_c int32 = 0
			seen = 0
			invert = 0
			c = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1))))
			if c == 0 {
				return 0
			}
			c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			if c2 == '^' {
				invert = 1
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == ']' {
				if c == ']' {
					seen = 1
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			for c2 != 0 && c2 != ']' {
				if c2 == '-' && int32(*(*int8)(unsafe.Pointer(zGlob))) != ']' && int32(*(*int8)(unsafe.Pointer(zGlob))) != 0 && prior_c > 0 {
					c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
					if c >= prior_c && c <= c2 {
						seen = 1
					}
					prior_c = 0
				} else {
					if c == c2 {
						seen = 1
					}
					prior_c = c2
				}
				c2 = int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&zGlob, 1))))
			}
			if c2 == 0 || seen^invert == 0 {
				return 0
			}
		} else if c == '/' {
			if int32(*(*int8)(unsafe.Pointer(z))) != '/' && int32(*(*int8)(unsafe.Pointer(z))) != '\\' {
				return 0
			}
			z++
		} else {
			if c != int32(*(*int8)(unsafe.Pointer(libc.PostIncUintptr(&z, 1)))) {
				return 0
			}
		}
	}
	return libc.Bool32(int32(*(*int8)(unsafe.Pointer(z))) == 0)
}

// Find a quotaGroup given the filename.
//
// Return a pointer to the quotaGroup object. Return NULL if not found.
func quotaGroupFind(tls *libc.TLS, zFilename uintptr) uintptr { /* test_quota.c:329:19: */
	var p uintptr
	for p = gQuota.FpGroup; p != 0 && quotaStrglob(tls, (*quotaGroup)(unsafe.Pointer(p)).FzPattern, zFilename) == 0; p = (*quotaGroup)(unsafe.Pointer(p)).FpNext {
	}
	return p
}

// Translate an sqlite3_file* that is really a quotaConn* into
// the sqlite3_file* for the underlying original VFS.
func quotaSubOpen(tls *libc.TLS, pConn uintptr) uintptr { /* test_quota.c:339:21: */
	var p uintptr = pConn
	return p + 1*16
}

// Find a file in a quota group and return a pointer to that file.
// Return NULL if the file is not in the group.
func quotaFindFile(tls *libc.TLS, pGroup uintptr, zName uintptr, createFlag int32) uintptr { /* test_quota.c:347:18: */
	var pFile uintptr = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
	for pFile != 0 && libc.Xstrcmp(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName) != 0 {
		pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
	}
	if pFile == uintptr(0) && createFlag != 0 {
		var nName int32 = int32(libc.Xstrlen(tls, zName) & uint64(0x3fffffff))
		pFile = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(quotaFile{}))+uint64(nName)+uint64(1)))
		if pFile != 0 {
			libc.Xmemset(tls, pFile, 0, uint64(unsafe.Sizeof(quotaFile{})))
			(*quotaFile)(unsafe.Pointer(pFile)).FzFilename = pFile + 1*48
			libc.Xmemcpy(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, zName, uint64(nName+1))
			(*quotaFile)(unsafe.Pointer(pFile)).FpNext = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles != 0 {
				(*quotaFile)(unsafe.Pointer((*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles)).FppPrev = pFile + 32
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FppPrev = pGroup + 64
			(*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles = pFile
			(*quotaFile)(unsafe.Pointer(pFile)).FpGroup = pGroup
		}
	}
	return pFile
}

// Translate UTF8 to MBCS for use in fopen() calls.  Return a pointer to the
// translated text..  Call quota_mbcs_free() to deallocate any memory
// used to store the returned pointer when done.
func quota_utf8_to_mbcs(tls *libc.TLS, zUtf8 uintptr) uintptr { /* test_quota.c:377:13: */
	return zUtf8 // No-op on unix
}

// Deallocate any memory allocated by quota_utf8_to_mbcs().
func quota_mbcs_free(tls *libc.TLS, zOld uintptr) { /* test_quota.c:408:13: */
	// No-op on unix
}

//************************ VFS Method Wrappers ****************************
// This is the xOpen method used for the "quota" VFS.
//
// Most of the work is done by the underlying original VFS.  This method
// simply links the new file into the appropriate quota group if it is a
// file that needs to be tracked.
func quotaOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pConn uintptr, flags int32, pOutFlags uintptr) int32 { /* test_quota.c:424:12: */
	var rc int32                            // Result code
	var pQuotaOpen uintptr                  // The new quota file descriptor
	var pFile uintptr                       // Corresponding quotaFile obj
	var pGroup uintptr                      // The group file belongs to
	var pSubOpen uintptr                    // Real file descriptor
	var pOrigVfs uintptr = gQuota.FpOrigVfs // Real VFS

	// If the file is not a main database file or a WAL, then use the
	// normal xOpen method.
	if flags&(SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_WAL) == 0 {
		return (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	}

	// If the name of the file does not match any quota group, then
	// use the normal xOpen method.
	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zName)
	if pGroup == uintptr(0) {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, zName, pConn, flags, pOutFlags)
	} else {
		// If we get to this point, it means the file needs to be quota tracked.
		pQuotaOpen = pConn
		pSubOpen = quotaSubOpen(tls, pConn)
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxOpen})).f(tls, pOrigVfs, zName, pSubOpen, flags, pOutFlags)
		if rc == SQLITE_OK {
			pFile = quotaFindFile(tls, pGroup, zName, 1)
			if pFile == uintptr(0) {
				quotaLeave(tls)
				(*struct {
					f func(*libc.TLS, uintptr) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxClose})).f(tls, pSubOpen)
				return SQLITE_NOMEM
			}
			(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = libc.Bool32(flags&SQLITE_OPEN_DELETEONCLOSE != 0)
			(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
			(*quotaConn)(unsafe.Pointer(pQuotaOpen)).FpFile = pFile
			if (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FiVersion == 1 {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = uintptr(unsafe.Pointer(&gQuota)) + 176
			} else {
				(*quotaConn)(unsafe.Pointer(pQuotaOpen)).Fbase.FpMethods = uintptr(unsafe.Pointer(&gQuota)) + 328
			}
		}
	}
	quotaLeave(tls)
	return rc
}

// This is the xDelete method used for the "quota" VFS.
//
// If the file being deleted is part of the quota group, then reduce
// the size of the quota group accordingly.  And remove the file from
// the set of files in the quota group.
func quotaDelete(tls *libc.TLS, pVfs uintptr, zName uintptr, syncDir int32) int32 { /* test_quota.c:486:12: */
	var rc int32                            // Result code
	var pFile uintptr                       // Files in the quota
	var pGroup uintptr                      // The group file belongs to
	var pOrigVfs uintptr = gQuota.FpOrigVfs // Real VFS

	// Do the actual file delete
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs)).FxDelete})).f(tls, pOrigVfs, zName, syncDir)

	// If the file just deleted is a member of a quota group, then remove
	// it from that quota group.
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = quotaGroupFind(tls, zName)
		if pGroup != 0 {
			pFile = quotaFindFile(tls, pGroup, zName, 0)
			if pFile != 0 {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
		quotaLeave(tls)
	}
	return rc
}

//*********************** I/O Method Wrappers ******************************

// xClose requests get passed through to the original VFS.  But we
// also have to unlink the quotaConn from the quotaFile and quotaGroup.
// The quotaFile and/or quotaGroup are freed if they are no longer in use.
func quotaClose(tls *libc.TLS, pConn uintptr) int32 { /* test_quota.c:528:12: */
	var p uintptr = pConn
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32
	rc = (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxClose})).f(tls, pSubOpen)
	quotaEnter(tls)
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
	if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxDelete})).f(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
			quotaRemoveFile(tls, pFile)
		}
		quotaGroupDeref(tls, pGroup)
	}
	quotaLeave(tls)
	return rc
}

// Pass xRead requests directory thru to the original VFS without
// further processing.
func quotaRead(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_quota.c:551:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxRead})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
}

// Check xWrite requests to see if they expand the file.  If they do,
// the perform a quota check before passing them through to the
// original VFS.
func quotaWrite(tls *libc.TLS, pConn uintptr, pBuf uintptr, iAmt int32, iOfst sqlite3_int64) int32 { /* test_quota.c:565:12: */
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var iEnd sqlite3_int64 = iOfst + sqlite3_int64(iAmt)
	var pGroup uintptr
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var szNew sqlite3_int64

	if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd {
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize + iEnd
		if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback})).f(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, pGroup+8 /* &.iLimit */, szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
				quotaLeave(tls)
				return SQLITE_FULL
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	}
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxWrite})).f(tls, pSubOpen, pBuf, iAmt, iOfst)
}

// Pass xTruncate requests thru to the original VFS.  If the
// success, update the file size.
func quotaTruncate(tls *libc.TLS, pConn uintptr, size sqlite3_int64) int32 { /* test_quota.c:602:12: */
	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxTruncate})).f(tls, pSubOpen, size)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16)) -= (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = size
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16)) += size
		quotaLeave(tls)
	}
	return rc
}

// Pass xSync requests through to the original VFS without change
func quotaSync(tls *libc.TLS, pConn uintptr, flags int32) int32 { /* test_quota.c:621:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSync})).f(tls, pSubOpen, flags)
}

// Pass xFileSize requests through to the original VFS but then
// update the quotaGroup with the new size before returning.
func quotaFileSize(tls *libc.TLS, pConn uintptr, pSize uintptr) int32 { /* test_quota.c:629:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pConn
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var pFile uintptr = (*quotaConn)(unsafe.Pointer(p)).FpFile
	var pGroup uintptr
	// var sz sqlite3_int64 at bp, 8

	var rc int32

	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileSize})).f(tls, pSubOpen, bp /* &sz */)
	if rc == SQLITE_OK {
		quotaEnter(tls)
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16)) -= (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16)) += *(*sqlite3_int64)(unsafe.Pointer(bp))
		quotaLeave(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pSize)) = *(*sqlite3_int64)(unsafe.Pointer(bp /* sz */))
	}
	return rc
}

// Pass xLock requests through to the original VFS unchanged.
func quotaLock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_quota.c:652:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxLock})).f(tls, pSubOpen, lock)
}

// Pass xUnlock requests through to the original VFS unchanged.
func quotaUnlock(tls *libc.TLS, pConn uintptr, lock int32) int32 { /* test_quota.c:659:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxUnlock})).f(tls, pSubOpen, lock)
}

// Pass xCheckReservedLock requests through to the original VFS unchanged.
func quotaCheckReservedLock(tls *libc.TLS, pConn uintptr, pResOut uintptr) int32 { /* test_quota.c:666:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxCheckReservedLock})).f(tls, pSubOpen, pResOut)
}

// Pass xFileControl requests through to the original VFS unchanged.
func quotaFileControl(tls *libc.TLS, pConn uintptr, op int32, pArg uintptr) int32 { /* test_quota.c:673:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	var rc int32 = (*struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxFileControl})).f(tls, pSubOpen, op, pArg)
	if op == SQLITE_FCNTL_VFSNAME && rc == SQLITE_OK {
		*(*uintptr)(unsafe.Pointer(pArg)) = sqlite3.Xsqlite3_mprintf(tls, ts+36466 /* "quota/%z" */, libc.VaList(bp, *(*uintptr)(unsafe.Pointer(pArg))))
	}
	return rc
}

// Pass xSectorSize requests through to the original VFS unchanged.
func quotaSectorSize(tls *libc.TLS, pConn uintptr) int32 { /* test_quota.c:686:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxSectorSize})).f(tls, pSubOpen)
}

// Pass xDeviceCharacteristics requests through to the original VFS unchanged.
func quotaDeviceCharacteristics(tls *libc.TLS, pConn uintptr) int32 { /* test_quota.c:693:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxDeviceCharacteristics})).f(tls, pSubOpen)
}

// Pass xShmMap requests through to the original VFS unchanged.
func quotaShmMap(tls *libc.TLS, pConn uintptr, iRegion int32, szRegion int32, bExtend int32, pp uintptr) int32 { /* test_quota.c:700:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmMap})).f(tls, pSubOpen, iRegion, szRegion, bExtend, pp)
}

// Pass xShmLock requests through to the original VFS unchanged.
func quotaShmLock(tls *libc.TLS, pConn uintptr, ofst int32, n int32, flags int32) int32 { /* test_quota.c:713:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmLock})).f(tls, pSubOpen, ofst, n, flags)
}

// Pass xShmBarrier requests through to the original VFS unchanged.
func quotaShmBarrier(tls *libc.TLS, pConn uintptr) { /* test_quota.c:725:13: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmBarrier})).f(tls, pSubOpen)
}

// Pass xShmUnmap requests through to the original VFS unchanged.
func quotaShmUnmap(tls *libc.TLS, pConn uintptr, deleteFlag int32) int32 { /* test_quota.c:732:12: */
	var pSubOpen uintptr = quotaSubOpen(tls, pConn)
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pSubOpen)).FpMethods)).FxShmUnmap})).f(tls, pSubOpen, deleteFlag)
}

//************************* Public Interfaces ****************************
// Initialize the quota VFS shim.  Use the VFS named zOrigVfsName
// as the VFS that does the actual work.  Use the default if
// zOrigVfsName==NULL.
//
// The quota VFS shim is named "quota".  It will become the default
// VFS if makeDefault is non-zero.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once
// during start-up.
func sqlite3_quota_initialize(tls *libc.TLS, zOrigVfsName uintptr, makeDefault int32) int32 { /* test_quota.c:749:5: */
	var pOrigVfs uintptr
	if gQuota.FisInitialized != 0 {
		return SQLITE_MISUSE
	}
	pOrigVfs = sqlite3.Xsqlite3_vfs_find(tls, zOrigVfsName)
	if pOrigVfs == uintptr(0) {
		return SQLITE_ERROR
	}

	gQuota.FpMutex = sqlite3.Xsqlite3_mutex_alloc(tls, SQLITE_MUTEX_FAST)
	if !(int32(gQuota.FpMutex) != 0) {
		return SQLITE_NOMEM
	}
	gQuota.FisInitialized = 1
	gQuota.FpOrigVfs = pOrigVfs
	gQuota.FsThisVfs = *(*sqlite3_vfs)(unsafe.Pointer(pOrigVfs))
	gQuota.FsThisVfs.FxOpen = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32
	}{quotaOpen}))
	gQuota.FsThisVfs.FxDelete = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32) int32
	}{quotaDelete}))
	*(*int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&gQuota)) + 8 + 4)) += int32(uint64(unsafe.Sizeof(quotaConn{})))
	gQuota.FsThisVfs.FzName = ts + 36475 /* "quota" */
	gQuota.FsIoMethodsV1.FiVersion = 1
	gQuota.FsIoMethodsV1.FxClose = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaClose}))
	gQuota.FsIoMethodsV1.FxRead = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaRead}))
	gQuota.FsIoMethodsV1.FxWrite = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32
	}{quotaWrite}))
	gQuota.FsIoMethodsV1.FxTruncate = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, sqlite3_int64) int32
	}{quotaTruncate}))
	gQuota.FsIoMethodsV1.FxSync = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaSync}))
	gQuota.FsIoMethodsV1.FxFileSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{quotaFileSize}))
	gQuota.FsIoMethodsV1.FxLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaLock}))
	gQuota.FsIoMethodsV1.FxUnlock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaUnlock}))
	gQuota.FsIoMethodsV1.FxCheckReservedLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{quotaCheckReservedLock}))
	gQuota.FsIoMethodsV1.FxFileControl = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr) int32
	}{quotaFileControl}))
	gQuota.FsIoMethodsV1.FxSectorSize = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaSectorSize}))
	gQuota.FsIoMethodsV1.FxDeviceCharacteristics = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) int32
	}{quotaDeviceCharacteristics}))
	gQuota.FsIoMethodsV2 = gQuota.FsIoMethodsV1
	gQuota.FsIoMethodsV2.FiVersion = 2
	gQuota.FsIoMethodsV2.FxShmMap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	}{quotaShmMap}))
	gQuota.FsIoMethodsV2.FxShmLock = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	}{quotaShmLock}))
	gQuota.FsIoMethodsV2.FxShmBarrier = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{quotaShmBarrier}))
	gQuota.FsIoMethodsV2.FxShmUnmap = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{quotaShmUnmap}))
	sqlite3.Xsqlite3_vfs_register(tls, uintptr(unsafe.Pointer(&gQuota))+8, makeDefault)
	return SQLITE_OK
}

// Shutdown the quota system.
//
// All SQLite database connections must be closed before calling this
// routine.
//
// THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while
// shutting down in order to free all remaining quota groups.
func sqlite3_quota_shutdown(tls *libc.TLS) int32 { /* test_quota.c:798:5: */
	var pGroup uintptr
	if gQuota.FisInitialized == 0 {
		return SQLITE_MISUSE
	}
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		if quotaGroupOpenFileCount(tls, pGroup) > 0 {
			return SQLITE_MISUSE
		}
	}
	for gQuota.FpGroup != 0 {
		pGroup = gQuota.FpGroup
		gQuota.FpGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = int64(0)

		quotaGroupDeref(tls, pGroup)
	}
	gQuota.FisInitialized = 0
	sqlite3.Xsqlite3_mutex_free(tls, gQuota.FpMutex)
	sqlite3.Xsqlite3_vfs_unregister(tls, uintptr(unsafe.Pointer(&gQuota))+8)
	libc.Xmemset(tls, uintptr(unsafe.Pointer(&gQuota)), 0, uint64(unsafe.Sizeof(gQuota)))
	return SQLITE_OK
}

// Create or destroy a quota group.
//
// The quota group is defined by the zPattern.  When calling this routine
// with a zPattern for a quota group that already exists, this routine
// merely updates the iLimit, xCallback, and pArg values for that quota
// group.  If zPattern is new, then a new quota group is created.
//
// If the iLimit for a quota group is set to zero, then the quota group
// is disabled and will be deleted when the last database connection using
// the quota group is closed.
//
// Calling this routine on a zPattern that does not exist and with a
// zero iLimit is a no-op.
//
// A quota group must exist with a non-zero iLimit prior to opening
// database connections if those connections are to participate in the
// quota group.  Creating a quota group does not affect database connections
// that are already open.
func sqlite3_quota_set(tls *libc.TLS, zPattern uintptr, iLimit sqlite3_int64, xCallback uintptr, pArg uintptr, xDestroy uintptr) int32 { /* test_quota.c:838:5: */
	var pGroup uintptr
	quotaEnter(tls)
	pGroup = gQuota.FpGroup
	for pGroup != 0 && libc.Xstrcmp(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern) != 0 {
		pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext
	}
	if pGroup == uintptr(0) {
		var nPattern int32 = int32(libc.Xstrlen(tls, zPattern) & uint64(0x3fffffff))
		if iLimit <= int64(0) {
			quotaLeave(tls)
			return SQLITE_OK
		}
		pGroup = sqlite3.Xsqlite3_malloc(tls, int32(uint64(unsafe.Sizeof(quotaGroup{}))+uint64(nPattern)+uint64(1)))
		if pGroup == uintptr(0) {
			quotaLeave(tls)
			return SQLITE_NOMEM
		}
		libc.Xmemset(tls, pGroup, 0, uint64(unsafe.Sizeof(quotaGroup{})))
		(*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern = pGroup + 1*72
		libc.Xmemcpy(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, zPattern, uint64(nPattern+1))
		if gQuota.FpGroup != 0 {
			(*quotaGroup)(unsafe.Pointer(gQuota.FpGroup)).FppPrev = pGroup + 48
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FpNext = gQuota.FpGroup
		(*quotaGroup)(unsafe.Pointer(pGroup)).FppPrev = uintptr(unsafe.Pointer(&gQuota)) + 496
		gQuota.FpGroup = pGroup
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit = iLimit
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback = xCallback
	if (*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy != 0 && (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg != pArg {
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy})).f(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
	}
	(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg = pArg
	(*quotaGroup)(unsafe.Pointer(pGroup)).FxDestroy = xDestroy
	quotaGroupDeref(tls, pGroup)
	quotaLeave(tls)
	return SQLITE_OK
}

// Bring the named file under quota management.  Or if it is already under
// management, update its size.
func sqlite3_quota_file(tls *libc.TLS, zFilename uintptr) int32 { /* test_quota.c:891:5: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var zFull uintptr = uintptr(0)
	var fd uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp /* outFlags */)) = 0
	// var iSize sqlite3_int64 at bp+8, 8

	var nAlloc int32 = gQuota.FsThisVfs.FszOsFile + gQuota.FsThisVfs.FmxPathname + 2

	// Allocate space for a file-handle and the full path for file zFilename
	fd = sqlite3.Xsqlite3_malloc(tls, nAlloc)
	if fd == uintptr(0) {
		rc = SQLITE_NOMEM
	} else {
		zFull = fd + uintptr(gQuota.FsThisVfs.FszOsFile)
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxFullPathname})).f(tls, gQuota.FpOrigVfs, zFilename,
			gQuota.FsThisVfs.FmxPathname+1, zFull)
	}

	if rc == SQLITE_OK {
		*(*int8)(unsafe.Pointer(zFull + uintptr(libc.Xstrlen(tls, zFull)+uint64(1)))) = int8(0)
		rc = quotaOpen(tls, uintptr(unsafe.Pointer(&gQuota))+8, zFull, fd,
			SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_DB, bp /* &outFlags */)
		if rc == SQLITE_OK {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxFileSize})).f(tls, fd, bp+8 /* &iSize */)
			(*struct {
				f func(*libc.TLS, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxClose})).f(tls, fd)
		} else if rc == SQLITE_CANTOPEN {
			var pGroup uintptr
			var pFile uintptr
			quotaEnter(tls)
			pGroup = quotaGroupFind(tls, zFull)
			if pGroup != 0 {
				pFile = quotaFindFile(tls, pGroup, zFull, 0)
				if pFile != 0 {
					quotaRemoveFile(tls, pFile)
				}
			}
			quotaLeave(tls)
		}
	}

	sqlite3.Xsqlite3_free(tls, fd)
	return rc
}

// Open a potentially quotaed file for I/O.
func sqlite3_quota_fopen(tls *libc.TLS, zFilename uintptr, zMode uintptr) uintptr { /* test_quota.c:936:12: */
	var p uintptr
	var zFull uintptr
	var zFullTranslated uintptr
	var rc int32
	var pGroup uintptr
	var pFile uintptr
	p = uintptr(0)
	zFull = uintptr(0)
	zFullTranslated = uintptr(0)

	zFull = sqlite3.Xsqlite3_malloc(tls, gQuota.FsThisVfs.FmxPathname+1)
	if !(zFull == uintptr(0)) {
		goto __1
	}
	return uintptr(0)
__1:
	;
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxFullPathname})).f(tls, gQuota.FpOrigVfs, zFilename,
		gQuota.FsThisVfs.FmxPathname+1, zFull)
	if !(rc != 0) {
		goto __2
	}
	goto quota_fopen_error
__2:
	;
	p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(quota_FILE{})))
	if !(p == uintptr(0)) {
		goto __3
	}
	goto quota_fopen_error
__3:
	;
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(quota_FILE{})))
	zFullTranslated = quota_utf8_to_mbcs(tls, zFull)
	if !(zFullTranslated == uintptr(0)) {
		goto __4
	}
	goto quota_fopen_error
__4:
	;
	(*quota_FILE)(unsafe.Pointer(p)).Ff = libc.Xfopen(tls, zFullTranslated, zMode)
	if !((*quota_FILE)(unsafe.Pointer(p)).Ff == uintptr(0)) {
		goto __5
	}
	goto quota_fopen_error
__5:
	;
	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if !(pGroup != 0) {
		goto __6
	}
	pFile = quotaFindFile(tls, pGroup, zFull, 1)
	if !(pFile == uintptr(0)) {
		goto __7
	}
	quotaLeave(tls)
	goto quota_fopen_error
__7:
	;
	(*quotaFile)(unsafe.Pointer(pFile)).FnRef++
	(*quota_FILE)(unsafe.Pointer(p)).FpFile = pFile
__6:
	;
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return p

quota_fopen_error:
	quota_mbcs_free(tls, zFullTranslated)
	sqlite3.Xsqlite3_free(tls, zFull)
	if !(p != 0 && (*quota_FILE)(unsafe.Pointer(p)).Ff != 0) {
		goto __8
	}
	libc.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
__8:
	;
	sqlite3.Xsqlite3_free(tls, p)
	return uintptr(0)
}

// Read content from a quota_FILE
func sqlite3_quota_fread(tls *libc.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t { /* test_quota.c:985:8: */
	return libc.Xfread(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Write content into a quota_FILE.  Invoke the quota callback and block
// the write if we exceed quota.
func sqlite3_quota_fwrite(tls *libc.TLS, pBuf uintptr, size size_t, nmemb size_t, p uintptr) size_t { /* test_quota.c:998:8: */
	var iOfst sqlite3_int64
	var iEnd sqlite3_int64
	var szNew sqlite3_int64
	var pFile uintptr
	var rc size_t

	iOfst = sqlite3_int64(libc.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff))
	iEnd = sqlite3_int64(uint64(iOfst) + uint64(size*nmemb))
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if pFile != 0 && (*quotaFile)(unsafe.Pointer(pFile)).FiSize < iEnd {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		szNew = (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize + iEnd
		if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
			if (*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
				})(unsafe.Pointer(&struct{ uintptr }{(*quotaGroup)(unsafe.Pointer(pGroup)).FxCallback})).f(tls, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, pGroup+8 /* &.iLimit */, szNew,
					(*quotaGroup)(unsafe.Pointer(pGroup)).FpArg)
			}
			if szNew > (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit && (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit > int64(0) {
				iEnd = (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit - (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize + (*quotaFile)(unsafe.Pointer(pFile)).FiSize
				nmemb = size_t(uint64(iEnd-iOfst) / uint64(size))
				iEnd = sqlite3_int64(uint64(iOfst) + uint64(size*nmemb))
				szNew = (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize - (*quotaFile)(unsafe.Pointer(pFile)).FiSize + iEnd
			}
		}
		(*quotaGroup)(unsafe.Pointer(pGroup)).FiSize = szNew
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iEnd
		quotaLeave(tls)
	} else {
		pFile = uintptr(0)
	}
	rc = libc.Xfwrite(tls, pBuf, size, nmemb, (*quota_FILE)(unsafe.Pointer(p)).Ff)

	// If the write was incomplete, adjust the file size and group size
	// downward
	if rc < nmemb && pFile != 0 {
		var nWritten size_t = rc
		var iNewEnd sqlite3_int64 = sqlite3_int64(uint64(iOfst) + uint64(size*nWritten))
		if iNewEnd < iEnd {
			iNewEnd = iEnd
		}
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FpGroup + 16)) += iNewEnd - (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = iNewEnd
		quotaLeave(tls)
	}
	return rc
}

// Close an open quota_FILE stream.
func sqlite3_quota_fclose(tls *libc.TLS, p uintptr) int32 { /* test_quota.c:1054:5: */
	var rc int32
	var pFile uintptr
	rc = libc.Xfclose(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	pFile = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	if pFile != 0 {
		quotaEnter(tls)
		(*quotaFile)(unsafe.Pointer(pFile)).FnRef--
		if (*quotaFile)(unsafe.Pointer(pFile)).FnRef == 0 {
			var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
			if (*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose != 0 {
				(*struct {
					f func(*libc.TLS, uintptr, uintptr, int32) int32
				})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxDelete})).f(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
				quotaRemoveFile(tls, pFile)
			}
			quotaGroupDeref(tls, pGroup)
		}
		quotaLeave(tls)
	}
	sqlite3.Xsqlite3_free(tls, p)
	return rc
}

// Flush memory buffers for a quota_FILE to disk.
func sqlite3_quota_fflush(tls *libc.TLS, p uintptr, doFsync int32) int32 { /* test_quota.c:1082:5: */
	var rc int32
	rc = libc.Xfflush(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	if rc == 0 && doFsync != 0 {
		rc = libc.Xfsync(tls, func() int32 {
			if !(libc.X__isthreaded != 0) {
				return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
			}
			return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
		}())
	}
	return libc.Bool32(rc != 0)
}

// Seek on a quota_FILE stream.
func sqlite3_quota_fseek(tls *libc.TLS, p uintptr, offset int64, whence int32) int32 { /* test_quota.c:1099:5: */
	return libc.Xfseek(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff, offset, whence)
}

// rewind a quota_FILE stream.
func sqlite3_quota_rewind(tls *libc.TLS, p uintptr) { /* test_quota.c:1106:6: */
	libc.Xrewind(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Tell the current location of a quota_FILE stream.
func sqlite3_quota_ftell(tls *libc.TLS, p uintptr) int64 { /* test_quota.c:1113:6: */
	return libc.Xftell(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
}

// Test the error indicator for the given file.
func sqlite3_quota_ferror(tls *libc.TLS, p uintptr) int32 { /* test_quota.c:1120:5: */
	return func() int32 {
		if !(libc.X__isthreaded != 0) {
			return libc.Bool32(int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_flags)&0x0040 != 0)
		}
		return libc.Xferror(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}()
}

// Truncate a file to szNew bytes.
func sqlite3_quota_ftruncate(tls *libc.TLS, p uintptr, szNew sqlite3_int64) int32 { /* test_quota.c:1127:5: */
	var pFile uintptr = (*quota_FILE)(unsafe.Pointer(p)).FpFile
	var rc int32
	if libc.AssignUintptr(&pFile, (*quota_FILE)(unsafe.Pointer(p)).FpFile) != uintptr(0) && (*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew {
		var pGroup uintptr
		if (*quotaFile)(unsafe.Pointer(pFile)).FiSize < szNew {
			// This routine cannot be used to extend a file that is under
			// quota management.  Only true truncation is allowed.
			return -1
		}
		pGroup = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16)) += szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		quotaLeave(tls)
	}
	rc = libc.Xftruncate(tls, func() int32 {
		if !(libc.X__isthreaded != 0) {
			return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
		}
		return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}(), int64(szNew))
	if pFile != 0 && rc == 0 {
		var pGroup uintptr = (*quotaFile)(unsafe.Pointer(pFile)).FpGroup
		quotaEnter(tls)
		*(*sqlite3_int64)(unsafe.Pointer(pGroup + 16)) += szNew - (*quotaFile)(unsafe.Pointer(pFile)).FiSize
		(*quotaFile)(unsafe.Pointer(pFile)).FiSize = szNew
		quotaLeave(tls)
	}
	return rc
}

// Determine the time that the given file was last modified, in
// seconds size 1970.  Write the result into *pTime.  Return 0 on
// success and non-zero on any kind of error.
func sqlite3_quota_file_mtime(tls *libc.TLS, p uintptr, pTime uintptr) int32 { /* test_quota.c:1169:5: */
	bp := tls.Alloc(224)
	defer tls.Free(224)

	var rc int32
	// var buf stat at bp, 224

	rc = libc.Xfstat(tls, func() int32 {
		if !(libc.X__isthreaded != 0) {
			return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
		}
		return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}(), bp)
	if rc == 0 {
		*(*time_t)(unsafe.Pointer(pTime)) = (*stat)(unsafe.Pointer(bp /* &buf */)).Fst_mtim.Ftv_sec
	}
	return rc
}

// Return the true size of the file, as reported by the operating
// system.
func sqlite3_quota_file_truesize(tls *libc.TLS, p uintptr) sqlite3_int64 { /* test_quota.c:1187:15: */
	bp := tls.Alloc(224)
	defer tls.Free(224)

	var rc int32
	// var buf stat at bp, 224

	rc = libc.Xfstat(tls, func() int32 {
		if !(libc.X__isthreaded != 0) {
			return int32((*FILE)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).Ff)).F_file)
		}
		return libc.Xfileno(tls, (*quota_FILE)(unsafe.Pointer(p)).Ff)
	}(), bp)
	if rc == 0 {
		return int64((*stat)(unsafe.Pointer(bp /* &buf */)).Fst_size)
	}
	return int64(-1)
}

// Return the size of the file, as it is known to the quota subsystem.
func sqlite3_quota_file_size(tls *libc.TLS, p uintptr) sqlite3_int64 { /* test_quota.c:1203:15: */
	if (*quota_FILE)(unsafe.Pointer(p)).FpFile != 0 {
		return (*quotaFile)(unsafe.Pointer((*quota_FILE)(unsafe.Pointer(p)).FpFile)).FiSize
	}
	return int64(-1)
}

// Determine the amount of data in bytes available for reading
// in the given file.
func sqlite3_quota_file_available(tls *libc.TLS, p uintptr) int64 { /* test_quota.c:1211:6: */
	var f uintptr = (*quota_FILE)(unsafe.Pointer(p)).Ff
	var pos1 int64
	var pos2 int64
	var rc int32
	pos1 = libc.Xftell(tls, f)
	if pos1 < int64(0) {
		return int64(-1)
	}
	rc = libc.Xfseek(tls, f, int64(0), SEEK_END)
	if rc != 0 {
		return int64(-1)
	}
	pos2 = libc.Xftell(tls, f)
	if pos2 < int64(0) {
		return int64(-1)
	}
	rc = libc.Xfseek(tls, f, pos1, SEEK_SET)
	if rc != 0 {
		return int64(-1)
	}
	return pos2 - pos1
}

// Remove a managed file.  Update quotas accordingly.
func sqlite3_quota_remove(tls *libc.TLS, zFilename uintptr) int32 { /* test_quota.c:1229:5: */
	var zFull uintptr     // Full pathname for zFilename
	var nFull size_t      // Number of bytes in zFilename
	var rc int32          // Result code
	var pGroup uintptr    // Group containing zFilename
	var pFile uintptr     // A file in the group
	var pNextFile uintptr // next file in the group
	var diff int32        // Difference between filenames
	var c int8            // First character past end of pattern

	zFull = sqlite3.Xsqlite3_malloc(tls, gQuota.FsThisVfs.FmxPathname+1)
	if zFull == uintptr(0) {
		return SQLITE_NOMEM
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxFullPathname})).f(tls, gQuota.FpOrigVfs, zFilename,
		gQuota.FsThisVfs.FmxPathname+1, zFull)
	if rc != 0 {
		sqlite3.Xsqlite3_free(tls, zFull)
		return rc
	}

	// Figure out the length of the full pathname.  If the name ends with
	// / (or \ on windows) then remove the trailing /.
	nFull = libc.Xstrlen(tls, zFull)
	if nFull > uint64(0) && (int32(*(*int8)(unsafe.Pointer(zFull + uintptr(nFull-uint64(1))))) == '/' || int32(*(*int8)(unsafe.Pointer(zFull + uintptr(nFull-uint64(1))))) == '\\') {
		nFull--
		*(*int8)(unsafe.Pointer(zFull + uintptr(nFull))) = int8(0)
	}

	quotaEnter(tls)
	pGroup = quotaGroupFind(tls, zFull)
	if pGroup != 0 {
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; pFile != 0 && rc == SQLITE_OK; pFile = pNextFile {
			pNextFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext
			diff = libc.Xstrncmp(tls, zFull, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, nFull)
			if diff == 0 && (int32(libc.AssignInt8(&c, *(*int8)(unsafe.Pointer((*quotaFile)(unsafe.Pointer(pFile)).FzFilename + uintptr(nFull))))) == 0 || int32(c) == '/' || int32(c) == '\\') {
				if (*quotaFile)(unsafe.Pointer(pFile)).FnRef != 0 {
					(*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose = 1
				} else {
					rc = (*struct {
						f func(*libc.TLS, uintptr, uintptr, int32) int32
					})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(gQuota.FpOrigVfs)).FxDelete})).f(tls, gQuota.FpOrigVfs, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename, 0)
					quotaRemoveFile(tls, pFile)
					quotaGroupDeref(tls, pGroup)
				}
			}
		}
	}
	quotaLeave(tls)
	sqlite3.Xsqlite3_free(tls, zFull)
	return rc
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Argument passed to a TCL quota-over-limit callback.
type TclQuotaCallback1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* test_quota.c:1293:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// Argument passed to a TCL quota-over-limit callback.
type TclQuotaCallback = TclQuotaCallback1 /* test_quota.c:1293:33 */

// This is the callback from a quota-over-limit.
func tclQuotaCallback(tls *libc.TLS, zFilename uintptr, piLimit uintptr, iSize sqlite3_int64, pArg uintptr) { /* test_quota.c:1305:13: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var p uintptr        // Callback script object
	var pEval uintptr    // Script to evaluate
	var pVarname uintptr // Name of variable to pass as 2nd arg
	// var rnd uint32 at bp, 4
	// Random part of pVarname
	var rc int32 // Tcl error code

	p = pArg
	if p == uintptr(0) {
		return
	}

	pVarname = tcl.XTcl_NewStringObj(tls, ts+36481 /* "::piLimit_" */, -1)
	(*Tcl_Obj)(unsafe.Pointer(pVarname)).FrefCount++
	sqlite3.Xsqlite3_randomness(tls, int32(unsafe.Sizeof(uint32(0))), bp /* &rnd */)
	tcl.XTcl_AppendObjToObj(tls, pVarname, tcl.XTcl_NewIntObj(tls, int32(*(*uint32)(unsafe.Pointer(bp))&uint32(0x7FFFFFFF))))
	tcl.XTcl_ObjSetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), tcl.XTcl_NewWideIntObj(tls, *(*sqlite3_int64)(unsafe.Pointer(piLimit))), 0)

	pEval = tcl.XTcl_DuplicateObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewStringObj(tls, zFilename, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, pVarname)
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pEval, tcl.XTcl_NewWideIntObj(tls, iSize))
	rc = tcl.XTcl_EvalObjEx(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)

	if rc == TCL_OK {
		// var x Tcl_WideInt at bp+8, 8

		var pLimit uintptr = tcl.XTcl_ObjGetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pVarname, uintptr(0), 0)
		rc = tcl.XTcl_GetWideIntFromObj(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, pLimit, bp+8 /* &x */)
		*(*sqlite3_int64)(unsafe.Pointer(piLimit)) = *(*Tcl_WideInt)(unsafe.Pointer(bp + 8 /* x */))
		tcl.XTcl_UnsetVar2(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetString(tls, pVarname), uintptr(0), 0)
	}

	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pVarname
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*TclQuotaCallback)(unsafe.Pointer(p)).Finterp)
	}
}

// Destructor for a TCL quota-over-limit callback.
func tclCallbackDestructor(tls *libc.TLS, pObj uintptr) { /* test_quota.c:1349:13: */
	var p uintptr = pObj
	if p != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TclQuotaCallback)(unsafe.Pointer(p)).FpScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		sqlite3.Xsqlite3_free(tls, p)
	}
}

// tclcmd: sqlite3_quota_initialize NAME MAKEDEFAULT
func test_quota_initialize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1360:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var zName uintptr // Name of new quota VFS
	// var makeDefault int32 at bp, 4
	// True to make the new VFS the default
	var rc int32 // Value returned by quota_initialize()

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+35370 /* "NAME MAKEDEFAULT" */)
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 {
		return TCL_ERROR
	}
	if int32(*(*int8)(unsafe.Pointer(zName))) == 0 {
		zName = uintptr(0)
	}

	// Call sqlite3_quota_initialize()
	rc = sqlite3_quota_initialize(tls, zName, *(*int32)(unsafe.Pointer(bp /* makeDefault */)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// tclcmd: sqlite3_quota_shutdown
func test_quota_shutdown(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1389:26: */
	var rc int32 // Value returned by quota_shutdown()

	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	// Call sqlite3_quota_shutdown()
	rc = sqlite3_quota_shutdown(tls)
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))

	return TCL_OK
}

// tclcmd: sqlite3_quota_set PATTERN LIMIT SCRIPT
func test_quota_set(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1412:26: */
	bp := tls.Alloc(12)
	defer tls.Free(12)

	var zPattern uintptr // File pattern to configure
	// var iLimit Tcl_WideInt at bp, 8
	// Initial quota in bytes
	var pScript uintptr // Tcl script to invoke to increase quota
	var rc int32        // Value returned by quota_set()
	var p uintptr       // Callback object
	// var nScript int32 at bp+8, 4
	// Length of callback script
	var xDestroy uintptr // Optional destructor for pArg
	var xCallback uintptr

	// Process arguments
	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36492 /* "PATTERN LIMIT SC..." */)
		return TCL_ERROR
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 {
		return TCL_ERROR
	}
	pScript = *(*uintptr)(unsafe.Pointer(objv + 3*8))
	tcl.XTcl_GetStringFromObj(tls, pScript, bp+8 /* &nScript */)

	if *(*int32)(unsafe.Pointer(bp + 8)) > 0 {
		// Allocate a TclQuotaCallback object
		p = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(TclQuotaCallback{})))
		if !(p != 0) {
			tcl.XTcl_SetResult(tls, interp, ts+33299 /* "SQLITE_NOMEM" */, uintptr(0))
			return TCL_OK
		}
		libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(TclQuotaCallback{})))
		(*TclQuotaCallback)(unsafe.Pointer(p)).Finterp = interp
		(*Tcl_Obj)(unsafe.Pointer(pScript)).FrefCount++
		(*TclQuotaCallback)(unsafe.Pointer(p)).FpScript = pScript
		xDestroy = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{tclCallbackDestructor}))
		xCallback = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_int64, uintptr)
		}{tclQuotaCallback}))
	} else {
		p = uintptr(0)
		xDestroy = uintptr(0)
		xCallback = uintptr(0)
	}

	// Invoke sqlite3_quota_set()
	rc = sqlite3_quota_set(tls, zPattern, *(*Tcl_WideInt)(unsafe.Pointer(bp /* iLimit */)), xCallback, p, xDestroy)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file FILENAME
func test_quota_file(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1466:26: */
	var zFilename uintptr // File pattern to configure
	var rc int32          // Value returned by quota_file()

	// Process arguments
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33483 /* "FILENAME" */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))

	// Invoke sqlite3_quota_file()
	rc = sqlite3_quota_file(tls, zFilename)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// tclcmd:  sqlite3_quota_dump
func test_quota_dump(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1492:26: */
	bp := tls.Alloc(1008)
	defer tls.Free(1008)

	var pResult uintptr
	var pGroupTerm uintptr
	var pFileTerm uintptr
	var pGroup uintptr
	var pFile uintptr

	pResult = tcl.XTcl_NewObj(tls)
	quotaEnter(tls)
	for pGroup = gQuota.FpGroup; pGroup != 0; pGroup = (*quotaGroup)(unsafe.Pointer(pGroup)).FpNext {
		pGroupTerm = tcl.XTcl_NewObj(tls)
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewStringObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FzPattern, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FiLimit))
		tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm,
			tcl.XTcl_NewWideIntObj(tls, (*quotaGroup)(unsafe.Pointer(pGroup)).FiSize))
		for pFile = (*quotaGroup)(unsafe.Pointer(pGroup)).FpFiles; pFile != 0; pFile = (*quotaFile)(unsafe.Pointer(pFile)).FpNext {
			var i int32
			// var zTemp [1000]int8 at bp+8, 1000

			pFileTerm = tcl.XTcl_NewObj(tls)
			sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([1000]int8{})), bp+8 /* &zTemp[0] */, ts /* "%s" */, libc.VaList(bp, (*quotaFile)(unsafe.Pointer(pFile)).FzFilename))
			for i = 0; *(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i))) != 0; i++ {
				if int32(*(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i)))) == '\\' {
					*(*int8)(unsafe.Pointer(bp + 8 /* &zTemp[0] */ + uintptr(i))) = int8('/')
				}
			}
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewStringObj(tls, bp+8 /* &zTemp[0] */, -1))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, (*quotaFile)(unsafe.Pointer(pFile)).FiSize))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FnRef)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pFileTerm,
				tcl.XTcl_NewWideIntObj(tls, int64((*quotaFile)(unsafe.Pointer(pFile)).FdeleteOnClose)))
			tcl.XTcl_ListObjAppendElement(tls, interp, pGroupTerm, pFileTerm)
		}
		tcl.XTcl_ListObjAppendElement(tls, interp, pResult, pGroupTerm)
	}
	quotaLeave(tls)
	tcl.XTcl_SetObjResult(tls, interp, pResult)
	return TCL_OK
}

// tclcmd: sqlite3_quota_fopen FILENAME MODE
func test_quota_fopen(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1540:26: */
	bp := tls.Alloc(58)
	defer tls.Free(58)

	var zFilename uintptr // File pattern to configure
	var zMode uintptr     // Mode string
	var p uintptr         // Open string object
	// var zReturn [50]int8 at bp+8, 50
	// Name of pointer to return

	// Process arguments
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36513 /* "FILENAME MODE" */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zMode = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	p = sqlite3_quota_fopen(tls, zFilename, zMode)
	sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+8 /* &zReturn[0] */, ts+10721 /* "%p" */, libc.VaList(bp, p))
	tcl.XTcl_SetResult(tls, interp, bp+8 /* &zReturn[0] */, uintptr(1))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fread HANDLE SIZE NELEM
func test_quota_fread(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1570:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr
	// var sz int32 at bp, 4

	// var nElem int32 at bp+4, 4

	var got size_t

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36527 /* "HANDLE SIZE NELE..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+4) != 0 {
		return TCL_ERROR
	}
	zBuf = sqlite3.Xsqlite3_malloc(tls, *(*int32)(unsafe.Pointer(bp))**(*int32)(unsafe.Pointer(bp + 4))+1)
	if zBuf == uintptr(0) {
		tcl.XTcl_SetResult(tls, interp, ts+2069 /* "out of memory" */, uintptr(0))
		return TCL_ERROR
	}
	got = sqlite3_quota_fread(tls, zBuf, uint64(*(*int32)(unsafe.Pointer(bp /* sz */))), uint64(*(*int32)(unsafe.Pointer(bp + 4 /* nElem */))), p)
	*(*int8)(unsafe.Pointer(zBuf + uintptr(got*size_t(*(*int32)(unsafe.Pointer(bp)))))) = int8(0)
	tcl.XTcl_SetResult(tls, interp, zBuf, uintptr(1))
	sqlite3.Xsqlite3_free(tls, zBuf)
	return TCL_OK
}

// tclcmd: sqlite3_quota_fwrite HANDLE SIZE NELEM CONTENT
func test_quota_fwrite(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1604:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var zBuf uintptr
	// var sz int32 at bp, 4

	// var nElem int32 at bp+4, 4

	var got size_t

	if objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36545 /* "HANDLE SIZE NELE..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 {
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+4) != 0 {
		return TCL_ERROR
	}
	zBuf = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))
	got = sqlite3_quota_fwrite(tls, zBuf, uint64(*(*int32)(unsafe.Pointer(bp /* sz */))), uint64(*(*int32)(unsafe.Pointer(bp + 4 /* nElem */))), p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(got)))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fclose HANDLE
func test_quota_fclose(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1632:26: */
	var p uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	rc = sqlite3_quota_fclose(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fflush HANDLE ?HARDSYNC?
func test_quota_fflush(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1654:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	var rc int32
	*(*int32)(unsafe.Pointer(bp /* doSync */)) = 0

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36571 /* "HANDLE ?HARDSYNC..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	if objc == 3 {
		if tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 {
			return TCL_ERROR
		}
	}
	rc = sqlite3_quota_fflush(tls, p, *(*int32)(unsafe.Pointer(bp /* doSync */)))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_fseek HANDLE OFFSET WHENCE
func test_quota_fseek(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1680:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var p uintptr
	// var ofst int32 at bp+16, 4

	var zWhence uintptr
	var whence int32
	var rc int32

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36589 /* "HANDLE OFFSET WH..." */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+16) != 0 {
		return TCL_ERROR
	}
	zWhence = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	if libc.Xstrcmp(tls, zWhence, ts+36610) == 0 {
		whence = SEEK_SET
	} else if libc.Xstrcmp(tls, zWhence, ts+36619) == 0 {
		whence = SEEK_CUR
	} else if libc.Xstrcmp(tls, zWhence, ts+36628) == 0 {
		whence = SEEK_END
	} else {
		tcl.XTcl_AppendResult(tls, interp,
			libc.VaList(bp, ts+36637 /* "WHENCE should be..." */, uintptr(0)))
		return TCL_ERROR
	}
	rc = sqlite3_quota_fseek(tls, p, int64(*(*int32)(unsafe.Pointer(bp + 16 /* ofst */))), whence)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_rewind HANDLE
func test_quota_rewind(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1718:26: */
	var p uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	sqlite3_quota_rewind(tls, p)
	return TCL_OK
}

// tclcmd: sqlite3_quota_ftell HANDLE
func test_quota_ftell(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1737:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	x = sqlite3_int64(sqlite3_quota_ftell(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_ftruncate HANDLE SIZE
func test_quota_ftruncate(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1758:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	var x sqlite3_int64
	// var w Tcl_WideInt at bp, 8

	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36686 /* "HANDLE SIZE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	if tcl.XTcl_GetWideIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 {
		return TCL_ERROR
	}
	x = *(*Tcl_WideInt)(unsafe.Pointer(bp /* w */))
	rc = sqlite3_quota_ftruncate(tls, p, x)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_size HANDLE
func test_quota_file_size(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1783:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	x = sqlite3_quota_file_size(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_truesize HANDLE
func test_quota_file_truesize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1804:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	x = sqlite3_quota_file_truesize(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_mtime HANDLE
func test_quota_file_mtime(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1825:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr
	// var t time_t at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	*(*time_t)(unsafe.Pointer(bp /* t */)) = int64(0)
	sqlite3_quota_file_mtime(tls, p, bp /* &t */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, int64(*(*time_t)(unsafe.Pointer(bp /* t */)))))
	return TCL_OK
}

// tclcmd: sqlite3_quota_remove FILENAME
func test_quota_remove(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1848:26: */
	var zFilename uintptr // File pattern to configure
	var rc int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33483 /* "FILENAME" */)
		return TCL_ERROR
	}
	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	rc = sqlite3_quota_remove(tls, zFilename)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_glob PATTERN TEXT
//
// Test the glob pattern matching.  Return 1 if TEXT matches PATTERN
// and return 0 if it does not.
func test_quota_glob(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1872:26: */
	var zPattern uintptr // The glob pattern
	var zText uintptr    // Text to compare agains the pattern
	var rc int32
	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+36698 /* "PATTERN TEXT" */)
		return TCL_ERROR
	}
	zPattern = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	zText = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	rc = quotaStrglob(tls, zPattern, zText)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, rc))
	return TCL_OK
}

// tclcmd: sqlite3_quota_file_available HANDLE
//
// Return the number of bytes from the current file point to the end of
// the file.
func test_quota_file_available(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1898:26: */
	var p uintptr
	var x sqlite3_int64
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	x = sqlite3_int64(sqlite3_quota_file_available(tls, p))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewWideIntObj(tls, x))
	return TCL_OK
}

// tclcmd: sqlite3_quota_ferror HANDLE
//
// Return true if the file handle is in the error state.
func test_quota_ferror(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_quota.c:1921:26: */
	var p uintptr
	var x int32
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+29210 /* "HANDLE" */)
		return TCL_ERROR
	}
	p = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	x = sqlite3_quota_ferror(tls, p)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, x))
	return TCL_OK
}

// This routine registers the custom TCL commands defined in this
// module.  This should be the only procedure visible from outside
// of this module.
func Sqlitequota_Init(tls *libc.TLS, interp uintptr) int32 { /* test_quota.c:1944:5: */
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aCmd9))/uint64(unsafe.Sizeof(struct {
		FzName uintptr
		FxProc uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aCmd9[i].FzName, aCmd9[i].FxProc, uintptr(0), uintptr(0))
	}

	return TCL_OK
}

var aCmd9 = [21]struct {
	FzName uintptr
	FxProc uintptr
}{
	{FzName: ts + 36711 /* "sqlite3_quota_in..." */, FxProc: 0},
	{FzName: ts + 36736 /* "sqlite3_quota_sh..." */, FxProc: 0},
	{FzName: ts + 36759 /* "sqlite3_quota_se..." */, FxProc: 0},
	{FzName: ts + 36777 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 36796 /* "sqlite3_quota_du..." */, FxProc: 0},
	{FzName: ts + 36815 /* "sqlite3_quota_fo..." */, FxProc: 0},
	{FzName: ts + 36835 /* "sqlite3_quota_fr..." */, FxProc: 0},
	{FzName: ts + 36855 /* "sqlite3_quota_fw..." */, FxProc: 0},
	{FzName: ts + 36876 /* "sqlite3_quota_fc..." */, FxProc: 0},
	{FzName: ts + 36897 /* "sqlite3_quota_ff..." */, FxProc: 0},
	{FzName: ts + 36918 /* "sqlite3_quota_fs..." */, FxProc: 0},
	{FzName: ts + 36938 /* "sqlite3_quota_re..." */, FxProc: 0},
	{FzName: ts + 36959 /* "sqlite3_quota_ft..." */, FxProc: 0},
	{FzName: ts + 36979 /* "sqlite3_quota_ft..." */, FxProc: 0},
	{FzName: ts + 37003 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 37027 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 37055 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 37080 /* "sqlite3_quota_re..." */, FxProc: 0},
	{FzName: ts + 37101 /* "sqlite3_quota_gl..." */, FxProc: 0},
	{FzName: ts + 37120 /* "sqlite3_quota_fi..." */, FxProc: 0},
	{FzName: ts + 37149 /* "sqlite3_quota_fe..." */, FxProc: 0},
} /* test_quota.c:1948:5 */

// Type used to cache parameter information for the "circle" r-tree geometry
// callback.
type Circle1 = struct {
	FaBox [2]struct {
		Fxmin float64
		Fxmax float64
		Fymin float64
		Fymax float64
	}
	Fcenterx     float64
	Fcentery     float64
	Fradius      float64
	FmxArea      float64
	FeScoreType  int32
	F__ccgo_pad1 [4]byte
} /* test_rtree.c:31:9 */

// Type used to cache parameter information for the "circle" r-tree geometry
// callback.
type Circle = Circle1 /* test_rtree.c:31:23 */
type Box = struct {
	Fxmin float64
	Fxmax float64
	Fymin float64
	Fymax float64
} /* test_rtree.c:31:9 */

// Destructor function for Circle objects allocated by circle_geom().
func circle_del(tls *libc.TLS, p uintptr) { /* test_rtree.c:49:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

// Implementation of "circle" r-tree geometry callback.
func circle_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, pRes uintptr) int32 { /* test_rtree.c:56:12: */
	var i int32         // Iterator variable
	var pCircle uintptr // Structure defining circular region
	var xmin float64
	var xmax float64 // X dimensions of box being tested
	var ymin float64
	var ymax float64 // X dimensions of box being tested

	xmin = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord))
	xmax = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 1*8))
	ymin = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 2*8))
	ymax = *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 3*8))
	pCircle = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser
	if pCircle == uintptr(0) {
		// If pUser is still 0, then the parameter values have not been tested
		// for correctness or stored into a Circle structure yet. Do this now.

		// This geometry callback is for use with a 2-dimensional r-tree table.
		// Return an error if the table does not have exactly 2 dimensions.
		if nCoord != 4 {
			return SQLITE_ERROR
		}

		// Test that the correct number of parameters (3) have been supplied,
		// and that the parameters are in range (that the radius of the circle
		// radius is greater than zero).
		if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != 3 || *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8)) < 0.0 {
			return SQLITE_ERROR
		}

		// Allocate a structure to cache parameter data in. Return SQLITE_NOMEM
		// if the allocation fails.
		pCircle = libc.AssignPtrUintptr(p+24, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Circle{}))))
		if !(pCircle != 0) {
			return SQLITE_NOMEM
		}
		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{circle_del}))

		// Record the center and radius of the circular region. One way that
		// tested bounding boxes that intersect the circular region are detected
		// is by testing if each corner of the bounding box lies within radius
		// units of the center of the circle.
		(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam))
		(*Circle)(unsafe.Pointer(pCircle)).Fcentery = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 1*8))
		(*Circle)(unsafe.Pointer(pCircle)).Fradius = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8))

		// Define two bounding box regions. The first, aBox[0], extends to
		// infinity in the X dimension. It covers the same range of the Y dimension
		// as the circular region. The second, aBox[1], extends to infinity in
		// the Y dimension and is constrained to the range of the circle in the
		// X dimension.
		//
		// Then imagine each box is split in half along its short axis by a line
		// that intersects the center of the circular region. A bounding box
		// being tested can be said to intersect the circular region if it contains
		// points from each half of either of the two infinite bounding boxes.
		(*Box)(unsafe.Pointer(pCircle)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Circle)(unsafe.Pointer(pCircle)).FmxArea = (xmax-xmin)*(ymax-ymin) + 1.0
	}

	// Check if any of the 4 corners of the bounding-box being tested lie
	// inside the circular region. If they do, then the bounding-box does
	// intersect the region of interest. Set the output variable to true and
	// return SQLITE_OK in this case.
	for i = 0; i < 4; i++ {
		var x float64
		if i&0x01 != 0 {
			x = xmax
		} else {
			x = xmin
		}
		var y float64
		if i&0x02 != 0 {
			y = ymax
		} else {
			y = ymin
		}
		var d2 float64

		d2 = (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx) * (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx)
		d2 = d2 + (y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)*(y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)
		if d2 < (*Circle)(unsafe.Pointer(pCircle)).Fradius*(*Circle)(unsafe.Pointer(pCircle)).Fradius {
			*(*int32)(unsafe.Pointer(pRes)) = 1
			return SQLITE_OK
		}
	}

	// Check if the bounding box covers any other part of the circular region.
	// See comments above for a description of how this test works. If it does
	// cover part of the circular region, set the output variable to true
	// and return SQLITE_OK.
	for i = 0; i < 2; i++ {
		if xmin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmin &&
			xmax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmax &&
			ymin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymin &&
			ymax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymax {
			*(*int32)(unsafe.Pointer(pRes)) = 1
			return SQLITE_OK
		}
	}

	// The specified bounding box does not intersect the circular region. Set
	// the output variable to zero and return SQLITE_OK.
	*(*int32)(unsafe.Pointer(pRes)) = 0
	return SQLITE_OK
}

// Implementation of "circle" r-tree geometry callback using the
// 2nd-generation interface that allows scoring.
//
// Two calling forms:
//
//          Qcircle(X,Y,Radius,eType)        -- All values are doubles
//          Qcircle('x:X y:Y r:R e:ETYPE')   -- Single string parameter
func circle_query_func(tls *libc.TLS, p uintptr) int32 { /* test_rtree.c:168:12: */
	var i int32         // Iterator variable
	var pCircle uintptr // Structure defining circular region
	var xmin float64
	var xmax float64 // X dimensions of box being tested
	var ymin float64
	var ymax float64      // X dimensions of box being tested
	var nWithin int32 = 0 // Number of corners inside the circle

	xmin = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord))
	xmax = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 1*8))
	ymin = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 2*8))
	ymax = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 3*8))
	pCircle = (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FpUser
	if pCircle == uintptr(0) {
		// If pUser is still 0, then the parameter values have not been tested
		// for correctness or stored into a Circle structure yet. Do this now.

		// This geometry callback is for use with a 2-dimensional r-tree table.
		// Return an error if the table does not have exactly 2 dimensions.
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnCoord != 4 {
			return SQLITE_ERROR
		}

		// Test that the correct number of parameters (1 or 4) have been supplied.
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 4 && (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 1 {
			return SQLITE_ERROR
		}

		// Allocate a structure to cache parameter data in. Return SQLITE_NOMEM
		// if the allocation fails.
		pCircle = libc.AssignPtrUintptr(p+24, sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Circle{}))))
		if !(pCircle != 0) {
			return SQLITE_NOMEM
		}
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{circle_del}))

		// Record the center and radius of the circular region. One way that
		// tested bounding boxes that intersect the circular region are detected
		// is by testing if each corner of the bounding box lies within radius
		// units of the center of the circle.
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam == 4 {
			(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam))
			(*Circle)(unsafe.Pointer(pCircle)).Fcentery = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 1*8))
			(*Circle)(unsafe.Pointer(pCircle)).Fradius = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 2*8))
			(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = libc.Int32FromFloat64(*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 3*8)))
		} else {
			var z uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FapSqlParam)))
			(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).Fcentery = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).Fradius = 0.0
			(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = 0
			for z != 0 && *(*int8)(unsafe.Pointer(z)) != 0 {
				if int32(*(*int8)(unsafe.Pointer(z))) == 'r' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).Fradius = libc.Xatof(tls, z+2)
				} else if int32(*(*int8)(unsafe.Pointer(z))) == 'x' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).Fcenterx = libc.Xatof(tls, z+2)
				} else if int32(*(*int8)(unsafe.Pointer(z))) == 'y' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).Fcentery = libc.Xatof(tls, z+2)
				} else if int32(*(*int8)(unsafe.Pointer(z))) == 'e' && int32(*(*int8)(unsafe.Pointer(z + 1))) == ':' {
					(*Circle)(unsafe.Pointer(pCircle)).FeScoreType = libc.Int32FromFloat64(libc.Xatof(tls, z+2))
				} else if int32(*(*int8)(unsafe.Pointer(z))) == ' ' {
					z++
					continue
				}
				for int32(*(*int8)(unsafe.Pointer(z))) != 0 && int32(*(*int8)(unsafe.Pointer(z))) != ' ' {
					z++
				}
				for int32(*(*int8)(unsafe.Pointer(z))) == ' ' {
					z++
				}
			}
		}
		if (*Circle)(unsafe.Pointer(pCircle)).Fradius < 0.0 {
			sqlite3.Xsqlite3_free(tls, pCircle)
			return SQLITE_NOMEM
		}

		// Define two bounding box regions. The first, aBox[0], extends to
		// infinity in the X dimension. It covers the same range of the Y dimension
		// as the circular region. The second, aBox[1], extends to infinity in
		// the Y dimension and is constrained to the range of the circle in the
		// X dimension.
		//
		// Then imagine each box is split in half along its short axis by a line
		// that intersects the center of the circular region. A bounding box
		// being tested can be said to intersect the circular region if it contains
		// points from each half of either of the two infinite bounding boxes.
		(*Box)(unsafe.Pointer(pCircle)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx
		(*Box)(unsafe.Pointer(pCircle)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmin = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx + (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fxmax = (*Circle)(unsafe.Pointer(pCircle)).Fcenterx - (*Circle)(unsafe.Pointer(pCircle)).Fradius
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymin = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Box)(unsafe.Pointer(pCircle + 1*32)).Fymax = (*Circle)(unsafe.Pointer(pCircle)).Fcentery
		(*Circle)(unsafe.Pointer(pCircle)).FmxArea = float64(200.0) * 200.0
	}

	// Check if any of the 4 corners of the bounding-box being tested lie
	// inside the circular region. If they do, then the bounding-box does
	// intersect the region of interest. Set the output variable to true and
	// return SQLITE_OK in this case.
	for i = 0; i < 4; i++ {
		var x float64
		if i&0x01 != 0 {
			x = xmax
		} else {
			x = xmin
		}
		var y float64
		if i&0x02 != 0 {
			y = ymax
		} else {
			y = ymin
		}
		var d2 float64

		d2 = (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx) * (x - (*Circle)(unsafe.Pointer(pCircle)).Fcenterx)
		d2 = d2 + (y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)*(y-(*Circle)(unsafe.Pointer(pCircle)).Fcentery)
		if d2 < (*Circle)(unsafe.Pointer(pCircle)).Fradius*(*Circle)(unsafe.Pointer(pCircle)).Fradius {
			nWithin++
		}
	}

	// Check if the bounding box covers any other part of the circular region.
	// See comments above for a description of how this test works. If it does
	// cover part of the circular region, set the output variable to true
	// and return SQLITE_OK.
	if nWithin == 0 {
		for i = 0; i < 2; i++ {
			if xmin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmin &&
				xmax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fxmax &&
				ymin <= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymin &&
				ymax >= (*Box)(unsafe.Pointer(pCircle+uintptr(i)*32)).Fymax {
				nWithin = 1
				break
			}
		}
	}

	if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 1 {
		// Depth first search
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 2 {
		// Breadth first search
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 3 {
		// Depth-first search, except sort the leaf nodes by area with
		// the largest area first
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel == 1 {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 1.0 - (xmax-xmin)*(ymax-ymin)/(*Circle)(unsafe.Pointer(pCircle)).FmxArea
			if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore < 0.01 {
				(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 0.01
			}
		} else {
			(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = 0.0
		}
	} else if (*Circle)(unsafe.Pointer(pCircle)).FeScoreType == 4 {
		// Depth-first search, except exclude odd rowids
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiRowid&int64(1) != 0 {
			nWithin = 0
		}
	} else {
		// Breadth-first search, except exclude odd rowids
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
		if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiRowid&int64(1) != 0 {
			nWithin = 0
		}
	}
	if nWithin == 0 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = NOT_WITHIN
	} else if nWithin >= 4 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = PARTLY_WITHIN
	}
	return SQLITE_OK
}

// Implementation of "breadthfirstsearch" r-tree geometry callback using the
// 2nd-generation interface that allows scoring.
//
//     ... WHERE id MATCH breadthfirstsearch($x0,$x1,$y0,$y1) ...
//
// It returns all entries whose bounding boxes overlap with $x0,$x1,$y0,$y1.
func bfs_query_func(tls *libc.TLS, p uintptr) int32 { /* test_rtree.c:329:12: */
	var x0 float64
	var x1 float64
	var y0 float64
	var y1 float64 // Dimensions of box being tested
	var bx0 float64
	var bx1 float64
	var by0 float64
	var by1 float64 // Boundary of the query function

	if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FnParam != 4 {
		return SQLITE_ERROR
	}
	x0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord))
	x1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 1*8))
	y0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 2*8))
	y1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaCoord + 3*8))
	bx0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam))
	bx1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 1*8))
	by0 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 2*8))
	by1 = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FaParam + 3*8))
	(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FrScore = sqlite3_rtree_dbl(100 - (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FiLevel)
	if (*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeParentWithin == FULLY_WITHIN {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else if x0 >= bx0 && x1 <= bx1 && y0 >= by0 && y1 <= by1 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = FULLY_WITHIN
	} else if x1 >= bx0 && x0 <= bx1 && y1 >= by0 && y0 <= by1 {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = PARTLY_WITHIN
	} else {
		(*sqlite3_rtree_query_info)(unsafe.Pointer(p)).FeWithin = NOT_WITHIN
	}
	return SQLITE_OK
}

// END of implementation of "circle" geometry callback.
//
//

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)assert.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Unlike other ANSI header files, <assert.h> may usefully be included
// multiple times, with and without NDEBUG defined.

// tcl.h --
//
//	This header file describes the externally-visible facilities of the
//	Tcl interpreter.
//
// Copyright (c) 1987-1994 The Regents of the University of California.
// Copyright (c) 1993-1996 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-2000 by Scriptics Corporation.
// Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Cube1 = struct {
	Fx      float64
	Fy      float64
	Fz      float64
	Fwidth  float64
	Fheight float64
	Fdepth  float64
} /* test_rtree.c:366:9 */

// END of implementation of "circle" geometry callback.
//
//

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)assert.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Unlike other ANSI header files, <assert.h> may usefully be included
// multiple times, with and without NDEBUG defined.

// tcl.h --
//
//	This header file describes the externally-visible facilities of the
//	Tcl interpreter.
//
// Copyright (c) 1987-1994 The Regents of the University of California.
// Copyright (c) 1993-1996 Lucent Technologies.
// Copyright (c) 1994-1998 Sun Microsystems, Inc.
// Copyright (c) 1998-2000 by Scriptics Corporation.
// Copyright (c) 2002 by Kevin B. Kenny.  All rights reserved.
//
// See the file "license.terms" for information on usage and redistribution of
// this file, and for a DISCLAIMER OF ALL WARRANTIES.

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Cube = Cube1 /* test_rtree.c:366:21 */

func cube_context_free(tls *libc.TLS, p uintptr) { /* test_rtree.c:376:13: */
	sqlite3.Xsqlite3_free(tls, p)
}

// The context pointer registered along with the 'cube' callback is
// always ((void *)&gHere). This is just to facilitate testing, it is not
// actually used for anything.
var gHere int32 = 42 /* test_rtree.c:385:12 */

// Implementation of a simple r-tree geom callback to test for intersection
// of r-tree rows with a "cube" shape. Cubes are defined by six scalar
// coordinates as follows:
//
//   cube(x, y, z, width, height, depth)
//
// The width, height and depth parameters must all be greater than zero.
func cube_geom(tls *libc.TLS, p uintptr, nCoord int32, aCoord uintptr, piRes uintptr) int32 { /* test_rtree.c:396:12: */
	var pCube uintptr = (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser

	if pCube == uintptr(0) {
		if (*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FnParam != 6 || nCoord != 6 ||
			*(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 3*8)) <= 0.0 || *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 4*8)) <= 0.0 || *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 5*8)) <= 0.0 {
			return SQLITE_ERROR
		}
		pCube = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Cube{})))
		if !(pCube != 0) {
			return SQLITE_NOMEM
		}
		(*Cube)(unsafe.Pointer(pCube)).Fx = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam))
		(*Cube)(unsafe.Pointer(pCube)).Fy = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 1*8))
		(*Cube)(unsafe.Pointer(pCube)).Fz = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 2*8))
		(*Cube)(unsafe.Pointer(pCube)).Fwidth = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 3*8))
		(*Cube)(unsafe.Pointer(pCube)).Fheight = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 4*8))
		(*Cube)(unsafe.Pointer(pCube)).Fdepth = *(*sqlite3_rtree_dbl)(unsafe.Pointer((*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FaParam + 5*8))

		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FpUser = pCube
		(*sqlite3_rtree_geometry)(unsafe.Pointer(p)).FxDelUser = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{cube_context_free}))
	}

	*(*int32)(unsafe.Pointer(piRes)) = 0
	if *(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord)) <= (*Cube)(unsafe.Pointer(pCube)).Fx+(*Cube)(unsafe.Pointer(pCube)).Fwidth &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 1*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fx &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 2*8)) <= (*Cube)(unsafe.Pointer(pCube)).Fy+(*Cube)(unsafe.Pointer(pCube)).Fheight &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 3*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fy &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 4*8)) <= (*Cube)(unsafe.Pointer(pCube)).Fz+(*Cube)(unsafe.Pointer(pCube)).Fdepth &&
		*(*sqlite3_rtree_dbl)(unsafe.Pointer(aCoord + 5*8)) >= (*Cube)(unsafe.Pointer(pCube)).Fz {
		*(*int32)(unsafe.Pointer(piRes)) = 1
	}

	return SQLITE_OK
}

func register_cube_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtree.c:443:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+37170 /* "cube" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{cube_geom})), uintptr(unsafe.Pointer(&gHere)))
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func register_circle_geom(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_rtree.c:471:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	rc = sqlite3.Xsqlite3_rtree_geometry_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+37175 /* "circle" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32
	}{circle_geom})), uintptr(0))
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_rtree_query_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+37182, /* "Qcircle" */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) int32
			}{circle_query_func})), uintptr(0), uintptr(0))
	}
	if rc == SQLITE_OK {
		rc = sqlite3.Xsqlite3_rtree_query_callback(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+37190, /* "breadthfirstsear..." */
			*(*uintptr)(unsafe.Pointer(&struct {
				f func(*libc.TLS, uintptr) int32
			}{bfs_query_func})), uintptr(0), uintptr(0))
	}
	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

func Sqlitetestrtree_Init(tls *libc.TLS, interp uintptr) int32 { /* test_rtree.c:507:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37209 /* "register_cube_ge..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_cube_geom})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37228 /* "register_circle_..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{register_circle_geom})), uintptr(0), uintptr(0))
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)assert.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Unlike other ANSI header files, <assert.h> may usefully be included
// multiple times, with and without NDEBUG defined.

type schema_vtab1 = struct {
	Fbase sqlite3_vtab
	Fdb   uintptr
} /* test_schema.c:53:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1992, 1993
//	The Regents of the University of California.  All rights reserved.
// (c) UNIX System Laboratories, Inc.
// All or some portions of this file are derived from material licensed
// to the University of California by American Telephone and Telegraph
// Co. or Unix System Laboratories, Inc. and are reproduced herein with
// the permission of UNIX System Laboratories, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)assert.h	8.2 (Berkeley) 1/21/94
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// Unlike other ANSI header files, <assert.h> may usefully be included
// multiple times, with and without NDEBUG defined.

type schema_vtab = schema_vtab1 /* test_schema.c:53:28 */
type schema_cursor1 = struct {
	Fbase        sqlite3_vtab_cursor
	FpDbList     uintptr
	FpTableList  uintptr
	FpColumnList uintptr
	Frowid       int32
	F__ccgo_pad1 [4]byte
} /* test_schema.c:54:9 */

type schema_cursor = schema_cursor1 /* test_schema.c:54:30 */

// None of this works unless we have virtual tables.

// Table destructor for the schema module.
func schemaDestroy(tls *libc.TLS, pVtab uintptr) int32 { /* test_schema.c:79:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return 0
}

// Table constructor for the schema module.
func schemaCreate(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_schema.c:87:12: */
	var rc int32 = SQLITE_NOMEM
	var pVtab uintptr = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_vtab{})))
	if pVtab != 0 {
		libc.Xmemset(tls, pVtab, 0, uint64(unsafe.Sizeof(schema_vtab{})))
		(*schema_vtab)(unsafe.Pointer(pVtab)).Fdb = db
		rc = sqlite3.Xsqlite3_declare_vtab(tls, db /* Name of database (i.e. main, temp etc.) */ /* Name of table */ /* Column number (from left-to-right, 0 upward) */ /* Column name */ /* Specified type (i.e. VARCHAR(32)) */ /* Boolean. True if NOT NULL was specified */ /* Default value for this column */ /* True if this column is part of the primary key */, ts+37249 /* "CREATE TABLE x(d..." */)
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	return rc
}

// Open a new cursor on the schema table.
func schemaOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_schema.c:110:12: */
	var rc int32 = SQLITE_NOMEM
	var pCur uintptr
	pCur = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(schema_cursor{})))
	if pCur != 0 {
		libc.Xmemset(tls, pCur, 0, uint64(unsafe.Sizeof(schema_cursor{})))
		*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
		rc = SQLITE_OK
	}
	return rc
}

// Close a schema table cursor.
func schemaClose(tls *libc.TLS, cur uintptr) int32 { /* test_schema.c:125:12: */
	var pCur uintptr = cur
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList)
	sqlite3.Xsqlite3_finalize(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList)
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Retrieve a column of data.
func schemaColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_schema.c:137:12: */
	var pCur uintptr = cur
	switch i {
	case 0:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1))
		break
	case 1:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0))
		break
	default:
		sqlite3.Xsqlite3_result_value(tls, ctx, sqlite3.Xsqlite3_column_value(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList, i-2))
		break
	}
	return SQLITE_OK
}

// Retrieve the current rowid.
func schemaRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_schema.c:156:12: */
	var pCur uintptr = cur
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = sqlite_int64((*schema_cursor)(unsafe.Pointer(pCur)).Frowid)
	return SQLITE_OK
}

func finalize(tls *libc.TLS, ppStmt uintptr) int32 { /* test_schema.c:162:12: */
	var rc int32 = sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(ppStmt)))
	*(*uintptr)(unsafe.Pointer(ppStmt)) = uintptr(0)
	return rc
}

func schemaEof(tls *libc.TLS, cur uintptr) int32 { /* test_schema.c:168:12: */
	var pCur uintptr = cur
	return func() int32 {
		if (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList != 0 {
			return 0
		}
		return 1
	}()
}

// Advance the cursor to the next row.
func schemaNext(tls *libc.TLS, cur uintptr) int32 { /* test_schema.c:176:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	var pCur uintptr
	var pVtab uintptr
	var zSql uintptr
	var pDbList uintptr
	rc = SQLITE_OK
	pCur = cur
	pVtab = (*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab
	zSql = uintptr(0)

__1:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList) != 0) || SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpColumnList)) {
		goto __2
	}
	if !(SQLITE_OK != libc.AssignInt32(&rc, finalize(tls, pCur+24))) {
		goto __3
	}
	goto next_exit
__3:
	;

__4:
	if !(!(int32((*schema_cursor)(unsafe.Pointer(pCur)).FpTableList) != 0) || SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList)) {
		goto __5
	}
	if !(SQLITE_OK != libc.AssignInt32(&rc, finalize(tls, pCur+16))) {
		goto __6
	}
	goto next_exit
__6:
	;

__7:
	if !(SQLITE_ROW != sqlite3.Xsqlite3_step(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList)) {
		goto __8
	}
	rc = finalize(tls, pCur+8)
	goto next_exit
	goto __7
__8:
	;

	// Set zSql to the SQL to pull the list of tables from the
	// sqlite_schema (or sqlite_temp_schema) table of the database
	// identified by the row pointed to by the SQL statement pCur->pDbList
	// (iterating through a "PRAGMA database_list;" statement).
	if !(sqlite3.Xsqlite3_column_int(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 0) == 1) {
		goto __9
	}
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+37321 /* "SELECT name FROM..." */, 0)
	goto __10
__9:
	pDbList = (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList
	zSql = sqlite3.Xsqlite3_mprintf(tls,
		ts+37376, /* "SELECT name FROM..." */
		libc.VaList(bp, sqlite3.Xsqlite3_column_text(tls, pDbList, 1)))
__10:
	;
	if !!(zSql != 0) {
		goto __11
	}
	rc = SQLITE_NOMEM
	goto next_exit
__11:
	;

	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, pCur+16, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != SQLITE_OK) {
		goto __12
	}
	goto next_exit
__12:
	;
	goto __4
__5:
	;

	// Set zSql to the SQL to the table_info pragma for the table currently
	// identified by the rows pointed to by statements pCur->pDbList and
	// pCur->pTableList.
	zSql = sqlite3.Xsqlite3_mprintf(tls, ts+37429, /* "PRAGMA %Q.table_..." */
		libc.VaList(bp+8, sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpDbList, 1),
			sqlite3.Xsqlite3_column_text(tls, (*schema_cursor)(unsafe.Pointer(pCur)).FpTableList, 0)))

	if !!(zSql != 0) {
		goto __13
	}
	rc = SQLITE_NOMEM
	goto next_exit
__13:
	;
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, zSql, -1, pCur+24, uintptr(0))
	sqlite3.Xsqlite3_free(tls, zSql)
	if !(rc != SQLITE_OK) {
		goto __14
	}
	goto next_exit
__14:
	;
	goto __1
__2:
	;
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid++

next_exit:
	// TODO: Handle rc
	return rc
}

// Reset a schema table cursor.
func schemaFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_schema.c:247:12: */
	var rc int32
	var pVtab uintptr = (*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab
	var pCur uintptr = pVtabCursor
	(*schema_cursor)(unsafe.Pointer(pCur)).Frowid = 0
	finalize(tls, pCur+16)
	finalize(tls, pCur+24)
	finalize(tls, pCur+8)
	rc = sqlite3.Xsqlite3_prepare(tls, (*schema_vtab)(unsafe.Pointer(pVtab)).Fdb, ts+37454 /* "PRAGMA database_..." */, -1, pCur+8, uintptr(0))
	return func() int32 {
		if rc == SQLITE_OK {
			return schemaNext(tls, pVtabCursor)
		}
		return rc
	}()
}

// Analyse the WHERE condition.
func schemaBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_schema.c:266:12: */
	return SQLITE_OK
}

// A virtual table module that merely echos method calls into TCL
// variables.
var schemaModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRename
} /* test_schema.c:274:23 */

// Register the schema virtual table module.
func register_schema_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_schema.c:309:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+4808 /* "schema" */, uintptr(unsafe.Pointer(&schemaModule)), uintptr(0))
	return TCL_OK
}

// Register commands with the TCL interpreter.
func Sqlitetestschema_Init(tls *libc.TLS, interp uintptr) int32 { /* test_schema.c:330:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd12))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd12[i].FzName,
			aObjCmd12[i].FxProc, aObjCmd12[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd12 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 37475 /* "register_schema_..." */, FxProc: 0},
} /* test_schema.c:335:5 */

// 2001-09-15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the SQLite library
// presents to client programs.  If a C-function, structure, datatype,
// or constant definition does not appear in this file, then it is
// not a published API of SQLite, is subject to change without
// notice, and should not be referenced by programs that use SQLite.
//
// Some of the definitions that are in this file are marked as
// "experimental".  Experimental interfaces are normally new
// features recently added to SQLite.  We do not anticipate changes
// to experimental interfaces but reserve the right to make minor changes
// if experience from use "in the wild" suggest such changes are prudent.
//
// The official C-language API documentation for SQLite is derived
// from comments in this file.  This file is the authoritative source
// on how SQLite interfaces are supposed to operate.
//
// The name of this file under configuration management is "sqlite.h.in".
// The makefile makes some minor changes to this file (such as inserting
// the version number) and changes its name to "sqlite3.h" as
// part of the build process.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

//******* End of fts5.h ********

// Messages are passed from client to server and back again as
// instances of the following structure.
type SqlMessage1 = struct {
	Fop           int32
	F__ccgo_pad1  [4]byte
	FpDb          uintptr
	FpStmt        uintptr
	FerrCode      int32
	F__ccgo_pad2  [4]byte
	FzIn          uintptr
	FnByte        int32
	F__ccgo_pad3  [4]byte
	FzOut         uintptr
	FpNext        uintptr
	FpPrev        uintptr
	FclientMutex  pthread_mutex_t
	FclientWakeup pthread_cond_t
} /* test_server.c:221:9 */

// 2001-09-15
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This header file defines the interface that the SQLite library
// presents to client programs.  If a C-function, structure, datatype,
// or constant definition does not appear in this file, then it is
// not a published API of SQLite, is subject to change without
// notice, and should not be referenced by programs that use SQLite.
//
// Some of the definitions that are in this file are marked as
// "experimental".  Experimental interfaces are normally new
// features recently added to SQLite.  We do not anticipate changes
// to experimental interfaces but reserve the right to make minor changes
// if experience from use "in the wild" suggest such changes are prudent.
//
// The official C-language API documentation for SQLite is derived
// from comments in this file.  This file is the authoritative source
// on how SQLite interfaces are supposed to operate.
//
// The name of this file under configuration management is "sqlite.h.in".
// The makefile makes some minor changes to this file (such as inserting
// the version number) and changes its name to "sqlite3.h" as
// part of the build process.

//******* Begin file sqlite3rtree.h ********
// 2010 August 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//

//******* End of sqlite3rtree.h ********
//******* Begin file sqlite3session.h ********

//******* End of sqlite3session.h ********
//******* Begin file fts5.h ********
// 2014 May 31
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// Interfaces to extend FTS5. Using the interfaces defined in this file,
// FTS5 may be extended with:
//
//     * custom tokenizers, and
//     * custom auxiliary functions.

//******* End of fts5.h ********

// Messages are passed from client to server and back again as
// instances of the following structure.
type SqlMessage = SqlMessage1 /* test_server.c:221:27 */

// Legal values for SqlMessage.op

// State information about the server is stored in a static variable
// named "g" as follows:
type ServerState = struct {
	FqueueMutex   pthread_mutex_t
	FserverMutex  pthread_mutex_t
	FserverWakeup pthread_cond_t
	FserverHalt   int32
	F__ccgo_pad1  [4]byte
	FpQueueHead   uintptr
	FpQueueTail   uintptr
} /* test_server.c:252:8 */

// Legal values for SqlMessage.op

// State information about the server is stored in a static variable
// named "g" as follows:
var g4 = ServerState{} /* test_server.c:259:3 */

// Send a message to the server.  Block until we get a reply.
//
// The mutex and condition variable in the message are uninitialized
// when this routine is called.  This routine takes care of
// initializing them and destroying them when it has finished.
func sendToServer(tls *libc.TLS, pMsg uintptr) { /* test_server.c:272:13: */
	// Initialize the mutex and condition variable on the message
	libc.Xpthread_mutex_init(tls, pMsg+72, uintptr(0))
	libc.Xpthread_cond_init(tls, pMsg+80, uintptr(0))

	// Add the message to the head of the server's message queue.
	libc.Xpthread_mutex_lock(tls, uintptr(unsafe.Pointer(&g4)))
	(*SqlMessage)(unsafe.Pointer(pMsg)).FpNext = g4.FpQueueHead
	if g4.FpQueueHead == uintptr(0) {
		g4.FpQueueTail = pMsg
	} else {
		(*SqlMessage)(unsafe.Pointer(g4.FpQueueHead)).FpPrev = pMsg
	}
	(*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev = uintptr(0)
	g4.FpQueueHead = pMsg
	libc.Xpthread_mutex_unlock(tls, uintptr(unsafe.Pointer(&g4)))

	// Signal the server that the new message has be queued, then
	// block waiting for the server to process the message.
	libc.Xpthread_mutex_lock(tls, pMsg+72)
	libc.Xpthread_cond_signal(tls, uintptr(unsafe.Pointer(&g4))+16)
	for (*SqlMessage)(unsafe.Pointer(pMsg)).Fop != MSG_Done {
		libc.Xpthread_cond_wait(tls, pMsg+80, pMsg+72)
	}
	libc.Xpthread_mutex_unlock(tls, pMsg+72)

	// Destroy the mutex and condition variable of the message.
	libc.Xpthread_mutex_destroy(tls, pMsg+72)
	libc.Xpthread_cond_destroy(tls, pMsg+80)
}

// The following 6 routines are client-side implementations of the
// core SQLite interfaces:
//
//        sqlite3_open
//        sqlite3_prepare
//        sqlite3_step
//        sqlite3_reset
//        sqlite3_finalize
//        sqlite3_close
//
// Clients should use the following client-side routines instead of
// the core routines above.
//
//        sqlite3_client_open
//        sqlite3_client_prepare
//        sqlite3_client_step
//        sqlite3_client_reset
//        sqlite3_client_finalize
//        sqlite3_client_close
//
// Each of these routines creates a message for the desired operation,
// sends that message to the server, waits for the server to process
// then message and return a response.
func sqlite3_client_open(tls *libc.TLS, zDatabaseName uintptr, ppDb uintptr) int32 { /* test_server.c:332:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var msg SqlMessage at bp, 88

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Open
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FzIn = zDatabaseName
	sendToServer(tls, bp /* &msg */)
	*(*uintptr)(unsafe.Pointer(ppDb)) = (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpDb
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_prepare(tls *libc.TLS, pDb uintptr, zSql uintptr, nByte int32, ppStmt uintptr, pzTail uintptr) int32 { /* test_server.c:340:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var msg SqlMessage at bp, 88

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Prepare
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpDb = pDb
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FzIn = zSql
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FnByte = nByte
	sendToServer(tls, bp /* &msg */)
	*(*uintptr)(unsafe.Pointer(ppStmt)) = (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt
	if pzTail != 0 {
		*(*uintptr)(unsafe.Pointer(pzTail)) = (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FzOut
	}
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_step(tls *libc.TLS, pStmt uintptr) int32 { /* test_server.c:357:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var msg SqlMessage at bp, 88

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Step
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt = pStmt
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_reset(tls *libc.TLS, pStmt uintptr) int32 { /* test_server.c:364:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var msg SqlMessage at bp, 88

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Reset
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt = pStmt
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_finalize(tls *libc.TLS, pStmt uintptr) int32 { /* test_server.c:371:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var msg SqlMessage at bp, 88

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Finalize
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpStmt = pStmt
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

func sqlite3_client_close(tls *libc.TLS, pDb uintptr) int32 { /* test_server.c:378:5: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	// var msg SqlMessage at bp, 88

	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).Fop = MSG_Close
	(*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FpDb = pDb
	sendToServer(tls, bp /* &msg */)
	return (*SqlMessage)(unsafe.Pointer(bp /* &msg */)).FerrCode
}

// This routine implements the server.  To start the server, first
// make sure g.serverHalt is false, then create a new detached thread
// on this procedure.  See the sqlite3_server_start() routine below
// for an example.  This procedure loops until g.serverHalt becomes
// true.
func sqlite3_server(tls *libc.TLS, NotUsed uintptr) uintptr { /* test_server.c:393:6: */
	if libc.Xpthread_mutex_trylock(tls, uintptr(unsafe.Pointer(&g4))+8) != 0 {
		return uintptr(0) // Another server is already running
	}
	sqlite3.Xsqlite3_enable_shared_cache(tls, 1)
	for !(g4.FserverHalt != 0) {
		var pMsg uintptr

		// Remove the last message from the message queue.
		libc.Xpthread_mutex_lock(tls, uintptr(unsafe.Pointer(&g4)))
		for g4.FpQueueTail == uintptr(0) && g4.FserverHalt == 0 {
			libc.Xpthread_cond_wait(tls, uintptr(unsafe.Pointer(&g4))+16, uintptr(unsafe.Pointer(&g4)))
		}
		pMsg = g4.FpQueueTail
		if pMsg != 0 {
			if (*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev != 0 {
				(*SqlMessage)(unsafe.Pointer((*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev)).FpNext = uintptr(0)
			} else {
				g4.FpQueueHead = uintptr(0)
			}
			g4.FpQueueTail = (*SqlMessage)(unsafe.Pointer(pMsg)).FpPrev
		}
		libc.Xpthread_mutex_unlock(tls, uintptr(unsafe.Pointer(&g4)))
		if pMsg == uintptr(0) {
			break
		}

		// Process the message just removed
		libc.Xpthread_mutex_lock(tls, pMsg+72)
		switch (*SqlMessage)(unsafe.Pointer(pMsg)).Fop {
		case MSG_Open:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_open(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FzIn, pMsg+8)
				break

			}
		case MSG_Prepare:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_prepare(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpDb, (*SqlMessage)(unsafe.Pointer(pMsg)).FzIn, (*SqlMessage)(unsafe.Pointer(pMsg)).FnByte,
					pMsg+16, pMsg+48)
				break

			}
		case MSG_Step:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_step(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpStmt)
				break

			}
		case MSG_Reset:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_reset(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpStmt)
				break

			}
		case MSG_Finalize:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_finalize(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpStmt)
				break

			}
		case MSG_Close:
			{
				(*SqlMessage)(unsafe.Pointer(pMsg)).FerrCode = sqlite3.Xsqlite3_close(tls, (*SqlMessage)(unsafe.Pointer(pMsg)).FpDb)
				break

			}
		}

		// Signal the client that the message has been processed.
		(*SqlMessage)(unsafe.Pointer(pMsg)).Fop = MSG_Done
		libc.Xpthread_mutex_unlock(tls, pMsg+72)
		libc.Xpthread_cond_signal(tls, pMsg+80)
	}
	libc.Xpthread_mutex_unlock(tls, uintptr(unsafe.Pointer(&g4))+8)
	return uintptr(0)
}

// Start a server thread if one is not already running.  If there
// is aleady a server thread running, the new thread will quickly
// die and this routine is effectively a no-op.
func sqlite3_server_start(tls *libc.TLS) { /* test_server.c:465:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var x pthread_t at bp, 8

	var rc int32
	g4.FserverHalt = 0
	rc = libc.Xpthread_create(tls, bp /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{sqlite3_server})), uintptr(0))
	if rc == 0 {
		libc.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp /* x */)))
	}
}

// A wrapper around sqlite3_server() that decrements the int variable
// pointed to by the first argument after the sqlite3_server() call
// returns.
func serverWrapper(tls *libc.TLS, pnDecr uintptr) uintptr { /* test_server.c:480:13: */
	var p uintptr = sqlite3_server(tls, uintptr(0))
	*(*int32)(unsafe.Pointer(pnDecr))--
	return p
}

// This function is the similar to sqlite3_server_start(), except that
// the integer pointed to by the first argument is decremented when
// the server thread exits.
func sqlite3_server_start2(tls *libc.TLS, pnDecr uintptr) { /* test_server.c:491:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var x pthread_t at bp, 8

	var rc int32
	g4.FserverHalt = 0
	rc = libc.Xpthread_create(tls, bp /* &x */, uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr) uintptr
	}{serverWrapper})), pnDecr)
	if rc == 0 {
		libc.Xpthread_detach(tls, *(*pthread_t)(unsafe.Pointer(bp /* x */)))
	}
}

// If a server thread is running, then stop it.  If no server is
// running, this routine is effectively a no-op.
//
// This routine waits until the server has actually stopped before
// returning.
func sqlite3_server_stop(tls *libc.TLS) { /* test_server.c:508:6: */
	g4.FserverHalt = 1
	libc.Xpthread_cond_broadcast(tls, uintptr(unsafe.Pointer(&g4))+16)
	libc.Xpthread_mutex_lock(tls, uintptr(unsafe.Pointer(&g4))+8)
	libc.Xpthread_mutex_unlock(tls, uintptr(unsafe.Pointer(&g4))+8)
}

// A structure to collect a busy-handler callback and argument and a count
// of the number of times it has been invoked.
type SuperlockBusy1 = struct {
	FxBusy       uintptr
	FpBusyArg    uintptr
	FnBusy       int32
	F__ccgo_pad1 [4]byte
} /* test_superlock.c:29:1 */

type SuperlockBusy = SuperlockBusy1 /* test_superlock.c:34:30 */

// An instance of the following structure is allocated for each active
// superlock. The opaque handle returned by sqlite3demo_superlock() is
// actually a pointer to an instance of this structure.
type Superlock1 = struct {
	Fdb          uintptr
	FbWal        int32
	F__ccgo_pad1 [4]byte
} /* test_superlock.c:41:1 */

type Superlock = Superlock1 /* test_superlock.c:45:26 */

// The pCtx pointer passed to this function is actually a pointer to a
// SuperlockBusy structure. Invoke the busy-handler function encapsulated
// by the structure and return the result.
func superlockBusyHandler(tls *libc.TLS, pCtx uintptr, UNUSED int32) int32 { /* test_superlock.c:52:12: */
	var pBusy uintptr = pCtx
	if (*SuperlockBusy)(unsafe.Pointer(pBusy)).FxBusy == uintptr(0) {
		return 0
	}
	return (*struct {
		f func(*libc.TLS, uintptr, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*SuperlockBusy)(unsafe.Pointer(pBusy)).FxBusy})).f(tls, (*SuperlockBusy)(unsafe.Pointer(pBusy)).FpBusyArg, libc.PostIncInt32(&(*SuperlockBusy)(unsafe.Pointer(pBusy)).FnBusy, 1))
}

// This function is used to determine if the main database file for
// connection db is open in WAL mode or not. If no error occurs and the
// database file is in WAL mode, set *pbWal to true and return SQLITE_OK.
// If it is not in WAL mode, set *pbWal to false.
//
// If an error occurs, return an SQLite error code. The value of *pbWal
// is undefined in this case.
func superlockIsWal(tls *libc.TLS, pLock uintptr) int32 { /* test_superlock.c:67:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 // Return Code
	// var pStmt uintptr at bp, 8
	// Compiled PRAGMA journal_mode statement

	rc = sqlite3.Xsqlite3_prepare(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+37498 /* "PRAGMA main.jour..." */, -1, bp /* &pStmt */, uintptr(0))
	if rc != SQLITE_OK {
		return rc
	}

	(*Superlock)(unsafe.Pointer(pLock)).FbWal = 0
	if SQLITE_ROW == sqlite3.Xsqlite3_step(tls, *(*uintptr)(unsafe.Pointer(bp))) {
		var zMode uintptr = sqlite3.Xsqlite3_column_text(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)), 0)
		if zMode != 0 && libc.Xstrlen(tls, zMode) == uint64(3) && sqlite3.Xsqlite3_strnicmp(tls, ts+30496, zMode, 3) == 0 {
			(*Superlock)(unsafe.Pointer(pLock)).FbWal = 1
		}
	}

	return sqlite3.Xsqlite3_finalize(tls, *(*uintptr)(unsafe.Pointer(bp /* pStmt */)))
}

// Obtain an exclusive shm-lock on nByte bytes starting at offset idx
// of the file fd. If the lock cannot be obtained immediately, invoke
// the busy-handler until either it is obtained or the busy-handler
// callback returns 0.
func superlockShmLock(tls *libc.TLS, fd uintptr, idx int32, nByte int32, pBusy uintptr) int32 { /* test_superlock.c:91:12: */
	var rc int32
	var xShmLock uintptr = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(fd)).FpMethods)).FxShmLock
	for ok := true; ok; ok = rc == SQLITE_BUSY && superlockBusyHandler(tls, pBusy, 0) != 0 {
		rc = (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{xShmLock})).f(tls, fd, idx, nByte, SQLITE_SHM_LOCK|SQLITE_SHM_EXCLUSIVE)
	}
	return rc
}

// Obtain the extra locks on the database file required for WAL databases.
// Invoke the supplied busy-handler as required.
func superlockWalLock(tls *libc.TLS, db uintptr, pBusy uintptr) int32 { /* test_superlock.c:109:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	var rc int32                                             // Return code
	*(*uintptr)(unsafe.Pointer(bp /* fd */)) = uintptr(0)    // Main database file handle
	*(*uintptr)(unsafe.Pointer(bp + 8 /* p */)) = uintptr(0) // Pointer to first page of shared memory

	// Obtain a pointer to the sqlite3_file object open on the main db file.
	rc = sqlite3.Xsqlite3_file_control(tls, db, ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp /* &fd */)
	if rc != SQLITE_OK {
		return rc
	}

	// Obtain the "recovery" lock. Normally, this lock is only obtained by
	// clients running database recovery.
	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 2, 1, pBusy)
	if rc != SQLITE_OK {
		return rc
	}

	// Zero the start of the first shared-memory page. This means that any
	// clients that open read or write transactions from this point on will
	// have to run recovery before proceeding. Since they need the "recovery"
	// lock that this process is holding to do that, no new read or write
	// transactions may now be opened. Nor can a checkpoint be run, for the
	// same reason.
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods)).FxShmMap})).f(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 0, 32*1024, 1, bp+8 /* &p */)
	if rc != SQLITE_OK {
		return rc
	}
	libc.Xmemset(tls, *(*uintptr)(unsafe.Pointer(bp + 8 /* p */)), 0, uint64(32))

	// Obtain exclusive locks on all the "read-lock" slots. Once these locks
	// are held, it is guaranteed that there are no active reader, writer or
	// checkpointer clients.
	rc = superlockShmLock(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 3, SQLITE_SHM_NLOCK-3, pBusy)
	return rc
}

// Release a superlock held on a database file. The argument passed to
// this function must have been obtained from a successful call to
// sqlite3demo_superlock().
func sqlite3demo_superunlock(tls *libc.TLS, pLock uintptr) { /* test_superlock.c:151:6: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var p uintptr = pLock
	if (*Superlock)(unsafe.Pointer(p)).FbWal != 0 {
		var rc int32 // Return code
		var flags int32 = SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE
		*(*uintptr)(unsafe.Pointer(bp /* fd */)) = uintptr(0)
		rc = sqlite3.Xsqlite3_file_control(tls, (*Superlock)(unsafe.Pointer(p)).Fdb, ts+85 /* "main" */, SQLITE_FCNTL_FILE_POINTER, bp /* &fd */)
		if rc == SQLITE_OK {
			(*struct {
				f func(*libc.TLS, uintptr, int32, int32, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods)).FxShmLock})).f(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 2, 1, flags)
			(*struct {
				f func(*libc.TLS, uintptr, int32, int32, int32) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp /* fd */)))).FpMethods)).FxShmLock})).f(tls, *(*uintptr)(unsafe.Pointer(bp /* fd */)), 3, SQLITE_SHM_NLOCK-3, flags)
		}
	}
	sqlite3.Xsqlite3_close(tls, (*Superlock)(unsafe.Pointer(p)).Fdb)
	sqlite3.Xsqlite3_free(tls, p)
}

// Obtain a superlock on the database file identified by zPath, using the
// locking primitives provided by VFS zVfs. If successful, SQLITE_OK is
// returned and output variable *ppLock is populated with an opaque handle
// that may be used with sqlite3demo_superunlock() to release the lock.
//
// If an error occurs, *ppLock is set to 0 and an SQLite error code
// (e.g. SQLITE_BUSY) is returned.
//
// If a required lock cannot be obtained immediately and the xBusy parameter
// to this function is not NULL, then xBusy is invoked in the same way
// as a busy-handler registered with SQLite (using sqlite3_busy_handler())
// until either the lock can be obtained or the busy-handler function returns
// 0 (indicating "give up").
func sqlite3demo_superlock(tls *libc.TLS, zPath uintptr, zVfs uintptr, xBusy uintptr, pBusyArg uintptr, ppLock uintptr) int32 { /* test_superlock.c:182:5: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	*(*SuperlockBusy)(unsafe.Pointer(bp /* busy */)) = SuperlockBusy{} // Busy handler wrapper object
	var rc int32                                                       // Return code
	var pLock uintptr

	pLock = sqlite3.Xsqlite3_malloc(tls, int32(unsafe.Sizeof(Superlock{})))
	if !(pLock != 0) {
		return SQLITE_NOMEM
	}
	libc.Xmemset(tls, pLock, 0, uint64(unsafe.Sizeof(Superlock{})))

	// Open a database handle on the file to superlock.
	rc = sqlite3.Xsqlite3_open_v2(tls,
		zPath, pLock, SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE, zVfs)

	// Install a busy-handler and execute a BEGIN EXCLUSIVE. If this is not
	// a WAL database, this is all we need to do.
	//
	// A wrapper function is used to invoke the busy-handler instead of
	// registering the busy-handler function supplied by the user directly
	// with SQLite. This is because the same busy-handler function may be
	// invoked directly later on when attempting to obtain the extra locks
	// required in WAL mode. By using the wrapper, we are able to guarantee
	// that the "nBusy" integer parameter passed to the users busy-handler
	// represents the total number of busy-handler invocations made within
	// this call to sqlite3demo_superlock(), including any made during the
	// "BEGIN EXCLUSIVE".
	if rc == SQLITE_OK {
		(*SuperlockBusy)(unsafe.Pointer(bp /* &busy */)).FxBusy = xBusy
		(*SuperlockBusy)(unsafe.Pointer(bp /* &busy */)).FpBusyArg = pBusyArg
		sqlite3.Xsqlite3_busy_handler(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{superlockBusyHandler})), bp /* &busy */)
		rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+14056 /* "BEGIN EXCLUSIVE" */, uintptr(0), uintptr(0), uintptr(0))
	}

	// If the BEGIN EXCLUSIVE was executed successfully and this is a WAL
	// database, call superlockWalLock() to obtain the extra locks required
	// to prevent readers, writers and/or checkpointers from accessing the
	// db while this process is holding the superlock.
	//
	// Before attempting any WAL locks, commit the transaction started above
	// to drop the WAL read and write locks currently held. Otherwise, the
	// new WAL locks may conflict with the old.
	if rc == SQLITE_OK {
		if SQLITE_OK == libc.AssignInt32(&rc, superlockIsWal(tls, pLock)) && (*Superlock)(unsafe.Pointer(pLock)).FbWal != 0 {
			rc = sqlite3.Xsqlite3_exec(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, ts+12467 /* "COMMIT" */, uintptr(0), uintptr(0), uintptr(0))
			if rc == SQLITE_OK {
				rc = superlockWalLock(tls, (*Superlock)(unsafe.Pointer(pLock)).Fdb, bp /* &busy */)
			}
		}
	}

	if rc != SQLITE_OK {
		sqlite3demo_superunlock(tls, pLock)
		*(*uintptr)(unsafe.Pointer(ppLock)) = uintptr(0)
	} else {
		*(*uintptr)(unsafe.Pointer(ppLock)) = pLock
	}

	return rc
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type InterpAndScript1 = struct {
	Finterp  uintptr
	FpScript uintptr
} /* test_superlock.c:268:1 */

type InterpAndScript = InterpAndScript1 /* test_superlock.c:272:32 */

func superunlock_del(tls *libc.TLS, cd ClientData) { /* test_superlock.c:274:27: */
	sqlite3demo_superunlock(tls, cd)
}

func superunlock_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_superlock.c:278:26: */
	if objc != 1 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+584 /* "" */)
		return TCL_ERROR
	}
	tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
	return TCL_OK
}

func superlock_busy(tls *libc.TLS, pCtx uintptr, nBusy int32) int32 { /* test_superlock.c:292:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = pCtx
	var pEval uintptr                            // Script to evaluate
	*(*int32)(unsafe.Pointer(bp /* iVal */)) = 0 // Value to return

	pEval = tcl.XTcl_DuplicateObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewIntObj(tls, nBusy))
	tcl.XTcl_EvalObjEx(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	tcl.XTcl_GetIntFromObj(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp, tcl.XTcl_GetObjResult(tls, (*InterpAndScript)(unsafe.Pointer(p)).Finterp), bp /* &iVal */)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}

	return *(*int32)(unsafe.Pointer(bp /* iVal */))
}

// Tclcmd: sqlite3demo_superlock CMDNAME PATH VFS BUSY-HANDLER-SCRIPT
func superlock_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_superlock.c:310:26: */
	bp := tls.Alloc(40)
	defer tls.Free(40)

	// var pLock uintptr at bp+32, 8
	// Lock context
	var zPath uintptr
	var zVfs uintptr = uintptr(0)
	*(*InterpAndScript)(unsafe.Pointer(bp + 16 /* busy */)) = InterpAndScript{}
	var xBusy uintptr = uintptr(0) // Busy handler callback
	var rc int32                   // Return code from sqlite3demo_superlock()

	if objc < 3 || objc > 5 {
		tcl.XTcl_WrongNumArgs(tls,
			interp, 1, objv, ts+37523 /* "CMDNAME PATH ?VF..." */)
		return TCL_ERROR
	}

	zPath = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))

	if objc > 3 {
		zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
		if libc.Xstrlen(tls, zVfs) == uint64(0) {
			zVfs = uintptr(0)
		}
	}
	if objc > 4 {
		(*InterpAndScript)(unsafe.Pointer(bp + 16 /* &busy */)).Finterp = interp
		(*InterpAndScript)(unsafe.Pointer(bp + 16 /* &busy */)).FpScript = *(*uintptr)(unsafe.Pointer(objv + 4*8))
		xBusy = *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32) int32
		}{superlock_busy}))
	}

	rc = sqlite3demo_superlock(tls, zPath, zVfs, xBusy, bp+16 /* &busy */, bp+32 /* &pLock */)

	if rc != SQLITE_OK {
		tcl.XTcl_ResetResult(tls, interp)
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, sqlite3.Xsqlite3ErrStr(tls, rc), 0))
		return TCL_ERROR
	}

	tcl.XTcl_CreateObjCommand(tls,
		interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{superunlock_cmd})), *(*uintptr)(unsafe.Pointer(bp + 32 /* pLock */)), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{superunlock_del})))
	tcl.XTcl_SetObjResult(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	return TCL_OK
}

func SqliteSuperlock_Init(tls *libc.TLS, interp uintptr) int32 { /* test_superlock.c:359:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+37564 /* "sqlite3demo_supe..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{superlock_cmd})), uintptr(0), uintptr(0))
	return TCL_OK
}

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1982, 1986, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)mman.h	8.2 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1991, 1993
//	The Regents of the University of California.  All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Berkeley Software Design, Inc.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-2-Clause-FreeBSD
//
// Copyright (c) 2002 Mike Barcroft <mike@FreeBSD.org>
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
// $FreeBSD$

// Inheritance for minherit()

// Protections are chosen from these bits, or-ed together

// Flags contain sharing type and options.
// Sharing types; choose one.

// Other flags

// Mapping type

// Extended flags

// Request specific alignment (n == log2 of the desired alignment).
//
// MAP_ALIGNED_SUPER requests optimal superpage alignment, but does
// not enforce a specific alignment.

// Flags provided to shm_rename
// Don't overwrite dest, if it exists
// Atomically swap src and dest

// Process memory locking

// Error return from mmap()

// msync() flags

// Advice to madvise

// Return bits from mincore

// Anonymous object constant for shm_open().

// shmflags for shm_open2()

type shm_largepage_conf = struct {
	Fpsind        int32
	Falloc_policy int32
	Fpad          [10]int32
} /* mman.h:201:1 */

// 11 was EAGAIN

// math software

// non-blocking and interrupt i/o

// ipc/network software -- argument errors

// ipc/network software -- operational errors

// should be rearranged

// quotas & mush

// Network File System

// ISO/IEC 9899:2011 K.3.2.2

type TestSyscallGlobal = struct {
	FbPersist         int32
	FnCount           int32
	FnFail            int32
	Fpgsz             int32
	Forig_getpagesize sqlite3_syscall_ptr
} /* test_syscall.c:97:8 */

// 11 was EAGAIN

// math software

// non-blocking and interrupt i/o

// ipc/network software -- argument errors

// ipc/network software -- operational errors

// should be rearranged

// quotas & mush

// Network File System

// ISO/IEC 9899:2011 K.3.2.2

var gSyscall = TestSyscallGlobal{} /* test_syscall.c:103:3 */

type TestSyscallArray = struct {
	FzName         uintptr
	FxTest         sqlite3_syscall_ptr
	FxOrig         sqlite3_syscall_ptr
	Fdefault_errno int32
	Fcustom_errno  int32
} /* test_syscall.c:127:1 */

var aSyscall = [19]TestSyscallArray{
	/*  0 */ {FzName: ts + 37586 /* "open" */, FxTest: 0, Fdefault_errno: EACCES},
	/*  1 */ {FzName: ts + 10322 /* "close" */, FxTest: 0},
	/*  2 */ {FzName: ts + 37591 /* "access" */, FxTest: 0},
	/*  3 */ {FzName: ts + 37598 /* "getcwd" */, FxTest: 0},
	/*  4 */ {FzName: ts + 37605 /* "stat" */, FxTest: 0},
	/*  5 */ {FzName: ts + 37610 /* "fstat" */, FxTest: 0},
	/*  6 */ {FzName: ts + 37616 /* "ftruncate" */, FxTest: 0, Fdefault_errno: EIO},
	/*  7 */ {FzName: ts + 37626 /* "fcntl" */, FxTest: 0, Fdefault_errno: EACCES},
	/*  8 */ {FzName: ts + 25761 /* "read" */, FxTest: 0},
	/*  9 */ {FzName: ts + 37632 /* "pread" */, FxTest: 0},
	/* 10 */ {FzName: ts + 37638 /* "pread64" */, FxTest: 0},
	/* 11 */ {FzName: ts + 25766 /* "write" */, FxTest: 0},
	/* 12 */ {FzName: ts + 37646 /* "pwrite" */, FxTest: 0},
	/* 13 */ {FzName: ts + 37653 /* "pwrite64" */, FxTest: 0},
	/* 14 */ {FzName: ts + 37662 /* "fchmod" */, FxTest: 0},
	/* 15 */ {FzName: ts + 37669 /* "fallocate" */, FxTest: 0},
	/* 16 */ {FzName: ts + 29590 /* "mmap" */, FxTest: 0},
	/* 17 */ {FzName: ts + 37679 /* "mremap" */, FxTest: 0},
	{},
} /* test_syscall.c:133:3 */

// This function is called exactly once from within each invocation of a
// system call wrapper in this file. It returns 1 if the function should
// fail, or 0 if it should succeed.
func tsIsFail(tls *libc.TLS) int32 { /* test_syscall.c:181:12: */
	gSyscall.FnCount--
	if gSyscall.FnCount == 0 || gSyscall.FnFail != 0 && gSyscall.FbPersist != 0 {
		gSyscall.FnFail++
		return 1
	}
	return 0
}

// Return the current error-number value for function zFunc. zFunc must be
// the name of a system call in the aSyscall[] table.
//
// Usually, the current error-number is the value that errno should be set
// to if the named system call fails. The exception is "fallocate". See
// comments above the implementation of ts_fallocate() for details.
func tsErrno(tls *libc.TLS, zFunc uintptr) int32 { /* test_syscall.c:198:12: */
	var i int32
	var nFunc int32 = int32(libc.Xstrlen(tls, zFunc))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if libc.Xstrlen(tls, aSyscall[i].FzName) != size_t(nFunc) {
			continue
		}
		if libc.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint64(nFunc)) != 0 {
			continue
		}
		return aSyscall[i].Fcustom_errno
	}

	return 0
}

/*
** A wrapper around tsIsFail(). If tsIsFail() returns non-zero, set the
** value of errno before returning.
 */
func tsIsFailErrno(tls *libc.TLS, zFunc uintptr) int32 { /* test_syscall.c:215:12: */
	if tsIsFail(tls) != 0 {
		*(*int32)(unsafe.Pointer(libc.X__error(tls))) = tsErrno(tls, zFunc)
		return 1
	}
	return 0
}

// A wrapper around open().
func ts_open(tls *libc.TLS, zFile uintptr, flags int32, mode int32) int32 { /* test_syscall.c:226:12: */
	if tsIsFailErrno(tls, ts+37586) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 16)))(tls, zFile, flags, mode)
}

// A wrapper around close().
func ts_close(tls *libc.TLS, fd int32) int32 { /* test_syscall.c:236:12: */
	if tsIsFail(tls) != 0 {
		// Even if simulating an error, close the original file-descriptor.
		// This is to stop the test process from running out of file-descriptors
		// when running a long test. If a call to close() appears to fail, SQLite
		// never attempts to use the file-descriptor afterwards (or even to close
		// it a second time).
		(*(*func(*libc.TLS, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 1*32 + 16)))(tls, fd)
		return -1
	}
	return (*(*func(*libc.TLS, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 1*32 + 16)))(tls, fd)
}

// A wrapper around access().
func ts_access(tls *libc.TLS, zPath uintptr, mode int32) int32 { /* test_syscall.c:252:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 2*32 + 16)))(tls, zPath, mode)
}

// A wrapper around getcwd().
func ts_getcwd(tls *libc.TLS, zPath uintptr, nPath size_t) uintptr { /* test_syscall.c:262:13: */
	if tsIsFail(tls) != 0 {
		return uintptr(0)
	}
	return (*(*func(*libc.TLS, uintptr, size_t) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 3*32 + 16)))(tls, zPath, nPath)
}

// A wrapper around stat().
func ts_stat(tls *libc.TLS, zPath uintptr, p uintptr) int32 { /* test_syscall.c:272:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 4*32 + 16)))(tls, zPath, p)
}

// A wrapper around fstat().
func ts_fstat(tls *libc.TLS, fd int32, p uintptr) int32 { /* test_syscall.c:282:12: */
	if tsIsFailErrno(tls, ts+37610) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 5*32 + 16)))(tls, fd, p)
}

// A wrapper around ftruncate().
func ts_ftruncate(tls *libc.TLS, fd int32, n off_t) int32 { /* test_syscall.c:292:12: */
	if tsIsFailErrno(tls, ts+37616) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, off_t) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 6*32 + 16)))(tls, fd, n)
}

// A wrapper around fcntl().
func ts_fcntl(tls *libc.TLS, fd int32, cmd int32, va uintptr) int32 { /* test_syscall.c:302:12: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+37626) != 0 {
		return -1
	}
	ap = va
	pArg = libc.VaUintptr(&ap)
	return (*(*func(*libc.TLS, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 7*32 + 16)))(tls, fd, cmd, libc.VaList(bp, pArg))
}

// A wrapper around read().
func ts_read(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 { /* test_syscall.c:316:12: */
	if tsIsFailErrno(tls, ts+25761) != 0 {
		return -1
	}
	return int32((*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 8*32 + 16)))(tls, fd, aBuf, nBuf))
}

// A wrapper around pread().
func ts_pread(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 { /* test_syscall.c:326:12: */
	if tsIsFailErrno(tls, ts+37632) != 0 {
		return -1
	}
	return int32((*(*func(*libc.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 9*32 + 16)))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around pread64().
func ts_pread64(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 { /* test_syscall.c:336:12: */
	if tsIsFailErrno(tls, ts+37638) != 0 {
		return -1
	}
	return int32((*(*func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 10*32 + 16)))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around write().
func ts_write(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t) int32 { /* test_syscall.c:346:12: */
	if tsIsFailErrno(tls, ts+25766) != 0 {
		if tsErrno(tls, ts+25766) == EINTR {
			(*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 11*32 + 16)))(tls, fd, aBuf, nBuf/uint64(2))
		}
		return -1
	}
	return int32((*(*func(*libc.TLS, int32, uintptr, size_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 11*32 + 16)))(tls, fd, aBuf, nBuf))
}

// A wrapper around pwrite().
func ts_pwrite(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off off_t) int32 { /* test_syscall.c:357:12: */
	if tsIsFailErrno(tls, ts+37646) != 0 {
		return -1
	}
	return int32((*(*func(*libc.TLS, int32, uintptr, size_t, off_t) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 12*32 + 16)))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around pwrite64().
func ts_pwrite64(tls *libc.TLS, fd int32, aBuf uintptr, nBuf size_t, off sqlite3_uint64) int32 { /* test_syscall.c:367:12: */
	if tsIsFailErrno(tls, ts+37653) != 0 {
		return -1
	}
	return int32((*(*func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) ssize_t)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 13*32 + 16)))(tls, fd, aBuf, nBuf, off))
}

// A wrapper around fchmod().
func ts_fchmod(tls *libc.TLS, fd int32, mode mode_t) int32 { /* test_syscall.c:377:12: */
	if tsIsFail(tls) != 0 {
		return -1
	}
	return (*(*func(*libc.TLS, int32, mode_t) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 14*32 + 16)))(tls, fd, mode)
}

// A wrapper around fallocate().
//
// SQLite assumes that the fallocate() function is compatible with
// posix_fallocate(). According to the Linux man page (2009-09-30):
//
//   posix_fallocate() returns  zero on success, or an error number on
//   failure. Note that errno is not set.
func ts_fallocate(tls *libc.TLS, fd int32, off off_t, len off_t) int32 { /* test_syscall.c:393:12: */
	if tsIsFail(tls) != 0 {
		return tsErrno(tls, ts+37669 /* "fallocate" */)
	}
	return (*(*func(*libc.TLS, int32, off_t, off_t) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 15*32 + 16)))(tls, fd, off, len)
}

func ts_mmap(tls *libc.TLS, pAddr uintptr, nByte size_t, prot int32, flags int32, fd int32, iOff off_t) uintptr { /* test_syscall.c:400:13: */
	if tsIsFailErrno(tls, ts+29590) != 0 {
		return libc.UintptrFromInt32(-1)
	}
	return (*(*func(*libc.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 16*32 + 16)))(tls, pAddr, nByte, prot, flags, fd, iOff)
}

func ts_mremap(tls *libc.TLS, a uintptr, b size_t, c size_t, d int32, va uintptr) uintptr { /* test_syscall.c:414:13: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var ap va_list
	_ = ap
	var pArg uintptr
	if tsIsFailErrno(tls, ts+37679) != 0 {
		return libc.UintptrFromInt32(-1)
	}
	ap = va
	pArg = libc.VaUintptr(&ap)
	return (*(*func(*libc.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 17*32 + 16)))(tls, a, b, c, d, libc.VaList(bp, pArg))
}

func test_syscall_install(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:425:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pVfs uintptr
	// var nElem int32 at bp, 4

	var i int32
	// var apElem uintptr at bp+8, 8

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+37686 /* "SYSCALL-LIST" */)
		return TCL_ERROR
	}
	if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp, bp+8) != 0 {
		return TCL_ERROR
	}
	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	for i = 0; i < *(*int32)(unsafe.Pointer(bp /* nElem */)); i++ {
		// var iCall int32 at bp+16, 4

		var rc int32 = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 8 /* apElem */)) + uintptr(i)*8)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+37699 /* "system-call" */, 0, bp+16 /* &iCall */)
		if rc != 0 {
			return rc
		}
		if aSyscall[*(*int32)(unsafe.Pointer(bp + 16))].FxOrig == uintptr(0) {
			aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FxOrig = (*struct {
				f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetSystemCall})).f(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FzName)
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FzName, aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].FxTest)
		}
		aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].Fcustom_errno = aSyscall[*(*int32)(unsafe.Pointer(bp + 16 /* iCall */))].Fdefault_errno
	}

	return TCL_OK
}

func test_syscall_uninstall(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:461:26: */
	var pVfs uintptr
	var i int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	for i = 0; aSyscall[i].FzName != 0; i++ {
		if aSyscall[i].FxOrig != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, aSyscall[i].FzName, uintptr(0))
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	return TCL_OK
}

func test_syscall_reset(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:485:26: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pVfs uintptr
	var i int32
	var rc int32

	if objc != 2 && objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	if objc == 2 {
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, uintptr(0), uintptr(0))
		for i = 0; aSyscall[i].FzName != 0; i++ {
			aSyscall[i].FxOrig = uintptr(0)
		}
	} else {
		// var nFunc int32 at bp, 4

		var zFunc uintptr = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp /* &nFunc */)
		rc = (*struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), uintptr(0))
		for i = 0; rc == SQLITE_OK && aSyscall[i].FzName != 0; i++ {
			if libc.Xstrlen(tls, aSyscall[i].FzName) != size_t(*(*int32)(unsafe.Pointer(bp))) {
				continue
			}
			if libc.Xmemcmp(tls, aSyscall[i].FzName, zFunc, uint64(*(*int32)(unsafe.Pointer(bp)))) != 0 {
				continue
			}
			aSyscall[i].FxOrig = uintptr(0)
		}
	}
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}

	tcl.XTcl_ResetResult(tls, interp)
	return TCL_OK
}

func test_syscall_exists(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:523:26: */
	var pVfs uintptr
	var x sqlite3_syscall_ptr

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	x = (*struct {
		f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetSystemCall})).f(tls, pVfs, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))))

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, libc.Bool32(libc.Bool32(x != uintptr(0)) != 0)))
	return TCL_OK
}

func test_syscall_fault(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:544:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	*(*int32)(unsafe.Pointer(bp /* nCount */)) = 0
	*(*int32)(unsafe.Pointer(bp + 4 /* bPersist */)) = 0

	if objc != 2 && objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+37711 /* "?COUNT PERSIST?" */)
		return TCL_ERROR
	}

	if objc == 4 {
		if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp) != 0 ||
			tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+4) != 0 {
			return TCL_ERROR
		}
	}

	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, gSyscall.FnFail))
	gSyscall.FnCount = *(*int32)(unsafe.Pointer(bp /* nCount */))
	gSyscall.FbPersist = *(*int32)(unsafe.Pointer(bp + 4 /* bPersist */))
	gSyscall.FnFail = 0
	return TCL_OK
}

func test_syscall_errno(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:573:26: */
	bp := tls.Alloc(204)
	defer tls.Free(204)

	// var iCall int32 at bp, 4

	// var iErrno int32 at bp+200, 4

	var rc int32

	*(*[12]Errno)(unsafe.Pointer(bp + 8 /* aErrno */)) = [12]Errno{
		{Fz: ts + 37727 /* "EACCES" */, Fi: EACCES},
		{Fz: ts + 37734 /* "EINTR" */, Fi: EINTR},
		{Fz: ts + 37740 /* "EIO" */, Fi: EIO},
		{Fz: ts + 37744 /* "EOVERFLOW" */, Fi: EOVERFLOW},
		{Fz: ts + 37754 /* "ENOMEM" */, Fi: ENOMEM},
		{Fz: ts + 37761 /* "EAGAIN" */, Fi: EAGAIN},
		{Fz: ts + 37768 /* "ETIMEDOUT" */, Fi: ETIMEDOUT},
		{Fz: ts + 37778 /* "EBUSY" */, Fi: EBUSY},
		{Fz: ts + 37784 /* "EPERM" */, Fi: EPERM},
		{Fz: ts + 37790 /* "EDEADLK" */, Fi: EDEADLK},
		{Fz: ts + 37798 /* "ENOLCK" */, Fi: ENOLCK},
		{},
	}

	if objc != 4 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+37805 /* "SYSCALL ERRNO" */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 2*8)), uintptr(unsafe.Pointer(&aSyscall)), int32(unsafe.Sizeof(TestSyscallArray{})), ts+37699 /* "system-call" */, 0, bp /* &iCall */)
	if rc != TCL_OK {
		return rc
	}
	rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
		*(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+8 /* &aErrno[0] */, int32(unsafe.Sizeof(Errno{})), ts+37819 /* "errno" */, 0, bp+200 /* &iErrno */)
	if rc != TCL_OK {
		return rc
	}

	aSyscall[*(*int32)(unsafe.Pointer(bp /* iCall */))].Fcustom_errno = (*Errno)(unsafe.Pointer(bp + 8 /* &aErrno */ + uintptr(*(*int32)(unsafe.Pointer(bp + 200 /* iErrno */)))*16)).Fi
	return TCL_OK
}

type Errno = struct {
	Fz           uintptr
	Fi           int32
	F__ccgo_pad1 [4]byte
} /* test_syscall.c:583:3 */

func test_syscall_list(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:619:26: */
	var zSys uintptr
	var pVfs uintptr
	var pList uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	for zSys = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxNextSystemCall})).f(tls, pVfs, uintptr(0)); zSys != uintptr(0); zSys = (*struct {
		f func(*libc.TLS, uintptr, uintptr) uintptr
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxNextSystemCall})).f(tls, pVfs, zSys) {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, zSys, -1))
	}

	tcl.XTcl_SetObjResult(tls, interp, pList)
	for ok := true; ok; ok = 0 != 0 {
		var _objPtr uintptr = pList
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return TCL_OK
}

func test_syscall_defaultvfs(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:649:26: */
	var pVfs uintptr

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+584 /* "" */)
		return TCL_ERROR
	}

	pVfs = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName, -1))
	return TCL_OK
}

func ts_getpagesize(tls *libc.TLS) int32 { /* test_syscall.c:667:12: */
	return gSyscall.Fpgsz
}

func test_syscall_pagesize(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:671:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	// var pgsz int32 at bp+16, 4

	if objc != 3 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+37825 /* "PGSZ" */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+16) != 0 {
		return TCL_ERROR
	}

	if *(*int32)(unsafe.Pointer(bp + 16)) < 0 {
		if gSyscall.Forig_getpagesize != 0 {
			(*struct {
				f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls, pVfs, ts+37830 /* "getpagesize" */, gSyscall.Forig_getpagesize)
		}
	} else {
		if *(*int32)(unsafe.Pointer(bp + 16)) < 512 || *(*int32)(unsafe.Pointer(bp + 16))&(*(*int32)(unsafe.Pointer(bp + 16))-1) != 0 {
			tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37842 /* "pgsz out of rang..." */, 0))
			return TCL_ERROR
		}
		gSyscall.Forig_getpagesize = (*struct {
			f func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxGetSystemCall})).f(tls, pVfs, ts+37830 /* "getpagesize" */)
		gSyscall.Fpgsz = *(*int32)(unsafe.Pointer(bp + 16 /* pgsz */))
		(*struct {
			f func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall})).f(tls,
			pVfs, ts+37830 /* "getpagesize" */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS) int32 }{ts_getpagesize})))
	}

	return TCL_OK
}

func test_syscall(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_syscall.c:706:26: */
	bp := tls.Alloc(180)
	defer tls.Free(180)

	*(*[10]SyscallCmd)(unsafe.Pointer(bp + 16 /* aCmd */)) = [10]SyscallCmd{
		{FzName: ts + 37860 /* "fault" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_fault}))},
		{FzName: ts + 37866 /* "install" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_install}))},
		{FzName: ts + 37874 /* "uninstall" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_uninstall}))},
		{FzName: ts + 7576 /* "reset" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_reset}))},
		{FzName: ts + 37819 /* "errno" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_errno}))},
		{FzName: ts + 14343 /* "exists" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_exists}))},
		{FzName: ts + 37884 /* "list" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_list}))},
		{FzName: ts + 37889 /* "defaultvfs" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_defaultvfs}))},
		{FzName: ts + 37900 /* "pagesize" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall_pagesize}))},
		{},
	}
	// var iCmd int32 at bp+176, 4

	var rc int32
	var pVfs uintptr = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+33535 /* "SUB-COMMAND ..." */)
		return TCL_ERROR
	}
	if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion < 3 || (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FxSetSystemCall == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+37909 /* "VFS does not sup..." */, 0))
		rc = TCL_ERROR
	} else {
		rc = tcl.XTcl_GetIndexFromObjStruct(tls, interp,
			*(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+16 /* &aCmd[0] */, int32(unsafe.Sizeof(SyscallCmd{})), ts+2014 /* "sub-command" */, 0, bp+176 /* &iCmd */)
	}
	if rc != TCL_OK {
		return rc
	}
	return (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*SyscallCmd)(unsafe.Pointer(bp + 16 /* &aCmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 176 /* iCmd */)))*16)).FxCmd})).f(tls, clientData, interp, objc, objv)
}

type SyscallCmd = struct {
	FzName uintptr
	FxCmd  uintptr
} /* test_syscall.c:712:3 */

func SqlitetestSyscall_Init(tls *libc.TLS, interp uintptr) int32 { /* test_syscall.c:747:5: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	*(*[1]SyscallCmd)(unsafe.Pointer(bp /* aCmd */)) = [1]SyscallCmd{
		{FzName: ts + 37945 /* "test_syscall" */, FxCmd: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{test_syscall}))},
	}
	var i int32

	for i = 0; uint64(i) < uint64(unsafe.Sizeof([1]SyscallCmd{}))/uint64(unsafe.Sizeof(SyscallCmd{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, (*SyscallCmd)(unsafe.Pointer(bp /* &aCmd */ +uintptr(i)*16)).FzName, (*SyscallCmd)(unsafe.Pointer(bp /* &aCmd */ +uintptr(i)*16)).FxCmd, uintptr(0), uintptr(0))
	}
	return TCL_OK
}

// This routine is the primary export of this file.
//
// Configure the interpreter passed as the first argument to have access
// to the commands and linked variables that make up:
//
//   * the [sqlite3] extension itself,
//
//   * If SQLITE_TCLMD5 or SQLITE_TEST is defined, the Md5 commands, and
//
//   * If SQLITE_TEST is set, the various test interfaces used by the Tcl
//     test suite.
func sqlite3TestInit(tls *libc.TLS, interp uintptr) uintptr { /* test_tclsh.c:58:12: */
	bp := tls.Alloc(80)
	defer tls.Free(80)

	// var cmdInfo Tcl_CmdInfo at bp+16, 64

	/* Since the primary use case for this binary is testing of SQLite,
	 ** be sure to generate core files if we crash */
	{
		// var x rlimit at bp, 16

		libc.Xgetrlimit(tls, RLIMIT_CORE, bp /* &x */)
		(*rlimit)(unsafe.Pointer(bp /* &x */)).Frlim_cur = (*rlimit)(unsafe.Pointer(bp /* &x */)).Frlim_max
		libc.Xsetrlimit(tls, RLIMIT_CORE, bp /* &x */)

	}

	if tcl.XTcl_GetCommandInfo(tls, interp, ts+15094, bp+16) == 0 {
		Sqlite3_Init(tls, interp)
	}
	Md5_Init(tls, interp)
	Sqliteconfig_Init(tls, interp)
	Sqlitetest1_Init(tls, interp)
	Sqlitetest2_Init(tls, interp)
	Sqlitetest3_Init(tls, interp)
	Sqlitetest4_Init(tls, interp)
	Sqlitetest5_Init(tls, interp)
	Sqlitetest6_Init(tls, interp)
	Sqlitetest7_Init(tls, interp)
	Sqlitetest8_Init(tls, interp)
	Sqlitetest9_Init(tls, interp)
	Sqlitetestasync_Init(tls, interp)
	Sqlitetest_autoext_Init(tls, interp)
	Sqlitetest_blob_Init(tls, interp)
	Sqlitetest_demovfs_Init(tls, interp)
	Sqlitetest_func_Init(tls, interp)
	Sqlitetest_hexio_Init(tls, interp)
	Sqlitetest_init_Init(tls, interp)
	Sqlitetest_malloc_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlitetestschema_Init(tls, interp)
	Sqlitetesttclvar_Init(tls, interp)
	Sqlitetestfs_Init(tls, interp)
	SqlitetestThread_Init(tls, interp)
	SqlitetestOnefile_Init(tls)
	SqlitetestOsinst_Init(tls, interp)
	Sqlitetestbackup_Init(tls, interp)
	Sqlitetestintarray_Init(tls, interp)
	Sqlitetestvfs_Init(tls, interp)
	Sqlitetestrtree_Init(tls, interp)
	Sqlitetestrtreedoc_Init(tls, interp)
	Sqlitequota_Init(tls, interp)
	Sqlitemultiplex_Init(tls, interp)
	SqliteSuperlock_Init(tls, interp)
	SqlitetestSyscall_Init(tls, interp)
	TestSession_Init(tls, interp)
	Fts5tcl_Init(tls, interp)
	SqliteRbu_Init(tls, interp)
	Sqlitetesttcl_Init(tls, interp)

	TestExpert_Init(tls, interp)
	Sqlitetest_window_Init(tls, interp)
	Sqlitetestvdbecov_Init(tls, interp)

	tcl.XTcl_CreateObjCommand(tls,
		interp, ts+37958 /* "load_testfixture..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{load_testfixture_extensions})), uintptr(0), uintptr(0))
	return uintptr(0)
}

// tclcmd:   load_testfixture_extensions
func load_testfixture_extensions(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_tclsh.c:187:26: */
	var slave uintptr
	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+37986 /* "SLAVE" */)
		return TCL_ERROR
	}

	slave = tcl.XTcl_GetSlave(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	if !(slave != 0) {
		return TCL_ERROR
	}

	sqlite3TestInit(tls, slave)
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// Characters that make up the idxStr created by xBestIndex for xFilter.

type tclvar_vtab1 = struct {
	Fbase   sqlite3_vtab
	Finterp uintptr
} /* test_tclvar.c:58:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:
// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)stdlib.h	8.5 (Berkeley) 5/19/95
// $FreeBSD$

// -
// SPDX-License-Identifier: BSD-3-Clause
//
// Copyright (c) 1990, 1993
//	The Regents of the University of California.  All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. Neither the name of the University nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.
//
//	@(#)string.h	8.1 (Berkeley) 6/2/93
// $FreeBSD$

// Characters that make up the idxStr created by xBestIndex for xFilter.

type tclvar_vtab = tclvar_vtab1 /* test_tclvar.c:58:28 */
type tclvar_cursor1 = struct {
	Fbase   sqlite3_vtab_cursor
	FpList1 uintptr
	FpList2 uintptr
	Fi1     int32
	Fi2     int32
} /* test_tclvar.c:59:9 */

type tclvar_cursor = tclvar_cursor1 /* test_tclvar.c:59:30 */

// Methods for the tclvar module
func tclvarConnect(tls *libc.TLS, db uintptr, pAux uintptr, argc int32, argv uintptr, ppVtab uintptr, pzErr uintptr) int32 { /* test_tclvar.c:80:12: */
	var pVtab uintptr
	pVtab = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_vtab{})))
	if pVtab == uintptr(0) {
		return SQLITE_NOMEM
	}
	*(*uintptr)(unsafe.Pointer(ppVtab)) = pVtab
	(*tclvar_vtab)(unsafe.Pointer(pVtab)).Finterp = pAux
	sqlite3.Xsqlite3_declare_vtab(tls, db, uintptr(unsafe.Pointer(&zSchema)))
	return SQLITE_OK
}

var zSchema =

// Base name
// Array index
// Value
// base(index) name
*(*[100]int8)(unsafe.Pointer(ts + 37992 /* "CREATE TABLE x( ..." */)) /* test_tclvar.c:88:21 */

// Note that for this virtual table, the xCreate and xConnect
// methods are identical.

func tclvarDisconnect(tls *libc.TLS, pVtab uintptr) int32 { /* test_tclvar.c:105:12: */
	sqlite3.Xsqlite3_free(tls, pVtab)
	return SQLITE_OK
}

// The xDisconnect and xDestroy methods are also the same

// Open a new tclvar cursor.
func tclvarOpen(tls *libc.TLS, pVTab uintptr, ppCursor uintptr) int32 { /* test_tclvar.c:114:12: */
	var pCur uintptr
	pCur = sqlite3.Xsqlite3MallocZero(tls, uint64(unsafe.Sizeof(tclvar_cursor{})))
	*(*uintptr)(unsafe.Pointer(ppCursor)) = pCur
	return SQLITE_OK
}

// Close a tclvar cursor.
func tclvarClose(tls *libc.TLS, cur uintptr) int32 { /* test_tclvar.c:124:12: */
	var pCur uintptr = cur
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_free(tls, pCur)
	return SQLITE_OK
}

// Returns 1 if data is ready, or 0 if not.
func next2(tls *libc.TLS, interp uintptr, pCur uintptr, pObj uintptr) int32 { /* test_tclvar.c:139:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr

	if pObj != 0 {
		if !(int32((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2) != 0) {
			p = tcl.XTcl_NewStringObj(tls, ts+38092 /* "array names" */, -1)
			(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
			tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, pObj)
			tcl.XTcl_EvalObjEx(tls, interp, p, TCL_EVAL_GLOBAL)
			for ok := true; ok; ok = 0 != 0 {
				var _objPtr uintptr = p
				if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
					tcl.XTclFreeObj(tls, _objPtr)
				}
			}
			(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = tcl.XTcl_GetObjResult(tls, interp)
			(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2)).FrefCount++

		} else {
			*(*int32)(unsafe.Pointer(bp /* n */)) = 0
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2++
			tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, bp /* &n */)
			if (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 >= *(*int32)(unsafe.Pointer(bp)) {
				for ok1 := true; ok1; ok1 = 0 != 0 {
					var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
				(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
				(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
				return 0
			}
		}
	}

	return 1
}

func tclvarNext(tls *libc.TLS, cur uintptr) int32 { /* test_tclvar.c:168:12: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var pObj uintptr at bp+8, 8

	*(*int32)(unsafe.Pointer(bp /* n */)) = 0
	var ok int32 = 0

	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjLength(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, bp /* &n */)
	for !(ok != 0) && (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 < *(*int32)(unsafe.Pointer(bp)) {
		tcl.XTcl_ListObjIndex(tls, uintptr(0), (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+8 /* &pObj */)
		ok = next2(tls, interp, pCur, *(*uintptr)(unsafe.Pointer(bp + 8 /* pObj */)))
		if !(ok != 0) {
			(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1++
		}
	}

	return 0
}

func tclvarFilter(tls *libc.TLS, pVtabCursor uintptr, idxNum int32, idxStr uintptr, argc int32, argv uintptr) int32 { /* test_tclvar.c:188:12: */
	var pCur uintptr = pVtabCursor
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(pVtabCursor)).FpVtab)).Finterp
	var p uintptr = tcl.XTcl_NewStringObj(tls, ts+38104 /* "tclvar_filter_cm..." */, -1)

	var zEq uintptr = ts + 584     /* "" */
	var zMatch uintptr = ts + 584  /* "" */
	var zGlob uintptr = ts + 584   /* "" */
	var zRegexp uintptr = ts + 584 /* "" */
	var zLike uintptr = ts + 584   /* "" */
	var i int32

	for i = 0; *(*int8)(unsafe.Pointer(idxStr + uintptr(i))) != 0; i++ {
		switch int32(*(*int8)(unsafe.Pointer(idxStr + uintptr(i)))) {
		case 'e':
			zEq = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'm':
			zMatch = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'g':
			zGlob = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'r':
			zRegexp = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		case 'l':
			zLike = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + uintptr(i)*8)))
			break
		default:

		}
	}

	(*Tcl_Obj)(unsafe.Pointer(p)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zEq, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zMatch, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zGlob, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zRegexp, -1))
	tcl.XTcl_ListObjAppendElement(tls, uintptr(0), p, tcl.XTcl_NewStringObj(tls, zLike, -1))

	tcl.XTcl_EvalObjEx(tls, interp, p, TCL_EVAL_GLOBAL)
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
		for ok1 := true; ok1; ok1 = 0 != 0 {
			var _objPtr uintptr = (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 = uintptr(0)
	}
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2 = 0
	(*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1 = tcl.XTcl_GetObjResult(tls, interp)
	(*Tcl_Obj)(unsafe.Pointer((*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1)).FrefCount++

	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = p
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	return tclvarNext(tls, pVtabCursor)
}

func tclvarColumn(tls *libc.TLS, cur uintptr, ctx uintptr, i int32) int32 { /* test_tclvar.c:250:12: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var p1 uintptr at bp+16, 8

	// var p2 uintptr at bp+24, 8

	var z1 uintptr
	var z2 uintptr = ts + 584 /* "" */
	var pCur uintptr = cur
	var interp uintptr = (*tclvar_vtab)(unsafe.Pointer((*sqlite3_vtab_cursor)(unsafe.Pointer(cur)).FpVtab)).Finterp

	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList1, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi1, bp+16 /* &p1 */)
	tcl.XTcl_ListObjIndex(tls, interp, (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2, (*tclvar_cursor)(unsafe.Pointer(pCur)).Fi2, bp+24 /* &p2 */)
	z1 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* p1 */)))
	if *(*uintptr)(unsafe.Pointer(bp + 24)) != 0 {
		z2 = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(bp + 24 /* p2 */)))
	}
	switch i {
	case 0:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, libc.UintptrFromInt32(-1))
			break

		}
	case 1:
		{
			sqlite3.Xsqlite3_result_text(tls, ctx, z2, -1, libc.UintptrFromInt32(-1))
			break

		}
	case 2:
		{
			var pVal uintptr = tcl.XTcl_GetVar2Ex(tls, interp, z1, func() uintptr {
				if *(*int8)(unsafe.Pointer(z2)) != 0 {
					return z2
				}
				return uintptr(0)
			}(), TCL_GLOBAL_ONLY)
			sqlite3.Xsqlite3_result_text(tls, ctx, tcl.XTcl_GetString(tls, pVal), -1, libc.UintptrFromInt32(-1))
			break

		}
	case 3:
		{
			var z3 uintptr
			if *(*uintptr)(unsafe.Pointer(bp + 24)) != 0 {
				z3 = sqlite3.Xsqlite3_mprintf(tls, ts+38122 /* "%s(%s)" */, libc.VaList(bp, z1, z2))
				sqlite3.Xsqlite3_result_text(tls, ctx, z3, -1, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sqlite3.Xsqlite3_free})))
			} else {
				sqlite3.Xsqlite3_result_text(tls, ctx, z1, -1, libc.UintptrFromInt32(-1))
			}
			break

		}
	}
	return SQLITE_OK
}

func tclvarRowid(tls *libc.TLS, cur uintptr, pRowid uintptr) int32 { /* test_tclvar.c:292:12: */
	*(*sqlite_int64)(unsafe.Pointer(pRowid)) = int64(0)
	return SQLITE_OK
}

func tclvarEof(tls *libc.TLS, cur uintptr) int32 { /* test_tclvar.c:297:12: */
	var pCur uintptr = cur
	return func() int32 {
		if (*tclvar_cursor)(unsafe.Pointer(pCur)).FpList2 != 0 {
			return 0
		}
		return 1
	}()
}

// If nul-terminated string zStr does not already contain the character
// passed as the second argument, append it and return 0. Or, if there is
// already an instance of x in zStr, do nothing return 1;
//
// There is guaranteed to be enough room in the buffer pointed to by zStr
// for the new character and nul-terminator.
func tclvarAddToIdxstr(tls *libc.TLS, zStr uintptr, x int8) int32 { /* test_tclvar.c:310:12: */
	var i int32
	for i = 0; *(*int8)(unsafe.Pointer(zStr + uintptr(i))) != 0; i++ {
		if int32(*(*int8)(unsafe.Pointer(zStr + uintptr(i)))) == int32(x) {
			return 1
		}
	}
	*(*int8)(unsafe.Pointer(zStr + uintptr(i))) = x
	*(*int8)(unsafe.Pointer(zStr + uintptr(i+1))) = int8(0)
	return 0
}

// Return true if variable $::tclvar_set_omit exists and is set to true.
// False otherwise.
func tclvarSetOmit(tls *libc.TLS, interp uintptr) int32 { /* test_tclvar.c:324:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var rc int32
	*(*int32)(unsafe.Pointer(bp /* res */)) = 0
	var pRes uintptr
	rc = tcl.XTcl_Eval(tls, interp,
		ts+38129 /* "expr {[info exis..." */)
	if rc == TCL_OK {
		pRes = tcl.XTcl_GetObjResult(tls, interp)
		rc = tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), pRes, bp /* &res */)
	}
	return libc.Bool32(rc == TCL_OK && *(*int32)(unsafe.Pointer(bp)) != 0)
}

// The xBestIndex() method. This virtual table supports the following
// operators:
//
//     name = ?                    (omit flag clear)
//     name MATCH ?                (omit flag set)
//     value GLOB ?                (omit flag set iff $::tclvar_set_omit)
//     value REGEXP ?              (omit flag set iff $::tclvar_set_omit)
//     value LIKE ?                (omit flag set iff $::tclvar_set_omit)
//
// For each constraint present, the corresponding TCLVAR_XXX character is
// appended to the idxStr value.
func tclvarBestIndex(tls *libc.TLS, tab uintptr, pIdxInfo uintptr) int32 { /* test_tclvar.c:351:12: */
	var pTab uintptr = tab
	var ii int32
	var zStr uintptr = sqlite3.Xsqlite3_malloc(tls, 32)
	var iStr int32 = 0

	if zStr == uintptr(0) {
		return SQLITE_NOMEM
	}
	*(*int8)(unsafe.Pointer(zStr)) = int8(0)

	for ii = 0; ii < (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FnConstraint; ii++ {
		var pCons uintptr = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraint + uintptr(ii)*12
		var pUsage uintptr

		pUsage = (*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FaConstraintUsage + uintptr(ii)*8
		if (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fusable != 0 {
			// name = ?
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_EQ && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('e')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(0)
				}
			}

			// name MATCH ?
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_MATCH && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 0 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('m')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(1)
				}
			}

			// value GLOB ?
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_GLOB && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('g')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			// value REGEXP ?
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_REGEXP && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('r')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}

			// value LIKE ?
			if int32((*sqlite3_index_constraint)(unsafe.Pointer(pCons)).Fop) == SQLITE_INDEX_CONSTRAINT_LIKE && (*sqlite3_index_constraint)(unsafe.Pointer(pCons)).FiColumn == 2 {
				if 0 == tclvarAddToIdxstr(tls, zStr, int8('l')) {
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).FargvIndex = libc.PreIncInt32(&iStr, 1)
					(*sqlite3_index_constraint_usage)(unsafe.Pointer(pUsage)).Fomit = uint8(tclvarSetOmit(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp))
				}
			}
		}
	}
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FidxStr = zStr
	(*sqlite3_index_info)(unsafe.Pointer(pIdxInfo)).FneedToFreeIdxStr = 1

	return SQLITE_OK
}

// Invoked for any UPDATE, INSERT, or DELETE against a tclvar table
func tclvarUpdate(tls *libc.TLS, tab uintptr, argc int32, argv uintptr, pRowid uintptr) int32 { /* test_tclvar.c:416:12: */
	var pTab uintptr = tab
	if argc == 1 {
		// A DELETE operation.  The variable to be deleted is stored in argv[0]
		var zVar uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zVar, uintptr(0), TCL_GLOBAL_ONLY)
		return SQLITE_OK
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_NULL {
		// An INSERT operation
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)))
		var zName uintptr
		if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8))) != SQLITE_TEXT {
			(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+38190 /* "the 'fullname' c..." */, 0)
			return SQLITE_ERROR
		}
		zName = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 5*8)))
		if zValue != 0 {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), zValue, TCL_GLOBAL_ONLY)
		} else {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zName, uintptr(0), TCL_GLOBAL_ONLY)
		}
		return SQLITE_OK
	}
	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv))) == SQLITE_TEXT &&
		sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8))) == SQLITE_TEXT {
		// An UPDATE operation
		var zOldName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv)))
		var zNewName uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)))
		var zValue uintptr = sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(argv + 4*8)))

		if libc.Xstrcmp(tls, zOldName, zNewName) != 0 || zValue == uintptr(0) {
			tcl.XTcl_UnsetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zOldName, uintptr(0), TCL_GLOBAL_ONLY)
		}
		if zValue != uintptr(0) {
			tcl.XTcl_SetVar2(tls, (*tclvar_vtab)(unsafe.Pointer(pTab)).Finterp, zNewName, uintptr(0), zValue, TCL_GLOBAL_ONLY)
		}
		return SQLITE_OK
	}
	(*sqlite3_vtab)(unsafe.Pointer(tab)).FzErrMsg = sqlite3.Xsqlite3_mprintf(tls, ts+38225 /* "prohibited TCL v..." */, 0)
	return SQLITE_ERROR
}

// A virtual table module that provides read-only access to a
// Tcl global variable namespace.
var tclvarModule = sqlite3_module{ // iVersion
	FxCreate:     0,
	FxConnect:    0,
	FxBestIndex:  0,
	FxDisconnect: 0,
	FxDestroy:    0,
	FxOpen:       0, // xOpen - open a cursor
	FxClose:      0, // xClose - close a cursor
	FxFilter:     0, // xFilter - configure scan constraints
	FxNext:       0, // xNext - advance a cursor
	FxEof:        0, // xEof - check for end of scan
	FxColumn:     0, // xColumn - read data
	FxRowid:      0, // xRowid - read data
	FxUpdate:     0, // xRename
} /* test_tclvar.c:469:23 */

// Register the echo virtual table module.
func register_tclvar_module(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_tclvar.c:500:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var rc int32 = TCL_OK
	// var db uintptr at bp, 8

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	sqlite3.Xsqlite3_create_module(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+30409 /* "tclvar" */, uintptr(unsafe.Pointer(&tclvarModule)), interp)
	rc = tcl.XTcl_Eval(tls, interp,

		ts+38256 /* "proc like {patte..." */)
	return rc
}

// Register commands with the TCL interpreter.
func Sqlitetesttclvar_Init(tls *libc.TLS, interp uintptr) int32 { /* test_tclvar.c:546:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd13))/uint64(unsafe.Sizeof(struct {
		FzName      uintptr
		FxProc      uintptr
		FclientData uintptr
	}{})); i++ {
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd13[i].FzName,
			aObjCmd13[i].FxProc, aObjCmd13[i].FclientData, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd13 = [1]struct {
	FzName      uintptr
	FxProc      uintptr
	FclientData uintptr
}{
	{FzName: ts + 38792 /* "register_tclvar_..." */, FxProc: 0},
} /* test_tclvar.c:552:5 */
// getopt(3) external variable

// One of these is allocated for each thread created by [sqlthread spawn].
type SqlThread1 = struct {
	Fparent   Tcl_ThreadId
	Finterp   uintptr
	FzScript  uintptr
	FzVarname uintptr
} /* test_thread.c:36:9 */

// getopt(3) external variable

// One of these is allocated for each thread created by [sqlthread spawn].
type SqlThread = SqlThread1 /* test_thread.c:36:26 */

// A custom Tcl_Event type used by this module. When the event is
// handled, script zScript is evaluated in interpreter interp. If
// the evaluation throws an exception (returns TCL_ERROR), then the
// error is handled by Tcl_BackgroundError(). If no error occurs,
// the result is simply discarded.
type EvalEvent1 = struct {
	Fbase    Tcl_Event
	FzScript uintptr
	Finterp  uintptr
} /* test_thread.c:51:9 */

// A custom Tcl_Event type used by this module. When the event is
// handled, script zScript is evaluated in interpreter interp. If
// the evaluation throws an exception (returns TCL_ERROR), then the
// error is handled by Tcl_BackgroundError(). If no error occurs,
// the result is simply discarded.
type EvalEvent = EvalEvent1 /* test_thread.c:51:26 */

// Handler for events of type EvalEvent.
func tclScriptEvent(tls *libc.TLS, evPtr uintptr, flags int32) int32 { /* test_thread.c:79:26: */
	var rc int32
	var p uintptr = evPtr
	rc = tcl.XTcl_Eval(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp, (*EvalEvent)(unsafe.Pointer(p)).FzScript)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*EvalEvent)(unsafe.Pointer(p)).Finterp)
	}
	_ = flags
	return 1
}

// Register an EvalEvent to evaluate the script pScript in the
// parent interpreter/thread of SqlThread p.
func postToParent(tls *libc.TLS, p uintptr, pScript uintptr) { /* test_thread.c:94:13: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var pEvent uintptr
	var zMsg uintptr
	// var nMsg int32 at bp, 4

	zMsg = tcl.XTcl_GetStringFromObj(tls, pScript, bp /* &nMsg */)
	pEvent = tcl.XTcl_Alloc(tls, uint32(uint64(unsafe.Sizeof(EvalEvent{}))+uint64(*(*int32)(unsafe.Pointer(bp)))+uint64(1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = pEvent + 1*32
	libc.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, uint64(*(*int32)(unsafe.Pointer(bp))+1))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp

	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, TCL_QUEUE_TAIL)
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)
}

// The main function for threads created with [sqlthread spawn].
func tclScriptThread(tls *libc.TLS, pSqlThread ClientData) { /* test_thread.c:114:29: */
	var interp uintptr
	var pRes uintptr
	var pList uintptr
	var rc int32
	var p uintptr = pSqlThread

	interp = tcl.XTcl_CreateInterp(tls)
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38815 /* "clock_seconds" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{clock_seconds_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38829 /* "sqlthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{sqlthread_proc})), pSqlThread, uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38839 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{blocking_step_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+38861 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(1), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+38889 /* "sqlite3_nonblock..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(0), uintptr(0))
	Sqlitetest1_Init(tls, interp)
	Sqlitetest_mutex_Init(tls, interp)
	Sqlite3_Init(tls, interp)

	rc = tcl.XTcl_Eval(tls, interp, (*SqlThread)(unsafe.Pointer(p)).FzScript)
	pRes = tcl.XTcl_GetObjResult(tls, interp)
	pList = tcl.XTcl_NewObj(tls)
	(*Tcl_Obj)(unsafe.Pointer(pList)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer(pRes)).FrefCount++

	if rc != TCL_OK {
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+10506 /* "error" */, -1))
		tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
		postToParent(tls, p, pList)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pList
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		pList = tcl.XTcl_NewObj(tls)
	}

	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, ts+38920 /* "set" */, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, tcl.XTcl_NewStringObj(tls, (*SqlThread)(unsafe.Pointer(p)).FzVarname, -1))
	tcl.XTcl_ListObjAppendElement(tls, interp, pList, pRes)
	postToParent(tls, p, pList)

	tcl.XTcl_Free(tls, p)
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pList
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	for ok2 := true; ok2; ok2 = 0 != 0 {
		var _objPtr uintptr = pRes
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
	tcl.XTcl_DeleteInterp(tls, interp)
	for tcl.XTcl_DoOneEvent(tls, libc.CplInt32(int32(1)<<1)|int32(1)<<1) != 0 {
	}
	tcl.XTcl_ExitThread(tls, 0)

}

// sqlthread spawn VARNAME SCRIPT
//
//     Spawn a new thread with its own Tcl interpreter and run the
//     specified SCRIPT(s) in it. The thread terminates after running
//     the script. The result of the script is stored in the variable
//     VARNAME.
//
//     The caller can wait for the script to terminate using [vwait VARNAME].
func sqlthread_spawn(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:174:26: */
	bp := tls.Alloc(32)
	defer tls.Free(32)

	// var x Tcl_ThreadId at bp+24, 8

	var pNew uintptr
	var rc int32
	// var nVarname int32 at bp+16, 4

	var zVarname uintptr
	// var nScript int32 at bp+20, 4

	var zScript uintptr

	// Parameters for thread creation
	var nStack int32 = 0
	var flags int32 = 0000

	_ = clientData
	_ = objc

	zVarname = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+16 /* &nVarname */)
	zScript = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+20 /* &nScript */)

	pNew = tcl.XTcl_Alloc(tls, uint32(uint64(unsafe.Sizeof(SqlThread{}))+uint64(*(*int32)(unsafe.Pointer(bp + 16)))+uint64(*(*int32)(unsafe.Pointer(bp + 20)))+uint64(2)))
	(*SqlThread)(unsafe.Pointer(pNew)).FzVarname = pNew + 1*32
	(*SqlThread)(unsafe.Pointer(pNew)).FzScript = (*SqlThread)(unsafe.Pointer(pNew)).FzVarname + uintptr(*(*int32)(unsafe.Pointer(bp + 16))+1)
	libc.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzVarname, zVarname, uint64(*(*int32)(unsafe.Pointer(bp + 16))+1))
	libc.Xmemcpy(tls, (*SqlThread)(unsafe.Pointer(pNew)).FzScript, zScript, uint64(*(*int32)(unsafe.Pointer(bp + 20))+1))
	(*SqlThread)(unsafe.Pointer(pNew)).Fparent = tcl.XTcl_GetCurrentThread(tls)
	(*SqlThread)(unsafe.Pointer(pNew)).Finterp = interp

	rc = tcl.XTcl_CreateThread(tls, bp+24 /* &x */, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{tclScriptThread})), pNew, nStack, flags)
	if rc != TCL_OK {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+38924 /* "Error in Tcl_Cre..." */, 0))
		tcl.XTcl_Free(tls, pNew)
		return TCL_ERROR
	}

	return TCL_OK
}

// sqlthread parent SCRIPT
//
//     This can be called by spawned threads only. It sends the specified
//     script back to the parent thread for execution. The result of
//     evaluating the SCRIPT is returned. The parent thread must enter
//     the event loop for this to work - otherwise the caller will
//     block indefinitely.
//
//     NOTE: At the moment, this doesn't work. FIXME.
func sqlthread_parent(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:227:26: */
	bp := tls.Alloc(20)
	defer tls.Free(20)

	var pEvent uintptr
	var zMsg uintptr
	// var nMsg int32 at bp+16, 4

	var p uintptr = clientData

	_ = objc

	if p == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+38952 /* "no parent thread" */, 0))
		return TCL_ERROR
	}

	zMsg = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+16 /* &nMsg */)
	pEvent = tcl.XTcl_Alloc(tls, uint32(uint64(unsafe.Sizeof(EvalEvent{}))+uint64(*(*int32)(unsafe.Pointer(bp + 16)))+uint64(1)))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.FnextPtr = uintptr(0)
	(*EvalEvent)(unsafe.Pointer(pEvent)).Fbase.Fproc = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{tclScriptEvent}))
	(*EvalEvent)(unsafe.Pointer(pEvent)).FzScript = pEvent + 1*32
	libc.Xmemcpy(tls, (*EvalEvent)(unsafe.Pointer(pEvent)).FzScript, zMsg, uint64(*(*int32)(unsafe.Pointer(bp + 16))+1))
	(*EvalEvent)(unsafe.Pointer(pEvent)).Finterp = (*SqlThread)(unsafe.Pointer(p)).Finterp
	tcl.XTcl_ThreadQueueEvent(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent, pEvent, TCL_QUEUE_TAIL)
	tcl.XTcl_ThreadAlert(tls, (*SqlThread)(unsafe.Pointer(p)).Fparent)

	return TCL_OK
}

func xBusy(tls *libc.TLS, pArg uintptr, nBusy int32) int32 { /* test_thread.c:259:12: */
	_ = pArg
	_ = nBusy
	sqlite3.Xsqlite3_sleep(tls, 50)
	return 1 // Try again...
}

// sqlthread open
//
//     Open a database handle and return the string representation of
//     the pointer value.
func sqlthread_open(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:272:26: */
	bp := tls.Alloc(124)
	defer tls.Free(124)

	var zFilename uintptr
	// var db uintptr at bp+16, 8

	// var zBuf [100]int8 at bp+24, 100

	_ = clientData
	_ = objc

	zFilename = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	sqlite3.Xsqlite3_open(tls, zFilename, bp+16 /* &db */)
	Md5_Register(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), uintptr(0), uintptr(0))
	sqlite3.Xsqlite3_busy_handler(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{xBusy})), uintptr(0))

	if sqlite3TestMakePointerStr(tls, interp, bp+24, *(*uintptr)(unsafe.Pointer(bp + 16))) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, bp+24 /* &zBuf[0] */, 0))

	return TCL_OK
}

// sqlthread open
//
//     Return the current thread-id (Tcl_GetCurrentThread()) cast to
//     an integer.
func sqlthread_id(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:306:26: */
	var id Tcl_ThreadId = tcl.XTcl_GetCurrentThread(tls)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(id)))
	_ = clientData
	_ = objc
	_ = objv
	return TCL_OK
}

// Dispatch routine for the sub-commands of [sqlthread].
func sqlthread_proc(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:324:26: */
	bp := tls.Alloc(164)
	defer tls.Free(164)

	*(*[5]struct {
		FzName       uintptr
		FxProc       uintptr
		FnArg        int32
		F__ccgo_pad1 [4]byte
		FzUsage      uintptr
	})(unsafe.Pointer(bp)) = [5]struct {
		FzName       uintptr
		FxProc       uintptr
		FnArg        int32
		F__ccgo_pad1 [4]byte
		FzUsage      uintptr
	}{
		{FzName: ts + 38969 /* "parent" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_parent})), FnArg: 1, FzUsage: ts + 11019 /* "SCRIPT" */},
		{FzName: ts + 38976 /* "spawn" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_spawn})), FnArg: 2, FzUsage: ts + 38982 /* "VARNAME SCRIPT" */},
		{FzName: ts + 37586 /* "open" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_open})), FnArg: 1, FzUsage: ts + 38997 /* "DBNAME" */},
		{FzName: ts + 39004 /* "id" */, FxProc: *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
		}{sqlthread_id})), FzUsage: ts + 584 /* "" */},
		{},
	}
	var pSub uintptr
	var rc int32
	// var iIndex int32 at bp+160, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2523 /* "SUB-COMMAND" */)
		return TCL_ERROR
	}

	rc = tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp /* &aSub[0] */, int32(unsafe.Sizeof(struct {
			FzName       uintptr
			FxProc       uintptr
			FnArg        int32
			F__ccgo_pad1 [4]byte
			FzUsage      uintptr
		}{})), ts+2014 /* "sub-command" */, 0, bp+160 /* &iIndex */)
	if rc != TCL_OK {
		return rc
	}
	pSub = bp + uintptr(*(*int32)(unsafe.Pointer(bp + 160)))*32

	if objc < (*struct {
		FzName       uintptr
		FxProc       uintptr
		FnArg        int32
		F__ccgo_pad1 [4]byte
		FzUsage      uintptr
	})(unsafe.Pointer(pSub)).FnArg+2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, (*struct {
			FzName       uintptr
			FxProc       uintptr
			FnArg        int32
			F__ccgo_pad1 [4]byte
			FzUsage      uintptr
		})(unsafe.Pointer(pSub)).FzUsage)
		return TCL_ERROR
	}

	return (*struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*struct {
		FzName       uintptr
		FxProc       uintptr
		FnArg        int32
		F__ccgo_pad1 [4]byte
		FzUsage      uintptr
	})(unsafe.Pointer(pSub)).FxProc})).f(tls, clientData, interp, objc, objv)
}

/*
** The [clock_seconds] command. This is more or less the same as the
** regular tcl [clock seconds], except that it is available in testfixture
** when linked against both Tcl 8.4 and 8.5. Because [clock seconds] is
** implemented as a script in Tcl 8.5, it is not usually available to
** testfixture.
 */
func clock_seconds_proc(tls *libc.TLS, clientData ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:372:26: */
	bp := tls.Alloc(16)
	defer tls.Free(16)

	// var now Tcl_Time at bp, 16

	tcl.XTcl_GetTime(tls, bp /* &now */)
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32((*Tcl_Time)(unsafe.Pointer(bp /* &now */)).Fsec)))
	_ = clientData
	_ = objc
	_ = objv
	return TCL_OK
}

// A pointer to an instance of this structure is passed as the user-context
// pointer when registering for an unlock-notify callback.
type UnlockNotification1 = struct {
	Ffired       int32
	F__ccgo_pad1 [4]byte
	Fcond        pthread_cond_t
	Fmutex       pthread_mutex_t
} /* test_thread.c:410:9 */

// A pointer to an instance of this structure is passed as the user-context
// pointer when registering for an unlock-notify callback.
type UnlockNotification = UnlockNotification1 /* test_thread.c:410:35 */

// This function is an unlock-notify callback registered with SQLite.
func unlock_notify_cb(tls *libc.TLS, apArg uintptr, nArg int32) { /* test_thread.c:420:13: */
	var i int32
	for i = 0; i < nArg; i++ {
		var p uintptr = *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))
		libc.Xpthread_mutex_lock(tls, p+16)
		(*UnlockNotification)(unsafe.Pointer(p)).Ffired = 1
		libc.Xpthread_cond_signal(tls, p+8)
		libc.Xpthread_mutex_unlock(tls, p+16)
	}
}

// This function assumes that an SQLite API call (either sqlite3_prepare_v2()
// or sqlite3_step()) has just returned SQLITE_LOCKED. The argument is the
// associated database connection.
//
// This function calls sqlite3_unlock_notify() to register for an
// unlock-notify callback, then blocks until that callback is delivered
// and returns SQLITE_OK. The caller should then retry the failed operation.
//
// Or, if sqlite3_unlock_notify() indicates that to block would deadlock
// the system, then this function returns SQLITE_LOCKED immediately. In
// this case the caller should not retry the operation and should roll
// back the current transaction (if any).
func wait_for_unlock_notify(tls *libc.TLS, db uintptr) int32 { /* test_thread.c:445:12: */
	bp := tls.Alloc(24)
	defer tls.Free(24)

	var rc int32
	// var un UnlockNotification at bp, 24

	// Initialize the UnlockNotification structure.
	(*UnlockNotification)(unsafe.Pointer(bp /* &un */)).Ffired = 0
	libc.Xpthread_mutex_init(tls, bp+16, uintptr(0))
	libc.Xpthread_cond_init(tls, bp+8, uintptr(0))

	// Register for an unlock-notify callback.
	rc = sqlite3.Xsqlite3_unlock_notify(tls, db, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32)
	}{unlock_notify_cb})), bp /* &un */)

	// The call to sqlite3_unlock_notify() always returns either SQLITE_LOCKED
	// or SQLITE_OK.
	//
	// If SQLITE_LOCKED was returned, then the system is deadlocked. In this
	// case this function needs to return SQLITE_LOCKED to the caller so
	// that the current transaction can be rolled back. Otherwise, block
	// until the unlock-notify callback is invoked, then return SQLITE_OK.
	if rc == SQLITE_OK {
		libc.Xpthread_mutex_lock(tls, bp+16)
		if !((*UnlockNotification)(unsafe.Pointer(bp)).Ffired != 0) {
			libc.Xpthread_cond_wait(tls, bp+8, bp+16)
		}
		libc.Xpthread_mutex_unlock(tls, bp+16)
	}

	// Destroy the mutex and condition variables.
	libc.Xpthread_cond_destroy(tls, bp+8)
	libc.Xpthread_mutex_destroy(tls, bp+16)

	return rc
}

// This function is a wrapper around the SQLite function sqlite3_step().
// It functions in the same way as step(), except that if a required
// shared-cache lock cannot be obtained, this function may block waiting for
// the lock to become available. In this scenario the normal API step()
// function always returns SQLITE_LOCKED.
//
// If this function returns SQLITE_LOCKED, the caller should rollback
// the current transaction (if any) and try again later. Otherwise, the
// system may become deadlocked.
func sqlite3_blocking_step(tls *libc.TLS, pStmt uintptr) int32 { /* test_thread.c:492:5: */
	var rc int32
	for SQLITE_LOCKED == libc.AssignInt32(&rc, sqlite3.Xsqlite3_step(tls, pStmt)) {
		rc = wait_for_unlock_notify(tls, sqlite3.Xsqlite3_db_handle(tls, pStmt))
		if rc != SQLITE_OK {
			break
		}
		sqlite3.Xsqlite3_reset(tls, pStmt)
	}
	return rc
}

// This function is a wrapper around the SQLite function sqlite3_prepare_v2().
// It functions in the same way as prepare_v2(), except that if a required
// shared-cache lock cannot be obtained, this function may block waiting for
// the lock to become available. In this scenario the normal API prepare_v2()
// function always returns SQLITE_LOCKED.
//
// If this function returns SQLITE_LOCKED, the caller should rollback
// the current transaction (if any) and try again later. Otherwise, the
// system may become deadlocked.
func sqlite3_blocking_prepare_v2(tls *libc.TLS, db uintptr, zSql uintptr, nSql int32, ppStmt uintptr, pz uintptr) int32 { /* test_thread.c:513:5: */
	var rc int32
	for SQLITE_LOCKED == libc.AssignInt32(&rc, sqlite3.Xsqlite3_prepare_v2(tls, db, zSql, nSql, ppStmt, pz)) {
		rc = wait_for_unlock_notify(tls, db)
		if rc != SQLITE_OK {
			break
		}
	}
	return rc
}

// END_SQLITE_BLOCKING_STEP

// Usage: sqlite3_blocking_step STMT
//
// Advance the statement to the next row.
func blocking_step_proc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:534:26: */
	var pStmt uintptr
	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+17778 /* "STMT" */)
		return TCL_ERROR
	}

	pStmt = sqlite3TestTextToPtr(tls, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))))
	rc = sqlite3_blocking_step(tls, pStmt)

	tcl.XTcl_SetResult(tls, interp, sqlite3.Xsqlite3ErrName(tls, rc), uintptr(0))
	return TCL_OK
}

// Usage: sqlite3_blocking_prepare_v2 DB sql bytes ?tailvar?
// Usage: sqlite3_nonblocking_prepare_v2 DB sql bytes ?tailvar?
func blocking_prepare_v2_proc(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_thread.c:560:26: */
	bp := tls.Alloc(162)
	defer tls.Free(162)

	// var db uintptr at bp+80, 8

	var zSql uintptr
	// var bytes int32 at bp+88, 4

	*(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)) = uintptr(0)
	*(*uintptr)(unsafe.Pointer(bp + 96 /* pStmt */)) = uintptr(0)
	// var zBuf [50]int8 at bp+112, 50

	var rc int32
	var isBlocking int32 = libc.BoolInt32(!(clientData == uintptr(0)))

	if objc != 5 && objc != 4 {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+15776, /* "wrong # args: sh..." */
			tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))), ts+17824 /* " DB sql bytes ta..." */, 0))
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+80) != 0 {
		return TCL_ERROR
	}
	zSql = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+88) != 0 {
		return TCL_ERROR
	}

	if isBlocking != 0 {
		rc = sqlite3_blocking_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+96 /* &pStmt */, bp+104 /* &zTail */)
	} else {
		rc = sqlite3.Xsqlite3_prepare_v2(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */)), zSql, *(*int32)(unsafe.Pointer(bp + 88 /* bytes */)), bp+96 /* &pStmt */, bp+104 /* &zTail */)
	}

	if *(*uintptr)(unsafe.Pointer(bp + 104)) != 0 && objc >= 5 {
		if *(*int32)(unsafe.Pointer(bp + 88)) >= 0 {
			*(*int32)(unsafe.Pointer(bp + 88 /* bytes */)) = int32(int64(*(*int32)(unsafe.Pointer(bp + 88))) - (int64(*(*uintptr)(unsafe.Pointer(bp + 104)))-int64(zSql))/1)
		}
		tcl.XTcl_ObjSetVar2(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), uintptr(0), tcl.XTcl_NewStringObj(tls, *(*uintptr)(unsafe.Pointer(bp + 104 /* zTail */)), *(*int32)(unsafe.Pointer(bp + 88 /* bytes */))), 0)
	}
	if rc != SQLITE_OK {

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([50]int8{})), bp+112 /* &zBuf[0] */, ts+39007 /* "%s " */, libc.VaList(bp+32, sqlite3.Xsqlite3ErrName(tls, rc)))
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+40, bp+112 /* &zBuf[0] */, sqlite3.Xsqlite3_errmsg(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* db */))), 0))
		return TCL_ERROR
	}

	if *(*uintptr)(unsafe.Pointer(bp + 96)) != 0 {
		if sqlite3TestMakePointerStr(tls, interp, bp+112, *(*uintptr)(unsafe.Pointer(bp + 96))) != 0 {
			return TCL_ERROR
		}
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+64, bp+112 /* &zBuf[0] */, 0))
	}
	return TCL_OK
}

//
// End of implementation of [sqlite3_blocking_step].
//

// Register commands with the TCL interpreter.
func SqlitetestThread_Init(tls *libc.TLS, interp uintptr) int32 { /* test_thread.c:619:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38829 /* "sqlthread" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{sqlthread_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38815 /* "clock_seconds" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{clock_seconds_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+38839 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{blocking_step_proc})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+38861 /* "sqlite3_blocking..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(1), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp,
		ts+38889 /* "sqlite3_nonblock..." */, *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
		}{blocking_prepare_v2_proc})), uintptr(0), uintptr(0))
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

func Sqlitetestvdbecov_Init(tls *libc.TLS, interp uintptr) int32 { /* test_vdbecov.c:113:5: */
	return TCL_OK
}

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Testvfs1 = struct {
	FzName        uintptr
	FpParent      uintptr
	FpVfs         uintptr
	Finterp       uintptr
	FpScript      uintptr
	FpBuffer      uintptr
	FisNoshm      int32
	FisFullshm    int32
	Fmask         int32
	Fioerr_err    TestFaultInject
	Ffull_err     TestFaultInject
	Fcantopen_err TestFaultInject
	FiDevchar     int32
	FiSectorsize  int32
} /* test_vfs.c:37:9 */

// end block for C++

// Local Variables:
// mode: c
// c-basic-offset: 4
// fill-column: 78
// End:

type Testvfs = Testvfs1 /* test_vfs.c:37:24 */
type TestvfsBuffer1 = struct {
	FzFile       uintptr
	Fpgsz        int32
	F__ccgo_pad1 [4]byte
	FaPage       [1024]uintptr
	FpFile       uintptr
	FpNext       uintptr
} /* test_vfs.c:37:9 */

type TestvfsBuffer = TestvfsBuffer1 /* test_vfs.c:39:30 */
type TestvfsFile1 = struct {
	Fbase sqlite3_file
	FpFd  uintptr
} /* test_vfs.c:40:9 */

type TestvfsFile = TestvfsFile1 /* test_vfs.c:40:28 */
type TestvfsFd1 = struct {
	FpVfs       uintptr
	FzFilename  uintptr
	FpReal      uintptr
	FpShmId     uintptr
	FpShm       uintptr
	Fexcllock   u32
	Fsharedlock u32
	FpNext      uintptr
} /* test_vfs.c:37:9 */

type TestvfsFd = TestvfsFd1 /* test_vfs.c:41:26 */

type TestFaultInject1 = struct {
	FiCnt   int32
	FeFault int32
	FnFail  int32
} /* test_vfs.c:37:9 */

type TestFaultInject = TestFaultInject1 /* test_vfs.c:69:32 */

var tvfs_io_methods = sqlite3_io_methods{
	FiVersion:               3, // iVersion
	FxClose:                 0, // xClose
	FxRead:                  0, // xRead
	FxWrite:                 0, // xWrite
	FxTruncate:              0, // xTruncate
	FxSync:                  0, // xSync
	FxFileSize:              0, // xFileSize
	FxLock:                  0, // xLock
	FxUnlock:                0, // xUnlock
	FxCheckReservedLock:     0, // xCheckReservedLock
	FxFileControl:           0, // xFileControl
	FxSectorSize:            0, // xSectorSize
	FxDeviceCharacteristics: 0, // xDeviceCharacteristics
	FxShmMap:                0, // xShmMap
	FxShmLock:               0, // xShmLock
	FxShmBarrier:            0, // xShmBarrier
	FxShmUnmap:              0, // xShmUnmap
	FxFetch:                 0,
	FxUnfetch:               0,
} /* test_vfs.c:204:27 */

func tvfsResultCode(tls *libc.TLS, p uintptr, pRc uintptr) int32 { /* test_vfs.c:226:12: */
	bp := tls.Alloc(144)
	defer tls.Free(144)

	*(*[9]errcode)(unsafe.Pointer(bp /* aCode */)) = [9]errcode{
		{FzCode: ts + 2127 /* "SQLITE_OK" */},
		{FeCode: SQLITE_ERROR, FzCode: ts + 2114 /* "SQLITE_ERROR" */},
		{FeCode: SQLITE_IOERR, FzCode: ts + 39011 /* "SQLITE_IOERR" */},
		{FeCode: SQLITE_LOCKED, FzCode: ts + 39024 /* "SQLITE_LOCKED" */},
		{FeCode: SQLITE_BUSY, FzCode: ts + 39038 /* "SQLITE_BUSY" */},
		{FeCode: SQLITE_READONLY, FzCode: ts + 39050 /* "SQLITE_READONLY" */},
		{FeCode: SQLITE_READONLY | int32(5)<<8, FzCode: ts + 39066 /* "SQLITE_READONLY_..." */},
		{FeCode: SQLITE_NOTFOUND, FzCode: ts + 39091 /* "SQLITE_NOTFOUND" */},
		{FeCode: -1, FzCode: ts + 39107 /* "SQLITE_OMIT" */},
	}
	var z uintptr
	var i int32

	z = tcl.XTcl_GetStringResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	for i = 0; i < int32(uint64(unsafe.Sizeof([9]errcode{}))/uint64(unsafe.Sizeof(errcode{}))); i++ {
		if 0 == libc.Xstrcmp(tls, z, (*errcode)(unsafe.Pointer(bp+uintptr(i)*16)).FzCode) {
			*(*int32)(unsafe.Pointer(pRc)) = (*errcode)(unsafe.Pointer(bp /* &aCode */ + uintptr(i)*16)).FeCode
			return 1
		}
	}

	return 0
}

type errcode = struct {
	FeCode       int32
	F__ccgo_pad1 [4]byte
	FzCode       uintptr
} /* test_vfs.c:227:3 */

func tvfsInjectFault(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:256:12: */
	var ret int32 = 0
	if (*TestFaultInject)(unsafe.Pointer(p)).FeFault != 0 {
		(*TestFaultInject)(unsafe.Pointer(p)).FiCnt--
		if (*TestFaultInject)(unsafe.Pointer(p)).FiCnt == 0 || (*TestFaultInject)(unsafe.Pointer(p)).FiCnt < 0 && (*TestFaultInject)(unsafe.Pointer(p)).FeFault == FAULT_INJECT_PERSISTENT {
			ret = 1
			(*TestFaultInject)(unsafe.Pointer(p)).FnFail++
		}
	}
	return ret
}

func tvfsInjectIoerr(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:269:12: */
	return tvfsInjectFault(tls, p+60)
}

func tvfsInjectFullerr(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:273:12: */
	return tvfsInjectFault(tls, p+72)
}

func tvfsInjectCantopenerr(tls *libc.TLS, p uintptr) int32 { /* test_vfs.c:276:12: */
	return tvfsInjectFault(tls, p+84)
}

func tvfsExecTcl(tls *libc.TLS, p uintptr, zMethod uintptr, arg1 uintptr, arg2 uintptr, arg3 uintptr, arg4 uintptr) { /* test_vfs.c:281:13: */
	var rc int32 // Return code from Tcl_EvalObj()
	var pEval uintptr

	pEval = tcl.XTcl_DuplicateObj(tls, (*Testvfs)(unsafe.Pointer(p)).FpScript)
	(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
	tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, zMethod, -1))
	if arg1 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg1)
	}
	if arg2 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg2)
	}
	if arg3 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg3)
	}
	if arg4 != 0 {
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, arg4)
	}

	rc = tcl.XTcl_EvalObjEx(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
	if rc != TCL_OK {
		tcl.XTcl_BackgroundError(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	}
}

// Close an tvfs-file.
func tvfsClose(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:317:12: */
	var pTestfile uintptr = pFile
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_CLOSE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+36109, /* "xClose" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	}
	if (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods != 0 {
		tcl.XTcl_Free(tls, (*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods)
	}
	sqlite3.Xsqlite3OsClose(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
	tcl.XTcl_Free(tls, pFd)
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = uintptr(0)
	return SQLITE_OK
}

// Read data from an tvfs-file.
func tvfsRead(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_vfs.c:344:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_READ_MASK != 0 {
		tvfsExecTcl(tls, p, ts+36116, /* "xRead" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_READ_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsRead(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Write data to an tvfs-file.
func tvfsWrite(tls *libc.TLS, pFile uintptr, zBuf uintptr, iAmt int32, iOfst sqlite_int64) int32 { /* test_vfs.c:371:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_WRITE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+36122, /* "xWrite" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewWideIntObj(tls, iOfst), tcl.XTcl_NewIntObj(tls, iAmt))
		tvfsResultCode(tls, p, bp /* &rc */)
		if *(*int32)(unsafe.Pointer(bp)) < 0 {
			return SQLITE_OK
		}
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && tvfsInjectFullerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_FULL
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_WRITE_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsWrite(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, zBuf, iAmt, iOfst)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Truncate an tvfs-file.
func tvfsTruncate(tls *libc.TLS, pFile uintptr, size sqlite_int64) int32 { /* test_vfs.c:406:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_TRUNCATE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+36129, /* "xTruncate" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsTruncate(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, size)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Sync an tvfs-file.
func tvfsSync(tls *libc.TLS, pFile uintptr, flags int32) int32 { /* test_vfs.c:427:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SYNC_MASK != 0 {
		var zFlags uintptr = uintptr(0)

		switch flags {
		case SQLITE_SYNC_NORMAL:
			zFlags = ts + 17229 /* "normal" */
			break
			fallthrough
		case SQLITE_SYNC_FULL:
			zFlags = ts + 19027 /* "full" */
			break
			fallthrough
		case SQLITE_SYNC_NORMAL | SQLITE_SYNC_DATAONLY:
			zFlags = ts + 39119 /* "normal|dataonly" */
			break
			fallthrough
		case SQLITE_SYNC_FULL | SQLITE_SYNC_DATAONLY:
			zFlags = ts + 39135 /* "full|dataonly" */
			break
			fallthrough
		default:

		}

		tvfsExecTcl(tls, p, ts+28484, /* "xSync" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, zFlags, -1), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && tvfsInjectFullerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_FULL
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsSync(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags)
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Return the current file-size of an tvfs-file.
func tvfsFileSize(tls *libc.TLS, pFile uintptr, pSize uintptr) int32 { /* test_vfs.c:471:12: */
	var p uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFileSize(tls, (*TestvfsFd)(unsafe.Pointer(p)).FpReal, pSize)
}

// Lock an tvfs-file.
func tvfsLock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_vfs.c:479:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_LOCK_MASK != 0 {
		// var zLock [30]int8 at bp+8, 30

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8 /* &zLock[0] */, ts+1333 /* "%d" */, libc.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+36149 /* "xLock" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8 /* &zLock[0] */, -1), uintptr(0), uintptr(0))
	}
	return sqlite3.Xsqlite3OsLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

// Unlock an tvfs-file.
func tvfsUnlock(tls *libc.TLS, pFile uintptr, eLock int32) int32 { /* test_vfs.c:494:12: */
	bp := tls.Alloc(38)
	defer tls.Free(38)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_UNLOCK_MASK != 0 {
		// var zLock [30]int8 at bp+8, 30

		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([30]int8{})), bp+8 /* &zLock[0] */, ts+1333 /* "%d" */, libc.VaList(bp, eLock))
		tvfsExecTcl(tls, p, ts+36155 /* "xUnlock" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			tcl.XTcl_NewStringObj(tls, bp+8 /* &zLock[0] */, -1), uintptr(0), uintptr(0))
	}
	if (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_WRITE_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		return SQLITE_IOERR | int32(8)<<8
	}
	return sqlite3.Xsqlite3OsUnlock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, eLock)
}

// Check if another file-handle holds a RESERVED lock on an tvfs-file.
func tvfsCheckReservedLock(tls *libc.TLS, pFile uintptr, pResOut uintptr) int32 { /* test_vfs.c:512:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_CKLOCK_MASK != 0 {
		tvfsExecTcl(tls, p, ts+39149 /* "xCheckReservedLo..." */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
			uintptr(0), uintptr(0), uintptr(0))
	}
	return sqlite3.Xsqlite3OsCheckReservedLock(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, pResOut)
}

// File control method. For custom operations on an tvfs-file.
func tvfsFileControl(tls *libc.TLS, pFile uintptr, op int32, pArg uintptr) int32 { /* test_vfs.c:525:12: */
	bp := tls.Alloc(68)
	defer tls.Free(68)

	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if op == SQLITE_FCNTL_PRAGMA {
		var argv uintptr = pArg
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+10506) == 0 {
			var rc int32 = SQLITE_ERROR
			if *(*uintptr)(unsafe.Pointer(argv + 2*8)) != 0 {
				var z uintptr = *(*uintptr)(unsafe.Pointer(argv + 2*8))
				var x int32 = libc.Xatoi(tls, z)
				if x != 0 {
					rc = x
					for int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x04 != 0 {
						z++
					}
					for int32(sqlite3.Xsqlite3CtypeMap[uint8(*(*int8)(unsafe.Pointer(z)))])&0x01 != 0 {
						z++
					}
				}
				if *(*int8)(unsafe.Pointer(z)) != 0 {
					*(*uintptr)(unsafe.Pointer(argv)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp, z))
				}
			}
			return rc
		}
		if sqlite3.Xsqlite3_stricmp(tls, *(*uintptr)(unsafe.Pointer(argv + 1*8)), ts+4794) == 0 {
			*(*uintptr)(unsafe.Pointer(argv)) = sqlite3.Xsqlite3_mprintf(tls, ts /* "%s" */, libc.VaList(bp+8, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
			return SQLITE_OK
		}
	}
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_FCNTL_MASK != 0 {
		*(*[3]Fcntl)(unsafe.Pointer(bp + 16 /* aF */)) = [3]Fcntl{
			{FiFnctl: SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, FzFnctl: ts + 39168 /* "BEGIN_ATOMIC_WRI..." */},
			{FiFnctl: SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, FzFnctl: ts + 39187 /* "COMMIT_ATOMIC_WR..." */},
			{FiFnctl: SQLITE_FCNTL_ZIPVFS, FzFnctl: ts + 39207 /* "ZIPVFS" */},
		}
		var i int32
		for i = 0; uint64(i) < uint64(unsafe.Sizeof([3]Fcntl{}))/uint64(unsafe.Sizeof(Fcntl{})); i++ {
			if op == (*Fcntl)(unsafe.Pointer(bp+16+uintptr(i)*16)).FiFnctl {
				break
			}
		}
		if uint64(i) < uint64(unsafe.Sizeof([3]Fcntl{}))/uint64(unsafe.Sizeof(Fcntl{})) {
			*(*int32)(unsafe.Pointer(bp + 64 /* rc */)) = 0
			tvfsExecTcl(tls, p, ts+36177, /* "xFileControl" */
				tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1),
				tcl.XTcl_NewStringObj(tls, (*Fcntl)(unsafe.Pointer(bp+16 /* &aF */ +uintptr(i)*16)).FzFnctl, -1),
				uintptr(0), uintptr(0))
			tvfsResultCode(tls, p, bp+64 /* &rc */)
			if *(*int32)(unsafe.Pointer(bp + 64)) != 0 {
				return func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 64)) < 0 {
						return SQLITE_OK
					}
					return *(*int32)(unsafe.Pointer(bp + 64))
				}()
			}
		}
	}
	return sqlite3.Xsqlite3OsFileControl(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, op, pArg)
}

type Fcntl = struct {
	FiFnctl      int32
	F__ccgo_pad1 [4]byte
	FzFnctl      uintptr
} /* test_vfs.c:550:5 */

// Return the sector-size in bytes for an tvfs-file.
func tvfsSectorSize(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:579:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiSectorsize >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiSectorsize
	}
	return sqlite3.Xsqlite3OsSectorSize(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

// Return the device characteristic flags supported by an tvfs-file.
func tvfsDeviceCharacteristics(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:591:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FiDevchar >= 0 {
		return (*Testvfs)(unsafe.Pointer(p)).FiDevchar
	}
	return sqlite3.Xsqlite3OsDeviceCharacteristics(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)
}

// Open an tvfs file handle.
func tvfsOpen(tls *libc.TLS, pVfs uintptr, zName uintptr, pFile uintptr, flags int32, pOutFlags uintptr) int32 { /* test_vfs.c:603:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	// var rc int32 at bp, 4

	var pTestfile uintptr = pFile
	var pFd uintptr
	var pId uintptr = uintptr(0)
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	pFd = tcl.XTcl_Alloc(tls, uint32(uint64(unsafe.Sizeof(TestvfsFd{}))+uint64((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent)).FszOsFile)))
	libc.Xmemset(tls, pFd, 0, uint64(unsafe.Sizeof(TestvfsFd{}))+uint64((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent)).FszOsFile))
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = uintptr(0)
	(*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename = zName
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs = pVfs
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpReal = pFd + 1*56
	libc.Xmemset(tls, pTestfile, 0, uint64(unsafe.Sizeof(TestvfsFile{})))
	(*TestvfsFile)(unsafe.Pointer(pTestfile)).FpFd = pFd

	// Evaluate the Tcl script:
	//
	//   SCRIPT xOpen FILENAME KEY-VALUE-ARGS
	//
	// If the script returns an SQLite error code other than SQLITE_OK, an
	// error is returned to the caller. If it returns SQLITE_OK, the new
	// connection is named "anon". Otherwise, the value returned by the
	// script is used as the connection name.
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_OPEN_MASK != 0 {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		if flags&SQLITE_OPEN_MAIN_DB != 0 {
			var z uintptr = zName + uintptr(libc.Xstrlen(tls, zName)+uint64(1))
			for *(*int8)(unsafe.Pointer(z)) != 0 {
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += uintptr(libc.Xstrlen(tls, z) + uint64(1))
				tcl.XTcl_ListObjAppendElement(tls, uintptr(0), pArg, tcl.XTcl_NewStringObj(tls, z, -1))
				z += uintptr(libc.Xstrlen(tls, z) + uint64(1))
			}
		}
		tvfsExecTcl(tls, p, ts+28056 /* "xOpen" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), pArg, uintptr(0), uintptr(0))
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pArg
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		} else {
			pId = tcl.XTcl_GetObjResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
		}
	}

	if (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_OPEN_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		return SQLITE_IOERR
	}
	if tvfsInjectCantopenerr(tls, p) != 0 {
		return SQLITE_CANTOPEN
	}
	if tvfsInjectFullerr(tls, p) != 0 {
		return SQLITE_FULL
	}

	if !(pId != 0) {
		pId = tcl.XTcl_NewStringObj(tls, ts+39214 /* "anon" */, -1)
	}
	(*Tcl_Obj)(unsafe.Pointer(pId)).FrefCount++
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId = pId
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsOpen(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zName, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, flags, pOutFlags)
	if (*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods != 0 {
		var pMethods uintptr
		var nByte int32

		if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1 {
			nByte = int32(unsafe.Sizeof(sqlite3_io_methods{}))
		} else {
			nByte = int32(uintptr(0) + 104)
		}

		pMethods = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemcpy(tls, pMethods, uintptr(unsafe.Pointer(&tvfs_io_methods)), uint64(nByte))
		(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpReal)).FpMethods)).FiVersion
		if (*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion > (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FiVersion = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion
		}
		if (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion > 1 && (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FisNoshm != 0 {
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmUnmap = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmLock = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmBarrier = uintptr(0)
			(*sqlite3_io_methods)(unsafe.Pointer(pMethods)).FxShmMap = uintptr(0)
		}
		(*sqlite3_file)(unsafe.Pointer(pFile)).FpMethods = pMethods
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Delete the file located at zPath. If the dirSync argument is true,
// ensure the file-system modifications are synced to disk before
// returning.
func tvfsDelete(tls *libc.TLS, pVfs uintptr, zPath uintptr, dirSync int32) int32 { /* test_vfs.c:702:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_DELETE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+36214, /* "xDelete" */
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewIntObj(tls, dirSync), uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = sqlite3.Xsqlite3OsDelete(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, dirSync)
	}
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

// Test for access permissions. Return true if the requested permission
// is available, or false otherwise.
func tvfsAccess(tls *libc.TLS, pVfs uintptr, zPath uintptr, flags int32, pResOut uintptr) int32 { /* test_vfs.c:722:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_ACCESS_MASK != 0 {
		// var rc int32 at bp, 4

		var zArg uintptr = uintptr(0)
		if flags == SQLITE_ACCESS_EXISTS {
			zArg = ts + 39219 /* "SQLITE_ACCESS_EX..." */
		}
		if flags == SQLITE_ACCESS_READWRITE {
			zArg = ts + 39240 /* "SQLITE_ACCESS_RE..." */
		}
		if flags == SQLITE_ACCESS_READ {
			zArg = ts + 39264 /* "SQLITE_ACCESS_RE..." */
		}
		tvfsExecTcl(tls, p, ts+36222, /* "xAccess" */
			tcl.XTcl_NewStringObj(tls, zPath, -1), tcl.XTcl_NewStringObj(tls, zArg, -1), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		} else {
			var interp uintptr = (*Testvfs)(unsafe.Pointer(p)).Finterp
			if TCL_OK == tcl.XTcl_GetBooleanFromObj(tls, uintptr(0), tcl.XTcl_GetObjResult(tls, interp), pResOut) {
				return SQLITE_OK
			}
		}
	}
	return sqlite3.Xsqlite3OsAccess(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, flags, pResOut)
}

// Populate buffer zOut with the full canonical pathname corresponding
// to the pathname in zPath. zOut is guaranteed to point to a buffer
// of at least (DEVSYM_MAX_PATHNAME+1) bytes.
func tvfsFullPathname(tls *libc.TLS, pVfs uintptr, zPath uintptr, nOut int32, zOut uintptr) int32 { /* test_vfs.c:755:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_FULLPATHNAME_MASK != 0 {
		// var rc int32 at bp, 4

		tvfsExecTcl(tls, p, ts+36230 /* "xFullPathname" */, tcl.XTcl_NewStringObj(tls, zPath, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		}
	}
	return sqlite3.Xsqlite3OsFullPathname(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, zPath, nOut, zOut)
}

// Populate the buffer pointed to by zBufOut with nByte bytes of
// random data.
func tvfsRandomness(tls *libc.TLS, pVfs uintptr, nByte int32, zBufOut uintptr) int32 { /* test_vfs.c:808:12: */
	return sqlite3.Xsqlite3OsRandomness(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nByte, zBufOut)
}

// Sleep for nMicro microseconds. Return the number of microseconds
// actually slept.
func tvfsSleep(tls *libc.TLS, pVfs uintptr, nMicro int32) int32 { /* test_vfs.c:816:12: */
	return sqlite3.Xsqlite3OsSleep(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, nMicro)
}

// Return the current time as a Julian Day number in *pTimeOut.
func tvfsCurrentTime(tls *libc.TLS, pVfs uintptr, pTimeOut uintptr) int32 { /* test_vfs.c:823:12: */
	return (*struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent)).FxCurrentTime})).f(tls, (*Testvfs)(unsafe.Pointer((*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData)).FpParent, pTimeOut)
}

func tvfsShmOpen(tls *libc.TLS, pFile uintptr) int32 { /* test_vfs.c:827:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	var p uintptr
	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK // Return code
	var pBuffer uintptr                                // Buffer to open connection to
	var pFd uintptr                                    // The testvfs file structure

	pFd = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	p = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	// Evaluate the Tcl script:
	//
	//   SCRIPT xShmOpen FILENAME
	tcl.XTcl_ResetResult(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp)
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMOPEN_MASK != 0 {
		tvfsExecTcl(tls, p, ts+39283 /* "xShmOpen" */, tcl.XTcl_NewStringObj(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, -1), uintptr(0), uintptr(0), uintptr(0))
		if tvfsResultCode(tls, p, bp) != 0 {
			if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
				return *(*int32)(unsafe.Pointer(bp /* rc */))
			}
		}
	}

	if (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMOPEN_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		return SQLITE_IOERR
	}

	// Search for a TestvfsBuffer. Create a new one if required.
	for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
		if 0 == libc.Xstrcmp(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile) {
			break
		}
	}
	if !(pBuffer != 0) {
		var szName int32 = int32(libc.Xstrlen(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename))
		var nByte int32 = int32(uint64(unsafe.Sizeof(TestvfsBuffer{})) + uint64(szName) + uint64(1))
		pBuffer = tcl.XTcl_Alloc(tls, uint32(nByte))
		libc.Xmemset(tls, pBuffer, 0, uint64(nByte))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile = pBuffer + 1*8224
		libc.Xmemcpy(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, (*TestvfsFd)(unsafe.Pointer(pFd)).FzFilename, uint64(szName+1))
		(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext = (*Testvfs)(unsafe.Pointer(p)).FpBuffer
		(*Testvfs)(unsafe.Pointer(p)).FpBuffer = pBuffer
	}

	// Connect the TestvfsBuffer to the new TestvfsShm handle and return.
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile
	(*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile = pFd
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = pBuffer
	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsAllocPage(tls *libc.TLS, p uintptr, iPage int32, pgsz int32) { /* test_vfs.c:877:13: */

	if *(*uintptr)(unsafe.Pointer(p + 16 + uintptr(iPage)*8)) == uintptr(0) {
		*(*uintptr)(unsafe.Pointer(p + 16 + uintptr(iPage)*8)) = tcl.XTcl_Alloc(tls, uint32(pgsz))
		libc.Xmemset(tls, *(*uintptr)(unsafe.Pointer(p + 16 + uintptr(iPage)*8)), 0, uint64(pgsz))
		(*TestvfsBuffer)(unsafe.Pointer(p)).Fpgsz = pgsz
	}
}

func tvfsShmMap(tls *libc.TLS, pFile uintptr, iPage int32, pgsz int32, isWrite int32, pp uintptr) int32 { /* test_vfs.c:886:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmMap})).f(tls, pReal, iPage, pgsz, isWrite, pp)
	}

	if uintptr(0) == (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = tvfsShmOpen(tls, pFile)
		if *(*int32)(unsafe.Pointer(bp)) != SQLITE_OK {
			return *(*int32)(unsafe.Pointer(bp /* rc */))
		}
	}

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMMAP_MASK != 0 {
		var pArg uintptr = tcl.XTcl_NewObj(tls)
		(*Tcl_Obj)(unsafe.Pointer(pArg)).FrefCount++
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, iPage))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, pgsz))
		tcl.XTcl_ListObjAppendElement(tls, (*Testvfs)(unsafe.Pointer(p)).Finterp, pArg, tcl.XTcl_NewIntObj(tls, isWrite))
		tvfsExecTcl(tls, p, ts+36307, /* "xShmMap" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, pArg, uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = pArg
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMMAP_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK && isWrite != 0 && !(int32(*(*uintptr)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 16 + uintptr(iPage)*8))) != 0) {
		tvfsAllocPage(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm, iPage, pgsz)
	}
	if *(*int32)(unsafe.Pointer(bp)) == SQLITE_OK || *(*int32)(unsafe.Pointer(bp)) == SQLITE_READONLY {
		*(*uintptr)(unsafe.Pointer(pp)) = *(*uintptr)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm + 16 + uintptr(iPage)*8))
	}

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsShmLock(tls *libc.TLS, pFile uintptr, ofst int32, n int32, flags int32) int32 { /* test_vfs.c:936:12: */
	bp := tls.Alloc(100)
	defer tls.Free(100)

	*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var nLock int32
	// var zLock [80]int8 at bp+16, 80

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*struct {
			f func(*libc.TLS, uintptr, int32, int32, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmLock})).f(tls, pReal, ofst, n, flags)
	}

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMLOCK_MASK != 0 {
		sqlite3.Xsqlite3_snprintf(tls, int32(unsafe.Sizeof([80]int8{})), bp+16 /* &zLock[0] */, ts+18562 /* "%d %d" */, libc.VaList(bp, ofst, n))
		nLock = int32(libc.Xstrlen(tls, bp+16 /* &zLock[0] */))
		if flags&SQLITE_SHM_LOCK != 0 {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+39292 /* " lock" */)
		} else {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+39298 /* " unlock" */)
		}
		nLock = nLock + int32(libc.Xstrlen(tls, bp+16+uintptr(nLock)))
		if flags&SQLITE_SHM_SHARED != 0 {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+39306 /* " shared" */)
		} else {
			libc.Xstrcpy(tls, bp+16+uintptr(nLock), ts+39314 /* " exclusive" */)
		}
		tvfsExecTcl(tls, p, ts+36286, /* "xShmLock" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId,
			tcl.XTcl_NewStringObj(tls, bp+16 /* &zLock[0] */, -1), uintptr(0))
		tvfsResultCode(tls, p, bp+96 /* &rc */)
	}

	if *(*int32)(unsafe.Pointer(bp + 96)) == SQLITE_OK && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMLOCK_MASK != 0 && tvfsInjectIoerr(tls, p) != 0 {
		*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = SQLITE_IOERR
	}

	if *(*int32)(unsafe.Pointer(bp + 96)) == SQLITE_OK {
		var isLock int32 = flags & SQLITE_SHM_LOCK
		var isExcl int32 = flags & SQLITE_SHM_EXCLUSIVE
		var mask u32 = u32((int32(1)<<n - 1) << ofst)
		if isLock != 0 {
			var p2 uintptr
			for p2 = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FpFile; p2 != 0; p2 = (*TestvfsFd)(unsafe.Pointer(p2)).FpNext {
				if p2 == pFd {
					continue
				}
				if (*TestvfsFd)(unsafe.Pointer(p2)).Fexcllock&mask != 0 || isExcl != 0 && (*TestvfsFd)(unsafe.Pointer(p2)).Fsharedlock&mask != 0 {
					*(*int32)(unsafe.Pointer(bp + 96 /* rc */)) = SQLITE_BUSY
					break
				}
			}
			if *(*int32)(unsafe.Pointer(bp + 96)) == SQLITE_OK {
				if isExcl != 0 {
					*(*u32)(unsafe.Pointer(pFd + 40)) |= mask
				}
				if !(isExcl != 0) {
					*(*u32)(unsafe.Pointer(pFd + 44)) |= mask
				}
			}
		} else {
			if isExcl != 0 {
				*(*u32)(unsafe.Pointer(pFd + 40)) &= ^mask
			}
			if !(isExcl != 0) {
				*(*u32)(unsafe.Pointer(pFd + 44)) &= ^mask
			}
		}
	}

	return *(*int32)(unsafe.Pointer(bp + 96 /* rc */))
}

func tvfsShmBarrier(tls *libc.TLS, pFile uintptr) { /* test_vfs.c:1004:13: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMBARRIER_MASK != 0 {
		var z uintptr
		if (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm != 0 {
			z = (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile
		} else {
			z = ts + 584 /* "" */
		}
		tvfsExecTcl(tls, p, ts+36295 /* "xShmBarrier" */, tcl.XTcl_NewStringObj(tls, z, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
	}

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		(*struct{ f func(*libc.TLS, uintptr) })(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmBarrier})).f(tls, pReal)
		return
	}
}

func tvfsShmUnmap(tls *libc.TLS, pFile uintptr, deleteFlag int32) int32 { /* test_vfs.c:1020:12: */
	bp := tls.Alloc(4)
	defer tls.Free(4)

	*(*int32)(unsafe.Pointer(bp /* rc */)) = SQLITE_OK
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	var p uintptr = (*sqlite3_vfs)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpVfs)).FpAppData
	var pBuffer uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpShm
	var ppFd uintptr

	if (*Testvfs)(unsafe.Pointer(p)).FisFullshm != 0 {
		var pReal uintptr = (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal
		return (*struct {
			f func(*libc.TLS, uintptr, int32) int32
		})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(pReal)).FpMethods)).FxShmUnmap})).f(tls, pReal, deleteFlag)
	}

	if !(pBuffer != 0) {
		return SQLITE_OK
	}

	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 && (*Testvfs)(unsafe.Pointer(p)).Fmask&TESTVFS_SHMCLOSE_MASK != 0 {
		tvfsExecTcl(tls, p, ts+36276, /* "xShmUnmap" */
			tcl.XTcl_NewStringObj(tls, (*TestvfsBuffer)(unsafe.Pointer((*TestvfsFd)(unsafe.Pointer(pFd)).FpShm)).FzFile, -1), (*TestvfsFd)(unsafe.Pointer(pFd)).FpShmId, uintptr(0), uintptr(0))
		tvfsResultCode(tls, p, bp /* &rc */)
	}

	for ppFd = pBuffer + 8208; *(*uintptr)(unsafe.Pointer(ppFd)) != pFd; ppFd = *(*uintptr)(unsafe.Pointer(ppFd)) + 48 {
	}

	*(*uintptr)(unsafe.Pointer(ppFd)) = (*TestvfsFd)(unsafe.Pointer(pFd)).FpNext
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpNext = uintptr(0)

	if (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpFile == uintptr(0) {
		var i int32
		var pp uintptr
		for pp = p + 40; *(*uintptr)(unsafe.Pointer(pp)) != pBuffer; pp = *(*uintptr)(unsafe.Pointer(pp)) + 8216 {
		}
		*(*uintptr)(unsafe.Pointer(pp)) = (*TestvfsBuffer)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(pp)))).FpNext
		for i = 0; *(*uintptr)(unsafe.Pointer(pBuffer + 16 /* &.aPage */ + uintptr(i)*8)) != 0; i++ {
			tcl.XTcl_Free(tls, *(*uintptr)(unsafe.Pointer(pBuffer + 16 + uintptr(i)*8)))
		}
		tcl.XTcl_Free(tls, pBuffer)
	}
	(*TestvfsFd)(unsafe.Pointer(pFd)).FpShm = uintptr(0)

	return *(*int32)(unsafe.Pointer(bp /* rc */))
}

func tvfsFetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, iAmt int32, pp uintptr) int32 { /* test_vfs.c:1065:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsFetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, iAmt, pp)
}

func tvfsUnfetch(tls *libc.TLS, pFile uintptr, iOfst sqlite3_int64, p uintptr) int32 { /* test_vfs.c:1075:12: */
	var pFd uintptr = (*TestvfsFile)(unsafe.Pointer(pFile)).FpFd
	return sqlite3.Xsqlite3OsUnfetch(tls, (*TestvfsFd)(unsafe.Pointer(pFd)).FpReal, iOfst, p)
}

func testvfs_obj_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1080:26: */
	bp := tls.Alloc(568)
	defer tls.Free(568)

	var p uintptr = cd
	*(*[10]TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* aSubcmd */)) = [10]TestvfsSubcmd{
		{FzName: ts + 39325 /* "shm" */},
		{FzName: ts + 10970 /* "delete" */, FeCmd: uint32(1) /* CMD_DELETE */},
		{FzName: ts + 39329 /* "filter" */, FeCmd: uint32(2) /* CMD_FILTER */},
		{FzName: ts + 39336 /* "ioerr" */, FeCmd: uint32(3) /* CMD_IOERR */},
		{FzName: ts + 39342 /* "fullerr" */, FeCmd: uint32(7) /* CMD_FULLERR */},
		{FzName: ts + 39350 /* "cantopenerr" */, FeCmd: uint32(8) /* CMD_CANTOPENERR */},
		{FzName: ts + 39362 /* "script" */, FeCmd: uint32(4) /* CMD_SCRIPT */},
		{FzName: ts + 39369 /* "devchar" */, FeCmd: uint32(5) /* CMD_DEVCHAR */},
		{FzName: ts + 39377 /* "sectorsize" */, FeCmd: uint32(6) /* CMD_SECTORSIZE */},
		{},
	}
	// var i int32 at bp+256, 4

	if objc < 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+1999 /* "SUBCOMMAND ..." */)
		return TCL_ERROR
	}
	if tcl.XTcl_GetIndexFromObjStruct(tls,
		interp, *(*uintptr)(unsafe.Pointer(objv + 1*8)), bp+96, int32(unsafe.Sizeof(TestvfsSubcmd{})), ts+39388, 0, bp+256) != 0 {
		return TCL_ERROR
	}
	tcl.XTcl_ResetResult(tls, interp)

	switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* &aSubcmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*16)).FeCmd {
	case uint32(0) /* CMD_SHM */ :
		{
			var pObj uintptr
			var rc int32
			var pBuffer uintptr
			var zName uintptr
			if objc != 3 && objc != 4 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+39399 /* "FILE ?VALUE?" */)
				return TCL_ERROR
			}
			zName = tcl.XTcl_Alloc(tls, uint32((*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname))
			rc = (*struct {
				f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
			})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FxFullPathname})).f(tls,
				(*Testvfs)(unsafe.Pointer(p)).FpParent, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))),
				(*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname, zName)
			if rc != SQLITE_OK {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+39412, /* "failed to get fu..." */
					tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), 0))
				tcl.XTcl_Free(tls, zName)
				return TCL_ERROR
			}
			for pBuffer = (*Testvfs)(unsafe.Pointer(p)).FpBuffer; pBuffer != 0; pBuffer = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FpNext {
				if 0 == libc.Xstrcmp(tls, (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).FzFile, zName) {
					break
				}
			}
			tcl.XTcl_Free(tls, zName)
			if !(pBuffer != 0) {
				tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+24, ts+39438 /* "no such file: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), 0))
				return TCL_ERROR
			}
			if objc == 4 {
				// var n int32 at bp+260, 4

				var a uintptr = tcl.XTcl_GetByteArrayFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+260 /* &n */)
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				for *(*int32)(unsafe.Pointer(bp + 256 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 256 /* i */))*pgsz < *(*int32)(unsafe.Pointer(bp + 260 /* n */)); *(*int32)(unsafe.Pointer(bp + 256 /* i */))++ {
					var nByte int32 = pgsz
					tvfsAllocPage(tls, pBuffer, *(*int32)(unsafe.Pointer(bp + 256 /* i */)), pgsz)
					if *(*int32)(unsafe.Pointer(bp + 260))-*(*int32)(unsafe.Pointer(bp + 256))*pgsz < pgsz {
						nByte = *(*int32)(unsafe.Pointer(bp + 260 /* n */))
					}
					libc.Xmemcpy(tls, *(*uintptr)(unsafe.Pointer(pBuffer + 16 + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)), a+uintptr(*(*int32)(unsafe.Pointer(bp + 256))*pgsz), uint64(nByte))
				}
			}

			pObj = tcl.XTcl_NewObj(tls)
			for *(*int32)(unsafe.Pointer(bp + 256 /* i */)) = 0; *(*uintptr)(unsafe.Pointer(pBuffer + 16 /* &.aPage */ + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)) != 0; *(*int32)(unsafe.Pointer(bp + 256 /* i */))++ {
				var pgsz int32 = (*TestvfsBuffer)(unsafe.Pointer(pBuffer)).Fpgsz
				if pgsz == 0 {
					pgsz = 65536
				}
				tcl.XTcl_AppendObjToObj(tls, pObj, tcl.XTcl_NewByteArrayObj(tls, *(*uintptr)(unsafe.Pointer(pBuffer + 16 + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)), pgsz))
			}
			tcl.XTcl_SetObjResult(tls, interp, pObj)
			break

		}

	// TESTVFS filter METHOD-LIST
	//
	//     Activate special processing for those methods contained in the list
	case uint32(2) /* CMD_FILTER */ :
		{
			*(*uintptr)(unsafe.Pointer(bp + 272 /* apElem */)) = uintptr(0)
			*(*int32)(unsafe.Pointer(bp + 264 /* nElem */)) = 0
			var mask int32 = 0
			if objc != 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+32972 /* "LIST" */)
				return TCL_ERROR
			}
			if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+264, bp+272) != 0 {
				return TCL_ERROR
			}
			tcl.XTcl_ResetResult(tls, interp)
			for *(*int32)(unsafe.Pointer(bp + 256 /* i */)) = 0; *(*int32)(unsafe.Pointer(bp + 256 /* i */)) < *(*int32)(unsafe.Pointer(bp + 264 /* nElem */)); *(*int32)(unsafe.Pointer(bp + 256 /* i */))++ {
				var iMethod int32
				var zElem uintptr = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 272 /* apElem */)) + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*8)))
				for iMethod = 0; iMethod < int32(uint64(unsafe.Sizeof(vfsmethod))/uint64(unsafe.Sizeof(VfsMethod{}))); iMethod++ {
					if libc.Xstrcmp(tls, zElem, vfsmethod[iMethod].FzName) == 0 {
						mask = mask | vfsmethod[iMethod].Fmask
						break
					}
				}
				if iMethod == int32(uint64(unsafe.Sizeof(vfsmethod))/uint64(unsafe.Sizeof(VfsMethod{}))) {
					tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+48, ts+39453 /* "unknown method: " */, zElem, 0))
					return TCL_ERROR
				}
			}
			(*Testvfs)(unsafe.Pointer(p)).Fmask = mask
			break

		}

	//  TESTVFS script ?SCRIPT?
	//
	//  Query or set the script to be run when filtered VFS events
	//  occur.
	case uint32(4) /* CMD_SCRIPT */ :
		{
			if objc == 3 {
				// var nByte int32 at bp+280, 4

				if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
					for ok := true; ok; ok = 0 != 0 {
						var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
						if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
							tcl.XTclFreeObj(tls, _objPtr)
						}
					}
					(*Testvfs)(unsafe.Pointer(p)).FpScript = uintptr(0)
				}
				tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+280 /* &nByte */)
				if *(*int32)(unsafe.Pointer(bp + 280)) > 0 {
					(*Testvfs)(unsafe.Pointer(p)).FpScript = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
					(*Tcl_Obj)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpScript)).FrefCount++
				}
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+14088 /* "?SCRIPT?" */)
				return TCL_ERROR
			}

			tcl.XTcl_ResetResult(tls, interp)
			if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
				tcl.XTcl_SetObjResult(tls, interp, (*Testvfs)(unsafe.Pointer(p)).FpScript)
			}

			break

		}

	// TESTVFS ioerr ?IFAIL PERSIST?
	//
	//   Where IFAIL is an integer and PERSIST is boolean.
	case uint32(8) /* CMD_CANTOPENERR */ :
		fallthrough
	case uint32(3) /* CMD_IOERR */ :
		fallthrough
	case uint32(7) /* CMD_FULLERR */ :
		{
			var pTest uintptr = uintptr(0)
			var iRet int32

			switch (*TestvfsSubcmd)(unsafe.Pointer(bp + 96 /* &aSubcmd */ + uintptr(*(*int32)(unsafe.Pointer(bp + 256 /* i */)))*16)).FeCmd {
			case uint32(3) /* CMD_IOERR */ :
				pTest = p + 60
				break
			case uint32(7) /* CMD_FULLERR */ :
				pTest = p + 72
				break
			case uint32(8) /* CMD_CANTOPENERR */ :
				pTest = p + 84
				break
			default:
			}
			iRet = (*TestFaultInject)(unsafe.Pointer(pTest)).FnFail
			(*TestFaultInject)(unsafe.Pointer(pTest)).FnFail = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = 0
			(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = 0

			if objc == 4 {
				// var iCnt int32 at bp+284, 4

				// var iPersist int32 at bp+288, 4

				if TCL_OK != tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+284) ||
					TCL_OK != tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+288) {
					return TCL_ERROR
				}
				(*TestFaultInject)(unsafe.Pointer(pTest)).FeFault = func() int32 {
					if *(*int32)(unsafe.Pointer(bp + 288)) != 0 {
						return FAULT_INJECT_PERSISTENT
					}
					return FAULT_INJECT_TRANSIENT
				}()
				(*TestFaultInject)(unsafe.Pointer(pTest)).FiCnt = *(*int32)(unsafe.Pointer(bp + 284 /* iCnt */))
			} else if objc != 2 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+39470 /* "?CNT PERSIST?" */)
				return TCL_ERROR
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, iRet))
			break

		}

	case uint32(1) /* CMD_DELETE */ :
		{
			tcl.XTcl_DeleteCommand(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv))))
			break

		}

	case uint32(5) /* CMD_DEVCHAR */ :
		{
			*(*[16]DeviceFlag)(unsafe.Pointer(bp + 304 /* aFlag */)) = [16]DeviceFlag{
				{FzName: ts + 39484 /* "default" */, FiValue: -1},
				{FzName: ts + 27038 /* "atomic" */, FiValue: SQLITE_IOCAP_ATOMIC},
				{FzName: ts + 27045 /* "atomic512" */, FiValue: SQLITE_IOCAP_ATOMIC512},
				{FzName: ts + 27055 /* "atomic1k" */, FiValue: SQLITE_IOCAP_ATOMIC1K},
				{FzName: ts + 27064 /* "atomic2k" */, FiValue: SQLITE_IOCAP_ATOMIC2K},
				{FzName: ts + 27073 /* "atomic4k" */, FiValue: SQLITE_IOCAP_ATOMIC4K},
				{FzName: ts + 27082 /* "atomic8k" */, FiValue: SQLITE_IOCAP_ATOMIC8K},
				{FzName: ts + 27091 /* "atomic16k" */, FiValue: SQLITE_IOCAP_ATOMIC16K},
				{FzName: ts + 27101 /* "atomic32k" */, FiValue: SQLITE_IOCAP_ATOMIC32K},
				{FzName: ts + 27111 /* "atomic64k" */, FiValue: SQLITE_IOCAP_ATOMIC64K},
				{FzName: ts + 27121 /* "sequential" */, FiValue: SQLITE_IOCAP_SEQUENTIAL},
				{FzName: ts + 27132 /* "safe_append" */, FiValue: SQLITE_IOCAP_SAFE_APPEND},
				{FzName: ts + 39492 /* "undeletable_when..." */, FiValue: SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN},
				{FzName: ts + 27144 /* "powersafe_overwr..." */, FiValue: SQLITE_IOCAP_POWERSAFE_OVERWRITE},
				{FzName: ts + 39514 /* "immutable" */, FiValue: SQLITE_IOCAP_IMMUTABLE},
				{},
			}
			var pRet uintptr
			var iFlag int32

			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+39524 /* "?ATTR-LIST?" */)
				return TCL_ERROR
			}
			if objc == 3 {
				var j int32
				var iNew int32 = 0
				*(*uintptr)(unsafe.Pointer(bp + 296 /* flags */)) = uintptr(0)
				*(*int32)(unsafe.Pointer(bp + 292 /* nFlags */)) = 0

				if tcl.XTcl_ListObjGetElements(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+292, bp+296) != 0 {
					return TCL_ERROR
				}

				for j = 0; j < *(*int32)(unsafe.Pointer(bp + 292 /* nFlags */)); j++ {
					*(*int32)(unsafe.Pointer(bp + 560 /* idx */)) = 0
					if tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 296)) + uintptr(j)*8)), bp+304,
						int32(unsafe.Sizeof(DeviceFlag{})), ts+18367, 0, bp+560) != 0 {
						return TCL_ERROR
					}
					if (*DeviceFlag)(unsafe.Pointer(bp+304+uintptr(*(*int32)(unsafe.Pointer(bp + 560)))*16)).FiValue < 0 && *(*int32)(unsafe.Pointer(bp + 292)) > 1 {
						tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp+72, ts+39536 /* "bad flags: " */, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8))), 0))
						return TCL_ERROR
					}
					iNew = iNew | (*DeviceFlag)(unsafe.Pointer(bp+304+uintptr(*(*int32)(unsafe.Pointer(bp + 560)))*16)).FiValue
				}

				(*Testvfs)(unsafe.Pointer(p)).FiDevchar = iNew | 0x10000000
			}

			pRet = tcl.XTcl_NewObj(tls)
			for iFlag = 0; uint64(iFlag) < uint64(unsafe.Sizeof([16]DeviceFlag{}))/uint64(unsafe.Sizeof(DeviceFlag{})); iFlag++ {
				if (*Testvfs)(unsafe.Pointer(p)).FiDevchar&(*DeviceFlag)(unsafe.Pointer(bp+304+uintptr(iFlag)*16)).FiValue != 0 {
					tcl.XTcl_ListObjAppendElement(tls,
						interp, pRet, tcl.XTcl_NewStringObj(tls, (*DeviceFlag)(unsafe.Pointer(bp+304 /* &aFlag */ +uintptr(iFlag)*16)).FzName, -1))
				}
			}
			tcl.XTcl_SetObjResult(tls, interp, pRet)

			break

		}

	case uint32(6) /* CMD_SECTORSIZE */ :
		{
			if objc > 3 {
				tcl.XTcl_WrongNumArgs(tls, interp, 2, objv, ts+39548 /* "?VALUE?" */)
				return TCL_ERROR
			}
			if objc == 3 {
				*(*int32)(unsafe.Pointer(bp + 564 /* iNew */)) = 0
				if tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 2*8)), bp+564) != 0 {
					return TCL_ERROR
				}
				(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = *(*int32)(unsafe.Pointer(bp + 564 /* iNew */))
			}
			tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, (*Testvfs)(unsafe.Pointer(p)).FiSectorsize))
			break

		}
	}

	return TCL_OK
}

type TestvfsSubcmd = struct {
	FzName       uintptr
	FeCmd        uint32
	F__ccgo_pad1 [4]byte
} /* test_vfs.c:1092:3 */

type VfsMethod = struct {
	FzName       uintptr
	Fmask        int32
	F__ccgo_pad1 [4]byte
} /* test_vfs.c:1179:14 */

var vfsmethod = [18]VfsMethod{
	{FzName: ts + 39283 /* "xShmOpen" */, Fmask: TESTVFS_SHMOPEN_MASK},
	{FzName: ts + 36286 /* "xShmLock" */, Fmask: TESTVFS_SHMLOCK_MASK},
	{FzName: ts + 36295 /* "xShmBarrier" */, Fmask: TESTVFS_SHMBARRIER_MASK},
	{FzName: ts + 36276 /* "xShmUnmap" */, Fmask: TESTVFS_SHMCLOSE_MASK},
	{FzName: ts + 36307 /* "xShmMap" */, Fmask: TESTVFS_SHMMAP_MASK},
	{FzName: ts + 28484 /* "xSync" */, Fmask: TESTVFS_SYNC_MASK},
	{FzName: ts + 36214 /* "xDelete" */, Fmask: TESTVFS_DELETE_MASK},
	{FzName: ts + 36122 /* "xWrite" */, Fmask: TESTVFS_WRITE_MASK},
	{FzName: ts + 36116 /* "xRead" */, Fmask: TESTVFS_READ_MASK},
	{FzName: ts + 36129 /* "xTruncate" */, Fmask: TESTVFS_TRUNCATE_MASK},
	{FzName: ts + 28056 /* "xOpen" */, Fmask: TESTVFS_OPEN_MASK},
	{FzName: ts + 36109 /* "xClose" */, Fmask: TESTVFS_CLOSE_MASK},
	{FzName: ts + 36222 /* "xAccess" */, Fmask: TESTVFS_ACCESS_MASK},
	{FzName: ts + 36230 /* "xFullPathname" */, Fmask: TESTVFS_FULLPATHNAME_MASK},
	{FzName: ts + 36155 /* "xUnlock" */, Fmask: TESTVFS_UNLOCK_MASK},
	{FzName: ts + 36149 /* "xLock" */, Fmask: TESTVFS_LOCK_MASK},
	{FzName: ts + 39149 /* "xCheckReservedLo..." */, Fmask: TESTVFS_CKLOCK_MASK},
	{FzName: ts + 36177 /* "xFileControl" */, Fmask: TESTVFS_FCNTL_MASK},
} /* test_vfs.c:1182:9 */

func testvfs_obj_del(tls *libc.TLS, cd ClientData) { /* test_vfs.c:1393:27: */
	var p uintptr = cd
	if (*Testvfs)(unsafe.Pointer(p)).FpScript != 0 {
		for ok := true; ok; ok = 0 != 0 {
			var _objPtr uintptr = (*Testvfs)(unsafe.Pointer(p)).FpScript
			if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
				tcl.XTclFreeObj(tls, _objPtr)
			}
		}
	}
	sqlite3.Xsqlite3_vfs_unregister(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	libc.Xmemset(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs, 0, uint64(unsafe.Sizeof(sqlite3_vfs{})))
	tcl.XTcl_Free(tls, (*Testvfs)(unsafe.Pointer(p)).FpVfs)
	libc.Xmemset(tls, p, 0, uint64(unsafe.Sizeof(Testvfs{})))
	tcl.XTcl_Free(tls, p)
}

// Usage:  testvfs VFSNAME ?SWITCHES?
//
// Switches are:
//
//   -noshm   BOOLEAN             (True to omit shm methods. Default false)
//   -default BOOLEAN             (True to make the vfs default. Default false)
//
// This command creates two things when it is invoked: an SQLite VFS, and
// a Tcl command. Both are named VFSNAME. The VFS is installed. It is not
// installed as the default VFS.
//
// The VFS passes all file I/O calls through to the underlying VFS.
//
// Whenever the xShmMap method of the VFS
// is invoked, the SCRIPT is executed as follows:
//
//   SCRIPT xShmMap    FILENAME ID
//
// The value returned by the invocation of SCRIPT above is interpreted as
// an SQLite error code and returned to SQLite. Either a symbolic
// "SQLITE_OK" or numeric "0" value may be returned.
//
// The contents of the shared-memory buffer associated with a given file
// may be read and set using the following command:
//
//   VFSNAME shm FILENAME ?NEWVALUE?
//
// When the xShmLock method is invoked by SQLite, the following script is
// run:
//
//   SCRIPT xShmLock    FILENAME ID LOCK
//
// where LOCK is of the form "OFFSET NBYTE lock/unlock shared/exclusive"
func testvfs_cmd(tls *libc.TLS, cd ClientData, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1438:26: */
	bp := tls.Alloc(28)
	defer tls.Free(28)

	var p uintptr    // New object
	var pVfs uintptr // New VFS
	var zVfs uintptr
	var nByte int32 // Bytes of space to allocate at p

	var i int32
	// var isNoshm int32 at bp+4, 4
	// True if -noshm is passed
	// var isFullshm int32 at bp+24, 4
	// True if -fullshm is passed
	// var isDefault int32 at bp+8, 4
	// True if -default is passed
	// var szOsFile int32 at bp+12, 4
	// Value passed to -szosfile
	// var mxPathname int32 at bp+16, 4
	// Value passed to -mxpathname
	// var iVersion int32 at bp+20, 4

	// var nSwitch int32 at bp, 4

	var zSwitch uintptr
	*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) = 0
	*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) = 0
	*(*int32)(unsafe.Pointer(bp + 8 /* isDefault */)) = 0
	*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */)) = 0
	*(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */)) = -1
	*(*int32)(unsafe.Pointer(bp + 20 /* iVersion */)) = 3 // Value passed to -iversion

	if !(objc < 2 || 0 != objc%2) {
		goto __1
	}
	goto bad_args
__1:
	;
	i = 2
__2:
	if !(i < objc) {
		goto __4
	}
	zSwitch = tcl.XTcl_GetStringFromObj(tls, *(*uintptr)(unsafe.Pointer(objv + uintptr(i)*8)), bp /* &nSwitch */)

	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+39556, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp))))) {
		goto __5
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+4) != 0) {
		goto __7
	}
	return TCL_ERROR
__7:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 4)) != 0) {
		goto __8
	}
	*(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */)) = 0
__8:
	;
	goto __6
__5:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+27414, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp))))) {
		goto __9
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+8) != 0) {
		goto __11
	}
	return TCL_ERROR
__11:
	;
	goto __10
__9:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+39563, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp))))) {
		goto __12
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+12) != 0) {
		goto __14
	}
	return TCL_ERROR
__14:
	;
	goto __13
__12:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+39573, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp))))) {
		goto __15
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+16) != 0) {
		goto __17
	}
	return TCL_ERROR
__17:
	;
	goto __16
__15:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+39585, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp))))) {
		goto __18
	}
	if !(tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+20) != 0) {
		goto __20
	}
	return TCL_ERROR
__20:
	;
	goto __19
__18:
	if !(*(*int32)(unsafe.Pointer(bp)) > 2 && 0 == libc.Xstrncmp(tls, ts+39595, zSwitch, uint64(*(*int32)(unsafe.Pointer(bp))))) {
		goto __21
	}
	if !(tcl.XTcl_GetBooleanFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + uintptr(i+1)*8)), bp+24) != 0) {
		goto __23
	}
	return TCL_ERROR
__23:
	;
	if !(*(*int32)(unsafe.Pointer(bp + 24)) != 0) {
		goto __24
	}
	*(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */)) = 0
__24:
	;
	goto __22
__21:
	goto bad_args
__22:
	;
__19:
	;
__16:
	;
__13:
	;
__10:
	;
__6:
	;
	goto __3
__3:
	i = i + 2
	goto __2
	goto __4
__4:
	;

	if !(uint64(*(*int32)(unsafe.Pointer(bp + 12))) < uint64(unsafe.Sizeof(TestvfsFile{}))) {
		goto __25
	}
	*(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */)) = int32(unsafe.Sizeof(TestvfsFile{}))
__25:
	;

	zVfs = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8)))
	nByte = int32(uint64(unsafe.Sizeof(Testvfs{})) + uint64(int32(libc.Xstrlen(tls, zVfs))) + uint64(1))
	p = tcl.XTcl_Alloc(tls, uint32(nByte))
	libc.Xmemset(tls, p, 0, uint64(nByte))
	(*Testvfs)(unsafe.Pointer(p)).FiDevchar = -1
	(*Testvfs)(unsafe.Pointer(p)).FiSectorsize = -1

	// Create the new object command before querying SQLite for a default VFS
	// to use for 'real' IO operations. This is because creating the new VFS
	// may delete an existing [testvfs] VFS of the same name. If such a VFS
	// is currently the default, the new [testvfs] may end up calling the
	// methods of a deleted object.
	tcl.XTcl_CreateObjCommand(tls, interp, zVfs, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_obj_cmd})), p, *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, ClientData) }{testvfs_obj_del})))
	(*Testvfs)(unsafe.Pointer(p)).FpParent = sqlite3.Xsqlite3_vfs_find(tls, uintptr(0))
	(*Testvfs)(unsafe.Pointer(p)).Finterp = interp

	(*Testvfs)(unsafe.Pointer(p)).FzName = p + 1*104
	libc.Xmemcpy(tls, (*Testvfs)(unsafe.Pointer(p)).FzName, zVfs, libc.Xstrlen(tls, zVfs)+uint64(1))

	pVfs = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(sqlite3_vfs{})))
	libc.Xmemcpy(tls, pVfs, uintptr(unsafe.Pointer(&tvfs_vfs)), uint64(unsafe.Sizeof(sqlite3_vfs{})))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FpAppData = p
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FiVersion = *(*int32)(unsafe.Pointer(bp + 20 /* iVersion */))
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FzName = (*Testvfs)(unsafe.Pointer(p)).FzName
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = (*sqlite3_vfs)(unsafe.Pointer((*Testvfs)(unsafe.Pointer(p)).FpParent)).FmxPathname
	if !(*(*int32)(unsafe.Pointer(bp + 16)) >= 0 && *(*int32)(unsafe.Pointer(bp + 16)) < (*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname) {
		goto __26
	}
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FmxPathname = *(*int32)(unsafe.Pointer(bp + 16 /* mxPathname */))
__26:
	;
	(*sqlite3_vfs)(unsafe.Pointer(pVfs)).FszOsFile = *(*int32)(unsafe.Pointer(bp + 12 /* szOsFile */))
	(*Testvfs)(unsafe.Pointer(p)).FpVfs = pVfs
	(*Testvfs)(unsafe.Pointer(p)).FisNoshm = *(*int32)(unsafe.Pointer(bp + 4 /* isNoshm */))
	(*Testvfs)(unsafe.Pointer(p)).FisFullshm = *(*int32)(unsafe.Pointer(bp + 24 /* isFullshm */))
	(*Testvfs)(unsafe.Pointer(p)).Fmask = TESTVFS_ALL_MASK

	sqlite3.Xsqlite3_vfs_register(tls, pVfs, *(*int32)(unsafe.Pointer(bp + 8 /* isDefault */)))

	return TCL_OK

bad_args:
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39604 /* "VFSNAME ?-noshm ..." */)
	return TCL_ERROR
}

var tvfs_vfs = sqlite3_vfs{
	FiVersion:      3, // pAppData
	FxOpen:         0, // xOpen
	FxDelete:       0, // xDelete
	FxAccess:       0, // xAccess
	FxFullPathname: 0, // xDlClose
	FxRandomness:   0, // xRandomness
	FxSleep:        0, // xSleep
	FxCurrentTime:  0, // xNextSystemCall
} /* test_vfs.c:1444:22 */

// tclcmd: vfs_shmlock DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N
func test_vfs_shmlock(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1586:26: */
	bp := tls.Alloc(88)
	defer tls.Free(88)

	*(*[3]uintptr)(unsafe.Pointer(bp + 8 /* azArg1 */)) = [3]uintptr{ts + 39708 /* "shared" */, ts + 14805 /* "exclusive" */, uintptr(0)}
	*(*[3]uintptr)(unsafe.Pointer(bp + 40 /* azArg2 */)) = [3]uintptr{ts + 39715 /* "lock" */, ts + 39720 /* "unlock" */, uintptr(0)}
	*(*uintptr)(unsafe.Pointer(bp /* db */)) = uintptr(0)
	var rc int32 = SQLITE_OK
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 32 /* iArg1 */)) = 0
	*(*int32)(unsafe.Pointer(bp + 64 /* iArg2 */)) = 0
	*(*int32)(unsafe.Pointer(bp + 68 /* iOffset */)) = 0
	*(*int32)(unsafe.Pointer(bp + 72 /* n */)) = 0
	// var pFd uintptr at bp+80, 8

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv,
			ts+39727 /* "DB DBNAME (share..." */)
		return TCL_ERROR
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 ||
		tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+8, int32(unsafe.Sizeof(uintptr(0))), ts+39779, 0, bp+32) != 0 ||
		tcl.XTcl_GetIndexFromObjStruct(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+40, int32(unsafe.Sizeof(uintptr(0))), ts+39779, 0, bp+64) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 5*8)), bp+68) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 6*8)), bp+72) != 0 {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zDbname, SQLITE_FCNTL_FILE_POINTER, bp+80 /* &pFd */)
	if *(*uintptr)(unsafe.Pointer(bp + 80)) == uintptr(0) {
		return TCL_ERROR
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 80 /* pFd */)))).FpMethods)).FxShmLock})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 80 /* pFd */)), *(*int32)(unsafe.Pointer(bp + 68 /* iOffset */)), *(*int32)(unsafe.Pointer(bp + 72 /* n */)),
		func() int32 {
			if *(*int32)(unsafe.Pointer(bp + 32)) == 0 {
				return SQLITE_SHM_SHARED
			}
			return SQLITE_SHM_EXCLUSIVE
		}()|
			func() int32 {
				if *(*int32)(unsafe.Pointer(bp + 64)) == 0 {
					return SQLITE_SHM_LOCK
				}
				return SQLITE_SHM_UNLOCK
			}())
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
	return TCL_OK
}

func test_vfs_set_readmark(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_vfs.c:1632:26: */
	bp := tls.Alloc(48)
	defer tls.Free(48)

	*(*uintptr)(unsafe.Pointer(bp + 16 /* db */)) = uintptr(0)
	var rc int32 = SQLITE_OK
	var zDbname uintptr = uintptr(0)
	*(*int32)(unsafe.Pointer(bp + 24 /* iSlot */)) = 0
	*(*int32)(unsafe.Pointer(bp + 28 /* iVal */)) = -1
	// var pFd uintptr at bp+32, 8

	*(*uintptr)(unsafe.Pointer(bp + 40 /* pShm */)) = uintptr(0)
	var aShm uintptr
	var iOff int32

	if objc != 4 && objc != 5 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39783 /* "DB DBNAME SLOT ?..." */)
		return TCL_ERROR
	}

	zDbname = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp+16) != 0 ||
		tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 3*8)), bp+24) != 0 ||
		objc == 5 && tcl.XTcl_GetIntFromObj(tls, interp, *(*uintptr)(unsafe.Pointer(objv + 4*8)), bp+28) != 0 {
		return TCL_ERROR
	}

	sqlite3.Xsqlite3_file_control(tls, *(*uintptr)(unsafe.Pointer(bp + 16 /* db */)), zDbname, SQLITE_FCNTL_FILE_POINTER, bp+32 /* &pFd */)
	if *(*uintptr)(unsafe.Pointer(bp + 32)) == uintptr(0) {
		return TCL_ERROR
	}
	rc = (*struct {
		f func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32
	})(unsafe.Pointer(&struct{ uintptr }{(*sqlite3_io_methods1)(unsafe.Pointer((*sqlite3_file)(unsafe.Pointer(*(*uintptr)(unsafe.Pointer(bp + 32 /* pFd */)))).FpMethods)).FxShmMap})).f(tls, *(*uintptr)(unsafe.Pointer(bp + 32 /* pFd */)), 0, 32*1024, 0, bp+40 /* &pShm */)
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	if *(*uintptr)(unsafe.Pointer(bp + 40)) == uintptr(0) {
		tcl.XTcl_AppendResult(tls, interp, libc.VaList(bp, ts+39806 /* "*-shm is not yet..." */, 0))
		return TCL_ERROR
	}
	aShm = *(*uintptr)(unsafe.Pointer(bp + 40 /* pShm */))
	iOff = 12*2 + 1 + *(*int32)(unsafe.Pointer(bp + 24))

	if objc == 5 {
		*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)) = u32(*(*int32)(unsafe.Pointer(bp + 28 /* iVal */)))
	}
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewIntObj(tls, int32(*(*u32)(unsafe.Pointer(aShm + uintptr(iOff)*4)))))

	return TCL_OK
}

func Sqlitetestvfs_Init(tls *libc.TLS, interp uintptr) int32 { /* test_vfs.c:1685:5: */
	tcl.XTcl_CreateObjCommand(tls, interp, ts+39830 /* "testvfs" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32
	}{testvfs_cmd})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+39838 /* "vfs_shmlock" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_shmlock})), uintptr(0), uintptr(0))
	tcl.XTcl_CreateObjCommand(tls, interp, ts+39850 /* "vfs_set_readmark" */, *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_vfs_set_readmark})), uintptr(0), uintptr(0))
	return TCL_OK
}

// 2015 November 30
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
// This file contains code to implement most of the opendir() family of
// POSIX functions on Win32 using the MSVCRT.

type TestWindow1 = struct {
	FxStep    uintptr
	FxFinal   uintptr
	FxValue   uintptr
	FxInverse uintptr
	Finterp   uintptr
} /* test_window.c:24:9 */

type TestWindow = TestWindow1 /* test_window.c:24:27 */

type TestWindowCtx1 = struct{ FpVal uintptr } /* test_window.c:33:9 */

type TestWindowCtx = TestWindowCtx1 /* test_window.c:33:30 */

func doTestWindowStep(tls *libc.TLS, bInverse int32, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:38:13: */
	var i int32
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bInverse != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxInverse
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxStep
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+584 /* "" */, -1))
		}
		for i = 0; i < nArg; i++ {
			var pArg uintptr
			pArg = tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3_value_text(tls, *(*uintptr)(unsafe.Pointer(apArg + uintptr(i)*8))), -1)
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, pArg)
		}
		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
		if rc != TCL_OK {
			zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = tcl.XTcl_DuplicateObj(tls, tcl.XTcl_GetObjResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp))
			(*Tcl_Obj)(unsafe.Pointer((*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal)).FrefCount++
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func doTestWindowFinalize(tls *libc.TLS, bValue int32, ctx uintptr) { /* test_window.c:76:13: */
	var p uintptr = sqlite3.Xsqlite3_user_data(tls, ctx)
	var pEval uintptr = tcl.XTcl_DuplicateObj(tls, func() uintptr {
		if bValue != 0 {
			return (*TestWindow)(unsafe.Pointer(p)).FxValue
		}
		return (*TestWindow)(unsafe.Pointer(p)).FxFinal
	}())
	var pCtx uintptr = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(TestWindowCtx{})))

	(*Tcl_Obj)(unsafe.Pointer(pEval)).FrefCount++
	if pCtx != 0 {
		var zResult uintptr
		var rc int32
		if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_DuplicateObj(tls, (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal))
		} else {
			tcl.XTcl_ListObjAppendElement(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, tcl.XTcl_NewStringObj(tls, ts+584 /* "" */, -1))
		}

		rc = tcl.XTcl_EvalObjEx(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp, pEval, TCL_EVAL_GLOBAL)
		zResult = tcl.XTcl_GetStringResult(tls, (*TestWindow)(unsafe.Pointer(p)).Finterp)
		if rc != TCL_OK {
			sqlite3.Xsqlite3_result_error(tls, ctx, zResult, -1)
		} else {
			sqlite3.Xsqlite3_result_text(tls, ctx, zResult, -1, libc.UintptrFromInt32(-1))
		}

		if bValue == 0 {
			if (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal != 0 {
				for ok := true; ok; ok = 0 != 0 {
					var _objPtr uintptr = (*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal
					if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
						tcl.XTclFreeObj(tls, _objPtr)
					}
				}
			}
			(*TestWindowCtx)(unsafe.Pointer(pCtx)).FpVal = uintptr(0)
		}
	}
	for ok1 := true; ok1; ok1 = 0 != 0 {
		var _objPtr uintptr = pEval
		if libc.PostDecInt32(&(*Tcl_Obj)(unsafe.Pointer(_objPtr)).FrefCount, 1) <= 1 {
			tcl.XTclFreeObj(tls, _objPtr)
		}
	}
}

func testWindowStep(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:107:13: */
	doTestWindowStep(tls, 0, ctx, nArg, apArg)
}

func testWindowInverse(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:114:13: */
	doTestWindowStep(tls, 1, ctx, nArg, apArg)
}

func testWindowFinal(tls *libc.TLS, ctx uintptr) { /* test_window.c:122:13: */
	doTestWindowFinalize(tls, 0, ctx)
}

func testWindowValue(tls *libc.TLS, ctx uintptr) { /* test_window.c:125:13: */
	doTestWindowFinalize(tls, 1, ctx)
}

func testWindowDestroy(tls *libc.TLS, pCtx uintptr) { /* test_window.c:129:13: */
	tcl.XTcl_Free(tls, pCtx)
}

// Usage: sqlite3_create_window_function DB NAME XSTEP XFINAL XVALUE XINVERSE
func test_create_window(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:136:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	var pNew uintptr
	// var db uintptr at bp, 8

	var zName uintptr
	var rc int32

	if objc != 7 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+39867 /* "DB NAME XSTEP XF..." */)
		return TCL_ERROR
	}

	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}
	zName = tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 2*8)))
	pNew = tcl.XTcl_Alloc(tls, uint32(unsafe.Sizeof(TestWindow{})))
	libc.Xmemset(tls, pNew, 0, uint64(unsafe.Sizeof(TestWindow{})))
	(*TestWindow)(unsafe.Pointer(pNew)).FxStep = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 3*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxFinal = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 4*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxValue = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 5*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).FxInverse = tcl.XTcl_DuplicateObj(tls, *(*uintptr)(unsafe.Pointer(objv + 6*8)))
	(*TestWindow)(unsafe.Pointer(pNew)).Finterp = interp

	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxStep)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxFinal)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxValue)).FrefCount++
	(*Tcl_Obj)(unsafe.Pointer((*TestWindow)(unsafe.Pointer(pNew)).FxInverse)).FrefCount++

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), zName, -1, SQLITE_UTF8, pNew,
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		*(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowDestroy})))
	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}

	return TCL_OK
}

func test_create_window_misuse(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:179:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if !(objc != 2) {
		goto __1
	}
	tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
	return TCL_ERROR
__1:
	;
	if !(getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0) {
		goto __2
	}
	return TCL_ERROR
__2:
	;

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+39904 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __3
	}
	goto error
__3:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+39904 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __4
	}
	goto error
__4:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+39904 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowInverse})),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __5
	}
	goto error
__5:
	;
	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+39904 /* "fff" */, -1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{testWindowStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{testWindowValue})), uintptr(0),
		uintptr(0))
	if !(rc != SQLITE_MISUSE) {
		goto __6
	}
	goto error
__6:
	;

	return TCL_OK

error:
	tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, ts+39908 /* "misuse test erro..." */, -1))
	return TCL_ERROR
}

// xStep for sumint().
func sumintStep(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:225:13: */
	var pInt uintptr

	if sqlite3.Xsqlite3_value_type(tls, *(*uintptr)(unsafe.Pointer(apArg))) != SQLITE_INTEGER {
		sqlite3.Xsqlite3_result_error(tls, ctx, ts+39926 /* "invalid argument" */, -1)
		return
	}
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	if pInt != 0 {
		*(*sqlite3_int64)(unsafe.Pointer(pInt)) += sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg)))
	}
}

// xInverse for sumint().
func sumintInverse(tls *libc.TLS, ctx uintptr, nArg int32, apArg uintptr) { /* test_window.c:246:13: */
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, int32(unsafe.Sizeof(sqlite3_int64(0))))
	*(*sqlite3_int64)(unsafe.Pointer(pInt)) -= sqlite3.Xsqlite3_value_int64(tls, *(*uintptr)(unsafe.Pointer(apArg)))
}

// xFinal for sumint().
func sumintFinal(tls *libc.TLS, ctx uintptr) { /* test_window.c:259:13: */
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

// xValue for sumint().
func sumintValue(tls *libc.TLS, ctx uintptr) { /* test_window.c:270:13: */
	var res sqlite3_int64 = int64(0)
	var pInt uintptr
	pInt = sqlite3.Xsqlite3_aggregate_context(tls, ctx, 0)
	if pInt != 0 {
		res = *(*sqlite3_int64)(unsafe.Pointer(pInt))
	}
	sqlite3.Xsqlite3_result_int64(tls, ctx, res)
}

func test_create_sumint(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:278:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_create_window_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+39943 /* "sumint" */, 1, SQLITE_UTF8, uintptr(0),
		*(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintFinal})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintValue})), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintInverse})),
		uintptr(0))

	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

func test_override_sum(tls *libc.TLS, clientData uintptr, interp uintptr, objc int32, objv uintptr) int32 { /* test_window.c:305:26: */
	bp := tls.Alloc(8)
	defer tls.Free(8)

	// var db uintptr at bp, 8

	var rc int32

	if objc != 2 {
		tcl.XTcl_WrongNumArgs(tls, interp, 1, objv, ts+2050 /* "DB" */)
		return TCL_ERROR
	}
	if getDbPointer(tls, interp, tcl.XTcl_GetString(tls, *(*uintptr)(unsafe.Pointer(objv + 1*8))), bp) != 0 {
		return TCL_ERROR
	}

	rc = sqlite3.Xsqlite3_create_function(tls, *(*uintptr)(unsafe.Pointer(bp /* db */)), ts+39950 /* "sum" */, -1, SQLITE_UTF8, uintptr(0),
		uintptr(0), *(*uintptr)(unsafe.Pointer(&struct {
			f func(*libc.TLS, uintptr, int32, uintptr)
		}{sumintStep})), *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, uintptr) }{sumintFinal})))

	if rc != SQLITE_OK {
		tcl.XTcl_SetObjResult(tls, interp, tcl.XTcl_NewStringObj(tls, sqlite3.Xsqlite3ErrName(tls, rc), -1))
		return TCL_ERROR
	}
	return TCL_OK
}

func Sqlitetest_window_Init(tls *libc.TLS, interp uintptr) int32 { /* test_window.c:331:5: */
	var i int32
	for i = 0; uint64(i) < uint64(unsafe.Sizeof(aObjCmd14))/uint64(unsafe.Sizeof(struct {
		FzName       uintptr
		FxProc       uintptr
		FclientData  int32
		F__ccgo_pad1 [4]byte
	}{})); i++ {
		var c ClientData = uintptr(intptr_t(aObjCmd14[i].FclientData))
		tcl.XTcl_CreateObjCommand(tls, interp, aObjCmd14[i].FzName, aObjCmd14[i].FxProc, c, uintptr(0))
	}
	return TCL_OK
}

var aObjCmd14 = [4]struct {
	FzName       uintptr
	FxProc       uintptr
	FclientData  int32
	F__ccgo_pad1 [4]byte
}{
	{FzName: ts + 39954 /* "sqlite3_create_w..." */, FxProc: 0},
	{FzName: ts + 39985 /* "test_create_wind..." */, FxProc: 0},
	{FzName: ts + 40020 /* "test_create_sumi..." */, FxProc: 0},
	{FzName: ts + 40039 /* "test_override_su..." */, FxProc: 0},
} /* test_window.c:336:5 */

// 2008 September 1
//
// The author disclaims copyright to this source code.  In place of
// a legal notice, here is a blessing:
//
//    May you do good and not evil.
//    May you find forgiveness for yourself and forgive others.
//    May you share freely, never taking more than you give.
//
//
//
// The code in this file contains sample implementations of the
// sqlite3_wsd_init() and sqlite3_wsd_find() functions required if the
// SQLITE_OMIT_WSD symbol is defined at build time.

func init() {
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 8)) = cfClose                                                        // test6.c:577:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 16)) = cfRead                          // test6.c:578:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 24)) = cfWrite                         // test6.c:579:3:
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 32)) = cfTruncate                                      // test6.c:580:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 40)) = cfSync                                                 // test6.c:581:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 48)) = cfFileSize                                           // test6.c:582:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 56)) = cfLock                                                 // test6.c:583:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 64)) = cfUnlock                                               // test6.c:584:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 72)) = cfCheckReservedLock                                  // test6.c:585:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 80)) = cfFileControl                                 // test6.c:586:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 88)) = cfSectorSize                                                  // test6.c:587:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 96)) = cfDeviceCharacteristics                                       // test6.c:588:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 104)) = cfShmMap                       // test6.c:589:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 112)) = cfShmLock                               // test6.c:590:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 120)) = cfShmBarrier                                                       // test6.c:591:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CrashFileVtab)) + 128)) = cfShmUnmap                                            // test6.c:592:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 8)) = csvtabCreate            // csv.c:874:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 16)) = csvtabConnect          // csv.c:875:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 24)) = csvtabBestIndex                                          // csv.c:876:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 32)) = csvtabDisconnect                                                  // csv.c:877:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 40)) = csvtabDisconnect                                                  // csv.c:878:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 48)) = csvtabOpen                                               // csv.c:879:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 56)) = csvtabClose                                                       // csv.c:880:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 64)) = csvtabFilter                      // csv.c:881:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 72)) = csvtabNext                                                        // csv.c:882:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 80)) = csvtabEof                                                         // csv.c:883:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 88)) = csvtabColumn                                      // csv.c:884:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModule)) + 96)) = csvtabRowid                                              // csv.c:885:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 8)) = csvtabCreate   // csv.c:906:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 16)) = csvtabConnect // csv.c:907:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 24)) = csvtabBestIndex                                 // csv.c:908:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 32)) = csvtabDisconnect                                         // csv.c:909:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 40)) = csvtabDisconnect                                         // csv.c:910:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 48)) = csvtabOpen                                      // csv.c:911:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 56)) = csvtabClose                                              // csv.c:912:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 64)) = csvtabFilter             // csv.c:913:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 72)) = csvtabNext                                               // csv.c:914:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 80)) = csvtabEof                                                // csv.c:915:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 88)) = csvtabColumn                             // csv.c:916:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 96)) = csvtabRowid                                     // csv.c:917:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&CsvModuleFauxWrite)) + 104)) = csvtabUpdate                   // csv.c:918:3:
	*(*func(*libc.TLS, ClientData, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 16)) = incrblobClose                               // tclsqlite.c:373:3:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 24)) = incrblobInput               // tclsqlite.c:374:3:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 32)) = incrblobOutput              // tclsqlite.c:375:3:
	*(*func(*libc.TLS, ClientData, int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 40)) = incrblobSeek                  // tclsqlite.c:376:3:
	*(*func(*libc.TLS, ClientData, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 64)) = incrblobWatch                                       // tclsqlite.c:379:3:
	*(*func(*libc.TLS, ClientData, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&IncrblobChannelType)) + 72)) = incrblobHandle                       // tclsqlite.c:380:3:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 8)) = f5tCreateTokenizer                          // fts5_tcl.c:1129:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 32)) = f5tTokenizerReturn                            // fts5_tcl.c:1130:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 56)) = f5tTokenize                                   // fts5_tcl.c:1131:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 80)) = f5tCreateFunction                             // fts5_tcl.c:1132:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 104)) = f5tMayBeCorrupt                              // fts5_tcl.c:1133:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 128)) = f5tTokenHash                                 // fts5_tcl.c:1134:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 152)) = f5tRegisterMatchinfo                         // fts5_tcl.c:1135:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd)) + 176)) = f5tRegisterTok                               // fts5_tcl.c:1136:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_enter})) // test1.c:8349:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{db_leave})) // test1.c:8350:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int})) // test1.c:8351:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_int64})) // test1.c:8352:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_long})) // test1.c:8353:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_str})) // test1.c:8354:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_snprintf_str})) // test1.c:8355:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_stronly})) // test1.c:8356:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_double})) // test1.c:8357:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_scaled})) // test1.c:8358:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite3_mprintf_hexdouble})) // test1.c:8359:39:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_z})) // test1.c:8360:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_mprintf_n})) // test1.c:8361:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_snprintf_int})) // test1.c:8362:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 232 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_last_rowid})) // test1.c:8363:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 248 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_printf})) // test1.c:8364:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 264 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_hex})) // test1.c:8365:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 280 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec})) // test1.c:8366:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 296 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_exec_nr})) // test1.c:8367:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 312 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_get_table_printf})) // test1.c:8369:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 328 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close})) // test1.c:8371:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 344 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_test_close_v2})) // test1.c:8372:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 360 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_function})) // test1.c:8373:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 376 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_create_aggregate})) // test1.c:8374:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 392 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_drop_modules})) // test1.c:8375:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 408 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_register_func})) // test1.c:8376:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 424 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{sqlite_abort})) // test1.c:8377:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 440 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_bind})) // test1.c:8378:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 456 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_breakpoint})) // test1.c:8379:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 472 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_key})) // test1.c:8380:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 488 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_rekey})) // test1.c:8381:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 504 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_interrupt})) // test1.c:8382:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 520 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_function})) // test1.c:8383:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 536 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{delete_collation})) // test1.c:8384:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 552 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{get_autocommit})) // test1.c:8385:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 568 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_busy_timeout})) // test1.c:8386:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 584 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_printf})) // test1.c:8387:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 600 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_io_trace})) // test1.c:8388:39:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd1)) + 616 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{clang_sanitize_address})) // test1.c:8389:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_open})) // test2.c:708:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_close})) // test2.c:709:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_commit})) // test2.c:710:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_rollback})) // test2.c:711:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_begin})) // test2.c:712:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_commit})) // test2.c:713:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stmt_rollback})) // test2.c:714:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_stats})) // test2.c:715:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_pagecount})) // test2.c:716:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_get})) // test2.c:717:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_lookup})) // test2.c:718:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_unref})) // test2.c:719:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_read})) // test2.c:720:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_write})) // test2.c:721:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 232 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{page_number})) // test2.c:722:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 248 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{pager_truncate})) // test2.c:723:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 264 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{fake_big_file})) // test2.c:725:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 280 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testBitvecBuiltinTest})) // test2.c:727:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 296 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{testPendingByte})) // test2.c:728:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd2)) + 312 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{faultInstallCmd})) // test2.c:729:45:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_open})) // test3.c:666:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close})) // test3.c:667:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_begin_transaction})) // test3.c:668:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_pager_stats})) // test3.c:669:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_cursor})) // test3.c:670:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_close_cursor})) // test3.c:671:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_next})) // test3.c:672:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_eof})) // test3.c:673:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_payload_size})) // test3.c:674:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_first})) // test3.c:675:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_varint_test})) // test3.c:676:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_from_db})) // test3.c:677:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_ismemdb})) // test3.c:678:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd3)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{btree_set_cache_size})) // test3.c:679:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_create})) // test4.c:701:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_wait})) // test4.c:702:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_halt})) // test4.c:703:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argc})) // test4.c:704:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_argv})) // test4.c:705:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_colname})) // test4.c:706:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_result})) // test4.c:707:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_error})) // test4.c:708:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_compile})) // test4.c:709:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_step})) // test4.c:710:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_finalize})) // test4.c:711:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_swap})) // test4.c:712:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_get})) // test4.c:713:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 216 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_db_put})) // test4.c:714:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd4)) + 232 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_thread_stmt_get})) // test4.c:715:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{binarize})) // test5.c:210:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_value_overhead})) // test5.c:211:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate})) // test5.c:212:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd5)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_translate_selftest})) // test5.c:213:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_create})) // test7.c:695:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_wait})) // test7.c:696:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_halt})) // test7.c:697:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_argc})) // test7.c:698:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_argv})) // test7.c:699:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_colname})) // test7.c:700:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_result})) // test7.c:701:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_error})) // test7.c:702:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_compile})) // test7.c:703:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_step})) // test7.c:704:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_reset})) // test7.c:705:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 184 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_finalize})) // test7.c:706:29:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd6)) + 200 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{tcl_client_swap})) // test7.c:707:29:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 8)) = test_multiplex_initialize  // test_multiplex.c:1364:39:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 24)) = test_multiplex_shutdown   // test_multiplex.c:1365:37:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd7)) + 40)) = test_multiplex_control // test_multiplex.c:1366:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 8 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_shutdown})) // test_mutex.c:485:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 24 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_initialize})) // test_mutex.c:486:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 40 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_config})) // test_mutex.c:487:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 56 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_static_mutex})) // test_mutex.c:489:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 72 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_static_mutex})) // test_mutex.c:490:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 88 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_enter_db_mutex})) // test_mutex.c:492:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 104 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_leave_db_mutex})) // test_mutex.c:493:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 120 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_alloc_mutex})) // test_mutex.c:495:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 136 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_install_mutex_counters})) // test_mutex.c:496:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 152 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_read_mutex_counters})) // test_mutex.c:497:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd8)) + 168 /* .xProc */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32
	}{test_clear_mutex_counters})) // test_mutex.c:498:34:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 8)) = test_quota_initialize                  // test_quota.c:1949:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 24)) = test_quota_shutdown                   // test_quota.c:1950:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 40)) = test_quota_set                        // test_quota.c:1951:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 56)) = test_quota_file                       // test_quota.c:1952:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 72)) = test_quota_dump                       // test_quota.c:1953:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 88)) = test_quota_fopen                      // test_quota.c:1954:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 104)) = test_quota_fread                     // test_quota.c:1955:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 120)) = test_quota_fwrite                    // test_quota.c:1956:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 136)) = test_quota_fclose                    // test_quota.c:1957:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 152)) = test_quota_fflush                    // test_quota.c:1958:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 168)) = test_quota_fseek                     // test_quota.c:1959:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 184)) = test_quota_rewind                    // test_quota.c:1960:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 200)) = test_quota_ftell                     // test_quota.c:1961:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 216)) = test_quota_ftruncate                 // test_quota.c:1962:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 232)) = test_quota_file_size                 // test_quota.c:1963:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 248)) = test_quota_file_truesize             // test_quota.c:1964:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 264)) = test_quota_file_mtime                // test_quota.c:1965:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 280)) = test_quota_remove                    // test_quota.c:1966:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 296)) = test_quota_glob                      // test_quota.c:1967:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 312)) = test_quota_file_available            // test_quota.c:1968:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aCmd9)) + 328)) = test_quota_ferror                    // test_quota.c:1969:38:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 8)) = sqlite3_amatch_init                      // test1.c:7556:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 24)) = sqlite3_appendvfs_init                  // test1.c:7557:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 40)) = sqlite3_carray_init                     // test1.c:7558:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 56)) = sqlite3_closure_init                    // test1.c:7559:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 72)) = sqlite3_csv_init                        // test1.c:7560:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 88)) = sqlite3_decimal_init                    // test1.c:7561:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 104)) = sqlite3_eval_init                      // test1.c:7562:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 120)) = sqlite3_explain_init                   // test1.c:7563:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 136)) = sqlite3_fileio_init                    // test1.c:7564:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 152)) = sqlite3_fuzzer_init                    // test1.c:7565:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 168)) = sqlite3_ieee_init                      // test1.c:7566:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 184)) = sqlite3_nextchar_init                  // test1.c:7567:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 200)) = sqlite3_percentile_init                // test1.c:7568:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 216)) = sqlite3_prefixes_init                  // test1.c:7570:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 232)) = sqlite3_regexp_init                    // test1.c:7572:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 248)) = sqlite3_remember_init                  // test1.c:7573:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 264)) = sqlite3_series_init                    // test1.c:7574:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 280)) = sqlite3_spellfix_init                  // test1.c:7575:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 296)) = sqlite3_totype_init                    // test1.c:7576:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 312)) = sqlite3_unionvtab_init                 // test1.c:7577:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 328)) = sqlite3_wholenumber_init               // test1.c:7578:32:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aExtension)) + 344)) = sqlite3_zipfile_init                   // test1.c:7580:32:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 16)) = decimalFunc                                          // decimal.c:608:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 40)) = decimalCmpFunc                                       // decimal.c:609:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 64)) = decimalAddFunc                                       // decimal.c:610:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 88)) = decimalSubFunc                                       // decimal.c:611:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc)) + 112)) = decimalMulFunc                                      // decimal.c:612:29:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 16)) = ieee754func                                         // ieee754.c:274:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 40)) = ieee754func                                         // ieee754.c:275:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 64)) = ieee754func                                         // ieee754.c:276:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 88)) = ieee754func                                         // ieee754.c:277:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 112)) = ieee754func_to_blob                                // ieee754.c:278:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFunc1)) + 136)) = ieee754func_from_blob                              // ieee754.c:279:36:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 16)) = randStr                                             // test_func.c:675:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 40)) = test_destructor                                     // test_func.c:676:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 64)) = test_destructor16                                   // test_func.c:678:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 88)) = testHexToUtf16be                                    // test_func.c:679:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 112)) = testHexToUtf16le                                   // test_func.c:680:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 136)) = testHexToUtf8                                      // test_func.c:682:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 160)) = test_destructor_count                              // test_func.c:683:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 184)) = test_auxdata                                       // test_func.c:684:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 208)) = test_error                                         // test_func.c:685:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 232)) = test_error                                         // test_func.c:686:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 256)) = test_eval                                          // test_func.c:687:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 280)) = test_isolation                                     // test_func.c:688:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 304)) = counterFunc                                        // test_func.c:689:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 328)) = real2hex                                           // test_func.c:690:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 352)) = test_decode                                        // test_func.c:691:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 376)) = test_extract                                       // test_func.c:692:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 400)) = test_zeroblob                                      // test_func.c:693:62:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 424)) = test_getsubtype                                    // test_func.c:694:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 448)) = test_setsubtype                                    // test_func.c:695:48:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&aFuncs)) + 472)) = test_frombind                                      // test_func.c:696:48:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 8)) = test_sqlite3rbu                   // test_rbu.c:370:21:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 24)) = test_sqlite3rbu_vacuum           // test_rbu.c:371:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 40)) = test_sqlite3rbu_create_vfs       // test_rbu.c:372:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 56)) = test_sqlite3rbu_destroy_vfs      // test_rbu.c:373:33:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd)) + 72)) = test_sqlite3rbu_internal_test    // test_rbu.c:374:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 8)) = test_sqlite3_db_config              // test1.c:8396:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 32)) = test_sqlite3_txn_state             // test1.c:8397:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 56)) = test_bad_behavior               // test1.c:8398:41:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 64 /* .clientData */)) = uintptr(unsafe.Pointer(&iZero))                                  // test1.c:8398:61:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 80)) = test_register_dbstat_vtab          // test1.c:8399:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 104)) = get_sqlite_pointer                // test1.c:8400:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 128)) = test_intarray_addr                // test1.c:8401:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 152)) = test_int64array_addr              // test1.c:8402:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 176)) = test_doublearray_addr             // test1.c:8403:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 200)) = test_textarray_addr               // test1.c:8404:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 224)) = test_bind_int                     // test1.c:8405:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 248)) = test_bind_zeroblob                // test1.c:8406:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 272)) = test_bind_zeroblob64              // test1.c:8407:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 296)) = test_bind_int64                   // test1.c:8408:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 320)) = test_bind_double                  // test1.c:8409:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 344)) = test_bind_null                    // test1.c:8410:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 368)) = test_bind_text                    // test1.c:8411:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 392)) = test_bind_text16                  // test1.c:8412:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 416)) = test_bind_blob                    // test1.c:8413:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 440)) = test_carray_bind                  // test1.c:8415:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 464)) = test_bind_parameter_count         // test1.c:8417:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 488)) = test_bind_parameter_name          // test1.c:8418:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 512)) = test_bind_parameter_index         // test1.c:8419:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 536)) = test_clear_bindings               // test1.c:8420:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 560)) = test_sleep                        // test1.c:8421:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 584)) = test_errcode                      // test1.c:8422:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 608)) = test_ex_errcode                   // test1.c:8423:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 632)) = test_errmsg                       // test1.c:8424:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 656)) = test_errmsg16                     // test1.c:8425:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 680)) = test_open                         // test1.c:8426:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 704)) = test_open16                       // test1.c:8427:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 728)) = test_open_v2                      // test1.c:8428:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 752)) = test_complete16                   // test1.c:8429:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 776)) = test_normalize                    // test1.c:8430:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 800)) = test_prepare                      // test1.c:8432:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 824)) = test_prepare16                    // test1.c:8433:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 848)) = test_prepare_v2                   // test1.c:8434:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 872)) = test_prepare_v3                   // test1.c:8435:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 896)) = test_prepare_tkt3134              // test1.c:8436:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 920)) = test_prepare16_v2                 // test1.c:8437:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 944)) = test_finalize                     // test1.c:8438:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 968)) = test_stmt_status                  // test1.c:8439:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 992)) = test_reset                        // test1.c:8440:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1016)) = test_expired                     // test1.c:8441:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1040)) = test_transfer_bind               // test1.c:8442:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1064)) = test_changes                     // test1.c:8443:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1088)) = test_step                        // test1.c:8444:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1112)) = test_sql                         // test1.c:8445:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1136)) = test_ex_sql                      // test1.c:8446:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1160)) = test_next_stmt                   // test1.c:8450:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1184)) = test_stmt_readonly               // test1.c:8451:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1208)) = test_stmt_isexplain              // test1.c:8452:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1232)) = test_stmt_busy                   // test1.c:8453:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1256)) = uses_stmt_journal                // test1.c:8454:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1280)) = test_release_memory              // test1.c:8456:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1304)) = test_db_release_memory           // test1.c:8457:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1328)) = test_db_cacheflush               // test1.c:8458:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1352)) = test_system_errno                // test1.c:8459:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1376)) = test_db_filename                 // test1.c:8460:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1400)) = test_db_readonly                 // test1.c:8461:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1424)) = test_soft_heap_limit             // test1.c:8462:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1448)) = test_soft_heap_limit             // test1.c:8463:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1472)) = test_hard_heap_limit             // test1.c:8464:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1496)) = test_thread_cleanup              // test1.c:8465:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1520)) = test_pager_refcounts             // test1.c:8466:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1544)) = test_load_extension           // test1.c:8468:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1568)) = test_enable_load              // test1.c:8469:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1592)) = test_extended_result_codes    // test1.c:8470:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1616)) = test_limit                    // test1.c:8471:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1640)) = test_dbconfig_maindbname_icecube // test1.c:8472:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1664)) = save_prng_state               // test1.c:8474:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1688)) = restore_prng_state            // test1.c:8475:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1712)) = reset_prng_state              // test1.c:8476:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1736)) = prng_seed                     // test1.c:8477:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1760)) = extra_schema_checks           // test1.c:8478:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1784)) = database_never_corrupt        // test1.c:8479:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1808)) = database_may_be_corrupt       // test1.c:8480:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1832)) = optimization_control             // test1.c:8481:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1856)) = runAsObjProc                     // test1.c:8490:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1880)) = test_column_count                // test1.c:8493:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1904)) = test_data_count                  // test1.c:8494:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1928)) = test_column_type                 // test1.c:8495:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1952)) = test_column_blob                 // test1.c:8496:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 1976)) = test_column_double               // test1.c:8497:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2000)) = test_column_int64                // test1.c:8498:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2024)) = test_stmt_utf8                   // test1.c:8499:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2032 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_text})) // test1.c:8499:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2048)) = test_stmt_utf8 // test1.c:8500:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2056 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_name})) // test1.c:8500:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2072)) = test_stmt_int // test1.c:8501:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2080 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_int})) // test1.c:8501:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2096)) = test_stmt_int // test1.c:8502:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2104 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_bytes})) // test1.c:8502:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2120)) = test_stmt_utf8 // test1.c:8504:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2128 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_decltype})) // test1.c:8504:49:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2144)) = test_stmt_utf8 // test1.c:8507:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2152 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_database_name})) // test1.c:8507:49:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2168)) = test_stmt_utf8 // test1.c:8508:31:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2176 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_table_name})) // test1.c:8508:46:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2192)) = test_stmt_utf8 // test1.c:8509:32:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2200 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_origin_name})) // test1.c:8509:47:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2216)) = test_stmt_int // test1.c:8513:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2224 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{sqlite3.Xsqlite3_column_bytes16})) // test1.c:8513:49:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2240)) = test_stmt_utf16 // test1.c:8514:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2248 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_text16})) // test1.c:8514:51:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2264)) = test_stmt_utf16 // test1.c:8515:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2272 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_name16})) // test1.c:8515:51:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2288)) = add_alignment_test_collations // test1.c:8516:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2312)) = test_stmt_utf16               // test1.c:8518:36:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2320 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_decltype16})) // test1.c:8518:52:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2336)) = test_stmt_utf16 // test1.c:8522:3:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2344 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_database_name16})) // test1.c:8522:20:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2360)) = test_stmt_utf16 // test1.c:8523:33:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2368 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_table_name16})) // test1.c:8523:50:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2384)) = test_stmt_utf16 // test1.c:8524:34:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2392 /* .clientData */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) uintptr
	}{sqlite3.Xsqlite3_column_origin_name16})) // test1.c:8524:51:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2408)) = test_create_collation_v2         // test1.c:8527:39:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2432)) = test_global_recover                 // test1.c:8528:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2456)) = working_64bit_int                // test1.c:8529:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2480)) = vfs_unlink_test                  // test1.c:8530:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2504)) = vfs_initfail_test                // test1.c:8531:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2528)) = vfs_unregister_all               // test1.c:8532:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2552)) = vfs_reregister_all               // test1.c:8533:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2576)) = file_control_test                // test1.c:8534:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2600)) = file_control_lasterrno_test      // test1.c:8535:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2624)) = file_control_lockproxy_test      // test1.c:8536:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2648)) = file_control_chunksize_test      // test1.c:8537:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2672)) = file_control_sizehint_test       // test1.c:8538:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2696)) = file_control_data_version        // test1.c:8539:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2720)) = file_control_persist_wal         // test1.c:8545:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2744)) = file_control_powersafe_overwrite // test1.c:8546:43:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2768)) = file_control_vfsname             // test1.c:8547:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2792)) = file_control_reservebytes        // test1.c:8548:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2816)) = file_control_tempfilename        // test1.c:8549:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2840)) = file_control_external_reader     // test1.c:8550:42:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2864)) = vfs_list                         // test1.c:8551:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2888)) = test_create_function_v2          // test1.c:8552:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2912)) = test_collate                        // test1.c:8556:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2936)) = test_collate_needed                 // test1.c:8557:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2960)) = test_function                       // test1.c:8558:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 2984)) = test_utf16bin_collate               // test1.c:8559:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3008)) = test_errstr                         // test1.c:8561:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3032)) = tcl_variable_type                   // test1.c:8562:35:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3056)) = test_enable_shared               // test1.c:8564:39:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3080)) = sqlite3BtreeSharedCacheReport       // test1.c:8565:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3104)) = test_libversion_number           // test1.c:8567:37:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3128)) = test_table_column_metadata       // test1.c:8568:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3152)) = test_blob_reopen                 // test1.c:8570:31:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3176)) = test_pcache_stats                // test1.c:8572:30:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3200)) = test_unlock_notify               // test1.c:8574:33:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3224)) = test_wal_checkpoint              // test1.c:8576:36:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3248)) = test_wal_checkpoint_v2           // test1.c:8577:36:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3272)) = test_wal_autocheckpoint          // test1.c:8578:37:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3296)) = test_sqlite3_log                 // test1.c:8579:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3320)) = test_print_eqp                      // test1.c:8581:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3344)) = test_test_control                   // test1.c:8583:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3368)) = test_getrusage                      // test1.c:8585:21:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3392)) = tclLoadStaticExtensionCmd           // test1.c:8587:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3416)) = sorter_test_fakeheap                // test1.c:8588:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3440)) = sorter_test_sort4_helper            // test1.c:8589:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3464)) = vfsCurrentTimeInt64                 // test1.c:8603:44:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3488)) = test_snapshot_get                   // test1.c:8605:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3512)) = test_snapshot_open                  // test1.c:8606:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3536)) = test_snapshot_free                  // test1.c:8607:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3560)) = test_snapshot_cmp                   // test1.c:8608:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3584)) = test_snapshot_recover               // test1.c:8609:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3608)) = test_snapshot_get_blob              // test1.c:8610:37:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3632)) = test_snapshot_open_blob             // test1.c:8611:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3656)) = test_snapshot_cmp_blob              // test1.c:8612:37:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3680)) = test_delete_database                // test1.c:8614:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3704)) = test_atomic_batch_write             // test1.c:8615:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3728)) = test_mmap_warm                      // test1.c:8616:35:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3752)) = test_config_sorterref               // test1.c:8617:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3776)) = test_autovacuum_pages               // test1.c:8618:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3800)) = test_decode_hexdb                   // test1.c:8619:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3824)) = test_write_db                       // test1.c:8620:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3848)) = test_register_cksumvfs              // test1.c:8621:37:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd1)) + 3872)) = test_unregister_cksumvfs            // test1.c:8622:39:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 8)) = test_intarray_create               // test_intarray.c:381:35:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd10)) + 32)) = test_intarray_bind                // test_intarray.c:382:33:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 8)) = test_malloc                           // test_malloc.c:1473:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 32)) = test_realloc                         // test_malloc.c:1474:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 56)) = test_free                            // test_malloc.c:1475:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 80)) = test_memset                          // test_malloc.c:1476:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 104)) = test_memget                         // test_malloc.c:1477:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 128)) = test_memory_used                    // test_malloc.c:1478:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 152)) = test_memory_highwater               // test_malloc.c:1479:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 176)) = test_memdebug_backtrace             // test_malloc.c:1480:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 200)) = test_memdebug_dump                  // test_malloc.c:1481:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 224)) = test_memdebug_fail                  // test_malloc.c:1482:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 248)) = test_memdebug_pending               // test_malloc.c:1483:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 272)) = test_memdebug_settitle              // test_malloc.c:1484:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 296)) = test_memdebug_malloc_count          // test_malloc.c:1485:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 320)) = test_memdebug_log                   // test_malloc.c:1486:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 344)) = test_config_pagecache               // test_malloc.c:1487:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 368)) = test_alt_pcache                     // test_malloc.c:1488:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 392)) = test_status                         // test_malloc.c:1489:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 416)) = test_db_status                      // test_malloc.c:1490:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 440)) = test_install_malloc_faultsim        // test_malloc.c:1491:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 464)) = test_config_heap                    // test_malloc.c:1492:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 488)) = test_config_heap_size               // test_malloc.c:1493:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 512)) = test_config_memstatus               // test_malloc.c:1494:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 536)) = test_config_lookaside               // test_malloc.c:1495:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 560)) = test_config_error                   // test_malloc.c:1496:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 584)) = test_config_uri                     // test_malloc.c:1497:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 608)) = test_config_cis                     // test_malloc.c:1498:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 632)) = test_config_pmasz                   // test_malloc.c:1499:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 656)) = test_db_config_lookaside            // test_malloc.c:1500:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 680)) = test_dump_memsys3                   // test_malloc.c:1501:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 704)) = test_dump_memsys3                   // test_malloc.c:1502:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 728)) = test_install_memsys3                // test_malloc.c:1503:38:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd11)) + 752)) = test_vfs_oom_test                   // test_malloc.c:1504:41:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd12)) + 8)) = register_schema_module             // test_schema.c:336:34:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd13)) + 8)) = register_tclvar_module             // test_tclvar.c:553:36:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 8)) = test_create_window                    // test_window.c:337:42:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 32)) = test_create_window_misuse            // test_window.c:338:46:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 56)) = test_create_sumint                   // test_window.c:339:30:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd14)) + 80)) = test_override_sum                    // test_window.c:340:29:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 8)) = register_echo_module                // test8.c:1440:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd2)) + 32)) = declare_vtab                       // test8.c:1441:38:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 8)) = c_misuse_test                       // test9.c:194:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 32)) = c_realloc_test                     // test9.c:195:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd3)) + 56)) = c_collation_test                   // test9.c:196:28:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd4)) + 8)) = register_tcl_module                 // test_bestindex.c:611:33:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 8)) = test_blob_open                      // test_blob.c:318:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 24)) = test_blob_close                    // test_blob.c:319:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 40)) = test_blob_bytes                    // test_blob.c:320:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 56)) = test_blob_read                     // test_blob.c:321:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd5)) + 72)) = test_blob_write                    // test_blob.c:322:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd6)) + 8)) = register_fs_module                  // test_fs.c:908:32:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 8)) = autoinstall_test_funcs                 // test_func.c:938:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 24)) = abuse_create_function                 // test_func.c:939:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd7)) + 40)) = install_fts3_rank_function            // test_func.c:940:41:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 8)) = hexio_read                             // test_hexio.c:451:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 24)) = hexio_write                           // test_hexio.c:452:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 40)) = hexio_get_int                         // test_hexio.c:453:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 56)) = hexio_render_int16                    // test_hexio.c:454:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 72)) = hexio_render_int32                    // test_hexio.c:455:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 88)) = utf8_to_utf8                          // test_hexio.c:456:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 104)) = read_fts3varint                      // test_hexio.c:457:40:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd8)) + 120)) = make_fts3record                      // test_hexio.c:458:40:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 8)) = init_wrapper_install                // test_init.c:283:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 24)) = init_wrapper_query                 // test_init.c:284:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 40)) = init_wrapper_uninstall             // test_init.c:285:32:
	*(*func(*libc.TLS, ClientData, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&aObjCmd9)) + 56)) = init_wrapper_clear                 // test_init.c:286:32:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 8 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32, int32) int32
	}{ts_open})) // test_syscall.c:134:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 40 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct{ f func(*libc.TLS, int32) int32 }{ts_close})) // test_syscall.c:135:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 72 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, int32) int32
	}{ts_access})) // test_syscall.c:136:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 104 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t) uintptr
	}{ts_getcwd})) // test_syscall.c:137:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 136 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, uintptr) int32
	}{ts_stat})) // test_syscall.c:138:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 168 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr) int32
	}{ts_fstat})) // test_syscall.c:139:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 200 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, off_t) int32
	}{ts_ftruncate})) // test_syscall.c:140:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 232 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, int32, uintptr) int32
	}{ts_fcntl})) // test_syscall.c:141:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 264 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t) int32
	}{ts_read})) // test_syscall.c:142:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 296 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pread})) // test_syscall.c:143:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 328 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pread64})) // test_syscall.c:144:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 360 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t) int32
	}{ts_write})) // test_syscall.c:145:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 392 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, off_t) int32
	}{ts_pwrite})) // test_syscall.c:146:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 424 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, uintptr, size_t, sqlite3_uint64) int32
	}{ts_pwrite64})) // test_syscall.c:147:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 456 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, mode_t) int32
	}{ts_fchmod})) // test_syscall.c:148:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 488 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, int32, off_t, off_t) int32
	}{ts_fallocate})) // test_syscall.c:149:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 520 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t, int32, int32, int32, off_t) uintptr
	}{ts_mmap})) // test_syscall.c:150:27:
	*(*sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&aSyscall)) + 552 /* .xTest */)) = *(*uintptr)(unsafe.Pointer(&struct {
		f func(*libc.TLS, uintptr, size_t, size_t, int32, uintptr) uintptr
	}{ts_mremap})) // test_syscall.c:151:27:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 8)) = amatchConnect            // amatch.c:1456:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 16)) = amatchConnect           // amatch.c:1457:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 24)) = amatchBestIndex                                           // amatch.c:1458:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 32)) = amatchDisconnect                                                   // amatch.c:1459:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 40)) = amatchDisconnect                                                   // amatch.c:1460:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 48)) = amatchOpen                                                // amatch.c:1461:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 56)) = amatchClose                                                        // amatch.c:1462:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 64)) = amatchFilter                       // amatch.c:1463:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 72)) = amatchNext                                                         // amatch.c:1464:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 80)) = amatchEof                                                          // amatch.c:1465:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 88)) = amatchColumn                                       // amatch.c:1466:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 96)) = amatchRowid                                               // amatch.c:1467:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&amatchModule)) + 104)) = amatchUpdate                             // amatch.c:1468:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 8)) = apndClose                                                        // appendvfs.c:204:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 16)) = apndRead                         // appendvfs.c:205:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 24)) = apndWrite                        // appendvfs.c:206:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 32)) = apndTruncate                                     // appendvfs.c:207:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 40)) = apndSync                                                 // appendvfs.c:208:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 48)) = apndFileSize                                           // appendvfs.c:209:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 56)) = apndLock                                                 // appendvfs.c:210:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 64)) = apndUnlock                                               // appendvfs.c:211:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 72)) = apndCheckReservedLock                                  // appendvfs.c:212:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 80)) = apndFileControl                                 // appendvfs.c:213:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 88)) = apndSectorSize                                                  // appendvfs.c:214:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 96)) = apndDeviceCharacteristics                                       // appendvfs.c:215:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 104)) = apndShmMap                       // appendvfs.c:216:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 112)) = apndShmLock                               // appendvfs.c:217:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 120)) = apndShmBarrier                                                       // appendvfs.c:218:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 128)) = apndShmUnmap                                            // appendvfs.c:219:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 136)) = apndFetch                       // appendvfs.c:220:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_io_methods)) + 144)) = apndUnfetch                            // appendvfs.c:221:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 40)) = apndOpen                             // appendvfs.c:184:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 48)) = apndDelete                                             // appendvfs.c:185:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 56)) = apndAccess                                    // appendvfs.c:186:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 64)) = apndFullPathname                              // appendvfs.c:187:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 72)) = apndDlOpen                                                  // appendvfs.c:188:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 80)) = apndDlError                                                  // appendvfs.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 88)) = apndDlSym                                          // appendvfs.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 96)) = apndDlClose                                                         // appendvfs.c:191:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 104)) = apndRandomness                                        // appendvfs.c:192:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 112)) = apndSleep                                                      // appendvfs.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 120)) = apndCurrentTime                                              // appendvfs.c:194:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 128)) = apndGetLastError                                      // appendvfs.c:195:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 136)) = apndCurrentTimeInt64                                         // appendvfs.c:196:3:
	*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 144)) = apndSetSystemCall                       // appendvfs.c:197:3:
	*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 152)) = apndGetSystemCall                              // appendvfs.c:198:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&apnd_vfs)) + 160)) = apndNextSystemCall                                         // appendvfs.c:199:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 16)) = carrayConnect           // carray.c:378:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 24)) = carrayBestIndex                                           // carray.c:379:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 32)) = carrayDisconnect                                                   // carray.c:380:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 48)) = carrayOpen                                                // carray.c:382:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 56)) = carrayClose                                                        // carray.c:383:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 64)) = carrayFilter                       // carray.c:384:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 72)) = carrayNext                                                         // carray.c:385:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 80)) = carrayEof                                                          // carray.c:386:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 88)) = carrayColumn                                       // carray.c:387:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&carrayModule)) + 96)) = carrayRowid                                               // carray.c:388:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 8)) = cksmClose                                                        // cksumvfs.c:274:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 16)) = cksmRead                         // cksumvfs.c:275:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 24)) = cksmWrite                        // cksumvfs.c:276:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 32)) = cksmTruncate                                     // cksumvfs.c:277:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 40)) = cksmSync                                                 // cksumvfs.c:278:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 48)) = cksmFileSize                                           // cksumvfs.c:279:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 56)) = cksmLock                                                 // cksumvfs.c:280:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 64)) = cksmUnlock                                               // cksumvfs.c:281:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 72)) = cksmCheckReservedLock                                  // cksumvfs.c:282:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 80)) = cksmFileControl                                 // cksumvfs.c:283:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 88)) = cksmSectorSize                                                  // cksumvfs.c:284:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 96)) = cksmDeviceCharacteristics                                       // cksumvfs.c:285:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 104)) = cksmShmMap                       // cksumvfs.c:286:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 112)) = cksmShmLock                               // cksumvfs.c:287:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 120)) = cksmShmBarrier                                                       // cksumvfs.c:288:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 128)) = cksmShmUnmap                                            // cksumvfs.c:289:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 136)) = cksmFetch                       // cksumvfs.c:290:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_io_methods)) + 144)) = cksmUnfetch                            // cksumvfs.c:291:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 40)) = cksmOpen                             // cksumvfs.c:254:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 48)) = cksmDelete                                             // cksumvfs.c:255:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 56)) = cksmAccess                                    // cksumvfs.c:256:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 64)) = cksmFullPathname                              // cksumvfs.c:257:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 72)) = cksmDlOpen                                                  // cksumvfs.c:258:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 80)) = cksmDlError                                                  // cksumvfs.c:259:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 88)) = cksmDlSym                                          // cksumvfs.c:260:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 96)) = cksmDlClose                                                         // cksumvfs.c:261:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 104)) = cksmRandomness                                        // cksumvfs.c:262:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 112)) = cksmSleep                                                      // cksumvfs.c:263:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 120)) = cksmCurrentTime                                              // cksumvfs.c:264:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 128)) = cksmGetLastError                                      // cksumvfs.c:265:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 136)) = cksmCurrentTimeInt64                                         // cksumvfs.c:266:3:
	*(*func(*libc.TLS, uintptr, uintptr, sqlite3_syscall_ptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 144)) = cksmSetSystemCall                       // cksumvfs.c:267:3:
	*(*func(*libc.TLS, uintptr, uintptr) sqlite3_syscall_ptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 152)) = cksmGetSystemCall                              // cksumvfs.c:268:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&cksm_vfs)) + 160)) = cksmNextSystemCall                                         // cksumvfs.c:269:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 8)) = closureConnect          // closure.c:920:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 16)) = closureConnect         // closure.c:921:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 24)) = closureBestIndex                                         // closure.c:922:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 32)) = closureDisconnect                                                 // closure.c:923:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 40)) = closureDisconnect                                                 // closure.c:924:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 48)) = closureOpen                                              // closure.c:925:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 56)) = closureClose                                                      // closure.c:926:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 64)) = closureFilter                     // closure.c:927:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 72)) = closureNext                                                       // closure.c:928:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 80)) = closureEof                                                        // closure.c:929:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 88)) = closureColumn                                     // closure.c:930:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&closureModule)) + 96)) = closureRowid                                             // closure.c:931:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 40)) = cfOpen                               // test6.c:857:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 48)) = cfDelete                                               // test6.c:858:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 56)) = cfAccess                                      // test6.c:859:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 64)) = cfFullPathname                                // test6.c:860:5:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 72)) = cfDlOpen                                                    // test6.c:861:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 80)) = cfDlError                                                    // test6.c:862:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 88)) = cfDlSym                                            // test6.c:863:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 96)) = cfDlClose                                                           // test6.c:864:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 104)) = cfRandomness                                          // test6.c:865:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 112)) = cfSleep                                                        // test6.c:866:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 120)) = cfCurrentTime                                                // test6.c:867:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&crashVfs)) + 128)) = cfGetLastError                                        // test6.c:868:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 8)) = devsymClose                                                    // test_devsym.c:229:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 16)) = devsymRead                      // test_devsym.c:230:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 24)) = devsymWrite                     // test_devsym.c:231:3:
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 32)) = devsymTruncate                                  // test_devsym.c:232:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 40)) = devsymSync                                             // test_devsym.c:233:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 48)) = devsymFileSize                                       // test_devsym.c:234:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 56)) = devsymLock                                             // test_devsym.c:235:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 64)) = devsymUnlock                                           // test_devsym.c:236:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 72)) = devsymCheckReservedLock                              // test_devsym.c:237:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 80)) = devsymFileControl                             // test_devsym.c:238:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 88)) = devsymSectorSize                                              // test_devsym.c:239:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 96)) = devsymDeviceCharacteristics                                   // test_devsym.c:240:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 104)) = devsymShmMap                   // test_devsym.c:241:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 112)) = devsymShmLock                           // test_devsym.c:242:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 120)) = devsymShmBarrier                                                   // test_devsym.c:243:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_io_methods)) + 128)) = devsymShmUnmap                                        // test_devsym.c:244:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 40)) = devsymOpen                         // test_devsym.c:428:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 48)) = devsymDelete                                         // test_devsym.c:429:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 56)) = devsymAccess                                // test_devsym.c:430:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 64)) = devsymFullPathname                          // test_devsym.c:431:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 104)) = devsymRandomness                                    // test_devsym.c:443:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 112)) = devsymSleep                                                  // test_devsym.c:444:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&devsym_vfs)) + 120)) = devsymCurrentTime                                          // test_devsym.c:445:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 8)) = echoCreate                 // test8.c:1302:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 16)) = echoConnect               // test8.c:1303:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 24)) = echoBestIndex                                               // test8.c:1304:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 32)) = echoDisconnect                                                       // test8.c:1305:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 40)) = echoDestroy                                                          // test8.c:1306:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 48)) = echoOpen                                                    // test8.c:1307:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 56)) = echoClose                                                            // test8.c:1308:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 64)) = echoFilter                           // test8.c:1309:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 72)) = echoNext                                                             // test8.c:1310:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 80)) = echoEof                                                              // test8.c:1311:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 88)) = echoColumn                                           // test8.c:1312:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 96)) = echoRowid                                                   // test8.c:1313:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 104)) = echoUpdate                                 // test8.c:1314:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 112)) = echoBegin                                                           // test8.c:1315:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 120)) = echoSync                                                            // test8.c:1316:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 128)) = echoCommit                                                          // test8.c:1317:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 136)) = echoRollback                                                        // test8.c:1318:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 144)) = echoFindFunction                  // test8.c:1319:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModule)) + 152)) = echoRename                                                 // test8.c:1320:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 8)) = echoCreate               // test8.c:1325:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 16)) = echoConnect             // test8.c:1326:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 24)) = echoBestIndex                                             // test8.c:1327:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 32)) = echoDisconnect                                                     // test8.c:1328:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 40)) = echoDestroy                                                        // test8.c:1329:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 48)) = echoOpen                                                  // test8.c:1330:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 56)) = echoClose                                                          // test8.c:1331:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 64)) = echoFilter                         // test8.c:1332:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 72)) = echoNext                                                           // test8.c:1333:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 80)) = echoEof                                                            // test8.c:1334:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 88)) = echoColumn                                         // test8.c:1335:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 96)) = echoRowid                                                 // test8.c:1336:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 104)) = echoUpdate                               // test8.c:1337:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 112)) = echoBegin                                                         // test8.c:1338:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 120)) = echoSync                                                          // test8.c:1339:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 128)) = echoCommit                                                        // test8.c:1340:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 136)) = echoRollback                                                      // test8.c:1341:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 144)) = echoFindFunction                // test8.c:1342:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 152)) = echoRename                                               // test8.c:1343:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 160)) = echoSavepoint                                              // test8.c:1344:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 168)) = echoRelease                                                // test8.c:1345:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&echoModuleV2)) + 176)) = echoRollbackTo                                             // test8.c:1346:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 8)) = expertConnect            // sqlite3expert.c:642:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 16)) = expertConnect           // sqlite3expert.c:643:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 24)) = expertBestIndex                                           // sqlite3expert.c:644:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 32)) = expertDisconnect                                                   // sqlite3expert.c:645:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 40)) = expertDisconnect                                                   // sqlite3expert.c:646:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 48)) = expertOpen                                                // sqlite3expert.c:647:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 56)) = expertClose                                                        // sqlite3expert.c:648:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 64)) = expertFilter                       // sqlite3expert.c:649:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 72)) = expertNext                                                         // sqlite3expert.c:650:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 80)) = expertEof                                                          // sqlite3expert.c:651:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 88)) = expertColumn                                       // sqlite3expert.c:652:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 96)) = expertRowid                                               // sqlite3expert.c:653:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&expertModule)) + 104)) = expertUpdate                             // sqlite3expert.c:654:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 16)) = explainConnect         // explain.c:274:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 24)) = explainBestIndex                                         // explain.c:275:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 32)) = explainDisconnect                                                 // explain.c:276:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 48)) = explainOpen                                              // explain.c:278:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 56)) = explainClose                                                      // explain.c:279:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 64)) = explainFilter                     // explain.c:280:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 72)) = explainNext                                                       // explain.c:281:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 80)) = explainEof                                                        // explain.c:282:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 88)) = explainColumn                                     // explain.c:283:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&explainModule)) + 96)) = explainRowid                                             // explain.c:284:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 8)) = fsConnect                    // test_fs.c:800:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 16)) = fsConnect                   // test_fs.c:801:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 24)) = fsBestIndex                                                   // test_fs.c:802:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 32)) = fsDisconnect                                                           // test_fs.c:803:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 40)) = fsDisconnect                                                           // test_fs.c:804:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 48)) = fsOpen                                                        // test_fs.c:805:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 56)) = fsClose                                                                // test_fs.c:806:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 64)) = fsFilter                               // test_fs.c:807:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 72)) = fsNext                                                                 // test_fs.c:808:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 80)) = fsEof                                                                  // test_fs.c:809:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 88)) = fsColumn                                               // test_fs.c:810:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsModule)) + 96)) = fsRowid                                                       // test_fs.c:811:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 8)) = fsClose1                                                           // test_onefile.c:210:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 16)) = fsRead                             // test_onefile.c:211:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 24)) = fsWrite                            // test_onefile.c:212:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 32)) = fsTruncate                                         // test_onefile.c:213:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 40)) = fsSync                                                     // test_onefile.c:214:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 48)) = fsFileSize                                               // test_onefile.c:215:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 56)) = fsLock                                                     // test_onefile.c:216:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 64)) = fsUnlock                                                   // test_onefile.c:217:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 72)) = fsCheckReservedLock                                      // test_onefile.c:218:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 80)) = fsFileControl                                     // test_onefile.c:219:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 88)) = fsSectorSize                                                      // test_onefile.c:220:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_io_methods)) + 96)) = fsDeviceCharacteristics                                           // test_onefile.c:221:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 40)) = fsOpen1                                // test_onefile.c:191:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 48)) = fsDelete                                                 // test_onefile.c:192:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 56)) = fsAccess                                        // test_onefile.c:193:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 64)) = fsFullPathname                                  // test_onefile.c:194:5:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 72)) = fsDlOpen                                                      // test_onefile.c:195:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 80)) = fsDlError                                                      // test_onefile.c:196:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 88)) = fsDlSym                                              // test_onefile.c:197:5:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 96)) = fsDlClose                                                             // test_onefile.c:198:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 104)) = fsRandomness                                            // test_onefile.c:199:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 112)) = fsSleep                                                          // test_onefile.c:200:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fs_vfs)) + 120)) = fsCurrentTime                                                  // test_onefile.c:201:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 8)) = fsdirConnect1             // test_fs.c:823:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 16)) = fsdirConnect1            // test_fs.c:824:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 24)) = fsdirBestIndex1                                            // test_fs.c:825:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 32)) = fsdirDisconnect1                                                    // test_fs.c:826:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 40)) = fsdirDisconnect1                                                    // test_fs.c:827:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 48)) = fsdirOpen1                                                 // test_fs.c:828:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 56)) = fsdirClose1                                                         // test_fs.c:829:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 64)) = fsdirFilter1                        // test_fs.c:830:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 72)) = fsdirNext1                                                          // test_fs.c:831:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 80)) = fsdirEof1                                                           // test_fs.c:832:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 88)) = fsdirColumn1                                        // test_fs.c:833:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule)) + 96)) = fsdirRowid1                                                // test_fs.c:834:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 16)) = fsdirConnect            // fileio.c:963:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 24)) = fsdirBestIndex                                            // fileio.c:964:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 32)) = fsdirDisconnect                                                    // fileio.c:965:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 48)) = fsdirOpen                                                 // fileio.c:967:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 56)) = fsdirClose                                                         // fileio.c:968:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 64)) = fsdirFilter                        // fileio.c:969:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 72)) = fsdirNext                                                          // fileio.c:970:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 80)) = fsdirEof                                                           // fileio.c:971:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 88)) = fsdirColumn                                        // fileio.c:972:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fsdirModule1)) + 96)) = fsdirRowid                                                // fileio.c:973:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 8)) = fstreeConnect            // test_fs.c:846:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 16)) = fstreeConnect           // test_fs.c:847:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 24)) = fstreeBestIndex                                           // test_fs.c:848:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 32)) = fstreeDisconnect                                                   // test_fs.c:849:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 40)) = fstreeDisconnect                                                   // test_fs.c:850:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 48)) = fstreeOpen                                                // test_fs.c:851:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 56)) = fstreeClose                                                        // test_fs.c:852:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 64)) = fstreeFilter                       // test_fs.c:853:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 72)) = fstreeNext                                                         // test_fs.c:854:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 80)) = fstreeEof                                                          // test_fs.c:855:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 88)) = fstreeColumn                                       // test_fs.c:856:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fstreeModule)) + 96)) = fstreeRowid                                               // test_fs.c:857:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 8)) = fts5tokConnectMethod   // fts5_test_tok.c:453:6:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 16)) = fts5tokConnectMethod  // fts5_test_tok.c:454:6:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 24)) = fts5tokBestIndexMethod                                  // fts5_test_tok.c:455:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 32)) = fts5tokDisconnectMethod                                          // fts5_test_tok.c:456:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 40)) = fts5tokDisconnectMethod                                          // fts5_test_tok.c:457:6:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 48)) = fts5tokOpenMethod                                       // fts5_test_tok.c:458:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 56)) = fts5tokCloseMethod                                               // fts5_test_tok.c:459:6:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 64)) = fts5tokFilterMethod              // fts5_test_tok.c:460:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 72)) = fts5tokNextMethod                                                // fts5_test_tok.c:461:6:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 80)) = fts5tokEofMethod                                                 // fts5_test_tok.c:462:6:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 88)) = fts5tokColumnMethod                              // fts5_test_tok.c:463:6:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fts5tok_module)) + 96)) = fts5tokRowidMethod                                      // fts5_test_tok.c:464:6:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 8)) = fuzzerConnect            // fuzzer.c:1149:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 16)) = fuzzerConnect           // fuzzer.c:1150:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 24)) = fuzzerBestIndex                                           // fuzzer.c:1151:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 32)) = fuzzerDisconnect                                                   // fuzzer.c:1152:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 40)) = fuzzerDisconnect                                                   // fuzzer.c:1153:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 48)) = fuzzerOpen                                                // fuzzer.c:1154:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 56)) = fuzzerClose                                                        // fuzzer.c:1155:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 64)) = fuzzerFilter                       // fuzzer.c:1156:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 72)) = fuzzerNext                                                         // fuzzer.c:1157:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 80)) = fuzzerEof                                                          // fuzzer.c:1158:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 88)) = fuzzerColumn                                       // fuzzer.c:1159:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&fuzzerModule)) + 96)) = fuzzerRowid                                               // fuzzer.c:1160:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 8)) = intarrayCreate         // test_intarray.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 16)) = intarrayCreate        // test_intarray.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 24)) = intarrayBestIndex                                       // test_intarray.c:191:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 32)) = intarrayDestroy                                                  // test_intarray.c:192:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 40)) = intarrayDestroy                                                  // test_intarray.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 48)) = intarrayOpen                                            // test_intarray.c:194:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 56)) = intarrayClose                                                    // test_intarray.c:195:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 64)) = intarrayFilter                   // test_intarray.c:196:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 72)) = intarrayNext                                                     // test_intarray.c:197:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 80)) = intarrayEof                                                      // test_intarray.c:198:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 88)) = intarrayColumn                                   // test_intarray.c:199:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&intarrayModule)) + 96)) = intarrayRowid                                           // test_intarray.c:200:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 8)) = jtClose                                                            // test_journal.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 16)) = jtRead                             // test_journal.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 24)) = jtWrite                            // test_journal.c:191:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 32)) = jtTruncate                                         // test_journal.c:192:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 40)) = jtSync                                                     // test_journal.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 48)) = jtFileSize                                               // test_journal.c:194:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 56)) = jtLock                                                     // test_journal.c:195:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 64)) = jtUnlock                                                   // test_journal.c:196:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 72)) = jtCheckReservedLock                                      // test_journal.c:197:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 80)) = jtFileControl                                     // test_journal.c:198:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 88)) = jtSectorSize                                                      // test_journal.c:199:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_io_methods)) + 96)) = jtDeviceCharacteristics                                           // test_journal.c:200:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 40)) = jtOpen                                 // test_journal.c:172:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 48)) = jtDelete                                                 // test_journal.c:173:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 56)) = jtAccess                                        // test_journal.c:174:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 64)) = jtFullPathname                                  // test_journal.c:175:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 72)) = jtDlOpen                                                      // test_journal.c:176:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 80)) = jtDlError                                                      // test_journal.c:177:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 88)) = jtDlSym                                              // test_journal.c:178:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 96)) = jtDlClose                                                             // test_journal.c:179:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 104)) = jtRandomness                                            // test_journal.c:180:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 112)) = jtSleep                                                          // test_journal.c:181:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 120)) = jtCurrentTime                                                  // test_journal.c:182:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 128)) = jtGetLastError                                          // test_journal.c:183:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&jt_vfs)) + 136)) = jtCurrentTimeInt64                                             // test_journal.c:184:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 16)) = prefixesConnect       // prefixes.c:230:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 24)) = prefixesBestIndex                                       // prefixes.c:231:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 32)) = prefixesDisconnect                                               // prefixes.c:232:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 48)) = prefixesOpen                                            // prefixes.c:234:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 56)) = prefixesClose                                                    // prefixes.c:235:21:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 64)) = prefixesFilter                   // prefixes.c:236:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 72)) = prefixesNext                                                     // prefixes.c:237:21:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 80)) = prefixesEof                                                      // prefixes.c:238:21:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 88)) = prefixesColumn                                   // prefixes.c:239:21:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&prefixesModule)) + 96)) = prefixesRowid                                           // prefixes.c:240:21:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&pzNeededCollation)) + 0)) = uintptr(unsafe.Pointer(&zNeededCollation))                                            // test1.c:3130:34:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 8)) = schemaCreate             // test_schema.c:276:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 16)) = schemaCreate            // test_schema.c:277:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 24)) = schemaBestIndex                                           // test_schema.c:278:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 32)) = schemaDestroy                                                      // test_schema.c:279:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 40)) = schemaDestroy                                                      // test_schema.c:280:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 48)) = schemaOpen                                                // test_schema.c:281:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 56)) = schemaClose                                                        // test_schema.c:282:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 64)) = schemaFilter                       // test_schema.c:283:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 72)) = schemaNext                                                         // test_schema.c:284:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 80)) = schemaEof                                                          // test_schema.c:285:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 88)) = schemaColumn                                       // test_schema.c:286:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&schemaModule)) + 96)) = schemaRowid                                               // test_schema.c:287:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 16)) = seriesConnect           // series.c:414:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 24)) = seriesBestIndex                                           // series.c:415:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 32)) = seriesDisconnect                                                   // series.c:416:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 48)) = seriesOpen                                                // series.c:418:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 56)) = seriesClose                                                        // series.c:419:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 64)) = seriesFilter                       // series.c:420:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 72)) = seriesNext                                                         // series.c:421:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 80)) = seriesEof                                                          // series.c:422:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 88)) = seriesColumn                                       // series.c:423:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&seriesModule)) + 96)) = seriesRowid                                               // series.c:424:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 8)) = spellfix1Create       // spellfix.c:2993:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 16)) = spellfix1Connect     // spellfix.c:2994:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 24)) = spellfix1BestIndex                                     // spellfix.c:2995:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 32)) = spellfix1Disconnect                                             // spellfix.c:2996:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 40)) = spellfix1Destroy                                                // spellfix.c:2997:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 48)) = spellfix1Open                                          // spellfix.c:2998:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 56)) = spellfix1Close                                                  // spellfix.c:2999:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 64)) = spellfix1Filter                 // spellfix.c:3000:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 72)) = spellfix1Next                                                   // spellfix.c:3001:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 80)) = spellfix1Eof                                                    // spellfix.c:3002:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 88)) = spellfix1Column                                 // spellfix.c:3003:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 96)) = spellfix1Rowid                                         // spellfix.c:3004:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 104)) = spellfix1Update                       // spellfix.c:3005:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&spellfix1Module)) + 152)) = spellfix1Rename                                       // spellfix.c:3011:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 8)) = tclConnect                  // test_bestindex.c:551:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 16)) = tclConnect                 // test_bestindex.c:552:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 24)) = tclBestIndex                                                 // test_bestindex.c:553:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 32)) = tclDisconnect                                                         // test_bestindex.c:554:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 40)) = tclDisconnect                                                         // test_bestindex.c:555:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 48)) = tclOpen                                                      // test_bestindex.c:556:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 56)) = tclClose                                                              // test_bestindex.c:557:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 64)) = tclFilter                             // test_bestindex.c:558:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 72)) = tclNext                                                               // test_bestindex.c:559:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 80)) = tclEof                                                                // test_bestindex.c:560:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 88)) = tclColumn                                             // test_bestindex.c:561:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclModule)) + 96)) = tclRowid                                                     // test_bestindex.c:562:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 8)) = tclvarConnect            // test_tclvar.c:471:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 16)) = tclvarConnect           // test_tclvar.c:472:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 24)) = tclvarBestIndex                                           // test_tclvar.c:473:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 32)) = tclvarDisconnect                                                   // test_tclvar.c:474:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 40)) = tclvarDisconnect                                                   // test_tclvar.c:475:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 48)) = tclvarOpen                                                // test_tclvar.c:476:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 56)) = tclvarClose                                                        // test_tclvar.c:477:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 64)) = tclvarFilter                       // test_tclvar.c:478:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 72)) = tclvarNext                                                         // test_tclvar.c:479:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 80)) = tclvarEof                                                          // test_tclvar.c:480:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 88)) = tclvarColumn                                       // test_tclvar.c:481:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 96)) = tclvarRowid                                               // test_tclvar.c:482:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tclvarModule)) + 104)) = tclvarUpdate                             // test_tclvar.c:483:3:
	*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 8 /* .pArg */)) = uintptr(unsafe.Pointer(&testpcacheGlobal))                                       // test_pcache.c:435:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 16)) = testpcacheInit                                                       // test_pcache.c:436:5:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 24)) = testpcacheShutdown                                                         // test_pcache.c:437:5:
	*(*func(*libc.TLS, int32, int32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 32)) = testpcacheCreate                                       // test_pcache.c:438:5:
	*(*func(*libc.TLS, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 40)) = testpcacheCachesize                                                 // test_pcache.c:439:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 48)) = testpcachePagecount                                                  // test_pcache.c:440:5:
	*(*func(*libc.TLS, uintptr, uint32, int32) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 56)) = testpcacheFetch                                     // test_pcache.c:441:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 64)) = testpcacheUnpin                                            // test_pcache.c:442:5:
	*(*func(*libc.TLS, uintptr, uintptr, uint32, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 72)) = testpcacheRekey                                   // test_pcache.c:443:5:
	*(*func(*libc.TLS, uintptr, uint32))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 80)) = testpcacheTruncate                                                 // test_pcache.c:444:5:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&testPcache)) + 88)) = testpcacheDestroy                                                          // test_pcache.c:445:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 8)) = tmpClose                                                          // test_onefile.c:231:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 16)) = tmpRead                           // test_onefile.c:232:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 24)) = tmpWrite                          // test_onefile.c:233:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 32)) = tmpTruncate                                       // test_onefile.c:234:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 40)) = tmpSync                                                   // test_onefile.c:235:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 48)) = tmpFileSize                                             // test_onefile.c:236:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 56)) = tmpLock                                                   // test_onefile.c:237:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 64)) = tmpUnlock                                                 // test_onefile.c:238:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 72)) = tmpCheckReservedLock                                    // test_onefile.c:239:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 80)) = tmpFileControl                                   // test_onefile.c:240:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 88)) = tmpSectorSize                                                    // test_onefile.c:241:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tmp_io_methods)) + 96)) = tmpDeviceCharacteristics                                         // test_onefile.c:242:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 8)) = tvfsClose                                                        // test_vfs.c:206:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 16)) = tvfsRead                         // test_vfs.c:207:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 24)) = tvfsWrite                        // test_vfs.c:208:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 32)) = tvfsTruncate                                     // test_vfs.c:209:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 40)) = tvfsSync                                                 // test_vfs.c:210:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 48)) = tvfsFileSize                                           // test_vfs.c:211:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 56)) = tvfsLock                                                 // test_vfs.c:212:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 64)) = tvfsUnlock                                               // test_vfs.c:213:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 72)) = tvfsCheckReservedLock                                  // test_vfs.c:214:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 80)) = tvfsFileControl                                 // test_vfs.c:215:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 88)) = tvfsSectorSize                                                  // test_vfs.c:216:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 96)) = tvfsDeviceCharacteristics                                       // test_vfs.c:217:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 104)) = tvfsShmMap                       // test_vfs.c:218:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 112)) = tvfsShmLock                               // test_vfs.c:219:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 120)) = tvfsShmBarrier                                                       // test_vfs.c:220:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 128)) = tvfsShmUnmap                                            // test_vfs.c:221:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 136)) = tvfsFetch                       // test_vfs.c:222:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_io_methods)) + 144)) = tvfsUnfetch                            // test_vfs.c:223:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 40)) = tvfsOpen                             // test_vfs.c:1451:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 48)) = tvfsDelete                                             // test_vfs.c:1452:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 56)) = tvfsAccess                                    // test_vfs.c:1453:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 64)) = tvfsFullPathname                              // test_vfs.c:1454:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 104)) = tvfsRandomness                                        // test_vfs.c:1466:5:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 112)) = tvfsSleep                                                      // test_vfs.c:1467:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&tvfs_vfs)) + 120)) = tvfsCurrentTime                                              // test_vfs.c:1468:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 8)) = unionConnect              // unionvtab.c:1332:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 16)) = unionConnect             // unionvtab.c:1333:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 24)) = unionBestIndex                                             // unionvtab.c:1334:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 32)) = unionDisconnect                                                     // unionvtab.c:1335:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 40)) = unionDisconnect                                                     // unionvtab.c:1336:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 48)) = unionOpen                                                  // unionvtab.c:1337:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 56)) = unionClose                                                          // unionvtab.c:1338:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 64)) = unionFilter                         // unionvtab.c:1339:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 72)) = unionNext                                                           // unionvtab.c:1340:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 80)) = unionEof                                                            // unionvtab.c:1341:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 88)) = unionColumn                                         // unionvtab.c:1342:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&unionModule)) + 96)) = unionRowid                                                 // unionvtab.c:1343:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 8)) = vfslogClose                                                    // test_osinst.c:204:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 16)) = vfslogRead                     // test_osinst.c:205:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 24)) = vfslogWrite                    // test_osinst.c:206:3:
	*(*func(*libc.TLS, uintptr, sqlite3_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 32)) = vfslogTruncate                                 // test_osinst.c:207:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 40)) = vfslogSync                                             // test_osinst.c:208:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 48)) = vfslogFileSize                                       // test_osinst.c:209:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 56)) = vfslogLock                                             // test_osinst.c:210:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 64)) = vfslogUnlock                                           // test_osinst.c:211:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 72)) = vfslogCheckReservedLock                              // test_osinst.c:212:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 80)) = vfslogFileControl                             // test_osinst.c:213:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 88)) = vfslogSectorSize                                              // test_osinst.c:214:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 96)) = vfslogDeviceCharacteristics                                   // test_osinst.c:215:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 104)) = vfslogShmMap                   // test_osinst.c:216:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 112)) = vfslogShmLock                           // test_osinst.c:217:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 120)) = vfslogShmBarrier                                                   // test_osinst.c:218:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_io_methods)) + 128)) = vfslogShmUnmap                                        // test_osinst.c:219:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 8)) = vlogConnect             // test_osinst.c:1074:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 16)) = vlogConnect            // test_osinst.c:1075:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 24)) = vlogBestIndex                                            // test_osinst.c:1076:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 32)) = vlogDisconnect                                                    // test_osinst.c:1077:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 40)) = vlogDisconnect                                                    // test_osinst.c:1078:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 48)) = vlogOpen                                                 // test_osinst.c:1079:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 56)) = vlogClose                                                         // test_osinst.c:1080:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 64)) = vlogFilter                        // test_osinst.c:1081:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 72)) = vlogNext                                                          // test_osinst.c:1082:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 80)) = vlogEof                                                           // test_osinst.c:1083:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 88)) = vlogColumn                                        // test_osinst.c:1084:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_module)) + 96)) = vlogRowid                                                // test_osinst.c:1085:5:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 40)) = vfslogOpen                         // test_osinst.c:187:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 48)) = vfslogDelete                                         // test_osinst.c:188:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 56)) = vfslogAccess                                // test_osinst.c:189:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 64)) = vfslogFullPathname                          // test_osinst.c:190:3:
	*(*func(*libc.TLS, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 72)) = vfslogDlOpen                                              // test_osinst.c:191:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 80)) = vfslogDlError                                              // test_osinst.c:192:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr) uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 88)) = vfslogDlSym                                      // test_osinst.c:193:3:
	*(*func(*libc.TLS, uintptr, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 96)) = vfslogDlClose                                                     // test_osinst.c:194:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 104)) = vfslogRandomness                                    // test_osinst.c:195:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 112)) = vfslogSleep                                                  // test_osinst.c:196:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 120)) = vfslogCurrentTime                                          // test_osinst.c:197:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 128)) = vfslogGetLastError                                  // test_osinst.c:198:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&vfslog_vfs)) + 136)) = vfslogCurrentTimeInt64                                     // test_osinst.c:199:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 8)) = wholenumberConnect  // wholenumber.c:238:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 16)) = wholenumberConnect // wholenumber.c:239:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 24)) = wholenumberBestIndex                                 // wholenumber.c:240:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 32)) = wholenumberDisconnect                                         // wholenumber.c:241:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 40)) = wholenumberDisconnect                                         // wholenumber.c:242:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 48)) = wholenumberOpen                                      // wholenumber.c:243:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 56)) = wholenumberClose                                              // wholenumber.c:244:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 64)) = wholenumberFilter             // wholenumber.c:245:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 72)) = wholenumberNext                                               // wholenumber.c:246:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 80)) = wholenumberEof                                                // wholenumber.c:247:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 88)) = wholenumberColumn                             // wholenumber.c:248:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&wholenumberModule)) + 96)) = wholenumberRowid                                     // wholenumber.c:249:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 8)) = devsymClose                                                // test_devsym.c:393:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 16)) = devsymRead                  // test_devsym.c:394:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 24)) = writecrashWrite             // test_devsym.c:395:3:
	*(*func(*libc.TLS, uintptr, sqlite_int64) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 32)) = devsymTruncate                              // test_devsym.c:396:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 40)) = devsymSync                                         // test_devsym.c:397:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 48)) = devsymFileSize                                   // test_devsym.c:398:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 56)) = devsymLock                                         // test_devsym.c:399:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 64)) = devsymUnlock                                       // test_devsym.c:400:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 72)) = devsymCheckReservedLock                          // test_devsym.c:401:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 80)) = devsymFileControl                         // test_devsym.c:402:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 88)) = writecrashSectorSize                                      // test_devsym.c:403:3:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 96)) = writecrashDeviceCharacteristics                           // test_devsym.c:404:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 104)) = devsymShmMap               // test_devsym.c:405:3:
	*(*func(*libc.TLS, uintptr, int32, int32, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 112)) = devsymShmLock                       // test_devsym.c:406:3:
	*(*func(*libc.TLS, uintptr))(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 120)) = devsymShmBarrier                                               // test_devsym.c:407:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_io_methods)) + 128)) = devsymShmUnmap                                    // test_devsym.c:408:3:
	*(*func(*libc.TLS, uintptr, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 40)) = writecrashOpen                 // test_devsym.c:457:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 48)) = devsymDelete                                     // test_devsym.c:458:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 56)) = devsymAccess                            // test_devsym.c:459:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 64)) = devsymFullPathname                      // test_devsym.c:460:3:
	*(*func(*libc.TLS, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 104)) = devsymRandomness                                // test_devsym.c:472:3:
	*(*func(*libc.TLS, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 112)) = devsymSleep                                              // test_devsym.c:473:3:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&writecrash_vfs)) + 120)) = devsymCurrentTime                                      // test_devsym.c:474:3:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 8)) = zipfileConnect          // zipfile.c:2154:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 16)) = zipfileConnect         // zipfile.c:2155:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 24)) = zipfileBestIndex                                         // zipfile.c:2156:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 32)) = zipfileDisconnect                                                 // zipfile.c:2157:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 40)) = zipfileDisconnect                                                 // zipfile.c:2158:5:
	*(*func(*libc.TLS, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 48)) = zipfileOpen                                              // zipfile.c:2159:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 56)) = zipfileClose                                                      // zipfile.c:2160:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, int32, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 64)) = zipfileFilter                     // zipfile.c:2161:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 72)) = zipfileNext                                                       // zipfile.c:2162:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 80)) = zipfileEof                                                        // zipfile.c:2163:5:
	*(*func(*libc.TLS, uintptr, uintptr, int32) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 88)) = zipfileColumn                                     // zipfile.c:2164:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 104)) = zipfileUpdate                           // zipfile.c:2166:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 112)) = zipfileBegin                                                     // zipfile.c:2167:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 128)) = zipfileCommit                                                    // zipfile.c:2169:5:
	*(*func(*libc.TLS, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 136)) = zipfileRollback                                                  // zipfile.c:2170:5:
	*(*func(*libc.TLS, uintptr, int32, uintptr, uintptr, uintptr) int32)(unsafe.Pointer(uintptr(unsafe.Pointer(&zipfileModule)) + 144)) = zipfileFindFunction            // zipfile.c:2171:5:
}

var ts1 = "%s\x00internal error!\x00SELECT * FROM main.%Q WHERE sample()\x00expert\x00PRAGMA table_xinfo=%Q\x00main\x00binary\x00, \x00%Q\x00 COLLATE %Q\x00 COLLATE %s\x00 DESC\x00PRAGMA index_list=%Q\x00PRAGMA index_xInfo=%Q\x00%s_idx_%08x\x00SELECT count(*) FROM sqlite_schema WHERE name=%Q AND type in ('index','table','view')\x00CREATE INDEX \"%w\" ON \"%w\"(%s)\x00CREATE INDEX %s ON %s(%s)\x00EXPLAIN QUERY PLAN %s\x00 USING INDEX \x00 USING COVERING INDEX \x00%s\n\x00%s;\n\x00SELECT 'CREATE TEMP' || substr(sql, 7) FROM sqlite_schema WHERE tbl_name = %Q AND type IN ('table', 'trigger') ORDER BY type;\x00ALTER TABLE temp.%Q RENAME TO %Q\x00INSERT INTO %Q VALUES(\x00%s?\x00\x00)\x00UPDATE %Q SET \x00%s%Q=?\x00DELETE FROM %Q\x00t592690916721053953805701627921227776\x00DROP TABLE t592690916721053953805701627921227776\x00SELECT type, name, sql, 1 FROM sqlite_schema WHERE type IN ('table','view') AND name NOT LIKE 'sqlite_%%'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_schema WHERE type = 'trigger'  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = 'view') ORDER BY 4, 1\x00CREATE TABLE x(\x00%s%Q COLLATE %s\x00CREATE VIRTUAL TABLE %Q USING expert(%Q)\x00SELECT max(i.seqno) FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = 'table'\x00%sx.%Q IS rem(%d, x.%Q) COLLATE %s\x00%s%d\x00SELECT %s FROM %Q x ORDER BY %s\x00SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\x00%d\x00 %d\x00DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\x00CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\x00SELECT s.rowid, s.name, l.name FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l WHERE s.type = 'table'\x00SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\x00INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\x00ANALYZE; PRAGMA writable_schema=1\x00rem\x00sample\x00ANALYZE sqlite_schema\x00:memory:\x00SELECT sql FROM sqlite_schema WHERE name NOT LIKE 'sqlite_%%' AND sql NOT LIKE 'CREATE VIRTUAL %%'\x00Cannot find a unique index name to propose.\x00%s;%s%s\n\x00 -- stat1: \x00no such handle: \x00sql\x00TABLE\x00analyze\x00count\x00report\x00STMT EREPORT\x00destroy\x00SUBCOMMAND ...\x00sub-command\x00indexes\x00plan\x00candidates\x00DB\x00sqlite3expert%d\x00out of memory\x00sqlite3_expert_new\x00SQLITE_DONE\x00SQLITE_ERROR\x00SQLITE_OK\x00SELECT fts5(?1)\x00error: \x00fts5_api_ptr\x00f5t_2_%lld\x00xColumnCount\x00xRowCount\x00xColumnTotalSize\x00COL\x00xTokenize\x00TEXT SCRIPT\x00xPhraseCount\x00xPhraseSize\x00PHRASE\x00xInstCount\x00xInst\x00IDX\x00xRowid\x00xColumnText\x00xColumnSize\x00xQueryPhrase\x00PHRASE SCRIPT\x00xSetAuxdata\x00VALUE\x00xGetAuxdata\x00CLEAR\x00xSetAuxdataInt\x00INTEGER\x00xGetAuxdataInt\x00xPhraseForeach\x00IPHRASE COLVAR OFFVAR SCRIPT\x00xPhraseColumnForeach\x00IPHRASE COLVAR SCRIPT\x00SUB-COMMAND\x00f5t_%lld\x00bytearray\x00boolean\x00double\x00wideInt\x00int\x00DB NAME SCRIPT\x00?-subst? DB NAME TEXT\x00-subst\x00unrecognized option: \x00no such tokenizer: \x00error in tokenizer.xCreate()\x00error in tokenizer.xTokenize()\x00document\x00aux\x00query\x00prefixquery\x00invalid\x00-colocated\x00sqlite3_fts5_token may only be used by tokenizer callback\x00?-colocated? TEXT START END\x00error in fts5_api.xCreateTokenizer()\x00NSLOT TOKEN\x00sqlite3_fts5_create_tokenizer\x00sqlite3_fts5_token\x00sqlite3_fts5_tokenize\x00sqlite3_fts5_create_function\x00sqlite3_fts5_may_be_corrupt\x00sqlite3_fts5_token_hash\x00sqlite3_fts5_register_matchinfo\x00sqlite3_fts5_register_fts5tokenize\x00unrecognized matchinfo flag: %c\x00pcx\x00matchinfo\x00CREATE TABLE x(input HIDDEN, token, start, end, position)\x00fts5tokenize\x00apndvfs\x00Start-Of-SQLite3-\x00apnd(%lld)/%z\x00SQLite format 3\x00%s: cost must be between 1 and %d\x00%s: maximum string length is %d\x00%s: iLang must be between 0 and %d\x00?\x00SELECT * FROM %Q.%Q\x00%s: %s\x00%s: %s has %d columns, expected 4\x00vocabulary_table\x00vocabulary_word\x00vocabulary_language\x00edit_distances\x00unrecognized argument: [%s]\n\x00no edit_distances table specified\x00CREATE TABLE x(word,distance,language,command HIDDEN,nword HIDDEN)\x000123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ^abcdefghijklmnopqrstuvwxyz~\x00SELECT \"%w\" FROM \"%w\"\x00 WHERE \"%w\">=?1 AND \"%w\"=?2 ORDER BY 1\x00SELECT \"%w\" FROM \"%w\" WHERE \"%w\">=?1 ORDER BY 1\x00*\x00DELETE from %s is not allowed\x00UPDATE of %s is not allowed\x00INSERT INTO %s allowed for column [command] only\x00approximate_match\x00int32\x00int64\x00char*\x00CREATE TABLE x(value,pointer hidden,count hidden,ctype hidden)\x00carray-bind\x00carray\x00unknown datatype: %Q\x00inttoptr\x00cksmvfs\x00ZV-\x00checksum fault offset %lld of \"%s\"\x00checksum_verification\x00enable%\x00yes\x00on\x00page_size\x00cksm/%z\x00verify_checksum\x00tablename\x00idcolumn\x00parentcolumn\x00CREATE TABLE x(id,depth,root HIDDEN,tablename HIDDEN,idcolumn HIDDEN,parentcolumn HIDDEN)\x00SELECT \"%w\".\"%w\" FROM \"%w\" WHERE \"%w\".\"%w\"=?1\x00transitive_closure\x00rb\x00cannot open '%s' for reading\x00line %d: unescaped %c character\x00line %d: unterminated %c-quoted field\n\x00more than one '%s' parameter\x00true\x00no\x00off\x00false\x00header\x00more than one 'header' parameter\x00testflags\x00columns\x00more than one 'columns' parameter\x00column= value must be positive\x00bad parameter: '%s'\x00must specify either filename= or data= but not both\x00%sc%d TEXT\x00,\x00%s\"%w\" TEXT\x00bad schema: '%s' - %s\x00filename\x00data\x00schema\x00csv\x00csv_wr\x00decimal_sum\x00decimal\x00decimal_cmp\x00decimal_add\x00decimal_sub\x00decimal_mul\x00 \x00eval\x00CREATE TABLE x(addr,opcode,p1,p2,p3,p4,p5,comment,sql HIDDEN)\x00EXPLAIN %s\x00explain\x00wb\x00wrong number of arguments to function writefile()\x00failed to create symlink: %s\x00failed to create directory: %s\x00failed to write file: %s\x00CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\x00cannot read directory: %s\x00%s/%s\x00cannot stat file: %s\x00table function fsdir requires an argument\x00table function fsdir requires a non-NULL argument\x00fsdir\x00readfile\x00writefile\x00lsmode\x00%s: ruleset must be between 0 and %d\x00%s: wrong number of CREATE VIRTUAL TABLE arguments\x00CREATE TABLE x(word,distance,ruleset)\x00fuzzer\x00ieee754(%lld,%d)\x00ieee754\x00ieee754_mantissa\x00ieee754_exponent\x00ieee754_to_blob\x00ieee754_from_blob\x00BEGIN; SELECT * FROM %s%q%ssqlite_schema\x00'\x00'.\x00PRAGMA %s%q%spage_size\x00sqlite3_mmap_warm_cache: Warmed up %d pages of %s\x00END\x00AND (%s)\x00collate \"%w\"\x00SELECT %s FROM %s WHERE %s>=(?1 || ?2) %s   AND %s<=(?1 || char(1114111)) %s   %s ORDER BY 1 %s ASC LIMIT 1\x00next_char\x00NULL\x00is\x00not\x00in(\x00in(select\x00in(with\x00?,?,?\x002nd argument to percentile() is not a number between 0.0 and 100.0\x002nd argument to percentile() is not the same for all input rows\x001st argument to percentile() is not numeric\x00Inf input to percentile()\x00percentile\x00CREATE TABLE prefixes(prefix TEXT, original_string TEXT HIDDEN)\x00prefixes\x00prefix_length\x00unknown \\ escape\x00afnrtv\\()*.+?[$^{|}]\x00\a\f\n\r\t\v\x00unmatched '('\x00'*' without operand\x00'+' without operand\x00'?' without operand\x00'{m,n}' without operand\x00unmatched '{'\x00n less than m in '{m,n}'\x00both m and n are zero in '{m,n}'\x00POSIX character classes not supported\x00unclosed '['\x00unrecognized character\x00regexp\x00regexpi\x00remember\x00CREATE TABLE x(value,start hidden,stop hidden,step hidden)\x00first argument to \"generate_series()\" missing or unusable\x00generate_series() requires SQLite 3.8.12 or later\x00generate_series\x00.ABCDHLRMY9 ?\x00non-ASCII input to editdist()\x00NULL input to editdist()\x00SELECT iLang, cFrom, cTo, iCost FROM \"%w\" WHERE iLang>=0 ORDER BY iLang\x00editdist3\x00DROP TABLE IF EXISTS \"%w\".\"%w_vocab\"\x00CREATE TABLE x(word,rank,distance,langid, score, matchlen, phonehash HIDDEN, top HIDDEN, scope HIDDEN, srchcnt HIDDEN, soundslike HIDDEN, command HIDDEN)\x00CREATE TABLE IF NOT EXISTS \"%w\".\"%w_vocab\"(\n  id INTEGER PRIMARY KEY,\n  rank INT,\n  langid INT,\n  word TEXT,\n  k1 TEXT,\n  k2 TEXT\n);\n\x00CREATE INDEX IF NOT EXISTS \"%w\".\"%w_vocab_index_langid_k2\" ON \"%w_vocab\"(langid,k2);\x00edit_cost_table=\x00bad argument to spellfix1(): \"%s\"\x00SELECT id, word, rank, coalesce(k1,word)  FROM \"%w\".\"%w_vocab\" WHERE langid=%d AND k2>=?1 AND k2<?2\x00SELECT word, rank, NULL, langid, id FROM \"%w\".\"%w_vocab\"%s\x00 WHERE rowid=?\x00ROLLBACK\x00IGNORE\x00ABORT\x00REPLACE\x00DELETE FROM \"%w\".\"%w_vocab\"  WHERE id=%lld\x00NOT NULL constraint failed: %s.word\x00reset\x00null\x00unknown value for %s.command: \"%w\"\x00INSERT INTO \"%w\".\"%w_vocab\"(rank,langid,word,k1,k2) VALUES(%d,%d,%Q,nullif(%Q,%Q),%Q)\x00INSERT OR %s INTO \"%w\".\"%w_vocab\"(id,rank,langid,word,k1,k2) VALUES(%lld,%d,%d,%Q,nullif(%Q,%Q),%Q)\x00UPDATE OR %s \"%w\".\"%w_vocab\" SET id=%lld, rank=%d, langid=%d, word=%Q, k1=nullif(%Q,%Q), k2=%Q WHERE id=%lld\x00ALTER TABLE \"%w\".\"%w_vocab\" RENAME TO \"%w_vocab\"\x00spellfix1_translit\x00spellfix1_editdist\x00spellfix1_phonehash\x00spellfix1_scriptcode\x00spellfix1\x00922337203685477580\x00tointeger\x00toreal\x00sql error: %s\x00_rowid_\x00integer\x00no such rowid table: %s%s%s\x00.\x00SELECT group_concat(quote(name) || '.' || quote(type)) FROM pragma_table_info(?, ?)\x00source table schema mismatch\x00swarmvtab: no such SQL parameter: %s\x00maxopen\x00swarmvtab: illegal maxopen value\x00missing\x00swarmvtab: duplicate \"missing\" option\x00SELECT \"%w\"(?%s)\x00,?\x00openclose\x00swarmvtab: duplicate \"openclose\" option\x00SELECT \"%w\"(?,?%s)\x00swarmvtab: unrecognized option: %s\x00SELECT \"%w\"(?)\x00swarmvtab: parse error: %s\x00swarmvtab\x00unionvtab\x00temp\x00%s tables must be created in TEMP schema\x00wrong number of arguments for %s\x00SELECT * FROM (%z) ORDER BY 3\x00rowid range mismatch error\x00no source tables configured\x00SELECT 'CREATE TABLE xyz('    || group_concat(quote(name) || ' ' || type, ', ')    || ')',max((cid+1) * (type='INTEGER' COLLATE nocase AND pk=1))-1 FROM pragma_table_info(%Q, ?)\x00SELECT rowid, * FROM %Q %s %lld\x00WHERE _rowid_ <=\x00-- \x00%z%sSELECT rowid, * FROM %s%q%s%Q\x00 UNION ALL \x00%z WHERE rowid=%lld\x00WHERE\x00%z WHERE rowid>=%lld\x00AND\x00%z %s rowid<=%lld\x00CREATE TABLE x(value)\x00wholenumber\x00CREATE TABLE y(name PRIMARY KEY,mode,mtime,sz,rawdata,data,method,z HIDDEN) WITHOUT ROWID;\x00zipfile\x00zipfile constructor requires one argument\x00error in fread()\x00error in fwrite()\x00failed to read CDS at offset %lld\x00%.*s\x00failed to read LFH at offset %d\x001.2.11\x00inflateInit2() failed (%d)\x00inflate() failed (%d)\x00zipfile: deflate() error\x00cannot find end of central directory record\x00zipfile() function requires an argument\x00cannot open file: %s\x00-rwxrwxrwx\x00zipfile: mode does not match data\x00zipfile: parse error in mode: %s\x00zipfile: missing filename\x00ab+\x00zipfile: failed to open file %s for writing\x00sz must be NULL\x00rawdata must be NULL\x00unknown compression method: %d\x00%s/\x00duplicate name: \"%s\"\x00{\"version-made-by\" : %u, \"version-to-extract\" : %u, \"flags\" : %u, \"compression\" : %u, \"time\" : %u, \"date\" : %u, \"crc32\" : %u, \"compressed-size\" : %u, \"uncompressed-size\" : %u, \"file-name-length\" : %u, \"extra-field-length\" : %u, \"file-comment-length\" : %u, \"disk-number-start\" : %u, \"internal-attr\" : %u, \"external-attr\" : %u, \"offset\" : %u }\x00zipfile_cds\x00wrong number of arguments to function zipfile()\x00first argument to zipfile() must be non-NULL\x00illegal method value: %d\x00non-directory name must not end with /\x00rbu_delta\x00step\x00close\x00create_rbu_delta\x00savestate\x00dbMain_eval\x00SQL\x00bp_progress\x00db\x00RBU\x00state\x00progress\x00close_no_error\x00temp_size_limit\x00LIMIT\x00temp_size\x00dbRbu_eval\x00METHOD\x00method\x00 - \x00oal\x00move\x00checkpoint\x00done\x00error\x00NAME TARGET-DB RBU-DB ?STATE-DB?\x00NAME TARGET-DB ?STATE-DB?\x00?-default? NAME PARENT\x00NAME\x00sqlite3rbu_db(0, 0)!=0\x00sqlite3rbu\x00sqlite3rbu_vacuum\x00sqlite3rbu_create_vfs\x00sqlite3rbu_destroy_vfs\x00sqlite3rbu_internal_test\x00%p\x00zero\x00user\x00user_is_zero\x00box\x00DB SCRIPT\x00partly\x00fully\x00aParam\x00aCoord\x00anQueue\x00iLevel\x00mxLevel\x00iRowid\x00rParentScore\x00eParentWithin\x00value\x00qbox\x00register_box_geom\x00register_box_query\x00DB SQL\x00error in sql_exec_changeset()\x00sqlite3session_streams\x00attach\x00changeset\x00delete\x00enable\x00BOOL\x00indirect\x00isempty\x00table_filter\x00SCRIPT\x00patchset\x00diff\x00FROMDB TBL\x00memory_used\x00changeset_size\x00object_config_size\x00CMD DB-HANDLE DB-NAME\x00n\x00i\x00f\x00t\x00b\x00FOREIGN_KEY\x00INSERT\x00UPDATE\x00DELETE\x00DATA\x00NOTFOUND\x00CONFLICT\x00CONSTRAINT\x00OMIT\x00-nosavepoint\x00-invert\x00?-nosavepoint? ?-inverse? DB CHANGESET CONFLICT-SCRIPT ?FILTER-SCRIPT?\x00DB CHANGESET CONFLICT-SCRIPT ?FILTER-SCRIPT?\x00DB CHANGESET\x00CHANGESET\x00LEFT RIGHT\x00-next\x00?-next? ?-invert? VARNAME CHANGESET SCRIPT\x00configure\x00REBASE-BLOB\x00rebase\x00OP VALUE\x00strm_size\x00sqlite3session\x00sqlite3session_foreach\x00sqlite3changeset_invert\x00sqlite3changeset_concat\x00sqlite3changeset_apply\x00sqlite3changeset_apply_v2\x00sqlite3changeset_apply_replace_all\x00sql_exec_changeset\x00sqlite3rebaser_create\x00sqlite3session_config\x00incrblob\x00incrblob_%d\x00%lld\x00sqlite_unlock_notify_arg\x00sqlite_unlock_notify_argcount\x00SQLITE_COPY\x00SQLITE_CREATE_INDEX\x00SQLITE_CREATE_TABLE\x00SQLITE_CREATE_TEMP_INDEX\x00SQLITE_CREATE_TEMP_TABLE\x00SQLITE_CREATE_TEMP_TRIGGER\x00SQLITE_CREATE_TEMP_VIEW\x00SQLITE_CREATE_TRIGGER\x00SQLITE_CREATE_VIEW\x00SQLITE_DELETE\x00SQLITE_DROP_INDEX\x00SQLITE_DROP_TABLE\x00SQLITE_DROP_TEMP_INDEX\x00SQLITE_DROP_TEMP_TABLE\x00SQLITE_DROP_TEMP_TRIGGER\x00SQLITE_DROP_TEMP_VIEW\x00SQLITE_DROP_TRIGGER\x00SQLITE_DROP_VIEW\x00SQLITE_INSERT\x00SQLITE_PRAGMA\x00SQLITE_READ\x00SQLITE_SELECT\x00SQLITE_TRANSACTION\x00SQLITE_UPDATE\x00SQLITE_ATTACH\x00SQLITE_DETACH\x00SQLITE_ALTER_TABLE\x00SQLITE_REINDEX\x00SQLITE_ANALYZE\x00SQLITE_CREATE_VTABLE\x00SQLITE_DROP_VTABLE\x00SQLITE_FUNCTION\x00SQLITE_SAVEPOINT\x00SQLITE_RECURSIVE\x00????\x00SQLITE_DENY\x00SQLITE_IGNORE\x00RELEASE _tcl_transaction\x00COMMIT\x00ROLLBACK TO _tcl_transaction ; RELEASE _tcl_transaction\x00option\x00?CALLBACK?\x00?DATABASE? FILENAME\x00cannot open target database: \x00backup failed: \x00CALLBACK\x00cache option ?arg?\x00flush\x00size\x00size n\x00cannot convert \"\x00\" to integer\x00bad option \"\x00\": must be flush or size\x00NAME SCRIPT\x00?OPTION? ?BOOLEAN?\x00unknown config option: \"\x00\"\x00CONFLICT-ALGORITHM TABLE FILENAME ?SEPARATOR? ?NULLINDICATOR?\x00\t\x00Error: non-null separator required for copy\x00rollback\x00abort\x00fail\x00ignore\x00replace\x00Error: \"\x00\", conflict-algorithm must be one of: rollback, abort, fail, ignore, or replace\x00SELECT * FROM '%q'\x00Error: no such table: \x00Error: \x00Error: can't malloc()\x00INSERT OR %q INTO '%q' VALUES(?\x00Error: cannot open file: \x00BEGIN\x00Error: %s line %d: expected %d columns of data but found %d\x00, failed while processing line: \x00?DATABASE? VALUE\x00-maxsize\x00-readonly\x00unknown option: \x00unable to set MEMDB content\x00extension loading is turned off at compile-time\x00-withoutnulls\x00unknown option: \"\x00?OPTIONS? SQL ?ARRAY-NAME? ?SCRIPT?\x00NAME ?SWITCHES? SCRIPT\x00-argcount\x00option requires an argument: \x00number of arguments must be non-negative\x00-deterministic\x00-directonly\x00-innocuous\x00-returntype\x00real\x00text\x00blob\x00any\x00type\x00\": must be -argcount, -deterministic, -directonly, -innocuous, or -returntype\x00?-readonly? ?DB? TABLE COLUMN ROWID\x00NULLVALUE\x00N CALLBACK\x00KEY\x00cannot open source database: \x00restore failed: \x00restore failed: source database busy\x00?DATABASE?\x00(step|sort|autoindex)\x00sort\x00autoindex\x00vmstep\x00bad argument: should be autoindex, step, sort or vmstep\x00MILLISECONDS\x00?CALLBACK? ?MASK?\x00trace type\x00SAVEPOINT _tcl_transaction\x00[TYPE] SCRIPT\x00transaction type\x00BEGIN EXCLUSIVE\x00BEGIN IMMEDIATE\x00?SCRIPT?\x00SUB-COMMAND ?ARGS?\x00hook ?SCRIPT?\x00INDEX\x00-use-legacy-prepare\x00-last-stmt-ptr\x00unknown argument: \x00authorizer\x00backup\x00bind_fallback\x00busy\x00cache\x00changes\x00collate\x00collation_needed\x00commit_hook\x00complete\x00config\x00copy\x00deserialize\x00enable_load_extension\x00errorcode\x00exists\x00function\x00interrupt\x00last_insert_rowid\x00nullvalue\x00onecolumn\x00preupdate\x00profile\x00rekey\x00restore\x00rollback_hook\x00serialize\x00status\x00timeout\x00total_changes\x00trace\x00trace_v2\x00transaction\x00unlock_notify\x00update_hook\x00version\x00wal_hook\x00defensive\x00dqs_ddl\x00dqs_dml\x00enable_fkey\x00enable_qpsg\x00enable_trigger\x00enable_view\x00fts3_tokenizer\x00legacy_alter_table\x00legacy_file_format\x00load_extension\x00no_ckpt_on_close\x00reset_database\x00trigger_eqp\x00trusted_schema\x00writable_schema\x00statement\x00row\x00deferred\x00exclusive\x00immediate\x00depth\x00hook\x00new\x00old\x00HANDLE ?FILENAME? ?-vfs VFSNAME? ?-readonly BOOLEAN? ?-create BOOLEAN? ?-nofollow BOOLEAN? ?-nomutex BOOLEAN? ?-fullmutex BOOLEAN? ?-uri BOOLEAN?\x00-version\x00-sourceid\x00-has-codec\x000\x00-key\x00-vfs\x00-create\x00-nofollow\x00-nomutex\x00-fullmutex\x00-uri\x00-translatefilename\x00sqlite3\x00sqlite\x003.37.0\x00if {[llength $argv]>=1} {\nset argv0 [lindex $argv 0]\nset argv [lrange $argv 1 end]\nsource $argv0\n} else {\nset line {}\nwhile {![eof stdin]} {\nif {$line!=\"\"} {\nputs -nonewline \"> \"\n} else {\nputs -nonewline \"% \"\n}\nflush stdout\nappend line [gets stdin]\nif {[info complete $line]} {\nif {[catch {uplevel #0 $line} result]} {\nputs stderr \"Error: $result\"\n} elseif {$result!=\"\"} {\nputs $result\n}\nset line {}\n} else {\nappend line \\n\n}\n}\n}\n\x00SQLITE_DEBUG_BREAK\x00attach debugger to process %d and press any key to continue.\n\x00utf-8\x00argc\x00argv0\x00argv\x00errorInfo\x00%s: %s\n\x00SQLITE-CONNECTION\x00command not found: \x00error code %s (%d) does not match sqlite3_errcode %s (%d)\x00OMIT_MISUSE\x00wrong # args: should be \"\x00 DB FORMAT STRING\x00 DB HEX\x00 DB\x00 DB SQL\x00%z%s%s\x00%s%n\x00abcdefghijklmnopqrstuvwxyz\x00 DB FORMAT STRING ?COUNT?\x00 DB\"\x00 FILENAME\"\x00%02x\x00%04x\x00tkt2213 is not fixed\x00text16\x00bytes\x00bytes16\x00noop\x00x_coalesce\x00hex8\x00hex16\x00tkt2213func\x00pointer_change\x00counter1\x00counter2\x00intreal\x00x_sqlite_exec\x00value of 40 handed to x_count\x00x_count totals to 42\x00x_count\x00legacy_count\x00 TEXT\"\x00 FORMAT INT INT INT\"\x00argument is not a valid 64-bit integer\x00 FORMAT INT INT ?STRING?\"\x00 INT FORMAT INT INT ?STRING?\"\x00N must be non-negative\x00 FORMAT INT INT DOUBLE\"\x00 FORMAT DOUBLE DOUBLE\"\x00 FORMAT STRING\"\x00%08x%08x\x002nd argument should be 16-characters of hex\x00?BOOLEAN?\x00DB BOOLEAN\x00DB dbname tblname colname\x00CHANNEL ROWID\x00DB-HANDLE NAME CMP-PROC DEL-PROC\x00sqlite3_create_collate_v2() failed to detect an invalid encoding\x00utf8\x00utf16\x00utf16le\x00utf16be\x00DB NAME NARG ENC SWITCHES...\x00encoding\x00-func\x00-step\x00-final\x00-destroy\x00switch\x00DB-HANDLE FILE ?PROC?\x00this build omits sqlite3_load_extension()\x00DB-HANDLE ONOFF\x00string\x00first argument should be one of: int int64 string double null value\x00 DB FUNCTION-NAME\x00 <STMT>\x00STMT PARAMETER RESETFLAG\x00SQLITE_STMTSTATUS_FULLSCAN_STEP\x00SQLITE_STMTSTATUS_SORT\x00SQLITE_STMTSTATUS_AUTOINDEX\x00SQLITE_STMTSTATUS_VM_STEP\x00SQLITE_STMTSTATUS_REPREPARE\x00SQLITE_STMTSTATUS_RUN\x00SQLITE_STMTSTATUS_MEMUSED\x00NBYTE\x00DB DBNAME\x00DB DBNAME SNAPSHOT\x00SNAPSHOT\x00SNAPSHOT1 SNAPSHOT2\x00bad SNAPSHOT\x00FILE\x00PATH\x00 DB STMT\x00 STMT\x00 FROM-STMT TO-STMT\x00 VM IDX VALUE (null|static|normal)\"\x00static\x00static-nbytes\x00normal\x00blob10\x00abc\x00xyz\x00pq\x004th argument should be \"null\" or \"static\" or \"normal\"\x00(%d) \x00test_collate\x00UTF-8\x00UTF-16LE\x00UTF-16BE\x00 <DB> <utf8> <utf16le> <utf16be>\x00utf16bin\x00utf16_unaligned\x00utf16_aligned\x00test_function\x00<error code>\x00STMT IDX N\x00 STMT N VALUE\x00NaN\x00SNaN\x00-NaN\x00-SNaN\x00+Inf\x00-Inf\x00Epsilon\x00-Epsilon\x00NaN0\x00-NaN0\x00 STMT N\x00 STMT N VALUE BYTES\x00 STMT N DATA BYTES\x00cannot use %d blob bytes, have %d\x00-transient\x00-static\x00-int32\x00-int64\x00-double\x00-text\x00--\x00text data must be either -static or -transient\x00cannot be both -static and -transient\x00[OPTIONS] STMT IDX VALUE ...\x00STMT\x00STMT N\x00STMT NAME\x00 DB sql bytes ?tailvar?\x00 DB sql bytes tailvar\x00 DB sql bytes flags tailvar\x00\x00SELECT 1\x00 filename options-list\x00FILENAME FLAGS VFS\x00SQLITE_OPEN_READONLY\x00SQLITE_OPEN_READWRITE\x00SQLITE_OPEN_CREATE\x00SQLITE_OPEN_DELETEONCLOSE\x00SQLITE_OPEN_EXCLUSIVE\x00SQLITE_OPEN_AUTOPROXY\x00SQLITE_OPEN_MAIN_DB\x00SQLITE_OPEN_TEMP_DB\x00SQLITE_OPEN_TRANSIENT_DB\x00SQLITE_OPEN_MAIN_JOURNAL\x00SQLITE_OPEN_TEMP_JOURNAL\x00SQLITE_OPEN_SUBJOURNAL\x00SQLITE_OPEN_SUPER_JOURNAL\x00SQLITE_OPEN_NOMUTEX\x00SQLITE_OPEN_FULLMUTEX\x00SQLITE_OPEN_SHAREDCACHE\x00SQLITE_OPEN_PRIVATECACHE\x00SQLITE_OPEN_WAL\x00SQLITE_OPEN_URI\x00SQLITE_OPEN_EXRESCODE\x00flag\x00<utf-16 sql>\x00 STMT column\x00FLOAT\x00TEXT\x00BLOB\x00 DB function-name\x00VARIABLE\x00?N?\x001234567890000000\x00__one\x00__two\x00notadatabase\x00Unexpected non-zero errno: \x00DB [DBNAME]\x00%u\x00DB DBNAME SIZE\x00 DB PWD\x00 DB FLAG\x00%d %d\x00 DB ?AUXDB?\x00DB N\x00 DB ID VALUE\x00unknown limit type: \x00SQLITE_LIMIT_LENGTH\x00SQLITE_LIMIT_SQL_LENGTH\x00SQLITE_LIMIT_COLUMN\x00SQLITE_LIMIT_EXPR_DEPTH\x00SQLITE_LIMIT_COMPOUND_SELECT\x00SQLITE_LIMIT_VDBE_OP\x00SQLITE_LIMIT_FUNCTION_ARG\x00SQLITE_LIMIT_ATTACHED\x00SQLITE_LIMIT_LIKE_PATTERN_LENGTH\x00SQLITE_LIMIT_VARIABLE_NUMBER\x00SQLITE_LIMIT_TRIGGER_DEPTH\x00SQLITE_LIMIT_WORKER_THREADS\x00SQLITE_LIMIT_TOOSMALL\x00SQLITE_LIMIT_TOOBIG\x00SEED ?DB?\x00BOOLEAN\x00current\x00max\x00min\x00recyclable\x00DB ?NAME?\x00passive\x00full\x00restart\x00truncate\x00DB MODE ?NAME?\x00mode\x00DB VALUE\x00COMMAND ...\x00command has no objProc: \x00%d %d %d %s\n\x00SQLITE_TESTCTRL_LOCALTIME_FAULT\x00SQLITE_TESTCTRL_SORTER_MMAP\x00SQLITE_TESTCTRL_IMPOSTER\x00SQLITE_TESTCTRL_INTERNAL_FUNCTIONS\x00VERB ARGS...\x00VERB\x00ONOFF\x00DB LIMIT\x00DB dbName onOff tnum\x00ru_utime=%d.%06d ru_stime=%d.%06d ru_minflt=%d ru_majflt=%d\x00DB OPT BOOLEAN\x00unknown optimization - should be one of:\x00all\x00none\x00query-flattener\x00groupby-order\x00factor-constants\x00distinct-opt\x00cover-idx-scan\x00order-by-idx-join\x00transitive\x00omit-noop-join\x00stat4\x00skip-scan\x00push-down\x00DB NAME ...\x00no such extension: \x00initialization of \x00 failed: \x00amatch\x00appendvfs\x00closure\x00fileio\x00nextchar\x00series\x00spellfix\x00totype\x00DB SQL1 NSTEP SQL2\x00data error: (a!=b)\x00checksum mismatch\x00sql error: \x00TYPE\x00Deliberate panic\x00DB SETTING [VALUE]\x00SQLITE_*\x00DBCONFIG_*\x00ENABLE_*\x00unknown sqlite3_db_config setting\x00FKEY\x00TRIGGER\x00FTS3_TOKENIZER\x00LOAD_EXTENSION\x00NO_CKPT_ON_CLOSE\x00QPSG\x00TRIGGER_EQP\x00RESET_DB\x00DEFENSIVE\x00WRITABLE_SCHEMA\x00LEGACY_ALTER_TABLE\x00DQS_DML\x00DQS_DDL\x00LEGACY_FILE_FORMAT\x00DB ?SCHEMA?\x00icecube\x00DB ?DBNAME?\x00DB OFFSET DATA\x00HEXDB\x00| size %d pagesize %d\x00bad 'pagesize' field\x00bad 'size' field\x00| page %d offset %d\x00| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\x00DB ?SCRIPT?\x00sqlite3_autovacuum_pages() returns %d\x00sqlite_search_count\x00sqlite_found_count\x00sqlite_sort_count\x00sqlite3_max_blobsize\x00sqlite_like_count\x00sqlite_interrupt_count\x00sqlite_open_file_count\x00sqlite_current_time\x00sqlite3_xferopt_count\x00sqlite3_pager_readdb_count\x00sqlite3_pager_writedb_count\x00sqlite3_pager_writej_count\x00unaligned_string_counter\x00sqlite_last_needed_collation\x00sqlite_query_plan\x00sqlite_opentemp_count\x00sqlite_static_bind_value\x00sqlite_static_bind_nbyte\x00sqlite_temp_directory\x00sqlite_data_directory\x00bitmask_size\x00longdouble_size\x00sqlite_sync_count\x00sqlite_fullsync_count\x00db_enter\x00db_leave\x00sqlite3_mprintf_int\x00sqlite3_mprintf_int64\x00sqlite3_mprintf_long\x00sqlite3_mprintf_str\x00sqlite3_snprintf_str\x00sqlite3_mprintf_stronly\x00sqlite3_mprintf_double\x00sqlite3_mprintf_scaled\x00sqlite3_mprintf_hexdouble\x00sqlite3_mprintf_z_test\x00sqlite3_mprintf_n_test\x00sqlite3_snprintf_int\x00sqlite3_last_insert_rowid\x00sqlite3_exec_printf\x00sqlite3_exec_hex\x00sqlite3_exec\x00sqlite3_exec_nr\x00sqlite3_get_table_printf\x00sqlite3_close\x00sqlite3_close_v2\x00sqlite3_create_function\x00sqlite3_create_aggregate\x00sqlite3_drop_modules\x00sqlite_register_test_function\x00sqlite_abort\x00sqlite_bind\x00breakpoint\x00sqlite3_key\x00sqlite3_rekey\x00sqlite3_interrupt\x00sqlite_delete_function\x00sqlite_delete_collation\x00sqlite3_get_autocommit\x00sqlite3_busy_timeout\x00printf\x00sqlite3IoTrace\x00clang_sanitize_address\x00sqlite3_db_config\x00sqlite3_txn_state\x00bad_behavior\x00register_dbstat_vtab\x00sqlite3_connection_pointer\x00intarray_addr\x00int64array_addr\x00doublearray_addr\x00textarray_addr\x00sqlite3_bind_int\x00sqlite3_bind_zeroblob\x00sqlite3_bind_zeroblob64\x00sqlite3_bind_int64\x00sqlite3_bind_double\x00sqlite3_bind_null\x00sqlite3_bind_text\x00sqlite3_bind_text16\x00sqlite3_bind_blob\x00sqlite3_carray_bind\x00sqlite3_bind_parameter_count\x00sqlite3_bind_parameter_name\x00sqlite3_bind_parameter_index\x00sqlite3_clear_bindings\x00sqlite3_sleep\x00sqlite3_errcode\x00sqlite3_extended_errcode\x00sqlite3_errmsg\x00sqlite3_errmsg16\x00sqlite3_open\x00sqlite3_open16\x00sqlite3_open_v2\x00sqlite3_complete16\x00sqlite3_normalize\x00sqlite3_prepare\x00sqlite3_prepare16\x00sqlite3_prepare_v2\x00sqlite3_prepare_v3\x00sqlite3_prepare_tkt3134\x00sqlite3_prepare16_v2\x00sqlite3_finalize\x00sqlite3_stmt_status\x00sqlite3_reset\x00sqlite3_expired\x00sqlite3_transfer_bindings\x00sqlite3_changes\x00sqlite3_step\x00sqlite3_sql\x00sqlite3_expanded_sql\x00sqlite3_next_stmt\x00sqlite3_stmt_readonly\x00sqlite3_stmt_isexplain\x00sqlite3_stmt_busy\x00uses_stmt_journal\x00sqlite3_release_memory\x00sqlite3_db_release_memory\x00sqlite3_db_cacheflush\x00sqlite3_system_errno\x00sqlite3_db_filename\x00sqlite3_db_readonly\x00sqlite3_soft_heap_limit\x00sqlite3_soft_heap_limit64\x00sqlite3_hard_heap_limit64\x00sqlite3_thread_cleanup\x00sqlite3_pager_refcounts\x00sqlite3_load_extension\x00sqlite3_enable_load_extension\x00sqlite3_extended_result_codes\x00sqlite3_limit\x00dbconfig_maindbname_icecube\x00save_prng_state\x00restore_prng_state\x00reset_prng_state\x00prng_seed\x00extra_schema_checks\x00database_never_corrupt\x00database_may_be_corrupt\x00optimization_control\x00tcl_objproc\x00sqlite3_column_count\x00sqlite3_data_count\x00sqlite3_column_type\x00sqlite3_column_blob\x00sqlite3_column_double\x00sqlite3_column_int64\x00sqlite3_column_text\x00sqlite3_column_name\x00sqlite3_column_int\x00sqlite3_column_bytes\x00sqlite3_column_decltype\x00sqlite3_column_database_name\x00sqlite3_column_table_name\x00sqlite3_column_origin_name\x00sqlite3_column_bytes16\x00sqlite3_column_text16\x00sqlite3_column_name16\x00add_alignment_test_collations\x00sqlite3_column_decltype16\x00sqlite3_column_database_name16\x00sqlite3_column_table_name16\x00sqlite3_column_origin_name16\x00sqlite3_create_collation_v2\x00sqlite3_global_recover\x00working_64bit_int\x00vfs_unlink_test\x00vfs_initfail_test\x00vfs_unregister_all\x00vfs_reregister_all\x00file_control_test\x00file_control_lasterrno_test\x00file_control_lockproxy_test\x00file_control_chunksize_test\x00file_control_sizehint_test\x00file_control_data_version\x00file_control_persist_wal\x00file_control_powersafe_overwrite\x00file_control_vfsname\x00file_control_reservebytes\x00file_control_tempfilename\x00file_control_external_reader\x00sqlite3_vfs_list\x00sqlite3_create_function_v2\x00add_test_collate\x00add_test_collate_needed\x00add_test_function\x00add_test_utf16bin_collate\x00sqlite3_test_errstr\x00tcl_variable_type\x00sqlite3_enable_shared_cache\x00sqlite3_shared_cache_report\x00sqlite3_libversion_number\x00sqlite3_table_column_metadata\x00sqlite3_blob_reopen\x00pcache_stats\x00sqlite3_unlock_notify\x00sqlite3_wal_checkpoint\x00sqlite3_wal_checkpoint_v2\x00sqlite3_wal_autocheckpoint\x00test_sqlite3_log\x00print_explain_query_plan\x00sqlite3_test_control\x00getrusage\x00load_static_extension\x00sorter_test_fakeheap\x00sorter_test_sort4_helper\x00vfs_current_time_int64\x00sqlite3_snapshot_get\x00sqlite3_snapshot_open\x00sqlite3_snapshot_free\x00sqlite3_snapshot_cmp\x00sqlite3_snapshot_recover\x00sqlite3_snapshot_get_blob\x00sqlite3_snapshot_open_blob\x00sqlite3_snapshot_cmp_blob\x00sqlite3_delete_database\x00atomic_batch_write\x00sqlite3_mmap_warm\x00sqlite3_config_sorterref\x00sqlite3_autovacuum_pages\x00decode_hexdb\x00test_write_db\x00sqlite3_register_cksumvfs\x00sqlite3_unregister_cksumvfs\x00*** OBSOLETE VARIABLE ***\x00 FILENAME N-PAGE\"\x00 ID\"\x00ref\x00page\x00err\x00hit\x00miss\x00ovfl\x00 ID PGNO\"\x00 PAGE\"\x00 PAGE DATA\"\x00 N-MEGABYTES FILE\"\x00open failed: \x00Hello, World!\x00write failed: \x00 PENDING-BYTE\"\x00fault simulator script failed: [%s]\x00 SCRIPT\"\x00 SIZE PROGRAM\"\x00sqlite_io_error_pending\x00sqlite_io_error_persist\x00sqlite_io_error_hit\x00sqlite_io_error_hardhit\x00sqlite_diskfull_pending\x00sqlite_diskfull\x00sqlite_pending_byte\x00pager_open\x00pager_close\x00pager_commit\x00pager_rollback\x00pager_stmt_begin\x00pager_stmt_commit\x00pager_stmt_rollback\x00pager_stats\x00pager_pagecount\x00page_get\x00page_lookup\x00page_unref\x00page_read\x00page_write\x00page_number\x00pager_truncate\x00fake_big_file\x00sqlite3BitvecBuiltinTest\x00sqlite3_test_control_pending_byte\x00sqlite3_test_control_fault_install\x00 FILENAME NCACHE FLAGS\"\x00read\x00write\x00 ID TABLENUM WRITEABLE\"\x00 START MULTIPLIER COUNT INCREMENT\"\x00putVarint returned %d - should be between 1 and 9\x00putVarint returned %d and getVarint returned %d\x00Wrote 0x%016llx and got back 0x%016llx\x00putVarint returned %d and GetVarint32 returned %d\x00Wrote 0x%016llx and got back 0x%016llx from GetVarint32\x00 DB-HANDLE ?N?\"\x00No such db-handle: \"\x00 BT NCACHE\"\x00?-intkey? CSR KEY VALUE\x00btree_insert\x00btree_open\x00btree_close\x00btree_begin_transaction\x00btree_pager_stats\x00btree_cursor\x00btree_close_cursor\x00btree_next\x00btree_eof\x00btree_payload_size\x00btree_first\x00btree_varint_test\x00btree_from_db\x00btree_ismemdb\x00btree_set_cache_size\x00thread ID must be an upper case letter\x00 ID FILENAME\x00thread \x00 is already running\x00failed to create the thread\x00 ID\x00no such thread\x00 ID N\x00column number out of range\x00no database is open\x00 ID SQL\x00no virtual machine available\x00 IDL\x00 ID1 ID2\x00 ID DB\x00thread_create\x00thread_wait\x00thread_halt\x00thread_argc\x00thread_argv\x00thread_colname\x00thread_result\x00thread_error\x00thread_compile\x00thread_step\x00thread_finalize\x00thread_swap\x00thread_db_get\x00thread_db_put\x00thread_stmt_get\x00 <repeat-count> <do-calls>\x00hello world\x00UTF8\x00UTF16LE\x00UTF16BE\x00UTF16\x00No such encoding: \x00 <string/blob> <from enc> <to enc>\x00binarize\x00test_value_overhead\x00test_translate\x00translate_selftest\x00out of memory in the crash simulator\n\x00atomic\x00atomic512\x00atomic1k\x00atomic2k\x00atomic4k\x00atomic8k\x00atomic16k\x00atomic32k\x00atomic64k\x00sequential\x00safe_append\x00powersafe_overwrite\x00batch-atomic\x00-sectorsize\x00-characteristics\x00Bad option: \"\x00\" - must be \"-characteristics\" or \"-sectorsize\"\x00Option requires an argument: \"\x00no such flag\x00ENABLE ?DEFAULT?\x00crash\x00?OPTIONS? DELAY CRASHFILE\x00Filename is too long: \"\x00NWRITE\x00?-default? PARENT-VFS\x00-default\x00\": must be -default\x00Error in jt_register\x00sqlite3_crash_enable\x00sqlite3_crashparams\x00sqlite3_crash_now\x00sqlite3_simulate_device\x00sqlite3_crash_on_write\x00unregister_devsim\x00register_jt_vfs\x00unregister_jt_vfs\x00client_create\x00client_wait\x00client_halt\x00client_argc\x00client_argv\x00client_colname\x00client_result\x00client_error\x00client_compile\x00client_step\x00client_reset\x00client_finalize\x00client_swap\x00echo_module_fail(%s,%s)\x00echo-vtab-error: %s\x00SELECT * FROM %Q\x00PRAGMA index_list(%s)\x00PRAGMA index_info(%s)\x00echo_module\x00SELECT sql FROM sqlite_schema WHERE type = 'table' AND name = ?\x00%s%s\x00xCreate\x00CREATE TABLE %Q(logmsg)\x00xConnect\x00xDisconnect\x00xDestroy\x00DROP TABLE %Q\x00xOpen\x00xNext\x00xColumn\x00xFilter\x00, *\x00%z, %s\x00%z, NULL\x00echo_module_ignore_usable\x00xBestIndex\x00echo_module_cost\x00SELECT count(*) FROM %Q\x00SELECT rowid%z FROM %Q\x00rowid\x00=\x00<\x00>\x00<=\x00>=\x00LIKE\x00like\x00glob\x00 %s %s LIKE (SELECT '%%'||?||'%%')\x00 %s %s %s ?\x00DESC\x00ASC\x00 ORDER BY %s %s\x00xUpdate\x00 SET\x00UPDATE %Q\x00 SET rowid=?1 \x00%s %Q=?%d\x00 WHERE rowid=?%d\x00DELETE FROM %Q WHERE rowid = ?1\x00INSERT INTO %Q (\x00%s%Q\x00%s?%d\x00) VALUES(\x00echo(%s)\x00xBegin\x00echo_module_begin_fail\x00xSync\x00echo_module_sync_fail\x00xCommit\x00xRollback\x00::echo_glob_overload\x00xRename\x00ALTER TABLE %s RENAME TO %s%s\x00function_that_does_not_exist_0982ma98\x00echo\x00echo_v2\x00register_echo_module\x00sqlite3_declare_vtab\x00N/A\x00sqlite3_create_collation\x00Error testing function: \x00sqlite3_malloc\x00sqlite3_realloc\x00c_misuse_test\x00c_realloc_test\x00c_collation_test\x00sqlite3_reset_auto_extension\x00npage\x00finish\x00remaining\x00pagecount\x00CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME\x00sqlite3_backup_init() failed\x00sqlite3_backup\x00wrong number of arguments\x00unexpected: %s\x00eq\x00gt\x00le\x00lt\x00ge\x00match\x00ne\x00isnot\x00isnotnull\x00isnull\x00op\x00column\x00usable\x00desc\x00cost\x00orderby\x00idxnum\x00idxstr\x00rows\x00use\x00omit\x00unexpected: %d\x00tcl\x00register_tcl_module\x00incrblob_\x00DB DATABASE TABLE COLUMN ROWID FLAGS VARNAME\x00HANDLE\x00CHANNEL OFFSET N\x00out of memory in testdata/sqlite-src-3370000/src/test_blob.c\x00HANDLE OFFSET DATA ?NDATA?\x00sqlite3_blob_open\x00sqlite3_blob_close\x00sqlite3_blob_bytes\x00sqlite3_blob_read\x00sqlite3_blob_write\x00sqlite_options\x00malloc_usable_size\x001\x00rowid32\x00casesensitivelike\x00configslower\x001.0\x00curdir\x00win32malloc\x00debug\x00default_ckptfullfsync\x00direct_read\x00dirsync\x00lfs\x00pagecache_overflow_stats\x00mmap\x00worker_threads\x008\x00memdebug\x008_3_names\x00cursorhints\x00hiddencolumns\x00mathlib\x00mem3\x00mem5\x00offset_sql_func\x00snapshot\x00mutex\x00mutex_noop\x00altertable\x00api_armor\x00atomicwrite\x00geopoly\x00json1\x00has_codec\x00like_match_blobs\x00auth\x00autoinc\x00autoreset\x00autovacuum\x00default_autovacuum\x00between_opt\x00builtin_test\x00bloblit\x00cast\x00check\x00cte\x00columnmetadata\x00oversize_cell_check\x00compileoption_diags\x00compound\x00conflict\x00crashtest\x00datetime\x00decltype\x00deprecated\x00diskio\x00floatingpoint\x00foreignkey\x00fts1\x00fts2\x00fts3\x00fts5\x00fts3_unicode\x00fts4_deferred\x00gettable\x00icu\x00icu_collations\x00integrityck\x00legacyformat\x00like_opt\x00load_ext\x00localtime\x00lookaside\x00long_double\x00memorydb\x00memorymanage\x00mergesort\x00null_trim\x00or_opt\x00rbu\x00pager_pragmas\x00pragma\x00reindex\x00rtree\x00rtree_int_only\x00schema_pragmas\x00schema_version\x00session\x00stmtvtab\x00scanstatus\x00lock_proxy_pragmas\x00prefer_proxy_locking\x00shared_cache\x00subquery\x00tclvar\x00threadsafe\x00threadsafe1\x00threadsafe2\x00tempdb\x00trigger\x00truncate_opt\x00vacuum\x00view\x00vtab\x00wal\x00wsd\x00update_delete_limit\x00fast_secure_delete\x00secure_delete\x00userauth\x00multiplex_ext_overwrite\x00yytrackmaxstackdepth\x00sqllog\x00uri_00_error\x00normalize\x00windowfunc\x00SQLITE_MAX_LENGTH\x00SQLITE_MAX_COLUMN\x00SQLITE_MAX_SQL_LENGTH\x00SQLITE_MAX_EXPR_DEPTH\x00SQLITE_MAX_COMPOUND_SELECT\x00SQLITE_MAX_VDBE_OP\x00SQLITE_MAX_FUNCTION_ARG\x00SQLITE_MAX_VARIABLE_NUMBER\x00SQLITE_MAX_PAGE_SIZE\x00SQLITE_MAX_PAGE_COUNT\x00SQLITE_MAX_LIKE_PATTERN_LENGTH\x00SQLITE_MAX_TRIGGER_DEPTH\x00SQLITE_DEFAULT_CACHE_SIZE\x00SQLITE_DEFAULT_PAGE_SIZE\x00SQLITE_DEFAULT_FILE_FORMAT\x00SQLITE_DEFAULT_SYNCHRONOUS\x00SQLITE_DEFAULT_WAL_SYNCHRONOUS\x00SQLITE_MAX_ATTACHED\x00SQLITE_MAX_DEFAULT_PAGE_SIZE\x00SQLITE_MAX_WORKER_THREADS\x00TEMP_STORE\x00__GNUC__\x00%s-journal\x00%s-wal\x00%s-shm\x00%s%03d\x00%s-journal%03d\x00%s-wal%03d\x00devsym\x00writecrash\x00CREATE TABLE xyz(dir, name);\x00CREATE TABLE xyz(path, size, data);\x00WITH r(d) AS (  SELECT CASE WHEN dir=?2 THEN ?3 ELSE dir END || '/' || name     FROM fsdir WHERE dir=?1 AND name NOT LIKE '.%'  UNION ALL  SELECT dir || '/' || name FROM r, fsdir WHERE dir=d AND name NOT LIKE '.%') SELECT d FROM r;\x00/\x00CREATE TABLE x(path TEXT, data TEXT)\x00SELECT * FROM %Q.%Q WHERE rowid=?\x00fs\x00fstree\x00register_fs_module\x00abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-!,:*^+=_|?/<> \x00sqlite3_prepare_v2() error: %s\x000123456789abcdef\x00x'\x00test_agg_errmsg16\x00randstr\x00test_destructor\x00test_destructor16\x00hex_to_utf16be\x00hex_to_utf16le\x00hex_to_utf8\x00test_destructor_count\x00test_auxdata\x00test_error\x00test_eval\x00test_isolation\x00test_counter\x00real2hex\x00test_decode\x00test_extract\x00test_zeroblob\x00test_getsubtype\x00test_setsubtype\x00test_frombind\x00tx\x00funcxx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00nullx_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789_123456789\x00sqlite3_create_function abused test failed\x00invalid matchinfo blob passed to function rank()\x00wrong number of arguments to function rank()\x00rank\x00autoinstall_test_functions\x00abuse_create_function\x00install_fts3_rank_function\x000123456789ABCDEF\x00FILENAME OFFSET AMT\x00r\x00cannot open input file \x00FILENAME OFFSET HEXDATA\x00r+b\x00r+\x00cannot open output file \x00HEXDATA\x00[utf8_to_utf8] unavailable - SQLITE_DEBUG not defined\x00BLOB VARNAME\x00LIST\x00hexio_read\x00hexio_write\x00hexio_get_int\x00hexio_render_int16\x00hexio_render_int32\x00utf8_to_utf8\x00read_fts3varint\x00make_fts3record\x00mem\x00pcache\x00Unknown argument: \"\x00init_wrapper_install\x00init_wrapper_query\x00init_wrapper_uninstall\x00init_wrapper_clear\x00CREATE TABLE x(value INTEGER PRIMARY KEY)\x00CREATE VIRTUAL TABLE temp.%Q USING %Q\x00INTARRAY\x00SQLITE_NOMEM\x00sqlite3_intarray_create\x00sqlite3_intarray_bind\x00jt\x00-journal\x00NBYTES\x00PRIOR NBYTES\x00bad pointer: \x00PRIOR\x00ADDRESS SIZE HEX\x00size must be positive\x00no data\x00ADDRESS SIZE\x00?RESET?\x00DEPT\x00FILENAME\x00COUNTER ?OPTIONS?\x00-repeat\x00-benigncnt\x00TITLE\x00SUB-COMMAND ...\x00start\x00stop\x00dump\x00clear\x00sync\x00SIZE N\x00INSTALLFLAG DISCARDCHANCE PRNGSEEED HIGHSTRESS\x00discard-chance should be between 0 and 100\x00SIZE COUNT\x00BUFID SIZE COUNT\x00illegal arguments - see documentation\x00NBYTE NMINALLOC\x00[DB]\x00sqlite3_db_config(db, 99999) does not return SQLITE_ERROR\x00sqlite3_config(99999) does not return SQLITE_ERROR\x00PARAMETER RESETFLAG\x00SQLITE_STATUS_MEMORY_USED\x00SQLITE_STATUS_MALLOC_SIZE\x00SQLITE_STATUS_PAGECACHE_USED\x00SQLITE_STATUS_PAGECACHE_OVERFLOW\x00SQLITE_STATUS_PAGECACHE_SIZE\x00SQLITE_STATUS_SCRATCH_USED\x00SQLITE_STATUS_SCRATCH_OVERFLOW\x00SQLITE_STATUS_SCRATCH_SIZE\x00SQLITE_STATUS_PARSER_STACK\x00SQLITE_STATUS_MALLOC_COUNT\x00DB PARAMETER RESETFLAG\x00SQLITE_\x00DBSTATUS_\x00LOOKASIDE_USED\x00CACHE_USED\x00SCHEMA_USED\x00STMT_USED\x00LOOKASIDE_HIT\x00LOOKASIDE_MISS_SIZE\x00LOOKASIDE_MISS_FULL\x00CACHE_HIT\x00CACHE_MISS\x00CACHE_WRITE\x00DEFERRED_FKS\x00CACHE_USED_SHARED\x00CACHE_SPILL\x00?INTEGER?\x00sqlite3_free\x00memset\x00memget\x00sqlite3_memory_used\x00sqlite3_memory_highwater\x00sqlite3_memdebug_backtrace\x00sqlite3_memdebug_dump\x00sqlite3_memdebug_fail\x00sqlite3_memdebug_pending\x00sqlite3_memdebug_settitle\x00sqlite3_memdebug_malloc_count\x00sqlite3_memdebug_log\x00sqlite3_config_pagecache\x00sqlite3_config_alt_pcache\x00sqlite3_status\x00sqlite3_db_status\x00install_malloc_faultsim\x00sqlite3_config_heap\x00sqlite3_config_heap_size\x00sqlite3_config_memstatus\x00sqlite3_config_lookaside\x00sqlite3_config_error\x00sqlite3_config_uri\x00sqlite3_config_cis\x00sqlite3_config_pmasz\x00sqlite3_db_config_lookaside\x00sqlite3_dump_memsys3\x00sqlite3_dump_memsys5\x00sqlite3_install_memsys3\x00sqlite3_memdebug_vfs_oom_test\x00%05u\x00 FILENAME [OFFSET AMT]\"\x00unable to open file \"\x00\" for reading\x00md5\x00md5-10x8\x00md5file\x00md5file-10x8\x00md5sum\x00%03d\x00multiplexor.xAccess failure on %s\x00multiplexor.xOpen failure on %s\x00multiplex_control\x00chunksize\x00multiplex_\x00multiplex_truncate\x00multiplex_enabled\x00multiplex_chunksize\x00multiplex_filecount\x00multiplex/%z\x00multiplex\x00NAME MAKEDEFAULT\x00-force\x00?-force?\x00chunk_size\x00max_chunks\x00HANDLE DBNAME SUB-COMMAND INT-VALUE\x00expected database handle, got \"\x00sqlite3_multiplex_initialize\x00sqlite3_multiplex_shutdown\x00sqlite3_multiplex_control\x00fast\x00recursive\x00static_main\x00static_mem\x00static_open\x00static_prng\x00static_lru\x00static_pmem\x00static_app1\x00static_app2\x00static_app3\x00static_vfs1\x00static_vfs2\x00static_vfs3\x00mutex counters are \x00already installed\x00not installed\x00singlethread\x00multithread\x00serialized\x00mutex name\x00disable_mutex_init\x00disable_mutex_try\x00sqlite3_shutdown\x00sqlite3_initialize\x00sqlite3_config\x00enter_static_mutex\x00leave_static_mutex\x00enter_db_mutex\x00leave_db_mutex\x00alloc_dealloc_mutex\x00install_mutex_counters\x00read_mutex_counters\x00clear_mutex_counters\x00\x00\x00\x00\x00\x00\x00\x00vfslog/%z\x00sqlite_ostrace1.....\x00xClose\x00xRead\x00xWrite\x00xTruncate\x00xFilesize\x00xLock\x00xUnlock\x00xCheckResLock\x00xFileControl\x00xSectorSize\x00xDeviceChar\x00xDelete\x00xAccess\x00xFullPathname\x00xRandomness\x00xSleep\x00xCurrentTime\x00xShmUnmap\x00xShmLock\x00xShmBarrier\x00xShmMap\x00annotation\x00CREATE TABLE xxx(event, file, click, rc, size, offset)\x00vfslog\x00VFS\x00failed\x00VFS PARENT LOGFILE\x00bad sqlite3 handle: \x00annotate\x00finalize\x00register\x00quota/%z\x00quota\x00::piLimit_\x00PATTERN LIMIT SCRIPT\x00FILENAME MODE\x00HANDLE SIZE NELEM\x00HANDLE SIZE NELEM CONTENT\x00HANDLE ?HARDSYNC?\x00HANDLE OFFSET WHENCE\x00SEEK_SET\x00SEEK_CUR\x00SEEK_END\x00WHENCE should be SEEK_SET, SEEK_CUR, or SEEK_END\x00HANDLE SIZE\x00PATTERN TEXT\x00sqlite3_quota_initialize\x00sqlite3_quota_shutdown\x00sqlite3_quota_set\x00sqlite3_quota_file\x00sqlite3_quota_dump\x00sqlite3_quota_fopen\x00sqlite3_quota_fread\x00sqlite3_quota_fwrite\x00sqlite3_quota_fclose\x00sqlite3_quota_fflush\x00sqlite3_quota_fseek\x00sqlite3_quota_rewind\x00sqlite3_quota_ftell\x00sqlite3_quota_ftruncate\x00sqlite3_quota_file_size\x00sqlite3_quota_file_truesize\x00sqlite3_quota_file_mtime\x00sqlite3_quota_remove\x00sqlite3_quota_glob\x00sqlite3_quota_file_available\x00sqlite3_quota_ferror\x00cube\x00circle\x00Qcircle\x00breadthfirstsearch\x00register_cube_geom\x00register_circle_geom\x00CREATE TABLE x(database,tablename,cid,name,type,not_null,dflt_value,pk)\x00SELECT name FROM sqlite_temp_schema WHERE type='table'\x00SELECT name FROM %Q.sqlite_schema WHERE type='table'\x00PRAGMA %Q.table_info(%Q)\x00PRAGMA database_list\x00register_schema_module\x00PRAGMA main.journal_mode\x00CMDNAME PATH ?VFS? ?BUSY-HANDLER-SCRIPT?\x00sqlite3demo_superlock\x00open\x00access\x00getcwd\x00stat\x00fstat\x00ftruncate\x00fcntl\x00pread\x00pread64\x00pwrite\x00pwrite64\x00fchmod\x00fallocate\x00mremap\x00SYSCALL-LIST\x00system-call\x00?COUNT PERSIST?\x00EACCES\x00EINTR\x00EIO\x00EOVERFLOW\x00ENOMEM\x00EAGAIN\x00ETIMEDOUT\x00EBUSY\x00EPERM\x00EDEADLK\x00ENOLCK\x00SYSCALL ERRNO\x00errno\x00PGSZ\x00getpagesize\x00pgsz out of range\x00fault\x00install\x00uninstall\x00list\x00defaultvfs\x00pagesize\x00VFS does not support xSetSystemCall\x00test_syscall\x00load_testfixture_extensions\x00SLAVE\x00CREATE TABLE x(  name TEXT,  arrayname TEXT,  value TEXT,  fullname TEXT PRIMARY KEY) WITHOUT ROWID\x00array names\x00tclvar_filter_cmd\x00%s(%s)\x00expr {[info exists ::tclvar_set_omit] && $::tclvar_set_omit}\x00the 'fullname' column must be TEXT\x00prohibited TCL variable change\x00proc like {pattern str} {\n  set p [string map {% * _ ?} $pattern]\n  string match $p $str\n}\nproc tclvar_filter_cmd {eq match glob regexp like} {\n  set res {}\n  set pattern $eq\n  if {$pattern=={}} { set pattern $match }\n  if {$pattern=={}} { set pattern * }\n  foreach v [uplevel #0 info vars $pattern] {\n    if {($glob=={} || [string match $glob [uplevel #0 set $v]])\n     && ($like=={} || [like $like [uplevel #0 set $v]])\n     && ($regexp=={} || [regexp $regexp [uplevel #0 set $v]])\n    } {\n      lappend res $v\n    }\n  }\n  set res\n}\n\x00register_tclvar_module\x00clock_seconds\x00sqlthread\x00sqlite3_blocking_step\x00sqlite3_blocking_prepare_v2\x00sqlite3_nonblocking_prepare_v2\x00set\x00Error in Tcl_CreateThread()\x00no parent thread\x00parent\x00spawn\x00VARNAME SCRIPT\x00DBNAME\x00id\x00%s \x00SQLITE_IOERR\x00SQLITE_LOCKED\x00SQLITE_BUSY\x00SQLITE_READONLY\x00SQLITE_READONLY_CANTINIT\x00SQLITE_NOTFOUND\x00SQLITE_OMIT\x00normal|dataonly\x00full|dataonly\x00xCheckReservedLock\x00BEGIN_ATOMIC_WRITE\x00COMMIT_ATOMIC_WRITE\x00ZIPVFS\x00anon\x00SQLITE_ACCESS_EXISTS\x00SQLITE_ACCESS_READWRITE\x00SQLITE_ACCESS_READ\x00xShmOpen\x00 lock\x00 unlock\x00 shared\x00 exclusive\x00shm\x00filter\x00ioerr\x00fullerr\x00cantopenerr\x00script\x00devchar\x00sectorsize\x00subcommand\x00FILE ?VALUE?\x00failed to get full path: \x00no such file: \x00unknown method: \x00?CNT PERSIST?\x00default\x00undeletable_when_open\x00immutable\x00?ATTR-LIST?\x00bad flags: \x00?VALUE?\x00-noshm\x00-szosfile\x00-mxpathname\x00-iversion\x00-fullshm\x00VFSNAME ?-noshm BOOL? ?-fullshm BOOL? ?-default BOOL? ?-mxpathname INT? ?-szosfile INT? ?-iversion INT?\x00shared\x00lock\x00unlock\x00DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N\x00ARG\x00DB DBNAME SLOT ?VALUE?\x00*-shm is not yet mapped\x00testvfs\x00vfs_shmlock\x00vfs_set_readmark\x00DB NAME XSTEP XFINAL XVALUE XINVERSE\x00fff\x00misuse test error\x00invalid argument\x00sumint\x00sum\x00sqlite3_create_window_function\x00test_create_window_function_misuse\x00test_create_sumint\x00test_override_sum\x00"
var ts = (*reflect.StringHeader)(unsafe.Pointer(&ts1)).Data
